{
  "version": 3,
  "sources": ["clarinet.js"],
  "sourcesContent": ["getGlobalThis().clarinet = {};\nvar exports = clarinet;\n\n//var Stream = stream;\n\n;(function (clarinet) {\n  \"use strict\";\n\n  // non node-js needs to set clarinet debug on root\n  var env =(typeof process === 'object' && process.env)\n    ? process.env\n    : self;\n\n  clarinet.parser            = function (opt) { return new CParser(opt);};\n  clarinet.CParser           = CParser;\n  clarinet.CStream           = CStream;\n  clarinet.createStream      = createStream;\n  clarinet.MAX_BUFFER_LENGTH = 64 * 1024;\n  clarinet.DEBUG             = (env.CDEBUG==='debug');\n  clarinet.INFO              = (env.CDEBUG==='debug' || env.CDEBUG==='info');\n  clarinet.EVENTS            =\n    [ \"value\"\n    , \"string\"\n    , \"key\"\n    , \"openobject\"\n    , \"closeobject\"\n    , \"openarray\"\n    , \"closearray\"\n    , \"error\"\n    , \"end\"\n    , \"ready\"\n    ];\n\n  var buffers     = {\n        textNode: undefined,\n        numberNode: \"\"\n    }\n    , streamWraps = clarinet.EVENTS.filter(function (ev) {\n          return ev !== \"error\" && ev !== \"end\";\n        })\n    , S           = 0\n    , Stream\n    ;\n\n  clarinet.STATE =\n    { BEGIN                             : S++\n    , VALUE                             : S++ // general stuff\n    , OPEN_OBJECT                       : S++ // {\n    , CLOSE_OBJECT                      : S++ // }\n    , OPEN_ARRAY                        : S++ // [\n    , CLOSE_ARRAY                       : S++ // ]\n    , TEXT_ESCAPE                       : S++ // \\ stuff\n    , STRING                            : S++ // \"\"\n    , BACKSLASH                         : S++\n    , END                               : S++ // No more stack\n    , OPEN_KEY                          : S++ // , \"a\"\n    , CLOSE_KEY                         : S++ // :\n    , TRUE                              : S++ // r\n    , TRUE2                             : S++ // u\n    , TRUE3                             : S++ // e\n    , FALSE                             : S++ // a\n    , FALSE2                            : S++ // l\n    , FALSE3                            : S++ // s\n    , FALSE4                            : S++ // e\n    , NULL                              : S++ // u\n    , NULL2                             : S++ // l\n    , NULL3                             : S++ // l\n    , NUMBER_DECIMAL_POINT              : S++ // .\n    , NUMBER_DIGIT                      : S++ // [0-9]\n    };\n\n  for (var s_ in clarinet.STATE) clarinet.STATE[clarinet.STATE[s_]] = s_;\n\n  // switcharoo\n  S = clarinet.STATE;\n\n  const Char = {\n    tab                 : 0x09,     // \\t\n    lineFeed            : 0x0A,     // \\n\n    carriageReturn      : 0x0D,     // \\r\n    space               : 0x20,     // \" \"\n\n    doubleQuote         : 0x22,     // \"\n    plus                : 0x2B,     // +\n    comma               : 0x2C,     // ,\n    minus               : 0x2D,     // -\n    period              : 0x2E,     // .\n\n    _0                  : 0x30,     // 0\n    _9                  : 0x39,     // 9\n\n    colon               : 0x3A,     // :\n\n    E                   : 0x45,     // E\n\n    openBracket         : 0x5B,     // [\n    backslash           : 0x5C,     // \\\n    closeBracket        : 0x5D,     // ]\n\n    a                   : 0x61,     // a\n    b                   : 0x62,     // b\n    e                   : 0x65,     // e \n    f                   : 0x66,     // f\n    l                   : 0x6C,     // l\n    n                   : 0x6E,     // n\n    r                   : 0x72,     // r\n    s                   : 0x73,     // s\n    t                   : 0x74,     // t\n    u                   : 0x75,     // u\n\n    openBrace           : 0x7B,     // {\n    closeBrace          : 0x7D,     // }\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function f () { this[\"__proto__\"] = o; }\n      f.prototype = o;\n      return new f;\n    };\n  }\n\n  if (!Object.getPrototypeOf) {\n    Object.getPrototypeOf = function (o) {\n      return o[\"__proto__\"];\n    };\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = [];\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);\n      return a;\n    };\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(clarinet.MAX_BUFFER_LENGTH, 10)\n      , maxActual = 0\n      ;\n    for (var buffer in buffers) {\n      var len = parser[buffer] === undefined ? 0 : parser[buffer].length;\n      if (len > maxAllowed) {\n        switch (buffer) {\n          case \"text\":\n            closeText(parser);\n          break;\n\n          default:\n            error(parser, \"Max buffer length exceeded: \"+ buffer);\n        }\n      }\n      maxActual = Math.max(maxActual, len);\n    }\n    parser.bufferCheckPosition = (clarinet.MAX_BUFFER_LENGTH - maxActual)\n                               + parser.position;\n  }\n\n  function clearBuffers (parser) {\n    for (var buffer in buffers) {\n      parser[buffer] = buffers[buffer];\n    }\n  }\n\n  var stringTokenPattern = /[\\\\\"\\n]/g;\n\n  function CParser (opt) {\n    if (!(this instanceof CParser)) return new CParser (opt);\n\n    var parser = this;\n    clearBuffers(parser);\n    parser.bufferCheckPosition = clarinet.MAX_BUFFER_LENGTH;\n    parser.q        = parser.c = parser.p = \"\";\n    parser.opt      = opt || {};\n    parser.closed   = parser.closedRoot = parser.sawRoot = false;\n    parser.tag      = parser.error = null;\n    parser.state    = S.BEGIN;\n    parser.stack    = new Array();\n    // mostly just for error reporting\n    parser.position = parser.column = 0;\n    parser.line     = 1;\n    parser.slashed  = false;\n    parser.unicodeI = 0;\n    parser.unicodeS = null;\n    parser.depth    = 0;\n    emit(parser, \"onready\");\n  }\n\n  CParser.prototype =\n    { end    : function () { end(this); }\n    , write  : write\n    , resume : function () { this.error = null; return this; }\n    , close  : function () { return this.write(null); }\n    };\n\n    /*\n  try        { Stream = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()); }\n  catch (ex) { Stream = function () {}; }\n  */\n\n  Stream = function () {};\n\n\n  function createStream (opt) { return new CStream(opt); }\n\n  function CStream (opt) {\n    if (!(this instanceof CStream)) return new CStream(opt);\n\n    this._parser = new CParser(opt);\n    this.writable = true;\n    this.readable = true;\n\n    //var Buffer = this.Buffer || function Buffer () {}; // if we don't have Buffers, fake it so we can do `var instanceof Buffer` and not throw an error\n    this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary\n    this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read\n    this.temp_buffs = { \"2\": new Buffer(2), \"3\": new Buffer(3), \"4\": new Buffer(4) }; // for rebuilding chars split before boundary is reached\n    this.string = '';\n\n    var me = this;\n    Stream.apply(me);\n\n    this._parser.onend = function () { me.emit(\"end\"); };\n    this._parser.onerror = function (er) {\n      me.emit(\"error\", er);\n      me._parser.error = null;\n    };\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, \"on\" + ev,\n        { get          : function () { return me._parser[\"on\" + ev]; }\n        , set          : function (h) {\n            if (!h) {\n              me.removeAllListeners(ev);\n              me._parser[\"on\"+ev] = h;\n              return h;\n            }\n            me.on(ev, h);\n          }\n        , enumerable   : true\n        , configurable : false\n        });\n    });\n  }\n\n  CStream.prototype = Object.create(Stream.prototype,\n    { constructor: { value: CStream } });\n\n  CStream.prototype.write = function (data) {\n    data = new Buffer(data);\n    for (var i = 0; i < data.length; i++) {\n      var n = data[i];\n\n      // check for carry over of a multi byte char split between data chunks\n      // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration\n      if (this.bytes_remaining > 0) {\n        for (var j = 0; j < this.bytes_remaining; j++) {\n          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = data[j];\n        }\n        this.string = this.temp_buffs[this.bytes_in_sequence].toString();\n        this.bytes_in_sequence = this.bytes_remaining = 0;\n\n        // move iterator forward by number of byte read during sequencing\n        i = i + j - 1;\n\n        // pass data to parser and move forward to parse rest of data\n        this._parser.write(this.string);\n        this.emit(\"data\", this.string);\n        continue;\n      }\n\n      // if no remainder bytes carried over, parse multi byte (>=128) chars one at a time\n      if (this.bytes_remaining === 0 && n >= 128) {\n        if ((n >= 194) && (n <= 223)) this.bytes_in_sequence = 2;\n        if ((n >= 224) && (n <= 239)) this.bytes_in_sequence = 3;\n        if ((n >= 240) && (n <= 244)) this.bytes_in_sequence = 4;\n        if ((this.bytes_in_sequence + i) > data.length) { // if bytes needed to complete char fall outside data length, we have a boundary split\n\n          for (var k = 0; k <= (data.length - 1 - i); k++) {\n            this.temp_buffs[this.bytes_in_sequence][k] = data[i + k]; // fill temp data of correct size with bytes available in this chunk\n          }\n          this.bytes_remaining = (i + this.bytes_in_sequence) - data.length;\n\n          // immediately return as we need another chunk to sequence the character\n          return true;\n        } else {\n          this.string = data.slice(i, (i + this.bytes_in_sequence)).toString();\n          i = i + this.bytes_in_sequence - 1;\n\n          this._parser.write(this.string);\n          this.emit(\"data\", this.string);\n          continue;\n        }\n      }\n\n      // is there a range of characters that are immediately parsable?\n      for (var p = i; p < data.length; p++) {\n        if (data[p] >= 128) break;\n      }\n      this.string = data.slice(i, p).toString();\n      this._parser.write(this.string);\n      this.emit(\"data\", this.string);\n      i = p - 1;\n\n      // handle any remaining characters using multibyte logic\n      continue;\n    }\n  };\n\n  CStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) this._parser.write(chunk.toString());\n    this._parser.end();\n    return true;\n  };\n\n  CStream.prototype.on = function (ev, handler) {\n    var me = this;\n    if (!me._parser[\"on\"+ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser[\"on\"+ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]]\n                 : Array.apply(null, arguments);\n        args.splice(0, 0, ev);\n        me.emit.apply(me, args);\n      };\n    }\n    return Stream.prototype.on.call(me, ev, handler);\n  };\n\n  CStream.prototype.destroy = function () {\n    clearBuffers(this._parser);\n    this.emit(\"close\");\n  };\n\n  function emit(parser, event, data) {\n    if(clarinet.INFO) console.log('-- emit', event, data);\n    if (parser[event]) parser[event](data);\n  }\n\n  function emitNode(parser, event, data) {\n    closeValue(parser);\n    emit(parser, event, data);\n  }\n\n  function closeValue(parser, event) {\n    parser.textNode = textopts(parser.opt, parser.textNode);\n    if (parser.textNode !== undefined) {\n      emit(parser, (event ? event : \"onvalue\"), parser.textNode);\n    }\n    parser.textNode = undefined;\n  }\n\n  function closeNumber(parser) {\n    if (parser.numberNode)\n      emit(parser, \"onvalue\", parseFloat(parser.numberNode));\n    parser.numberNode = \"\";\n  }\n\n  function textopts (opt, text) {\n    if (text === undefined) {\n      return text;\n    }\n    if (opt.trim) text = text.trim();\n    if (opt.normalize) text = text.replace(/\\s+/g, \" \");\n    return text;\n  }\n\n  function error (parser, er) {\n    closeValue(parser);\n    er += \"\\nLine: \"+parser.line+\n          \"\\nColumn: \"+parser.column+\n          \"\\nChar: \"+parser.c;\n    er = new Error(er);\n    parser.error = er;\n    emit(parser, \"onerror\", er);\n    return parser;\n  }\n\n  function end(parser) {\n    if (parser.state !== S.VALUE || parser.depth !== 0)\n      error(parser, \"Unexpected end\");\n\n    closeValue(parser);\n    parser.c      = \"\";\n    parser.closed = true;\n    emit(parser, \"onend\");\n    CParser.call(parser, parser.opt);\n    return parser;\n  }\n\n  function isWhitespace(c) {\n    return c === Char.carriageReturn || c === Char.lineFeed || c === Char.space || c === Char.tab;\n  }\n\n  function write (chunk) {\n    var parser = this;\n    if (this.error) throw this.error;\n    if (parser.closed) return error(parser,\n      \"Cannot write after close. Assign an onready handler.\");\n    if (chunk === null) return end(parser);\n    var i = 0, c = chunk.charCodeAt(0), p = parser.p;\n    var lockIncrements = false;\n    if (clarinet.DEBUG) console.log('write -> [' + chunk + ']');\n    while (c) {\n      p = c;\n      parser.c = c = chunk.charCodeAt(i++);\n      // if chunk doesnt have next, like streaming char by char\n      // this way we need to check if previous is really previous\n      // if not we need to reset to what the parser says is the previous\n      // from buffer\n      if(p !== c ) parser.p = p;\n      else p = parser.p;\n\n      if(!c) break;\n\n      if (clarinet.DEBUG) console.log(i,c,clarinet.STATE[parser.state]);\n      if (!lockIncrements) {\n        parser.position ++;\n        if (c === Char.lineFeed) {\n          parser.line ++;\n          parser.column = 0;\n        } else parser.column ++;\n      } else {\n        lockIncrements = false;\n      }\n      switch (parser.state) {\n\n        case S.BEGIN:\n          if (c === Char.openBrace) parser.state = S.OPEN_OBJECT;\n          else if (c === Char.openBracket) parser.state = S.OPEN_ARRAY;\n          else if (!isWhitespace(c))\n            error(parser, \"Non-whitespace before {[.\");\n        continue;\n\n        case S.OPEN_KEY:\n        case S.OPEN_OBJECT:\n          if (isWhitespace(c)) continue;\n          if(parser.state === S.OPEN_KEY) parser.stack.push(S.CLOSE_KEY);\n          else {\n            if(c === Char.closeBrace) {\n              emit(parser, 'onopenobject');\n              this.depth++;\n              emit(parser, 'oncloseobject');\n              this.depth--;\n              parser.state = parser.stack.pop() || S.VALUE;\n              continue;\n            } else  parser.stack.push(S.CLOSE_OBJECT);\n          }\n          if(c === Char.doubleQuote) parser.state = S.STRING;\n          else error(parser, \"Malformed object key should start with \\\"\");\n        continue;\n\n        case S.CLOSE_KEY:\n        case S.CLOSE_OBJECT:\n          if (isWhitespace(c)) continue;\n          var event = (parser.state === S.CLOSE_KEY) ? 'key' : 'object';\n          if(c === Char.colon) {\n            if(parser.state === S.CLOSE_OBJECT) {\n              parser.stack.push(S.CLOSE_OBJECT);\n              closeValue(parser, 'onopenobject');\n               this.depth++;\n            } else closeValue(parser, 'onkey');\n            parser.state  = S.VALUE;\n          } else if (c === Char.closeBrace) {\n            emitNode(parser, 'oncloseobject');\n            this.depth--;\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else if(c === Char.comma) {\n            if(parser.state === S.CLOSE_OBJECT)\n              parser.stack.push(S.CLOSE_OBJECT);\n            closeValue(parser);\n            parser.state  = S.OPEN_KEY;\n          } else error(parser, 'Bad object');\n        continue;\n\n        case S.OPEN_ARRAY: // after an array there always a value\n        case S.VALUE:\n          if (isWhitespace(c)) continue;\n          if(parser.state===S.OPEN_ARRAY) {\n            emit(parser, 'onopenarray');\n            this.depth++;\n            parser.state = S.VALUE;\n            if(c === Char.closeBracket) {\n              emit(parser, 'onclosearray');\n              this.depth--;\n              parser.state = parser.stack.pop() || S.VALUE;\n              continue;\n            } else {\n              parser.stack.push(S.CLOSE_ARRAY);\n            }\n          }\n               if(c === Char.doubleQuote) parser.state = S.STRING;\n          else if(c === Char.openBrace) parser.state = S.OPEN_OBJECT;\n          else if(c === Char.openBracket) parser.state = S.OPEN_ARRAY;\n          else if(c === Char.t) parser.state = S.TRUE;\n          else if(c === Char.f) parser.state = S.FALSE;\n          else if(c === Char.n) parser.state = S.NULL;\n          else if(c === Char.minus) { // keep and continue\n            parser.numberNode += \"-\";\n          } else if(Char._0 <= c && c <= Char._9) {\n            parser.numberNode += String.fromCharCode(c);\n            parser.state = S.NUMBER_DIGIT;\n          } else               error(parser, \"Bad value\");\n        continue;\n\n        case S.CLOSE_ARRAY:\n          if(c === Char.comma) {\n            parser.stack.push(S.CLOSE_ARRAY);\n            closeValue(parser, 'onvalue');\n            parser.state  = S.VALUE;\n          } else if (c === Char.closeBracket) {\n            emitNode(parser, 'onclosearray');\n            this.depth--;\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else if (isWhitespace(c))\n              continue;\n          else error(parser, 'Bad array');\n        continue;\n\n        case S.STRING:\n          if (parser.textNode === undefined) {\n            parser.textNode = \"\";\n          }\n\n          // thanks thejh, this is an about 50% performance improvement.\n          var starti              = i-1\n            , slashed = parser.slashed\n            , unicodeI = parser.unicodeI\n            ;\n          STRING_BIGLOOP: while (true) {\n            if (clarinet.DEBUG)\n              console.log(i,c,clarinet.STATE[parser.state]\n                         ,slashed);\n            // zero means \"no unicode active\". 1-4 mean \"parse some more\". end after 4.\n            while (unicodeI > 0) {\n              parser.unicodeS += String.fromCharCode(c);\n              c = chunk.charCodeAt(i++);\n              parser.position++;\n              if (unicodeI === 4) {\n                // TODO this might be slow? well, probably not used too often anyway\n                parser.textNode += String.fromCharCode(parseInt(parser.unicodeS, 16));\n                unicodeI = 0;\n                starti = i-1;\n              } else {\n                unicodeI++;\n              }\n              // we can just break here: no stuff we skipped that still has to be sliced out or so\n              if (!c) break STRING_BIGLOOP;\n            }\n            if (c === Char.doubleQuote && !slashed) {\n              parser.state = parser.stack.pop() || S.VALUE;\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              break;\n            }\n            if (c === Char.backslash && !slashed) {\n              slashed = true;\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              c = chunk.charCodeAt(i++);\n              parser.position++;\n              if (!c) break;\n            }\n            if (slashed) {\n              slashed = false;\n                   if (c === Char.n) { parser.textNode += '\\n'; }\n              else if (c === Char.r) { parser.textNode += '\\r'; }\n              else if (c === Char.t) { parser.textNode += '\\t'; }\n              else if (c === Char.f) { parser.textNode += '\\f'; }\n              else if (c === Char.b) { parser.textNode += '\\b'; }\n              else if (c === Char.u) {\n                // \\uxxxx. meh!\n                unicodeI = 1;\n                parser.unicodeS = '';\n              } else {\n                parser.textNode += String.fromCharCode(c);\n              }\n              c = chunk.charCodeAt(i++);\n              parser.position++;\n              starti = i-1;\n              if (!c) break;\n              else continue;\n            }\n\n            stringTokenPattern.lastIndex = i;\n            var reResult = stringTokenPattern.exec(chunk);\n            if (reResult === null) {\n              i = chunk.length+1;\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              break;\n            }\n            i = reResult.index+1;\n            c = chunk.charCodeAt(reResult.index);\n            if (!c) {\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              break;\n            }\n          }\n          parser.slashed = slashed;\n          parser.unicodeI = unicodeI;\n        continue;\n\n        case S.TRUE:\n          if (c === Char.r) parser.state = S.TRUE2;\n          else error(parser, 'Invalid true started with t'+ c);\n        continue;\n\n        case S.TRUE2:\n          if (c === Char.u) parser.state = S.TRUE3;\n          else error(parser, 'Invalid true started with tr'+ c);\n        continue;\n\n        case S.TRUE3:\n          if(c === Char.e) {\n            emit(parser, \"onvalue\", true);\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else error(parser, 'Invalid true started with tru'+ c);\n        continue;\n\n        case S.FALSE:\n          if (c === Char.a) parser.state = S.FALSE2;\n          else error(parser, 'Invalid false started with f'+ c);\n        continue;\n\n        case S.FALSE2:\n          if (c === Char.l) parser.state = S.FALSE3;\n          else error(parser, 'Invalid false started with fa'+ c);\n        continue;\n\n        case S.FALSE3:\n          if (c === Char.s) parser.state = S.FALSE4;\n          else error(parser, 'Invalid false started with fal'+ c);\n        continue;\n\n        case S.FALSE4:\n          if (c === Char.e) {\n            emit(parser, \"onvalue\", false);\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else error(parser, 'Invalid false started with fals'+ c);\n        continue;\n\n        case S.NULL:\n          if (c === Char.u) parser.state = S.NULL2;\n          else error(parser, 'Invalid null started with n'+ c);\n        continue;\n\n        case S.NULL2:\n          if (c === Char.l) parser.state = S.NULL3;\n          else error(parser, 'Invalid null started with nu'+ c);\n        continue;\n\n        case S.NULL3:\n          if(c === Char.l) {\n            emit(parser, \"onvalue\", null);\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else error(parser, 'Invalid null started with nul'+ c);\n        continue;\n\n        case S.NUMBER_DECIMAL_POINT:\n          if(c === Char.period) {\n            parser.numberNode += \".\";\n            parser.state       = S.NUMBER_DIGIT;\n          } else error(parser, 'Leading zero not followed by .');\n        continue;\n\n        case S.NUMBER_DIGIT:\n          if(Char._0 <= c && c <= Char._9) parser.numberNode += String.fromCharCode(c);\n          else if (c === Char.period) {\n            if(parser.numberNode.indexOf('.')!==-1)\n              error(parser, 'Invalid number has two dots');\n            parser.numberNode += \".\";\n          } else if (c === Char.e || c === Char.E) {\n            if(parser.numberNode.indexOf('e')!==-1 ||\n               parser.numberNode.indexOf('E')!==-1 )\n               error(parser, 'Invalid number has two exponential');\n            parser.numberNode += \"e\";\n          } else if (c === Char.plus || c === Char.minus) {\n            if(!(p === Char.e || p === Char.E))\n              error(parser, 'Invalid symbol in number');\n            parser.numberNode += String.fromCharCode(c);\n          } else {\n            closeNumber(parser);\n            i--; // go back one\n            lockIncrements = true; // do not apply increments for a single cycle\n            parser.state = parser.stack.pop() || S.VALUE;\n          }\n        continue;\n\n        default:\n          error(parser, \"Unknown state: \" + parser.state);\n      }\n    }\n    if (parser.position >= parser.bufferCheckPosition)\n      checkBufferLength(parser);\n    return parser;\n  }\n\n})( false ? 0 : exports);\n\n//debugger;"],
  "mappings": ";;;;;;;AAAA;AAAA;AAAA,oBAAc,EAAE,WAAW,CAAC;AAC5B,UAAI,UAAU;AAIb,OAAC,SAAUA,WAAU;AACpB;AAGA,YAAI,MAAM,OAAO,YAAY,YAAY,QAAQ,MAC7C,QAAQ,MACR;AAEJ,QAAAA,UAAS,SAAoB,SAAU,KAAK;AAAE,iBAAO,IAAI,QAAQ,GAAG;AAAA,QAAE;AACtE,QAAAA,UAAS,UAAoB;AAC7B,QAAAA,UAAS,UAAoB;AAC7B,QAAAA,UAAS,eAAoB;AAC7B,QAAAA,UAAS,oBAAoB,KAAK;AAClC,QAAAA,UAAS,QAAqB,IAAI,WAAS;AAC3C,QAAAA,UAAS,OAAqB,IAAI,WAAS,WAAW,IAAI,WAAS;AACnE,QAAAA,UAAS,SACP;AAAA,UAAE;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAEF,YAAI,UAAc;AAAA,UACZ,UAAU;AAAA,UACV,YAAY;AAAA,QAChB,GACE,cAAcA,UAAS,OAAO,OAAO,SAAU,IAAI;AAC/C,iBAAO,OAAO,WAAW,OAAO;AAAA,QAClC,CAAC,GACH,IAAc,GACd;AAGJ,QAAAA,UAAS,QACP;AAAA,UAAE,OAAoC;AAAA,UACpC,OAAoC;AAAA,UACpC,aAAoC;AAAA,UACpC,cAAoC;AAAA,UACpC,YAAoC;AAAA,UACpC,aAAoC;AAAA,UACpC,aAAoC;AAAA,UACpC,QAAoC;AAAA,UACpC,WAAoC;AAAA,UACpC,KAAoC;AAAA,UACpC,UAAoC;AAAA,UACpC,WAAoC;AAAA,UACpC,MAAoC;AAAA,UACpC,OAAoC;AAAA,UACpC,OAAoC;AAAA,UACpC,OAAoC;AAAA,UACpC,QAAoC;AAAA,UACpC,QAAoC;AAAA,UACpC,QAAoC;AAAA,UACpC,MAAoC;AAAA,UACpC,OAAoC;AAAA,UACpC,OAAoC;AAAA,UACpC,sBAAoC;AAAA,UACpC,cAAoC;AAAA;AAAA,QACtC;AAEF,iBAAS,MAAMA,UAAS,MAAO,CAAAA,UAAS,MAAMA,UAAS,MAAM,EAAE,CAAC,IAAI;AAGpE,YAAIA,UAAS;AAEb,cAAM,OAAO;AAAA,UACX,KAAsB;AAAA;AAAA,UACtB,UAAsB;AAAA;AAAA,UACtB,gBAAsB;AAAA;AAAA,UACtB,OAAsB;AAAA;AAAA,UAEtB,aAAsB;AAAA;AAAA,UACtB,MAAsB;AAAA;AAAA,UACtB,OAAsB;AAAA;AAAA,UACtB,OAAsB;AAAA;AAAA,UACtB,QAAsB;AAAA;AAAA,UAEtB,IAAsB;AAAA;AAAA,UACtB,IAAsB;AAAA;AAAA,UAEtB,OAAsB;AAAA;AAAA,UAEtB,GAAsB;AAAA;AAAA,UAEtB,aAAsB;AAAA;AAAA,UACtB,WAAsB;AAAA;AAAA,UACtB,cAAsB;AAAA;AAAA,UAEtB,GAAsB;AAAA;AAAA,UACtB,GAAsB;AAAA;AAAA,UACtB,GAAsB;AAAA;AAAA,UACtB,GAAsB;AAAA;AAAA,UACtB,GAAsB;AAAA;AAAA,UACtB,GAAsB;AAAA;AAAA,UACtB,GAAsB;AAAA;AAAA,UACtB,GAAsB;AAAA;AAAA,UACtB,GAAsB;AAAA;AAAA,UACtB,GAAsB;AAAA;AAAA,UAEtB,WAAsB;AAAA;AAAA,UACtB,YAAsB;AAAA;AAAA,QACxB;AAEA,YAAI,CAAC,OAAO,QAAQ;AAClB,iBAAO,SAAS,SAAU,GAAG;AAC3B,qBAAS,IAAK;AAAE,mBAAK,WAAW,IAAI;AAAA,YAAG;AACvC,cAAE,YAAY;AACd,mBAAO,IAAI;AAAA,UACb;AAAA,QACF;AAEA,YAAI,CAAC,OAAO,gBAAgB;AAC1B,iBAAO,iBAAiB,SAAU,GAAG;AACnC,mBAAO,EAAE,WAAW;AAAA,UACtB;AAAA,QACF;AAEA,YAAI,CAAC,OAAO,MAAM;AAChB,iBAAO,OAAO,SAAU,GAAG;AACzB,gBAAI,IAAI,CAAC;AACT,qBAAS,KAAK,EAAG,KAAI,EAAE,eAAe,CAAC,EAAG,GAAE,KAAK,CAAC;AAClD,mBAAO;AAAA,UACT;AAAA,QACF;AAEA,iBAAS,kBAAmB,QAAQ;AAClC,cAAI,aAAa,KAAK,IAAIA,UAAS,mBAAmB,EAAE,GACpD,YAAY;AAEhB,mBAAS,UAAU,SAAS;AAC1B,gBAAI,MAAM,OAAO,MAAM,MAAM,SAAY,IAAI,OAAO,MAAM,EAAE;AAC5D,gBAAI,MAAM,YAAY;AACpB,sBAAQ,QAAQ;AAAA,gBACd,KAAK;AACH,4BAAU,MAAM;AAClB;AAAA,gBAEA;AACE,wBAAM,QAAQ,iCAAgC,MAAM;AAAA,cACxD;AAAA,YACF;AACA,wBAAY,KAAK,IAAI,WAAW,GAAG;AAAA,UACrC;AACA,iBAAO,sBAAuBA,UAAS,oBAAoB,YAC9B,OAAO;AAAA,QACtC;AAEA,iBAAS,aAAc,QAAQ;AAC7B,mBAAS,UAAU,SAAS;AAC1B,mBAAO,MAAM,IAAI,QAAQ,MAAM;AAAA,UACjC;AAAA,QACF;AAEA,YAAI,qBAAqB;AAEzB,iBAAS,QAAS,KAAK;AACrB,cAAI,EAAE,gBAAgB,SAAU,QAAO,IAAI,QAAS,GAAG;AAEvD,cAAI,SAAS;AACb,uBAAa,MAAM;AACnB,iBAAO,sBAAsBA,UAAS;AACtC,iBAAO,IAAW,OAAO,IAAI,OAAO,IAAI;AACxC,iBAAO,MAAW,OAAO,CAAC;AAC1B,iBAAO,SAAW,OAAO,aAAa,OAAO,UAAU;AACvD,iBAAO,MAAW,OAAO,QAAQ;AACjC,iBAAO,QAAW,EAAE;AACpB,iBAAO,QAAW,IAAI,MAAM;AAE5B,iBAAO,WAAW,OAAO,SAAS;AAClC,iBAAO,OAAW;AAClB,iBAAO,UAAW;AAClB,iBAAO,WAAW;AAClB,iBAAO,WAAW;AAClB,iBAAO,QAAW;AAClB,eAAK,QAAQ,SAAS;AAAA,QACxB;AAEA,gBAAQ,YACN;AAAA,UAAE,KAAS,WAAY;AAAE,gBAAI,IAAI;AAAA,UAAG;AAAA,UAClC;AAAA,UACA,QAAS,WAAY;AAAE,iBAAK,QAAQ;AAAM,mBAAO;AAAA,UAAM;AAAA,UACvD,OAAS,WAAY;AAAE,mBAAO,KAAK,MAAM,IAAI;AAAA,UAAG;AAAA,QAClD;AAOF,iBAAS,WAAY;AAAA,QAAC;AAGtB,iBAAS,aAAc,KAAK;AAAE,iBAAO,IAAI,QAAQ,GAAG;AAAA,QAAG;AAEvD,iBAAS,QAAS,KAAK;AACrB,cAAI,EAAE,gBAAgB,SAAU,QAAO,IAAI,QAAQ,GAAG;AAEtD,eAAK,UAAU,IAAI,QAAQ,GAAG;AAC9B,eAAK,WAAW;AAChB,eAAK,WAAW;AAGhB,eAAK,kBAAkB;AACvB,eAAK,oBAAoB;AACzB,eAAK,aAAa,EAAE,KAAK,IAAI,OAAO,CAAC,GAAG,KAAK,IAAI,OAAO,CAAC,GAAG,KAAK,IAAI,OAAO,CAAC,EAAE;AAC/E,eAAK,SAAS;AAEd,cAAI,KAAK;AACT,iBAAO,MAAM,EAAE;AAEf,eAAK,QAAQ,QAAQ,WAAY;AAAE,eAAG,KAAK,KAAK;AAAA,UAAG;AACnD,eAAK,QAAQ,UAAU,SAAU,IAAI;AACnC,eAAG,KAAK,SAAS,EAAE;AACnB,eAAG,QAAQ,QAAQ;AAAA,UACrB;AAEA,sBAAY,QAAQ,SAAU,IAAI;AAChC,mBAAO;AAAA,cAAe;AAAA,cAAI,OAAO;AAAA,cAC/B;AAAA,gBAAE,KAAe,WAAY;AAAE,yBAAO,GAAG,QAAQ,OAAO,EAAE;AAAA,gBAAG;AAAA,gBAC3D,KAAe,SAAU,GAAG;AAC1B,sBAAI,CAAC,GAAG;AACN,uBAAG,mBAAmB,EAAE;AACxB,uBAAG,QAAQ,OAAK,EAAE,IAAI;AACtB,2BAAO;AAAA,kBACT;AACA,qBAAG,GAAG,IAAI,CAAC;AAAA,gBACb;AAAA,gBACA,YAAe;AAAA,gBACf,cAAe;AAAA,cACjB;AAAA,YAAC;AAAA,UACL,CAAC;AAAA,QACH;AAEA,gBAAQ,YAAY,OAAO;AAAA,UAAO,OAAO;AAAA,UACvC,EAAE,aAAa,EAAE,OAAO,QAAQ,EAAE;AAAA,QAAC;AAErC,gBAAQ,UAAU,QAAQ,SAAU,MAAM;AACxC,iBAAO,IAAI,OAAO,IAAI;AACtB,mBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,gBAAI,IAAI,KAAK,CAAC;AAId,gBAAI,KAAK,kBAAkB,GAAG;AAC5B,uBAAS,IAAI,GAAG,IAAI,KAAK,iBAAiB,KAAK;AAC7C,qBAAK,WAAW,KAAK,iBAAiB,EAAE,KAAK,oBAAoB,KAAK,kBAAkB,CAAC,IAAI,KAAK,CAAC;AAAA,cACrG;AACA,mBAAK,SAAS,KAAK,WAAW,KAAK,iBAAiB,EAAE,SAAS;AAC/D,mBAAK,oBAAoB,KAAK,kBAAkB;AAGhD,kBAAI,IAAI,IAAI;AAGZ,mBAAK,QAAQ,MAAM,KAAK,MAAM;AAC9B,mBAAK,KAAK,QAAQ,KAAK,MAAM;AAC7B;AAAA,YACF;AAGA,gBAAI,KAAK,oBAAoB,KAAK,KAAK,KAAK;AAC1C,kBAAK,KAAK,OAAS,KAAK,IAAM,MAAK,oBAAoB;AACvD,kBAAK,KAAK,OAAS,KAAK,IAAM,MAAK,oBAAoB;AACvD,kBAAK,KAAK,OAAS,KAAK,IAAM,MAAK,oBAAoB;AACvD,kBAAK,KAAK,oBAAoB,IAAK,KAAK,QAAQ;AAE9C,yBAAS,IAAI,GAAG,KAAM,KAAK,SAAS,IAAI,GAAI,KAAK;AAC/C,uBAAK,WAAW,KAAK,iBAAiB,EAAE,CAAC,IAAI,KAAK,IAAI,CAAC;AAAA,gBACzD;AACA,qBAAK,kBAAmB,IAAI,KAAK,oBAAqB,KAAK;AAG3D,uBAAO;AAAA,cACT,OAAO;AACL,qBAAK,SAAS,KAAK,MAAM,GAAI,IAAI,KAAK,iBAAkB,EAAE,SAAS;AACnE,oBAAI,IAAI,KAAK,oBAAoB;AAEjC,qBAAK,QAAQ,MAAM,KAAK,MAAM;AAC9B,qBAAK,KAAK,QAAQ,KAAK,MAAM;AAC7B;AAAA,cACF;AAAA,YACF;AAGA,qBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,kBAAI,KAAK,CAAC,KAAK,IAAK;AAAA,YACtB;AACA,iBAAK,SAAS,KAAK,MAAM,GAAG,CAAC,EAAE,SAAS;AACxC,iBAAK,QAAQ,MAAM,KAAK,MAAM;AAC9B,iBAAK,KAAK,QAAQ,KAAK,MAAM;AAC7B,gBAAI,IAAI;AAGR;AAAA,UACF;AAAA,QACF;AAEA,gBAAQ,UAAU,MAAM,SAAU,OAAO;AACvC,cAAI,SAAS,MAAM,OAAQ,MAAK,QAAQ,MAAM,MAAM,SAAS,CAAC;AAC9D,eAAK,QAAQ,IAAI;AACjB,iBAAO;AAAA,QACT;AAEA,gBAAQ,UAAU,KAAK,SAAU,IAAI,SAAS;AAC5C,cAAI,KAAK;AACT,cAAI,CAAC,GAAG,QAAQ,OAAK,EAAE,KAAK,YAAY,QAAQ,EAAE,MAAM,IAAI;AAC1D,eAAG,QAAQ,OAAK,EAAE,IAAI,WAAY;AAChC,kBAAI,OAAO,UAAU,WAAW,IAAI,CAAC,UAAU,CAAC,CAAC,IACtC,MAAM,MAAM,MAAM,SAAS;AACtC,mBAAK,OAAO,GAAG,GAAG,EAAE;AACpB,iBAAG,KAAK,MAAM,IAAI,IAAI;AAAA,YACxB;AAAA,UACF;AACA,iBAAO,OAAO,UAAU,GAAG,KAAK,IAAI,IAAI,OAAO;AAAA,QACjD;AAEA,gBAAQ,UAAU,UAAU,WAAY;AACtC,uBAAa,KAAK,OAAO;AACzB,eAAK,KAAK,OAAO;AAAA,QACnB;AAEA,iBAAS,KAAK,QAAQ,OAAO,MAAM;AACjC,cAAGA,UAAS,KAAM,SAAQ,IAAI,WAAW,OAAO,IAAI;AACpD,cAAI,OAAO,KAAK,EAAG,QAAO,KAAK,EAAE,IAAI;AAAA,QACvC;AAEA,iBAAS,SAAS,QAAQ,OAAO,MAAM;AACrC,qBAAW,MAAM;AACjB,eAAK,QAAQ,OAAO,IAAI;AAAA,QAC1B;AAEA,iBAAS,WAAW,QAAQ,OAAO;AACjC,iBAAO,WAAW,SAAS,OAAO,KAAK,OAAO,QAAQ;AACtD,cAAI,OAAO,aAAa,QAAW;AACjC,iBAAK,QAAS,QAAQ,QAAQ,WAAY,OAAO,QAAQ;AAAA,UAC3D;AACA,iBAAO,WAAW;AAAA,QACpB;AAEA,iBAAS,YAAY,QAAQ;AAC3B,cAAI,OAAO;AACT,iBAAK,QAAQ,WAAW,WAAW,OAAO,UAAU,CAAC;AACvD,iBAAO,aAAa;AAAA,QACtB;AAEA,iBAAS,SAAU,KAAK,MAAM;AAC5B,cAAI,SAAS,QAAW;AACtB,mBAAO;AAAA,UACT;AACA,cAAI,IAAI,KAAM,QAAO,KAAK,KAAK;AAC/B,cAAI,IAAI,UAAW,QAAO,KAAK,QAAQ,QAAQ,GAAG;AAClD,iBAAO;AAAA,QACT;AAEA,iBAAS,MAAO,QAAQ,IAAI;AAC1B,qBAAW,MAAM;AACjB,gBAAM,aAAW,OAAO,OAClB,eAAa,OAAO,SACpB,aAAW,OAAO;AACxB,eAAK,IAAI,MAAM,EAAE;AACjB,iBAAO,QAAQ;AACf,eAAK,QAAQ,WAAW,EAAE;AAC1B,iBAAO;AAAA,QACT;AAEA,iBAAS,IAAI,QAAQ;AACnB,cAAI,OAAO,UAAU,EAAE,SAAS,OAAO,UAAU;AAC/C,kBAAM,QAAQ,gBAAgB;AAEhC,qBAAW,MAAM;AACjB,iBAAO,IAAS;AAChB,iBAAO,SAAS;AAChB,eAAK,QAAQ,OAAO;AACpB,kBAAQ,KAAK,QAAQ,OAAO,GAAG;AAC/B,iBAAO;AAAA,QACT;AAEA,iBAAS,aAAa,GAAG;AACvB,iBAAO,MAAM,KAAK,kBAAkB,MAAM,KAAK,YAAY,MAAM,KAAK,SAAS,MAAM,KAAK;AAAA,QAC5F;AAEA,iBAAS,MAAO,OAAO;AACrB,cAAI,SAAS;AACb,cAAI,KAAK,MAAO,OAAM,KAAK;AAC3B,cAAI,OAAO,OAAQ,QAAO;AAAA,YAAM;AAAA,YAC9B;AAAA,UAAsD;AACxD,cAAI,UAAU,KAAM,QAAO,IAAI,MAAM;AACrC,cAAI,IAAI,GAAG,IAAI,MAAM,WAAW,CAAC,GAAG,IAAI,OAAO;AAC/C,cAAI,iBAAiB;AACrB,cAAIA,UAAS,MAAO,SAAQ,IAAI,eAAe,QAAQ,GAAG;AAC1D,iBAAO,GAAG;AACR,gBAAI;AACJ,mBAAO,IAAI,IAAI,MAAM,WAAW,GAAG;AAKnC,gBAAG,MAAM,EAAI,QAAO,IAAI;AAAA,gBACnB,KAAI,OAAO;AAEhB,gBAAG,CAAC,EAAG;AAEP,gBAAIA,UAAS,MAAO,SAAQ,IAAI,GAAE,GAAEA,UAAS,MAAM,OAAO,KAAK,CAAC;AAChE,gBAAI,CAAC,gBAAgB;AACnB,qBAAO;AACP,kBAAI,MAAM,KAAK,UAAU;AACvB,uBAAO;AACP,uBAAO,SAAS;AAAA,cAClB,MAAO,QAAO;AAAA,YAChB,OAAO;AACL,+BAAiB;AAAA,YACnB;AACA,oBAAQ,OAAO,OAAO;AAAA,cAEpB,KAAK,EAAE;AACL,oBAAI,MAAM,KAAK,UAAW,QAAO,QAAQ,EAAE;AAAA,yBAClC,MAAM,KAAK,YAAa,QAAO,QAAQ,EAAE;AAAA,yBACzC,CAAC,aAAa,CAAC;AACtB,wBAAM,QAAQ,2BAA2B;AAC7C;AAAA,cAEA,KAAK,EAAE;AAAA,cACP,KAAK,EAAE;AACL,oBAAI,aAAa,CAAC,EAAG;AACrB,oBAAG,OAAO,UAAU,EAAE,SAAU,QAAO,MAAM,KAAK,EAAE,SAAS;AAAA,qBACxD;AACH,sBAAG,MAAM,KAAK,YAAY;AACxB,yBAAK,QAAQ,cAAc;AAC3B,yBAAK;AACL,yBAAK,QAAQ,eAAe;AAC5B,yBAAK;AACL,2BAAO,QAAQ,OAAO,MAAM,IAAI,KAAK,EAAE;AACvC;AAAA,kBACF,MAAQ,QAAO,MAAM,KAAK,EAAE,YAAY;AAAA,gBAC1C;AACA,oBAAG,MAAM,KAAK,YAAa,QAAO,QAAQ,EAAE;AAAA,oBACvC,OAAM,QAAQ,0CAA2C;AAChE;AAAA,cAEA,KAAK,EAAE;AAAA,cACP,KAAK,EAAE;AACL,oBAAI,aAAa,CAAC,EAAG;AACrB,oBAAI,QAAS,OAAO,UAAU,EAAE,YAAa,QAAQ;AACrD,oBAAG,MAAM,KAAK,OAAO;AACnB,sBAAG,OAAO,UAAU,EAAE,cAAc;AAClC,2BAAO,MAAM,KAAK,EAAE,YAAY;AAChC,+BAAW,QAAQ,cAAc;AAChC,yBAAK;AAAA,kBACR,MAAO,YAAW,QAAQ,OAAO;AACjC,yBAAO,QAAS,EAAE;AAAA,gBACpB,WAAW,MAAM,KAAK,YAAY;AAChC,2BAAS,QAAQ,eAAe;AAChC,uBAAK;AACL,yBAAO,QAAQ,OAAO,MAAM,IAAI,KAAK,EAAE;AAAA,gBACzC,WAAU,MAAM,KAAK,OAAO;AAC1B,sBAAG,OAAO,UAAU,EAAE;AACpB,2BAAO,MAAM,KAAK,EAAE,YAAY;AAClC,6BAAW,MAAM;AACjB,yBAAO,QAAS,EAAE;AAAA,gBACpB,MAAO,OAAM,QAAQ,YAAY;AACnC;AAAA,cAEA,KAAK,EAAE;AAAA;AAAA,cACP,KAAK,EAAE;AACL,oBAAI,aAAa,CAAC,EAAG;AACrB,oBAAG,OAAO,UAAQ,EAAE,YAAY;AAC9B,uBAAK,QAAQ,aAAa;AAC1B,uBAAK;AACL,yBAAO,QAAQ,EAAE;AACjB,sBAAG,MAAM,KAAK,cAAc;AAC1B,yBAAK,QAAQ,cAAc;AAC3B,yBAAK;AACL,2BAAO,QAAQ,OAAO,MAAM,IAAI,KAAK,EAAE;AACvC;AAAA,kBACF,OAAO;AACL,2BAAO,MAAM,KAAK,EAAE,WAAW;AAAA,kBACjC;AAAA,gBACF;AACK,oBAAG,MAAM,KAAK,YAAa,QAAO,QAAQ,EAAE;AAAA,yBACzC,MAAM,KAAK,UAAW,QAAO,QAAQ,EAAE;AAAA,yBACvC,MAAM,KAAK,YAAa,QAAO,QAAQ,EAAE;AAAA,yBACzC,MAAM,KAAK,EAAG,QAAO,QAAQ,EAAE;AAAA,yBAC/B,MAAM,KAAK,EAAG,QAAO,QAAQ,EAAE;AAAA,yBAC/B,MAAM,KAAK,EAAG,QAAO,QAAQ,EAAE;AAAA,yBAC/B,MAAM,KAAK,OAAO;AACxB,yBAAO,cAAc;AAAA,gBACvB,WAAU,KAAK,MAAM,KAAK,KAAK,KAAK,IAAI;AACtC,yBAAO,cAAc,OAAO,aAAa,CAAC;AAC1C,yBAAO,QAAQ,EAAE;AAAA,gBACnB,MAAqB,OAAM,QAAQ,WAAW;AAChD;AAAA,cAEA,KAAK,EAAE;AACL,oBAAG,MAAM,KAAK,OAAO;AACnB,yBAAO,MAAM,KAAK,EAAE,WAAW;AAC/B,6BAAW,QAAQ,SAAS;AAC5B,yBAAO,QAAS,EAAE;AAAA,gBACpB,WAAW,MAAM,KAAK,cAAc;AAClC,2BAAS,QAAQ,cAAc;AAC/B,uBAAK;AACL,yBAAO,QAAQ,OAAO,MAAM,IAAI,KAAK,EAAE;AAAA,gBACzC,WAAW,aAAa,CAAC;AACrB;AAAA,oBACC,OAAM,QAAQ,WAAW;AAChC;AAAA,cAEA,KAAK,EAAE;AACL,oBAAI,OAAO,aAAa,QAAW;AACjC,yBAAO,WAAW;AAAA,gBACpB;AAGA,oBAAI,SAAsB,IAAE,GACxB,UAAU,OAAO,SACjB,WAAW,OAAO;AAEtB,+BAAgB,QAAO,MAAM;AAC3B,sBAAIA,UAAS;AACX,4BAAQ;AAAA,sBAAI;AAAA,sBAAE;AAAA,sBAAEA,UAAS,MAAM,OAAO,KAAK;AAAA,sBAC/B;AAAA,oBAAO;AAErB,yBAAO,WAAW,GAAG;AACnB,2BAAO,YAAY,OAAO,aAAa,CAAC;AACxC,wBAAI,MAAM,WAAW,GAAG;AACxB,2BAAO;AACP,wBAAI,aAAa,GAAG;AAElB,6BAAO,YAAY,OAAO,aAAa,SAAS,OAAO,UAAU,EAAE,CAAC;AACpE,iCAAW;AACX,+BAAS,IAAE;AAAA,oBACb,OAAO;AACL;AAAA,oBACF;AAEA,wBAAI,CAAC,EAAG,OAAM;AAAA,kBAChB;AACA,sBAAI,MAAM,KAAK,eAAe,CAAC,SAAS;AACtC,2BAAO,QAAQ,OAAO,MAAM,IAAI,KAAK,EAAE;AACvC,2BAAO,YAAY,MAAM,UAAU,QAAQ,IAAE,CAAC;AAC9C,2BAAO,YAAY,IAAI,IAAI;AAC3B;AAAA,kBACF;AACA,sBAAI,MAAM,KAAK,aAAa,CAAC,SAAS;AACpC,8BAAU;AACV,2BAAO,YAAY,MAAM,UAAU,QAAQ,IAAE,CAAC;AAC9C,2BAAO,YAAY,IAAI,IAAI;AAC3B,wBAAI,MAAM,WAAW,GAAG;AACxB,2BAAO;AACP,wBAAI,CAAC,EAAG;AAAA,kBACV;AACA,sBAAI,SAAS;AACX,8BAAU;AACL,wBAAI,MAAM,KAAK,GAAG;AAAE,6BAAO,YAAY;AAAA,oBAAM,WACzC,MAAM,KAAK,GAAG;AAAE,6BAAO,YAAY;AAAA,oBAAM,WACzC,MAAM,KAAK,GAAG;AAAE,6BAAO,YAAY;AAAA,oBAAM,WACzC,MAAM,KAAK,GAAG;AAAE,6BAAO,YAAY;AAAA,oBAAM,WACzC,MAAM,KAAK,GAAG;AAAE,6BAAO,YAAY;AAAA,oBAAM,WACzC,MAAM,KAAK,GAAG;AAErB,iCAAW;AACX,6BAAO,WAAW;AAAA,oBACpB,OAAO;AACL,6BAAO,YAAY,OAAO,aAAa,CAAC;AAAA,oBAC1C;AACA,wBAAI,MAAM,WAAW,GAAG;AACxB,2BAAO;AACP,6BAAS,IAAE;AACX,wBAAI,CAAC,EAAG;AAAA,wBACH;AAAA,kBACP;AAEA,qCAAmB,YAAY;AAC/B,sBAAI,WAAW,mBAAmB,KAAK,KAAK;AAC5C,sBAAI,aAAa,MAAM;AACrB,wBAAI,MAAM,SAAO;AACjB,2BAAO,YAAY,MAAM,UAAU,QAAQ,IAAE,CAAC;AAC9C,2BAAO,YAAY,IAAI,IAAI;AAC3B;AAAA,kBACF;AACA,sBAAI,SAAS,QAAM;AACnB,sBAAI,MAAM,WAAW,SAAS,KAAK;AACnC,sBAAI,CAAC,GAAG;AACN,2BAAO,YAAY,MAAM,UAAU,QAAQ,IAAE,CAAC;AAC9C,2BAAO,YAAY,IAAI,IAAI;AAC3B;AAAA,kBACF;AAAA,gBACF;AACA,uBAAO,UAAU;AACjB,uBAAO,WAAW;AACpB;AAAA,cAEA,KAAK,EAAE;AACL,oBAAI,MAAM,KAAK,EAAG,QAAO,QAAQ,EAAE;AAAA,oBAC9B,OAAM,QAAQ,gCAA+B,CAAC;AACrD;AAAA,cAEA,KAAK,EAAE;AACL,oBAAI,MAAM,KAAK,EAAG,QAAO,QAAQ,EAAE;AAAA,oBAC9B,OAAM,QAAQ,iCAAgC,CAAC;AACtD;AAAA,cAEA,KAAK,EAAE;AACL,oBAAG,MAAM,KAAK,GAAG;AACf,uBAAK,QAAQ,WAAW,IAAI;AAC5B,yBAAO,QAAQ,OAAO,MAAM,IAAI,KAAK,EAAE;AAAA,gBACzC,MAAO,OAAM,QAAQ,kCAAiC,CAAC;AACzD;AAAA,cAEA,KAAK,EAAE;AACL,oBAAI,MAAM,KAAK,EAAG,QAAO,QAAQ,EAAE;AAAA,oBAC9B,OAAM,QAAQ,iCAAgC,CAAC;AACtD;AAAA,cAEA,KAAK,EAAE;AACL,oBAAI,MAAM,KAAK,EAAG,QAAO,QAAQ,EAAE;AAAA,oBAC9B,OAAM,QAAQ,kCAAiC,CAAC;AACvD;AAAA,cAEA,KAAK,EAAE;AACL,oBAAI,MAAM,KAAK,EAAG,QAAO,QAAQ,EAAE;AAAA,oBAC9B,OAAM,QAAQ,mCAAkC,CAAC;AACxD;AAAA,cAEA,KAAK,EAAE;AACL,oBAAI,MAAM,KAAK,GAAG;AAChB,uBAAK,QAAQ,WAAW,KAAK;AAC7B,yBAAO,QAAQ,OAAO,MAAM,IAAI,KAAK,EAAE;AAAA,gBACzC,MAAO,OAAM,QAAQ,oCAAmC,CAAC;AAC3D;AAAA,cAEA,KAAK,EAAE;AACL,oBAAI,MAAM,KAAK,EAAG,QAAO,QAAQ,EAAE;AAAA,oBAC9B,OAAM,QAAQ,gCAA+B,CAAC;AACrD;AAAA,cAEA,KAAK,EAAE;AACL,oBAAI,MAAM,KAAK,EAAG,QAAO,QAAQ,EAAE;AAAA,oBAC9B,OAAM,QAAQ,iCAAgC,CAAC;AACtD;AAAA,cAEA,KAAK,EAAE;AACL,oBAAG,MAAM,KAAK,GAAG;AACf,uBAAK,QAAQ,WAAW,IAAI;AAC5B,yBAAO,QAAQ,OAAO,MAAM,IAAI,KAAK,EAAE;AAAA,gBACzC,MAAO,OAAM,QAAQ,kCAAiC,CAAC;AACzD;AAAA,cAEA,KAAK,EAAE;AACL,oBAAG,MAAM,KAAK,QAAQ;AACpB,yBAAO,cAAc;AACrB,yBAAO,QAAc,EAAE;AAAA,gBACzB,MAAO,OAAM,QAAQ,gCAAgC;AACvD;AAAA,cAEA,KAAK,EAAE;AACL,oBAAG,KAAK,MAAM,KAAK,KAAK,KAAK,GAAI,QAAO,cAAc,OAAO,aAAa,CAAC;AAAA,yBAClE,MAAM,KAAK,QAAQ;AAC1B,sBAAG,OAAO,WAAW,QAAQ,GAAG,MAAI;AAClC,0BAAM,QAAQ,6BAA6B;AAC7C,yBAAO,cAAc;AAAA,gBACvB,WAAW,MAAM,KAAK,KAAK,MAAM,KAAK,GAAG;AACvC,sBAAG,OAAO,WAAW,QAAQ,GAAG,MAAI,MACjC,OAAO,WAAW,QAAQ,GAAG,MAAI;AACjC,0BAAM,QAAQ,oCAAoC;AACrD,yBAAO,cAAc;AAAA,gBACvB,WAAW,MAAM,KAAK,QAAQ,MAAM,KAAK,OAAO;AAC9C,sBAAG,EAAE,MAAM,KAAK,KAAK,MAAM,KAAK;AAC9B,0BAAM,QAAQ,0BAA0B;AAC1C,yBAAO,cAAc,OAAO,aAAa,CAAC;AAAA,gBAC5C,OAAO;AACL,8BAAY,MAAM;AAClB;AACA,mCAAiB;AACjB,yBAAO,QAAQ,OAAO,MAAM,IAAI,KAAK,EAAE;AAAA,gBACzC;AACF;AAAA,cAEA;AACE,sBAAM,QAAQ,oBAAoB,OAAO,KAAK;AAAA,YAClD;AAAA,UACF;AACA,cAAI,OAAO,YAAY,OAAO;AAC5B,8BAAkB,MAAM;AAC1B,iBAAO;AAAA,QACT;AAAA,MAEF,GAAI,QAAQ,IAAI,OAAO;AAAA;AAAA;",
  "names": ["clarinet"]
}
