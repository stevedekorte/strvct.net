{
  "xobl1OO5XUSQbp1wm7/qDIgnIcPLj1Yv7ySZ/NM94Aw=": "html,\nbody {\n    position: absolute;\n    overflow: hidden;\n\n    overscroll-behavior-x: none;\n    overscroll-behavior-y: none;\n\n    top: 0px;\n    left: 0px;\n\n    height: 100%;\n    width: 100%;\n\n    padding: 0px;\n    margin: 0px;\n    border: 0px;\n\n    background-color: black;\n    zoom: 100%;\n\n    font-size: 16px;\n    text-size-adjust: 100%;\n\n    -webkit-font-smoothing: antialiased;\n\n    /*\n    text-size-adjust: none; \n    -ms-text-size-adjust: none;\n    -moz-text-size-adjust: none;\n    -webkit-text-size-adjust: none;\n    */\n\n    /* text-size-adjust fixes issue with contenteditable fonts being tiny */\n    /*\n    text-size-adjust: 100%; \n    -ms-text-size-adjust: 100%; \n    -moz-text-size-adjust: 100%; \n    -webkit-text-size-adjust: 100%;\n    */\n\n    /* disable pinch-zoom browser action, but still available to JS */\n    touch-action: none;\n\n    /* disable left-right paging on windows surface */\n    -ms-scroll-chaining: none;\n}\n\n/* an attempt to deal with tiny fonts on mobile */\n\nhtml * {\n    min-height: 1px;\n    max-height: 999999px;\n    zoom: 100%;\n}\n\n/* to avoid slow/choppy handling of touchmove events */\n\nhtml * {\n    touch-action: pan-y;\n}\n\n/* use border-box to make sure padding is included in dom width calculations */\n\nhtml * {\n    box-sizing: border-box;\n}\n\n/* avoid outlines */\n\nhtml * {\n    outline: none;\n    outline-style: none;\n    -moz-outline-style: none;\n}\n\nhtml * :focus {\n    outline: none;\n    outline-style: none;\n    -moz-outline-style: none;\n}\n\nhtml * :active {\n    outline: none;\n    outline-style: none;\n    -moz-outline-style: none;\n}",
  "bbNosz5JlGdezcH8vxdbJ+b/hVKQTTRxrb+kM13pxc0=": "/**\n * [js-sha256]{@link https://github.com/emn178/js-sha256}\n *\n * @version 0.9.0\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2017\n * @license MIT\n */\n/*jslint bitwise: true */\n(function () {\n  'use strict';\n\n  var ERROR = 'input is invalid type';\n  var WINDOW = typeof window === 'object';\n  var root = WINDOW ? window : {};\n  if (root.JS_SHA256_NO_WINDOW) {\n    WINDOW = false;\n  }\n  var WEB_WORKER = !WINDOW && typeof self === 'object';\n  var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\n  if (NODE_JS) {\n    root = global;\n  } else if (WEB_WORKER) {\n    root = self;\n  }\n  var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === 'object' && module.exports;\n  var AMD = typeof define === 'function' && define.amd;\n  var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';\n  var HEX_CHARS = '0123456789abcdef'.split('');\n  var EXTRA = [-2147483648, 8388608, 32768, 128];\n  var SHIFT = [24, 16, 8, 0];\n  var K = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n  ];\n  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];\n\n  var blocks = [];\n\n  if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {\n    Array.isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {\n    ArrayBuffer.isView = function (obj) {\n      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n    };\n  }\n\n  var createOutputMethod = function (outputType, is224) {\n    return function (message) {\n      return new Sha256(is224, true).update(message)[outputType]();\n    };\n  };\n\n  var createMethod = function (is224) {\n    var method = createOutputMethod('hex', is224);\n    if (NODE_JS) {\n      method = nodeWrap(method, is224);\n    }\n    method.create = function () {\n      return new Sha256(is224);\n    };\n    method.update = function (message) {\n      return method.create().update(message);\n    };\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createOutputMethod(type, is224);\n    }\n    return method;\n  };\n\n  var nodeWrap = function (method, is224) {\n    var crypto = eval(\"require('crypto')\");\n    var Buffer = eval(\"require('buffer').Buffer\");\n    var algorithm = is224 ? 'sha224' : 'sha256';\n    var nodeMethod = function (message) {\n      if (typeof message === 'string') {\n        return crypto.createHash(algorithm).update(message, 'utf8').digest('hex');\n      } else {\n        if (message === null || message === undefined) {\n          throw new Error(ERROR);\n        } else if (message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        }\n      }\n      if (Array.isArray(message) || ArrayBuffer.isView(message) ||\n        message.constructor === Buffer) {\n        return crypto.createHash(algorithm).update(new Buffer(message)).digest('hex');\n      } else {\n        return method(message);\n      }\n    };\n    return nodeMethod;\n  };\n\n  var createHmacOutputMethod = function (outputType, is224) {\n    return function (key, message) {\n      return new HmacSha256(key, is224, true).update(message)[outputType]();\n    };\n  };\n\n  var createHmacMethod = function (is224) {\n    var method = createHmacOutputMethod('hex', is224);\n    method.create = function (key) {\n      return new HmacSha256(key, is224);\n    };\n    method.update = function (key, message) {\n      return method.create(key).update(message);\n    };\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createHmacOutputMethod(type, is224);\n    }\n    return method;\n  };\n\n  function Sha256(is224, sharedMemory) {\n    if (sharedMemory) {\n      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n        blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n        blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      this.blocks = blocks;\n    } else {\n      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    }\n\n    if (is224) {\n      this.h0 = 0xc1059ed8;\n      this.h1 = 0x367cd507;\n      this.h2 = 0x3070dd17;\n      this.h3 = 0xf70e5939;\n      this.h4 = 0xffc00b31;\n      this.h5 = 0x68581511;\n      this.h6 = 0x64f98fa7;\n      this.h7 = 0xbefa4fa4;\n    } else { // 256\n      this.h0 = 0x6a09e667;\n      this.h1 = 0xbb67ae85;\n      this.h2 = 0x3c6ef372;\n      this.h3 = 0xa54ff53a;\n      this.h4 = 0x510e527f;\n      this.h5 = 0x9b05688c;\n      this.h6 = 0x1f83d9ab;\n      this.h7 = 0x5be0cd19;\n    }\n\n    this.block = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n    this.is224 = is224;\n  }\n\n  Sha256.prototype.update = function (message) {\n    if (this.finalized) {\n      return;\n    }\n    var notString, type = typeof message;\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (message === null) {\n          throw new Error(ERROR);\n        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        } else if (!Array.isArray(message)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n            throw new Error(ERROR);\n          }\n        }\n      } else {\n        throw new Error(ERROR);\n      }\n      notString = true;\n    }\n    var code, index = 0, i, length = message.length, blocks = this.blocks;\n\n    while (index < length) {\n      if (this.hashed) {\n        this.hashed = false;\n        blocks[0] = this.block;\n        blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n          blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n          blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n          blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      }\n\n      if (notString) {\n        for (i = this.start; index < length && i < 64; ++index) {\n          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n        }\n      } else {\n        for (i = this.start; index < length && i < 64; ++index) {\n          code = message.charCodeAt(index);\n          if (code < 0x80) {\n            blocks[i >> 2] |= code << SHIFT[i++ & 3];\n          } else if (code < 0x800) {\n            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else if (code < 0xd800 || code >= 0xe000) {\n            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else {\n            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          }\n        }\n      }\n\n      this.lastByteIndex = i;\n      this.bytes += i - this.start;\n      if (i >= 64) {\n        this.block = blocks[16];\n        this.start = i - 64;\n        this.hash();\n        this.hashed = true;\n      } else {\n        this.start = i;\n      }\n    }\n    if (this.bytes > 4294967295) {\n      this.hBytes += this.bytes / 4294967296 << 0;\n      this.bytes = this.bytes % 4294967296;\n    }\n    return this;\n  };\n\n  Sha256.prototype.finalize = function () {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex;\n    blocks[16] = this.block;\n    blocks[i >> 2] |= EXTRA[i & 3];\n    this.block = blocks[16];\n    if (i >= 56) {\n      if (!this.hashed) {\n        this.hash();\n      }\n      blocks[0] = this.block;\n      blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n        blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n        blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n    }\n    blocks[14] = this.hBytes << 3 | this.bytes >>> 29;\n    blocks[15] = this.bytes << 3;\n    this.hash();\n  };\n\n  Sha256.prototype.hash = function () {\n    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6,\n      h = this.h7, blocks = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;\n\n    for (j = 16; j < 64; ++j) {\n      // rightrotate\n      t1 = blocks[j - 15];\n      s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);\n      t1 = blocks[j - 2];\n      s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);\n      blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0;\n    }\n\n    bc = b & c;\n    for (j = 0; j < 64; j += 4) {\n      if (this.first) {\n        if (this.is224) {\n          ab = 300032;\n          t1 = blocks[0] - 1413257819;\n          h = t1 - 150054599 << 0;\n          d = t1 + 24177077 << 0;\n        } else {\n          ab = 704751109;\n          t1 = blocks[0] - 210244248;\n          h = t1 - 1521486534 << 0;\n          d = t1 + 143694565 << 0;\n        }\n        this.first = false;\n      } else {\n        s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));\n        s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));\n        ab = a & b;\n        maj = ab ^ (a & c) ^ bc;\n        ch = (e & f) ^ (~e & g);\n        t1 = h + s1 + ch + K[j] + blocks[j];\n        t2 = s0 + maj;\n        h = d + t1 << 0;\n        d = t1 + t2 << 0;\n      }\n      s0 = ((d >>> 2) | (d << 30)) ^ ((d >>> 13) | (d << 19)) ^ ((d >>> 22) | (d << 10));\n      s1 = ((h >>> 6) | (h << 26)) ^ ((h >>> 11) | (h << 21)) ^ ((h >>> 25) | (h << 7));\n      da = d & a;\n      maj = da ^ (d & b) ^ ab;\n      ch = (h & e) ^ (~h & f);\n      t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];\n      t2 = s0 + maj;\n      g = c + t1 << 0;\n      c = t1 + t2 << 0;\n      s0 = ((c >>> 2) | (c << 30)) ^ ((c >>> 13) | (c << 19)) ^ ((c >>> 22) | (c << 10));\n      s1 = ((g >>> 6) | (g << 26)) ^ ((g >>> 11) | (g << 21)) ^ ((g >>> 25) | (g << 7));\n      cd = c & d;\n      maj = cd ^ (c & a) ^ da;\n      ch = (g & h) ^ (~g & e);\n      t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];\n      t2 = s0 + maj;\n      f = b + t1 << 0;\n      b = t1 + t2 << 0;\n      s0 = ((b >>> 2) | (b << 30)) ^ ((b >>> 13) | (b << 19)) ^ ((b >>> 22) | (b << 10));\n      s1 = ((f >>> 6) | (f << 26)) ^ ((f >>> 11) | (f << 21)) ^ ((f >>> 25) | (f << 7));\n      bc = b & c;\n      maj = bc ^ (b & d) ^ cd;\n      ch = (f & g) ^ (~f & h);\n      t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];\n      t2 = s0 + maj;\n      e = a + t1 << 0;\n      a = t1 + t2 << 0;\n    }\n\n    this.h0 = this.h0 + a << 0;\n    this.h1 = this.h1 + b << 0;\n    this.h2 = this.h2 + c << 0;\n    this.h3 = this.h3 + d << 0;\n    this.h4 = this.h4 + e << 0;\n    this.h5 = this.h5 + f << 0;\n    this.h6 = this.h6 + g << 0;\n    this.h7 = this.h7 + h << 0;\n  };\n\n  Sha256.prototype.hex = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,\n      h6 = this.h6, h7 = this.h7;\n\n    var hex = HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +\n      HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +\n      HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +\n      HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +\n      HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +\n      HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +\n      HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +\n      HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +\n      HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +\n      HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +\n      HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +\n      HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +\n      HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F] +\n      HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +\n      HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +\n      HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +\n      HEX_CHARS[(h4 >> 28) & 0x0F] + HEX_CHARS[(h4 >> 24) & 0x0F] +\n      HEX_CHARS[(h4 >> 20) & 0x0F] + HEX_CHARS[(h4 >> 16) & 0x0F] +\n      HEX_CHARS[(h4 >> 12) & 0x0F] + HEX_CHARS[(h4 >> 8) & 0x0F] +\n      HEX_CHARS[(h4 >> 4) & 0x0F] + HEX_CHARS[h4 & 0x0F] +\n      HEX_CHARS[(h5 >> 28) & 0x0F] + HEX_CHARS[(h5 >> 24) & 0x0F] +\n      HEX_CHARS[(h5 >> 20) & 0x0F] + HEX_CHARS[(h5 >> 16) & 0x0F] +\n      HEX_CHARS[(h5 >> 12) & 0x0F] + HEX_CHARS[(h5 >> 8) & 0x0F] +\n      HEX_CHARS[(h5 >> 4) & 0x0F] + HEX_CHARS[h5 & 0x0F] +\n      HEX_CHARS[(h6 >> 28) & 0x0F] + HEX_CHARS[(h6 >> 24) & 0x0F] +\n      HEX_CHARS[(h6 >> 20) & 0x0F] + HEX_CHARS[(h6 >> 16) & 0x0F] +\n      HEX_CHARS[(h6 >> 12) & 0x0F] + HEX_CHARS[(h6 >> 8) & 0x0F] +\n      HEX_CHARS[(h6 >> 4) & 0x0F] + HEX_CHARS[h6 & 0x0F];\n    if (!this.is224) {\n      hex += HEX_CHARS[(h7 >> 28) & 0x0F] + HEX_CHARS[(h7 >> 24) & 0x0F] +\n        HEX_CHARS[(h7 >> 20) & 0x0F] + HEX_CHARS[(h7 >> 16) & 0x0F] +\n        HEX_CHARS[(h7 >> 12) & 0x0F] + HEX_CHARS[(h7 >> 8) & 0x0F] +\n        HEX_CHARS[(h7 >> 4) & 0x0F] + HEX_CHARS[h7 & 0x0F];\n    }\n    return hex;\n  };\n\n  Sha256.prototype.toString = Sha256.prototype.hex;\n\n  Sha256.prototype.digest = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,\n      h6 = this.h6, h7 = this.h7;\n\n    var arr = [\n      (h0 >> 24) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 8) & 0xFF, h0 & 0xFF,\n      (h1 >> 24) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 8) & 0xFF, h1 & 0xFF,\n      (h2 >> 24) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 8) & 0xFF, h2 & 0xFF,\n      (h3 >> 24) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 8) & 0xFF, h3 & 0xFF,\n      (h4 >> 24) & 0xFF, (h4 >> 16) & 0xFF, (h4 >> 8) & 0xFF, h4 & 0xFF,\n      (h5 >> 24) & 0xFF, (h5 >> 16) & 0xFF, (h5 >> 8) & 0xFF, h5 & 0xFF,\n      (h6 >> 24) & 0xFF, (h6 >> 16) & 0xFF, (h6 >> 8) & 0xFF, h6 & 0xFF\n    ];\n    if (!this.is224) {\n      arr.push((h7 >> 24) & 0xFF, (h7 >> 16) & 0xFF, (h7 >> 8) & 0xFF, h7 & 0xFF);\n    }\n    return arr;\n  };\n\n  Sha256.prototype.array = Sha256.prototype.digest;\n\n  Sha256.prototype.arrayBuffer = function () {\n    this.finalize();\n\n    var buffer = new ArrayBuffer(this.is224 ? 28 : 32);\n    var dataView = new DataView(buffer);\n    dataView.setUint32(0, this.h0);\n    dataView.setUint32(4, this.h1);\n    dataView.setUint32(8, this.h2);\n    dataView.setUint32(12, this.h3);\n    dataView.setUint32(16, this.h4);\n    dataView.setUint32(20, this.h5);\n    dataView.setUint32(24, this.h6);\n    if (!this.is224) {\n      dataView.setUint32(28, this.h7);\n    }\n    return buffer;\n  };\n\n  function HmacSha256(key, is224, sharedMemory) {\n    var i, type = typeof key;\n    if (type === 'string') {\n      var bytes = [], length = key.length, index = 0, code;\n      for (i = 0; i < length; ++i) {\n        code = key.charCodeAt(i);\n        if (code < 0x80) {\n          bytes[index++] = code;\n        } else if (code < 0x800) {\n          bytes[index++] = (0xc0 | (code >> 6));\n          bytes[index++] = (0x80 | (code & 0x3f));\n        } else if (code < 0xd800 || code >= 0xe000) {\n          bytes[index++] = (0xe0 | (code >> 12));\n          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));\n          bytes[index++] = (0x80 | (code & 0x3f));\n        } else {\n          code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff));\n          bytes[index++] = (0xf0 | (code >> 18));\n          bytes[index++] = (0x80 | ((code >> 12) & 0x3f));\n          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));\n          bytes[index++] = (0x80 | (code & 0x3f));\n        }\n      }\n      key = bytes;\n    } else {\n      if (type === 'object') {\n        if (key === null) {\n          throw new Error(ERROR);\n        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {\n          key = new Uint8Array(key);\n        } else if (!Array.isArray(key)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {\n            throw new Error(ERROR);\n          }\n        }\n      } else {\n        throw new Error(ERROR);\n      }\n    }\n\n    if (key.length > 64) {\n      key = (new Sha256(is224, true)).update(key).array();\n    }\n\n    var oKeyPad = [], iKeyPad = [];\n    for (i = 0; i < 64; ++i) {\n      var b = key[i] || 0;\n      oKeyPad[i] = 0x5c ^ b;\n      iKeyPad[i] = 0x36 ^ b;\n    }\n\n    Sha256.call(this, is224, sharedMemory);\n\n    this.update(iKeyPad);\n    this.oKeyPad = oKeyPad;\n    this.inner = true;\n    this.sharedMemory = sharedMemory;\n  }\n  HmacSha256.prototype = new Sha256();\n\n  HmacSha256.prototype.finalize = function () {\n    Sha256.prototype.finalize.call(this);\n    if (this.inner) {\n      this.inner = false;\n      var innerHash = this.array();\n      Sha256.call(this, this.is224, this.sharedMemory);\n      this.update(this.oKeyPad);\n      this.update(innerHash);\n      Sha256.prototype.finalize.call(this);\n    }\n  };\n\n  var exports = createMethod();\n  exports.sha256 = exports;\n  exports.sha224 = createMethod(true);\n  exports.sha256.hmac = createHmacMethod();\n  exports.sha224.hmac = createHmacMethod(true);\n\n  if (COMMON_JS) {\n    module.exports = exports;\n  } else {\n    root.sha256 = exports.sha256;\n    root.sha224 = exports.sha224;\n    if (AMD) {\n      define(function () {\n        return exports;\n      });\n    }\n  }\n})();\n",
  "ckaqXTgn7bWI5Dvm1sgNY33xyo2iCrS9c4a5tkguIDs=": "//var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');\n\nJSON.stableStringify = function (obj, opts) {\n    var json = JSON\n    \n    var isArray = Array.isArray || function (x) {\n        return {}.toString.call(x) === '[object Array]';\n    };\n    \n    var objectKeys = Object.keys || function (obj) {\n        var has = Object.prototype.hasOwnProperty || function () { return true };\n        var keys = [];\n        for (var key in obj) {\n            if (has.call(obj, key)) keys.push(key);\n        }\n        return keys;\n    };\n\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var space = opts.space || '';\n    if (typeof space === 'number') space = Array(space+1).join(' ');\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n    var replacer = opts.replacer || function(key, value) { return value; };\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (parent, key, node, level) {\n        var indent = space ? ('\\n' + new Array(level + 1).join(space)) : '';\n        var colonSeparator = space ? ': ' : ':';\n\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        node = replacer.call(parent, key, node);\n\n        if (node === undefined) {\n            return;\n        }\n        if (typeof node !== 'object' || node === null) {\n            return json.stringify(node);\n        }\n        if (isArray(node)) {\n            var out = [];\n            for (var i = 0; i < node.length; i++) {\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\n                out.push(indent + space + item);\n            }\n            return '[' + out.join(',') + indent + ']';\n        }\n        else {\n            if (seen.indexOf(node) !== -1) {\n                if (cycles) return json.stringify('__cycle__');\n                throw new TypeError('Converting circular structure to JSON');\n            }\n            else seen.push(node);\n\n            var keys = objectKeys(node).sort(cmp && cmp(node));\n            var out = [];\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var value = stringify(node, key, node[key], level+1);\n\n                if(!value) continue;\n\n                var keyValue = json.stringify(key)\n                    + colonSeparator\n                    + value;\n                ;\n                out.push(indent + space + keyValue);\n            }\n            seen.splice(seen.indexOf(node), 1);\n            return '{' + out.join(',') + indent + '}';\n        }\n    })({ '': obj }, '', obj, 0);\n};\n\n",
  "WFLs+cOgt9QinoIRTW6gGCsvbRtyBPeacj+pvS9G9zM=": "\n/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.pako = {}));\n  }(this, (function (exports) { 'use strict';\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\t/* eslint-disable space-unary-ops */\n  \n\t/* Public constants ==========================================================*/\n\t/* ===========================================================================*/\n  \n  \n\t//const Z_FILTERED          = 1;\n\t//const Z_HUFFMAN_ONLY      = 2;\n\t//const Z_RLE               = 3;\n\tconst Z_FIXED$1               = 4;\n\t//const Z_DEFAULT_STRATEGY  = 0;\n  \n\t/* Possible values of the data_type field (though see inflate()) */\n\tconst Z_BINARY              = 0;\n\tconst Z_TEXT                = 1;\n\t//const Z_ASCII             = 1; // = Z_TEXT\n\tconst Z_UNKNOWN$1             = 2;\n  \n\t/*============================================================================*/\n  \n  \n\tfunction zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n  \n\t// From zutil.h\n  \n\tconst STORED_BLOCK = 0;\n\tconst STATIC_TREES = 1;\n\tconst DYN_TREES    = 2;\n\t/* The three kinds of block type */\n  \n\tconst MIN_MATCH$1    = 3;\n\tconst MAX_MATCH$1    = 258;\n\t/* The minimum and maximum match lengths */\n  \n\t// From deflate.h\n\t/* ===========================================================================\n\t * Internal compression state.\n\t */\n  \n\tconst LENGTH_CODES$1  = 29;\n\t/* number of length codes, not counting the special END_BLOCK code */\n  \n\tconst LITERALS$1      = 256;\n\t/* number of literal bytes 0..255 */\n  \n\tconst L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;\n\t/* number of Literal or Length codes, including the END_BLOCK code */\n  \n\tconst D_CODES$1       = 30;\n\t/* number of distance codes */\n  \n\tconst BL_CODES$1      = 19;\n\t/* number of codes used to transfer the bit lengths */\n  \n\tconst HEAP_SIZE$1     = 2 * L_CODES$1 + 1;\n\t/* maximum heap size */\n  \n\tconst MAX_BITS$1      = 15;\n\t/* All codes must not exceed MAX_BITS bits */\n  \n\tconst Buf_size      = 16;\n\t/* size of bit buffer in bi_buf */\n  \n  \n\t/* ===========================================================================\n\t * Constants\n\t */\n  \n\tconst MAX_BL_BITS = 7;\n\t/* Bit length codes must not exceed MAX_BL_BITS bits */\n  \n\tconst END_BLOCK   = 256;\n\t/* end of block literal code */\n  \n\tconst REP_3_6     = 16;\n\t/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n  \n\tconst REPZ_3_10   = 17;\n\t/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n  \n\tconst REPZ_11_138 = 18;\n\t/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n  \n\t/* eslint-disable comma-spacing,array-bracket-spacing */\n\tconst extra_lbits =   /* extra bits for each length code */\n\t  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);\n  \n\tconst extra_dbits =   /* extra bits for each distance code */\n\t  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);\n  \n\tconst extra_blbits =  /* extra bits for each bit length code */\n\t  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);\n  \n\tconst bl_order =\n\t  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);\n\t/* eslint-enable comma-spacing,array-bracket-spacing */\n  \n\t/* The lengths of the bit length codes are sent in order of decreasing\n\t * probability, to avoid transmitting the lengths for unused bit length codes.\n\t */\n  \n\t/* ===========================================================================\n\t * Local data. These are initialized only once.\n\t */\n  \n\t// We pre-fill arrays with 0 to avoid uninitialized gaps\n  \n\tconst DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n  \n\t// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\n\tconst static_ltree  = new Array((L_CODES$1 + 2) * 2);\n\tzero$1(static_ltree);\n\t/* The static literal tree. Since the bit lengths are imposed, there is no\n\t * need for the L_CODES extra codes used during heap construction. However\n\t * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n\t * below).\n\t */\n  \n\tconst static_dtree  = new Array(D_CODES$1 * 2);\n\tzero$1(static_dtree);\n\t/* The static distance tree. (Actually a trivial tree since all codes use\n\t * 5 bits.)\n\t */\n  \n\tconst _dist_code    = new Array(DIST_CODE_LEN);\n\tzero$1(_dist_code);\n\t/* Distance codes. The first 256 values correspond to the distances\n\t * 3 .. 258, the last 256 values correspond to the top 8 bits of\n\t * the 15 bit distances.\n\t */\n  \n\tconst _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);\n\tzero$1(_length_code);\n\t/* length code for each normalized match length (0 == MIN_MATCH) */\n  \n\tconst base_length   = new Array(LENGTH_CODES$1);\n\tzero$1(base_length);\n\t/* First normalized length for each code (0 = MIN_MATCH) */\n  \n\tconst base_dist     = new Array(D_CODES$1);\n\tzero$1(base_dist);\n\t/* First normalized distance for each code (0 = distance of 1) */\n  \n  \n\tfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n  \n\t  this.static_tree  = static_tree;  /* static tree or NULL */\n\t  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n\t  this.extra_base   = extra_base;   /* base index for extra_bits */\n\t  this.elems        = elems;        /* max number of elements in the tree */\n\t  this.max_length   = max_length;   /* max bit length for the codes */\n  \n\t  // show if `static_tree` has data or dummy - needed for monomorphic objects\n\t  this.has_stree    = static_tree && static_tree.length;\n\t}\n  \n  \n\tlet static_l_desc;\n\tlet static_d_desc;\n\tlet static_bl_desc;\n  \n  \n\tfunction TreeDesc(dyn_tree, stat_desc) {\n\t  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n\t  this.max_code = 0;            /* largest code with non zero frequency */\n\t  this.stat_desc = stat_desc;   /* the corresponding static tree */\n\t}\n  \n  \n  \n\tconst d_code = (dist) => {\n  \n\t  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Output a short LSB first on the stream.\n\t * IN assertion: there is enough room in pendingBuf.\n\t */\n\tconst put_short = (s, w) => {\n\t//    put_byte(s, (uch)((w) & 0xff));\n\t//    put_byte(s, (uch)((ush)(w) >> 8));\n\t  s.pending_buf[s.pending++] = (w) & 0xff;\n\t  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Send a value on a given number of bits.\n\t * IN assertion: length <= 16 and value fits in length bits.\n\t */\n\tconst send_bits = (s, value, length) => {\n  \n\t  if (s.bi_valid > (Buf_size - length)) {\n\t\ts.bi_buf |= (value << s.bi_valid) & 0xffff;\n\t\tput_short(s, s.bi_buf);\n\t\ts.bi_buf = value >> (Buf_size - s.bi_valid);\n\t\ts.bi_valid += length - Buf_size;\n\t  } else {\n\t\ts.bi_buf |= (value << s.bi_valid) & 0xffff;\n\t\ts.bi_valid += length;\n\t  }\n\t};\n  \n  \n\tconst send_code = (s, c, tree) => {\n  \n\t  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Reverse the first len bits of a code, using straightforward code (a faster\n\t * method would use a table)\n\t * IN assertion: 1 <= len <= 15\n\t */\n\tconst bi_reverse = (code, len) => {\n  \n\t  let res = 0;\n\t  do {\n\t\tres |= code & 1;\n\t\tcode >>>= 1;\n\t\tres <<= 1;\n\t  } while (--len > 0);\n\t  return res >>> 1;\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Flush the bit buffer, keeping at most 7 bits in it.\n\t */\n\tconst bi_flush = (s) => {\n  \n\t  if (s.bi_valid === 16) {\n\t\tput_short(s, s.bi_buf);\n\t\ts.bi_buf = 0;\n\t\ts.bi_valid = 0;\n  \n\t  } else if (s.bi_valid >= 8) {\n\t\ts.pending_buf[s.pending++] = s.bi_buf & 0xff;\n\t\ts.bi_buf >>= 8;\n\t\ts.bi_valid -= 8;\n\t  }\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Compute the optimal bit lengths for a tree and update the total bit length\n\t * for the current block.\n\t * IN assertion: the fields freq and dad are set, heap[heap_max] and\n\t *    above are the tree nodes sorted by increasing frequency.\n\t * OUT assertions: the field len is set to the optimal bit length, the\n\t *     array bl_count contains the frequencies for each bit length.\n\t *     The length opt_len is updated; static_len is also updated if stree is\n\t *     not null.\n\t */\n\tconst gen_bitlen = (s, desc) =>\n\t//    deflate_state *s;\n\t//    tree_desc *desc;    /* the tree descriptor */\n\t{\n\t  const tree            = desc.dyn_tree;\n\t  const max_code        = desc.max_code;\n\t  const stree           = desc.stat_desc.static_tree;\n\t  const has_stree       = desc.stat_desc.has_stree;\n\t  const extra           = desc.stat_desc.extra_bits;\n\t  const base            = desc.stat_desc.extra_base;\n\t  const max_length      = desc.stat_desc.max_length;\n\t  let h;              /* heap index */\n\t  let n, m;           /* iterate over the tree elements */\n\t  let bits;           /* bit length */\n\t  let xbits;          /* extra bits */\n\t  let f;              /* frequency */\n\t  let overflow = 0;   /* number of elements with bit length too large */\n  \n\t  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n\t\ts.bl_count[bits] = 0;\n\t  }\n  \n\t  /* In a first pass, compute the optimal bit lengths (which may\n\t   * overflow in the case of the bit length tree).\n\t   */\n\t  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n  \n\t  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {\n\t\tn = s.heap[h];\n\t\tbits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n\t\tif (bits > max_length) {\n\t\t  bits = max_length;\n\t\t  overflow++;\n\t\t}\n\t\ttree[n * 2 + 1]/*.Len*/ = bits;\n\t\t/* We overwrite tree[n].Dad which is no longer needed */\n  \n\t\tif (n > max_code) { continue; } /* not a leaf node */\n  \n\t\ts.bl_count[bits]++;\n\t\txbits = 0;\n\t\tif (n >= base) {\n\t\t  xbits = extra[n - base];\n\t\t}\n\t\tf = tree[n * 2]/*.Freq*/;\n\t\ts.opt_len += f * (bits + xbits);\n\t\tif (has_stree) {\n\t\t  s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n\t\t}\n\t  }\n\t  if (overflow === 0) { return; }\n  \n\t  // Trace((stderr,\"\\nbit length overflow\\n\"));\n\t  /* This happens for example on obj2 and pic of the Calgary corpus */\n  \n\t  /* Find the first bit length which could increase: */\n\t  do {\n\t\tbits = max_length - 1;\n\t\twhile (s.bl_count[bits] === 0) { bits--; }\n\t\ts.bl_count[bits]--;      /* move one leaf down the tree */\n\t\ts.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n\t\ts.bl_count[max_length]--;\n\t\t/* The brother of the overflow item also moves one step up,\n\t\t * but this does not affect bl_count[max_length]\n\t\t */\n\t\toverflow -= 2;\n\t  } while (overflow > 0);\n  \n\t  /* Now recompute all bit lengths, scanning in increasing frequency.\n\t   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n\t   * lengths instead of fixing only the wrong ones. This idea is taken\n\t   * from 'ar' written by Haruhiko Okumura.)\n\t   */\n\t  for (bits = max_length; bits !== 0; bits--) {\n\t\tn = s.bl_count[bits];\n\t\twhile (n !== 0) {\n\t\t  m = s.heap[--h];\n\t\t  if (m > max_code) { continue; }\n\t\t  if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n\t\t\t// Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n\t\t\ts.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n\t\t\ttree[m * 2 + 1]/*.Len*/ = bits;\n\t\t  }\n\t\t  n--;\n\t\t}\n\t  }\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Generate the codes for a given tree and bit counts (which need not be\n\t * optimal).\n\t * IN assertion: the array bl_count contains the bit length statistics for\n\t * the given tree and the field len is set for all tree elements.\n\t * OUT assertion: the field code is set for all tree elements of non\n\t *     zero code length.\n\t */\n\tconst gen_codes = (tree, max_code, bl_count) =>\n\t//    ct_data *tree;             /* the tree to decorate */\n\t//    int max_code;              /* largest code with non zero frequency */\n\t//    ushf *bl_count;            /* number of codes at each bit length */\n\t{\n\t  const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */\n\t  let code = 0;              /* running code value */\n\t  let bits;                  /* bit index */\n\t  let n;                     /* code index */\n  \n\t  /* The distribution counts are first used to generate the code values\n\t   * without bit reversal.\n\t   */\n\t  for (bits = 1; bits <= MAX_BITS$1; bits++) {\n\t\tnext_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n\t  }\n\t  /* Check that the bit counts in bl_count are consistent. The last code\n\t   * must be all ones.\n\t   */\n\t  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n\t  //        \"inconsistent bit counts\");\n\t  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n  \n\t  for (n = 0;  n <= max_code; n++) {\n\t\tlet len = tree[n * 2 + 1]/*.Len*/;\n\t\tif (len === 0) { continue; }\n\t\t/* Now reverse the bits */\n\t\ttree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n  \n\t\t//Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n\t\t//     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n\t  }\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Initialize the various 'constant' tables.\n\t */\n\tconst tr_static_init = () => {\n  \n\t  let n;        /* iterates over tree elements */\n\t  let bits;     /* bit counter */\n\t  let length;   /* length value */\n\t  let code;     /* code value */\n\t  let dist;     /* distance index */\n\t  const bl_count = new Array(MAX_BITS$1 + 1);\n\t  /* number of codes at each bit length for an optimal tree */\n  \n\t  // do check in _tr_init()\n\t  //if (static_init_done) return;\n  \n\t  /* For some embedded targets, global variables are not initialized: */\n\t/*#ifdef NO_INIT_GLOBAL_POINTERS\n\t  static_l_desc.static_tree = static_ltree;\n\t  static_l_desc.extra_bits = extra_lbits;\n\t  static_d_desc.static_tree = static_dtree;\n\t  static_d_desc.extra_bits = extra_dbits;\n\t  static_bl_desc.extra_bits = extra_blbits;\n\t#endif*/\n  \n\t  /* Initialize the mapping length (0..255) -> length code (0..28) */\n\t  length = 0;\n\t  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {\n\t\tbase_length[code] = length;\n\t\tfor (n = 0; n < (1 << extra_lbits[code]); n++) {\n\t\t  _length_code[length++] = code;\n\t\t}\n\t  }\n\t  //Assert (length == 256, \"tr_static_init: length != 256\");\n\t  /* Note that the length 255 (match length 258) can be represented\n\t   * in two different ways: code 284 + 5 bits or code 285, so we\n\t   * overwrite length_code[255] to use the best encoding:\n\t   */\n\t  _length_code[length - 1] = code;\n  \n\t  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n\t  dist = 0;\n\t  for (code = 0; code < 16; code++) {\n\t\tbase_dist[code] = dist;\n\t\tfor (n = 0; n < (1 << extra_dbits[code]); n++) {\n\t\t  _dist_code[dist++] = code;\n\t\t}\n\t  }\n\t  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n\t  dist >>= 7; /* from now on, all distances are divided by 128 */\n\t  for (; code < D_CODES$1; code++) {\n\t\tbase_dist[code] = dist << 7;\n\t\tfor (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n\t\t  _dist_code[256 + dist++] = code;\n\t\t}\n\t  }\n\t  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n  \n\t  /* Construct the codes of the static literal tree */\n\t  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n\t\tbl_count[bits] = 0;\n\t  }\n  \n\t  n = 0;\n\t  while (n <= 143) {\n\t\tstatic_ltree[n * 2 + 1]/*.Len*/ = 8;\n\t\tn++;\n\t\tbl_count[8]++;\n\t  }\n\t  while (n <= 255) {\n\t\tstatic_ltree[n * 2 + 1]/*.Len*/ = 9;\n\t\tn++;\n\t\tbl_count[9]++;\n\t  }\n\t  while (n <= 279) {\n\t\tstatic_ltree[n * 2 + 1]/*.Len*/ = 7;\n\t\tn++;\n\t\tbl_count[7]++;\n\t  }\n\t  while (n <= 287) {\n\t\tstatic_ltree[n * 2 + 1]/*.Len*/ = 8;\n\t\tn++;\n\t\tbl_count[8]++;\n\t  }\n\t  /* Codes 286 and 287 do not exist, but we must include them in the\n\t   * tree construction to get a canonical Huffman tree (longest code\n\t   * all ones)\n\t   */\n\t  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);\n  \n\t  /* The static distance tree is trivial: */\n\t  for (n = 0; n < D_CODES$1; n++) {\n\t\tstatic_dtree[n * 2 + 1]/*.Len*/ = 5;\n\t\tstatic_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n\t  }\n  \n\t  // Now data ready and we can init static trees\n\t  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);\n\t  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);\n\t  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);\n  \n\t  //static_init_done = true;\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Initialize a new block.\n\t */\n\tconst init_block = (s) => {\n  \n\t  let n; /* iterates over tree elements */\n  \n\t  /* Initialize the trees. */\n\t  for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n\t  for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n\t  for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n  \n\t  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n\t  s.opt_len = s.static_len = 0;\n\t  s.last_lit = s.matches = 0;\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Flush the bit buffer and align the output on a byte boundary\n\t */\n\tconst bi_windup = (s) =>\n\t{\n\t  if (s.bi_valid > 8) {\n\t\tput_short(s, s.bi_buf);\n\t  } else if (s.bi_valid > 0) {\n\t\t//put_byte(s, (Byte)s->bi_buf);\n\t\ts.pending_buf[s.pending++] = s.bi_buf;\n\t  }\n\t  s.bi_buf = 0;\n\t  s.bi_valid = 0;\n\t};\n  \n\t/* ===========================================================================\n\t * Copy a stored block, storing first the length and its\n\t * one's complement if requested.\n\t */\n\tconst copy_block = (s, buf, len, header) =>\n\t//DeflateState *s;\n\t//charf    *buf;    /* the input data */\n\t//unsigned len;     /* its length */\n\t//int      header;  /* true if block header must be written */\n\t{\n\t  bi_windup(s);        /* align on byte boundary */\n  \n\t  if (header) {\n\t\tput_short(s, len);\n\t\tput_short(s, ~len);\n\t  }\n\t//  while (len--) {\n\t//    put_byte(s, *buf++);\n\t//  }\n\t  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);\n\t  s.pending += len;\n\t};\n  \n\t/* ===========================================================================\n\t * Compares to subtrees, using the tree depth as tie breaker when\n\t * the subtrees have equal frequency. This minimizes the worst case length.\n\t */\n\tconst smaller = (tree, n, m, depth) => {\n  \n\t  const _n2 = n * 2;\n\t  const _m2 = m * 2;\n\t  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n\t\t\t (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n\t};\n  \n\t/* ===========================================================================\n\t * Restore the heap property by moving down the tree starting at node k,\n\t * exchanging a node with the smallest of its two sons if necessary, stopping\n\t * when the heap property is re-established (each father smaller than its\n\t * two sons).\n\t */\n\tconst pqdownheap = (s, tree, k) =>\n\t//    deflate_state *s;\n\t//    ct_data *tree;  /* the tree to restore */\n\t//    int k;               /* node to move down */\n\t{\n\t  const v = s.heap[k];\n\t  let j = k << 1;  /* left son of k */\n\t  while (j <= s.heap_len) {\n\t\t/* Set j to the smallest of the two sons: */\n\t\tif (j < s.heap_len &&\n\t\t  smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n\t\t  j++;\n\t\t}\n\t\t/* Exit if v is smaller than both sons */\n\t\tif (smaller(tree, v, s.heap[j], s.depth)) { break; }\n  \n\t\t/* Exchange v with the smallest son */\n\t\ts.heap[k] = s.heap[j];\n\t\tk = j;\n  \n\t\t/* And continue down the tree, setting j to the left son of k */\n\t\tj <<= 1;\n\t  }\n\t  s.heap[k] = v;\n\t};\n  \n  \n\t// inlined manually\n\t// const SMALLEST = 1;\n  \n\t/* ===========================================================================\n\t * Send the block data compressed using the given Huffman trees\n\t */\n\tconst compress_block = (s, ltree, dtree) =>\n\t//    deflate_state *s;\n\t//    const ct_data *ltree; /* literal tree */\n\t//    const ct_data *dtree; /* distance tree */\n\t{\n\t  let dist;           /* distance of matched string */\n\t  let lc;             /* match length or unmatched char (if dist == 0) */\n\t  let lx = 0;         /* running index in l_buf */\n\t  let code;           /* the code to send */\n\t  let extra;          /* number of extra bits to send */\n  \n\t  if (s.last_lit !== 0) {\n\t\tdo {\n\t\t  dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n\t\t  lc = s.pending_buf[s.l_buf + lx];\n\t\t  lx++;\n  \n\t\t  if (dist === 0) {\n\t\t\tsend_code(s, lc, ltree); /* send a literal byte */\n\t\t\t//Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n\t\t  } else {\n\t\t\t/* Here, lc is the match length - MIN_MATCH */\n\t\t\tcode = _length_code[lc];\n\t\t\tsend_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */\n\t\t\textra = extra_lbits[code];\n\t\t\tif (extra !== 0) {\n\t\t\t  lc -= base_length[code];\n\t\t\t  send_bits(s, lc, extra);       /* send the extra length bits */\n\t\t\t}\n\t\t\tdist--; /* dist is now the match distance - 1 */\n\t\t\tcode = d_code(dist);\n\t\t\t//Assert (code < D_CODES, \"bad d_code\");\n  \n\t\t\tsend_code(s, code, dtree);       /* send the distance code */\n\t\t\textra = extra_dbits[code];\n\t\t\tif (extra !== 0) {\n\t\t\t  dist -= base_dist[code];\n\t\t\t  send_bits(s, dist, extra);   /* send the extra distance bits */\n\t\t\t}\n\t\t  } /* literal or match pair ? */\n  \n\t\t  /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n\t\t  //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n\t\t  //       \"pendingBuf overflow\");\n  \n\t\t} while (lx < s.last_lit);\n\t  }\n  \n\t  send_code(s, END_BLOCK, ltree);\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Construct one Huffman tree and assigns the code bit strings and lengths.\n\t * Update the total bit length for the current block.\n\t * IN assertion: the field freq is set for all tree elements.\n\t * OUT assertions: the fields len and code are set to the optimal bit length\n\t *     and corresponding code. The length opt_len is updated; static_len is\n\t *     also updated if stree is not null. The field max_code is set.\n\t */\n\tconst build_tree = (s, desc) =>\n\t//    deflate_state *s;\n\t//    tree_desc *desc; /* the tree descriptor */\n\t{\n\t  const tree     = desc.dyn_tree;\n\t  const stree    = desc.stat_desc.static_tree;\n\t  const has_stree = desc.stat_desc.has_stree;\n\t  const elems    = desc.stat_desc.elems;\n\t  let n, m;          /* iterate over heap elements */\n\t  let max_code = -1; /* largest code with non zero frequency */\n\t  let node;          /* new node being created */\n  \n\t  /* Construct the initial heap, with least frequent element in\n\t   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n\t   * heap[0] is not used.\n\t   */\n\t  s.heap_len = 0;\n\t  s.heap_max = HEAP_SIZE$1;\n  \n\t  for (n = 0; n < elems; n++) {\n\t\tif (tree[n * 2]/*.Freq*/ !== 0) {\n\t\t  s.heap[++s.heap_len] = max_code = n;\n\t\t  s.depth[n] = 0;\n  \n\t\t} else {\n\t\t  tree[n * 2 + 1]/*.Len*/ = 0;\n\t\t}\n\t  }\n  \n\t  /* The pkzip format requires that at least one distance code exists,\n\t   * and that at least one bit should be sent even if there is only one\n\t   * possible code. So to avoid special checks later on we force at least\n\t   * two codes of non zero frequency.\n\t   */\n\t  while (s.heap_len < 2) {\n\t\tnode = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n\t\ttree[node * 2]/*.Freq*/ = 1;\n\t\ts.depth[node] = 0;\n\t\ts.opt_len--;\n  \n\t\tif (has_stree) {\n\t\t  s.static_len -= stree[node * 2 + 1]/*.Len*/;\n\t\t}\n\t\t/* node is 0 or 1 so it does not have extra bits */\n\t  }\n\t  desc.max_code = max_code;\n  \n\t  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n\t   * establish sub-heaps of increasing lengths:\n\t   */\n\t  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n  \n\t  /* Construct the Huffman tree by repeatedly combining the least two\n\t   * frequent nodes.\n\t   */\n\t  node = elems;              /* next internal node of the tree */\n\t  do {\n\t\t//pqremove(s, tree, n);  /* n = node of least frequency */\n\t\t/*** pqremove ***/\n\t\tn = s.heap[1/*SMALLEST*/];\n\t\ts.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n\t\tpqdownheap(s, tree, 1/*SMALLEST*/);\n\t\t/***/\n  \n\t\tm = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n  \n\t\ts.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n\t\ts.heap[--s.heap_max] = m;\n  \n\t\t/* Create a new node father of n and m */\n\t\ttree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n\t\ts.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n\t\ttree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n  \n\t\t/* and insert the new node in the heap */\n\t\ts.heap[1/*SMALLEST*/] = node++;\n\t\tpqdownheap(s, tree, 1/*SMALLEST*/);\n  \n\t  } while (s.heap_len >= 2);\n  \n\t  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n  \n\t  /* At this point, the fields freq and dad are set. We can now\n\t   * generate the bit lengths.\n\t   */\n\t  gen_bitlen(s, desc);\n  \n\t  /* The field len is now set, we can generate the bit codes */\n\t  gen_codes(tree, max_code, s.bl_count);\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Scan a literal or distance tree to determine the frequencies of the codes\n\t * in the bit length tree.\n\t */\n\tconst scan_tree = (s, tree, max_code) =>\n\t//    deflate_state *s;\n\t//    ct_data *tree;   /* the tree to be scanned */\n\t//    int max_code;    /* and its largest code of non zero frequency */\n\t{\n\t  let n;                     /* iterates over all tree elements */\n\t  let prevlen = -1;          /* last emitted length */\n\t  let curlen;                /* length of current code */\n  \n\t  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n  \n\t  let count = 0;             /* repeat count of the current code */\n\t  let max_count = 7;         /* max repeat count */\n\t  let min_count = 4;         /* min repeat count */\n  \n\t  if (nextlen === 0) {\n\t\tmax_count = 138;\n\t\tmin_count = 3;\n\t  }\n\t  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n  \n\t  for (n = 0; n <= max_code; n++) {\n\t\tcurlen = nextlen;\n\t\tnextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n  \n\t\tif (++count < max_count && curlen === nextlen) {\n\t\t  continue;\n  \n\t\t} else if (count < min_count) {\n\t\t  s.bl_tree[curlen * 2]/*.Freq*/ += count;\n  \n\t\t} else if (curlen !== 0) {\n  \n\t\t  if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n\t\t  s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n  \n\t\t} else if (count <= 10) {\n\t\t  s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n  \n\t\t} else {\n\t\t  s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n\t\t}\n  \n\t\tcount = 0;\n\t\tprevlen = curlen;\n  \n\t\tif (nextlen === 0) {\n\t\t  max_count = 138;\n\t\t  min_count = 3;\n  \n\t\t} else if (curlen === nextlen) {\n\t\t  max_count = 6;\n\t\t  min_count = 3;\n  \n\t\t} else {\n\t\t  max_count = 7;\n\t\t  min_count = 4;\n\t\t}\n\t  }\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Send a literal or distance tree in compressed form, using the codes in\n\t * bl_tree.\n\t */\n\tconst send_tree = (s, tree, max_code) =>\n\t//    deflate_state *s;\n\t//    ct_data *tree; /* the tree to be scanned */\n\t//    int max_code;       /* and its largest code of non zero frequency */\n\t{\n\t  let n;                     /* iterates over all tree elements */\n\t  let prevlen = -1;          /* last emitted length */\n\t  let curlen;                /* length of current code */\n  \n\t  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n  \n\t  let count = 0;             /* repeat count of the current code */\n\t  let max_count = 7;         /* max repeat count */\n\t  let min_count = 4;         /* min repeat count */\n  \n\t  /* tree[max_code+1].Len = -1; */  /* guard already set */\n\t  if (nextlen === 0) {\n\t\tmax_count = 138;\n\t\tmin_count = 3;\n\t  }\n  \n\t  for (n = 0; n <= max_code; n++) {\n\t\tcurlen = nextlen;\n\t\tnextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n  \n\t\tif (++count < max_count && curlen === nextlen) {\n\t\t  continue;\n  \n\t\t} else if (count < min_count) {\n\t\t  do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n  \n\t\t} else if (curlen !== 0) {\n\t\t  if (curlen !== prevlen) {\n\t\t\tsend_code(s, curlen, s.bl_tree);\n\t\t\tcount--;\n\t\t  }\n\t\t  //Assert(count >= 3 && count <= 6, \" 3_6?\");\n\t\t  send_code(s, REP_3_6, s.bl_tree);\n\t\t  send_bits(s, count - 3, 2);\n  \n\t\t} else if (count <= 10) {\n\t\t  send_code(s, REPZ_3_10, s.bl_tree);\n\t\t  send_bits(s, count - 3, 3);\n  \n\t\t} else {\n\t\t  send_code(s, REPZ_11_138, s.bl_tree);\n\t\t  send_bits(s, count - 11, 7);\n\t\t}\n  \n\t\tcount = 0;\n\t\tprevlen = curlen;\n\t\tif (nextlen === 0) {\n\t\t  max_count = 138;\n\t\t  min_count = 3;\n  \n\t\t} else if (curlen === nextlen) {\n\t\t  max_count = 6;\n\t\t  min_count = 3;\n  \n\t\t} else {\n\t\t  max_count = 7;\n\t\t  min_count = 4;\n\t\t}\n\t  }\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Construct the Huffman tree for the bit lengths and return the index in\n\t * bl_order of the last bit length code to send.\n\t */\n\tconst build_bl_tree = (s) => {\n  \n\t  let max_blindex;  /* index of last bit length code of non zero freq */\n  \n\t  /* Determine the bit length frequencies for literal and distance trees */\n\t  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n\t  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n  \n\t  /* Build the bit length tree: */\n\t  build_tree(s, s.bl_desc);\n\t  /* opt_len now includes the length of the tree representations, except\n\t   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n\t   */\n  \n\t  /* Determine the number of bit length codes to send. The pkzip format\n\t   * requires that at least 4 bit length codes be sent. (appnote.txt says\n\t   * 3 but the actual value used is 4.)\n\t   */\n\t  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {\n\t\tif (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n\t\t  break;\n\t\t}\n\t  }\n\t  /* Update opt_len to include the bit length tree and counts */\n\t  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n\t  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n\t  //        s->opt_len, s->static_len));\n  \n\t  return max_blindex;\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Send the header for a block using dynamic Huffman trees: the counts, the\n\t * lengths of the bit length codes, the literal tree and the distance tree.\n\t * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n\t */\n\tconst send_all_trees = (s, lcodes, dcodes, blcodes) =>\n\t//    deflate_state *s;\n\t//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n\t{\n\t  let rank;                    /* index in bl_order */\n  \n\t  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n\t  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n\t  //        \"too many codes\");\n\t  //Tracev((stderr, \"\\nbl counts: \"));\n\t  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n\t  send_bits(s, dcodes - 1,   5);\n\t  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n\t  for (rank = 0; rank < blcodes; rank++) {\n\t\t//Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n\t\tsend_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n\t  }\n\t  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n  \n\t  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n\t  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n  \n\t  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n\t  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Check if the data type is TEXT or BINARY, using the following algorithm:\n\t * - TEXT if the two conditions below are satisfied:\n\t *    a) There are no non-portable control characters belonging to the\n\t *       \"black list\" (0..6, 14..25, 28..31).\n\t *    b) There is at least one printable character belonging to the\n\t *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n\t * - BINARY otherwise.\n\t * - The following partially-portable control characters form a\n\t *   \"gray list\" that is ignored in this detection algorithm:\n\t *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n\t * IN assertion: the fields Freq of dyn_ltree are set.\n\t */\n\tconst detect_data_type = (s) => {\n\t  /* black_mask is the bit mask of black-listed bytes\n\t   * set bits 0..6, 14..25, and 28..31\n\t   * 0xf3ffc07f = binary 11110011111111111100000001111111\n\t   */\n\t  let black_mask = 0xf3ffc07f;\n\t  let n;\n  \n\t  /* Check for non-textual (\"black-listed\") bytes. */\n\t  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n\t\tif ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n\t\t  return Z_BINARY;\n\t\t}\n\t  }\n  \n\t  /* Check for textual (\"white-listed\") bytes. */\n\t  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n\t\t  s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n\t\treturn Z_TEXT;\n\t  }\n\t  for (n = 32; n < LITERALS$1; n++) {\n\t\tif (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n\t\t  return Z_TEXT;\n\t\t}\n\t  }\n  \n\t  /* There are no \"black-listed\" or \"white-listed\" bytes:\n\t   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n\t   */\n\t  return Z_BINARY;\n\t};\n  \n  \n\tlet static_init_done = false;\n  \n\t/* ===========================================================================\n\t * Initialize the tree data structures for a new zlib stream.\n\t */\n\tconst _tr_init$1 = (s) =>\n\t{\n  \n\t  if (!static_init_done) {\n\t\ttr_static_init();\n\t\tstatic_init_done = true;\n\t  }\n  \n\t  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n\t  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n\t  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n  \n\t  s.bi_buf = 0;\n\t  s.bi_valid = 0;\n  \n\t  /* Initialize the first block of the first file: */\n\t  init_block(s);\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Send a stored block\n\t */\n\tconst _tr_stored_block$1 = (s, buf, stored_len, last) =>\n\t//DeflateState *s;\n\t//charf *buf;       /* input block */\n\t//ulg stored_len;   /* length of input block */\n\t//int last;         /* one if this is the last block for a file */\n\t{\n\t  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n\t  copy_block(s, buf, stored_len, true); /* with header */\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Send one empty static block to give enough lookahead for inflate.\n\t * This takes 10 bits, of which 7 may remain in the bit buffer.\n\t */\n\tconst _tr_align$1 = (s) => {\n\t  send_bits(s, STATIC_TREES << 1, 3);\n\t  send_code(s, END_BLOCK, static_ltree);\n\t  bi_flush(s);\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Determine the best encoding for the current block: dynamic trees, static\n\t * trees or store, and output the encoded block to the zip file.\n\t */\n\tconst _tr_flush_block$1 = (s, buf, stored_len, last) =>\n\t//DeflateState *s;\n\t//charf *buf;       /* input block, or NULL if too old */\n\t//ulg stored_len;   /* length of input block */\n\t//int last;         /* one if this is the last block for a file */\n\t{\n\t  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n\t  let max_blindex = 0;        /* index of last bit length code of non zero freq */\n  \n\t  /* Build the Huffman trees unless a stored block is forced */\n\t  if (s.level > 0) {\n  \n\t\t/* Check if the file is binary or text */\n\t\tif (s.strm.data_type === Z_UNKNOWN$1) {\n\t\t  s.strm.data_type = detect_data_type(s);\n\t\t}\n  \n\t\t/* Construct the literal and distance trees */\n\t\tbuild_tree(s, s.l_desc);\n\t\t// Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n\t\t//        s->static_len));\n  \n\t\tbuild_tree(s, s.d_desc);\n\t\t// Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n\t\t//        s->static_len));\n\t\t/* At this point, opt_len and static_len are the total bit lengths of\n\t\t * the compressed block data, excluding the tree representations.\n\t\t */\n  \n\t\t/* Build the bit length tree for the above two trees, and get the index\n\t\t * in bl_order of the last bit length code to send.\n\t\t */\n\t\tmax_blindex = build_bl_tree(s);\n  \n\t\t/* Determine the best encoding. Compute the block lengths in bytes. */\n\t\topt_lenb = (s.opt_len + 3 + 7) >>> 3;\n\t\tstatic_lenb = (s.static_len + 3 + 7) >>> 3;\n  \n\t\t// Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n\t\t//        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n\t\t//        s->last_lit));\n  \n\t\tif (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n  \n\t  } else {\n\t\t// Assert(buf != (char*)0, \"lost buf\");\n\t\topt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n\t  }\n  \n\t  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n\t\t/* 4: two words for the lengths */\n  \n\t\t/* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n\t\t * Otherwise we can't have processed more than WSIZE input bytes since\n\t\t * the last block flush, because compression would have been\n\t\t * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n\t\t * transform a block into a stored block.\n\t\t */\n\t\t_tr_stored_block$1(s, buf, stored_len, last);\n  \n\t  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {\n  \n\t\tsend_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n\t\tcompress_block(s, static_ltree, static_dtree);\n  \n\t  } else {\n\t\tsend_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n\t\tsend_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n\t\tcompress_block(s, s.dyn_ltree, s.dyn_dtree);\n\t  }\n\t  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n\t  /* The above check is made mod 2^32, for files larger than 512 MB\n\t   * and uLong implemented on 32 bits.\n\t   */\n\t  init_block(s);\n  \n\t  if (last) {\n\t\tbi_windup(s);\n\t  }\n\t  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n\t  //       s->compressed_len-7*last));\n\t};\n  \n\t/* ===========================================================================\n\t * Save the match info and tally the frequency counts. Return true if\n\t * the current block must be flushed.\n\t */\n\tconst _tr_tally$1 = (s, dist, lc) =>\n\t//    deflate_state *s;\n\t//    unsigned dist;  /* distance of matched string */\n\t//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n\t{\n\t  //let out_length, in_length, dcode;\n  \n\t  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n\t  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n  \n\t  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n\t  s.last_lit++;\n  \n\t  if (dist === 0) {\n\t\t/* lc is the unmatched char */\n\t\ts.dyn_ltree[lc * 2]/*.Freq*/++;\n\t  } else {\n\t\ts.matches++;\n\t\t/* Here, lc is the match length - MIN_MATCH */\n\t\tdist--;             /* dist = match distance - 1 */\n\t\t//Assert((ush)dist < (ush)MAX_DIST(s) &&\n\t\t//       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n\t\t//       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n  \n\t\ts.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;\n\t\ts.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n\t  }\n  \n\t// (!) This block is disabled in zlib defaults,\n\t// don't enable it for binary compatibility\n  \n\t//#ifdef TRUNCATE_BLOCK\n\t//  /* Try to guess if it is profitable to stop the current block here */\n\t//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n\t//    /* Compute an upper bound for the compressed length */\n\t//    out_length = s.last_lit*8;\n\t//    in_length = s.strstart - s.block_start;\n\t//\n\t//    for (dcode = 0; dcode < D_CODES; dcode++) {\n\t//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n\t//    }\n\t//    out_length >>>= 3;\n\t//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n\t//    //       s->last_lit, in_length, out_length,\n\t//    //       100L - out_length*100L/in_length));\n\t//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n\t//      return true;\n\t//    }\n\t//  }\n\t//#endif\n  \n\t  return (s.last_lit === s.lit_bufsize - 1);\n\t  /* We avoid equality with lit_bufsize because of wraparound at 64K\n\t   * on 16 bit machines and because stored blocks are restricted to\n\t   * 64K-1 bytes.\n\t   */\n\t};\n  \n\tvar _tr_init_1  = _tr_init$1;\n\tvar _tr_stored_block_1 = _tr_stored_block$1;\n\tvar _tr_flush_block_1  = _tr_flush_block$1;\n\tvar _tr_tally_1 = _tr_tally$1;\n\tvar _tr_align_1 = _tr_align$1;\n  \n\tvar trees = {\n\t\t_tr_init: _tr_init_1,\n\t\t_tr_stored_block: _tr_stored_block_1,\n\t\t_tr_flush_block: _tr_flush_block_1,\n\t\t_tr_tally: _tr_tally_1,\n\t\t_tr_align: _tr_align_1\n\t};\n  \n\t// Note: adler32 takes 12% for level 0 and 2% for level 6.\n\t// It isn't worth it to make additional optimizations as in original.\n\t// Small size is preferable.\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\tconst adler32 = (adler, buf, len, pos) => {\n\t  let s1 = (adler & 0xffff) |0,\n\t\t  s2 = ((adler >>> 16) & 0xffff) |0,\n\t\t  n = 0;\n  \n\t  while (len !== 0) {\n\t\t// Set limit ~ twice less than 5552, to keep\n\t\t// s2 in 31-bits, because we force signed ints.\n\t\t// in other case %= will fail.\n\t\tn = len > 2000 ? 2000 : len;\n\t\tlen -= n;\n  \n\t\tdo {\n\t\t  s1 = (s1 + buf[pos++]) |0;\n\t\t  s2 = (s2 + s1) |0;\n\t\t} while (--n);\n  \n\t\ts1 %= 65521;\n\t\ts2 %= 65521;\n\t  }\n  \n\t  return (s1 | (s2 << 16)) |0;\n\t};\n  \n  \n\tvar adler32_1 = adler32;\n  \n\t// Note: we can't get significant speed boost here.\n\t// So write code to minimize size - no pregenerated tables\n\t// and array tools dependencies.\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\t// Use ordinary array, since untyped makes no boost here\n\tconst makeTable = () => {\n\t  let c, table = [];\n  \n\t  for (var n = 0; n < 256; n++) {\n\t\tc = n;\n\t\tfor (var k = 0; k < 8; k++) {\n\t\t  c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n\t\t}\n\t\ttable[n] = c;\n\t  }\n  \n\t  return table;\n\t};\n  \n\t// Create table on load. Just 255 signed longs. Not a problem.\n\tconst crcTable = new Uint32Array(makeTable());\n  \n  \n\tconst crc32 = (crc, buf, len, pos) => {\n\t  const t = crcTable;\n\t  const end = pos + len;\n  \n\t  crc ^= -1;\n  \n\t  for (let i = pos; i < end; i++) {\n\t\tcrc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n\t  }\n  \n\t  return (crc ^ (-1)); // >>> 0;\n\t};\n  \n  \n\tvar crc32_1 = crc32;\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\tvar messages = {\n\t  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n\t  1:      'stream end',          /* Z_STREAM_END      1  */\n\t  0:      '',                    /* Z_OK              0  */\n\t  '-1':   'file error',          /* Z_ERRNO         (-1) */\n\t  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n\t  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n\t  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n\t  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n\t  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n\t};\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\tvar constants$2 = {\n  \n\t  /* Allowed flush values; see deflate() and inflate() below for details */\n\t  Z_NO_FLUSH:         0,\n\t  Z_PARTIAL_FLUSH:    1,\n\t  Z_SYNC_FLUSH:       2,\n\t  Z_FULL_FLUSH:       3,\n\t  Z_FINISH:           4,\n\t  Z_BLOCK:            5,\n\t  Z_TREES:            6,\n  \n\t  /* Return codes for the compression/decompression functions. Negative values\n\t  * are errors, positive values are used for special but normal events.\n\t  */\n\t  Z_OK:               0,\n\t  Z_STREAM_END:       1,\n\t  Z_NEED_DICT:        2,\n\t  Z_ERRNO:           -1,\n\t  Z_STREAM_ERROR:    -2,\n\t  Z_DATA_ERROR:      -3,\n\t  Z_MEM_ERROR:       -4,\n\t  Z_BUF_ERROR:       -5,\n\t  //Z_VERSION_ERROR: -6,\n  \n\t  /* compression levels */\n\t  Z_NO_COMPRESSION:         0,\n\t  Z_BEST_SPEED:             1,\n\t  Z_BEST_COMPRESSION:       9,\n\t  Z_DEFAULT_COMPRESSION:   -1,\n  \n  \n\t  Z_FILTERED:               1,\n\t  Z_HUFFMAN_ONLY:           2,\n\t  Z_RLE:                    3,\n\t  Z_FIXED:                  4,\n\t  Z_DEFAULT_STRATEGY:       0,\n  \n\t  /* Possible values of the data_type field (though see inflate()) */\n\t  Z_BINARY:                 0,\n\t  Z_TEXT:                   1,\n\t  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n\t  Z_UNKNOWN:                2,\n  \n\t  /* The deflate compression method */\n\t  Z_DEFLATED:               8\n\t  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n\t};\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\tconst { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;\n  \n  \n  \n  \n\t/* Public constants ==========================================================*/\n\t/* ===========================================================================*/\n  \n\tconst {\n\t  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,\n\t  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,\n\t  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,\n\t  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,\n\t  Z_UNKNOWN,\n\t  Z_DEFLATED: Z_DEFLATED$2\n\t} = constants$2;\n  \n\t/*============================================================================*/\n  \n  \n\tconst MAX_MEM_LEVEL = 9;\n\t/* Maximum value for memLevel in deflateInit2 */\n\tconst MAX_WBITS$1 = 15;\n\t/* 32K LZ77 window */\n\tconst DEF_MEM_LEVEL = 8;\n  \n  \n\tconst LENGTH_CODES  = 29;\n\t/* number of length codes, not counting the special END_BLOCK code */\n\tconst LITERALS      = 256;\n\t/* number of literal bytes 0..255 */\n\tconst L_CODES       = LITERALS + 1 + LENGTH_CODES;\n\t/* number of Literal or Length codes, including the END_BLOCK code */\n\tconst D_CODES       = 30;\n\t/* number of distance codes */\n\tconst BL_CODES      = 19;\n\t/* number of codes used to transfer the bit lengths */\n\tconst HEAP_SIZE     = 2 * L_CODES + 1;\n\t/* maximum heap size */\n\tconst MAX_BITS  = 15;\n\t/* All codes must not exceed MAX_BITS bits */\n  \n\tconst MIN_MATCH = 3;\n\tconst MAX_MATCH = 258;\n\tconst MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n  \n\tconst PRESET_DICT = 0x20;\n  \n\tconst INIT_STATE = 42;\n\tconst EXTRA_STATE = 69;\n\tconst NAME_STATE = 73;\n\tconst COMMENT_STATE = 91;\n\tconst HCRC_STATE = 103;\n\tconst BUSY_STATE = 113;\n\tconst FINISH_STATE = 666;\n  \n\tconst BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\n\tconst BS_BLOCK_DONE     = 2; /* block flush performed */\n\tconst BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\n\tconst BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n  \n\tconst OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n  \n\tconst err = (strm, errorCode) => {\n\t  strm.msg = messages[errorCode];\n\t  return errorCode;\n\t};\n  \n\tconst rank = (f) => {\n\t  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n\t};\n  \n\tconst zero = (buf) => {\n\t  let len = buf.length; while (--len >= 0) { buf[len] = 0; }\n\t};\n  \n  \n\t/* eslint-disable new-cap */\n\tlet HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;\n\t// This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n\t// But breaks binary compatibility\n\t//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\n\tlet HASH = HASH_ZLIB;\n  \n\t/* =========================================================================\n\t * Flush as much pending output as possible. All deflate() output goes\n\t * through this function so some applications may wish to modify it\n\t * to avoid allocating a large strm->output buffer and copying into it.\n\t * (See also read_buf()).\n\t */\n\tconst flush_pending = (strm) => {\n\t  const s = strm.state;\n  \n\t  //_tr_flush_bits(s);\n\t  let len = s.pending;\n\t  if (len > strm.avail_out) {\n\t\tlen = strm.avail_out;\n\t  }\n\t  if (len === 0) { return; }\n  \n\t  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n\t  strm.next_out += len;\n\t  s.pending_out += len;\n\t  strm.total_out += len;\n\t  strm.avail_out -= len;\n\t  s.pending -= len;\n\t  if (s.pending === 0) {\n\t\ts.pending_out = 0;\n\t  }\n\t};\n  \n  \n\tconst flush_block_only = (s, last) => {\n\t  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n\t  s.block_start = s.strstart;\n\t  flush_pending(s.strm);\n\t};\n  \n  \n\tconst put_byte = (s, b) => {\n\t  s.pending_buf[s.pending++] = b;\n\t};\n  \n  \n\t/* =========================================================================\n\t * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n\t * IN assertion: the stream state is correct and there is enough room in\n\t * pending_buf.\n\t */\n\tconst putShortMSB = (s, b) => {\n  \n\t  //  put_byte(s, (Byte)(b >> 8));\n\t//  put_byte(s, (Byte)(b & 0xff));\n\t  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n\t  s.pending_buf[s.pending++] = b & 0xff;\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Read a new buffer from the current input stream, update the adler32\n\t * and total number of bytes read.  All deflate() input goes through\n\t * this function so some applications may wish to modify it to avoid\n\t * allocating a large strm->input buffer and copying from it.\n\t * (See also flush_pending()).\n\t */\n\tconst read_buf = (strm, buf, start, size) => {\n  \n\t  let len = strm.avail_in;\n  \n\t  if (len > size) { len = size; }\n\t  if (len === 0) { return 0; }\n  \n\t  strm.avail_in -= len;\n  \n\t  // zmemcpy(buf, strm->next_in, len);\n\t  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n\t  if (strm.state.wrap === 1) {\n\t\tstrm.adler = adler32_1(strm.adler, buf, len, start);\n\t  }\n  \n\t  else if (strm.state.wrap === 2) {\n\t\tstrm.adler = crc32_1(strm.adler, buf, len, start);\n\t  }\n  \n\t  strm.next_in += len;\n\t  strm.total_in += len;\n  \n\t  return len;\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Set match_start to the longest match starting at the given string and\n\t * return its length. Matches shorter or equal to prev_length are discarded,\n\t * in which case the result is equal to prev_length and match_start is\n\t * garbage.\n\t * IN assertions: cur_match is the head of the hash chain for the current\n\t *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n\t * OUT assertion: the match length is not greater than s->lookahead.\n\t */\n\tconst longest_match = (s, cur_match) => {\n  \n\t  let chain_length = s.max_chain_length;      /* max hash chain length */\n\t  let scan = s.strstart; /* current string */\n\t  let match;                       /* matched string */\n\t  let len;                           /* length of current match */\n\t  let best_len = s.prev_length;              /* best match length so far */\n\t  let nice_match = s.nice_match;             /* stop if match long enough */\n\t  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n\t\t  s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n  \n\t  const _win = s.window; // shortcut\n  \n\t  const wmask = s.w_mask;\n\t  const prev  = s.prev;\n  \n\t  /* Stop when cur_match becomes <= limit. To simplify the code,\n\t   * we prevent matches with the string of window index 0.\n\t   */\n  \n\t  const strend = s.strstart + MAX_MATCH;\n\t  let scan_end1  = _win[scan + best_len - 1];\n\t  let scan_end   = _win[scan + best_len];\n  \n\t  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n\t   * It is easy to get rid of this optimization if necessary.\n\t   */\n\t  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n  \n\t  /* Do not waste too much time if we already have a good match: */\n\t  if (s.prev_length >= s.good_match) {\n\t\tchain_length >>= 2;\n\t  }\n\t  /* Do not look for matches beyond the end of the input. This is necessary\n\t   * to make deflate deterministic.\n\t   */\n\t  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n  \n\t  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n  \n\t  do {\n\t\t// Assert(cur_match < s->strstart, \"no future\");\n\t\tmatch = cur_match;\n  \n\t\t/* Skip to next match if the match length cannot increase\n\t\t * or if the match length is less than 2.  Note that the checks below\n\t\t * for insufficient lookahead only occur occasionally for performance\n\t\t * reasons.  Therefore uninitialized memory will be accessed, and\n\t\t * conditional jumps will be made that depend on those values.\n\t\t * However the length of the match is limited to the lookahead, so\n\t\t * the output of deflate is not affected by the uninitialized values.\n\t\t */\n  \n\t\tif (_win[match + best_len]     !== scan_end  ||\n\t\t\t_win[match + best_len - 1] !== scan_end1 ||\n\t\t\t_win[match]                !== _win[scan] ||\n\t\t\t_win[++match]              !== _win[scan + 1]) {\n\t\t  continue;\n\t\t}\n  \n\t\t/* The check at best_len-1 can be removed because it will be made\n\t\t * again later. (This heuristic is not always a win.)\n\t\t * It is not necessary to compare scan[2] and match[2] since they\n\t\t * are always equal when the other bytes match, given that\n\t\t * the hash keys are equal and that HASH_BITS >= 8.\n\t\t */\n\t\tscan += 2;\n\t\tmatch++;\n\t\t// Assert(*scan == *match, \"match[2]?\");\n  \n\t\t/* We check for insufficient lookahead only every 8th comparison;\n\t\t * the 256th check will be made at strstart+258.\n\t\t */\n\t\tdo {\n\t\t  /*jshint noempty:false*/\n\t\t} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n\t\t\t\t _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n\t\t\t\t _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n\t\t\t\t _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n\t\t\t\t scan < strend);\n  \n\t\t// Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n  \n\t\tlen = MAX_MATCH - (strend - scan);\n\t\tscan = strend - MAX_MATCH;\n  \n\t\tif (len > best_len) {\n\t\t  s.match_start = cur_match;\n\t\t  best_len = len;\n\t\t  if (len >= nice_match) {\n\t\t\tbreak;\n\t\t  }\n\t\t  scan_end1  = _win[scan + best_len - 1];\n\t\t  scan_end   = _win[scan + best_len];\n\t\t}\n\t  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n  \n\t  if (best_len <= s.lookahead) {\n\t\treturn best_len;\n\t  }\n\t  return s.lookahead;\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Fill the window when the lookahead becomes insufficient.\n\t * Updates strstart and lookahead.\n\t *\n\t * IN assertion: lookahead < MIN_LOOKAHEAD\n\t * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n\t *    At least one byte has been read, or avail_in == 0; reads are\n\t *    performed for at least two bytes (required for the zip translate_eol\n\t *    option -- not supported here).\n\t */\n\tconst fill_window = (s) => {\n  \n\t  const _w_size = s.w_size;\n\t  let p, n, m, more, str;\n  \n\t  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n  \n\t  do {\n\t\tmore = s.window_size - s.lookahead - s.strstart;\n  \n\t\t// JS ints have 32 bit, block below not needed\n\t\t/* Deal with !@#$% 64K limit: */\n\t\t//if (sizeof(int) <= 2) {\n\t\t//    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n\t\t//        more = wsize;\n\t\t//\n\t\t//  } else if (more == (unsigned)(-1)) {\n\t\t//        /* Very unlikely, but possible on 16 bit machine if\n\t\t//         * strstart == 0 && lookahead == 1 (input done a byte at time)\n\t\t//         */\n\t\t//        more--;\n\t\t//    }\n\t\t//}\n  \n  \n\t\t/* If the window is almost full and there is insufficient lookahead,\n\t\t * move the upper half to the lower one to make room in the upper half.\n\t\t */\n\t\tif (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n  \n\t\t  s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);\n\t\t  s.match_start -= _w_size;\n\t\t  s.strstart -= _w_size;\n\t\t  /* we now have strstart >= MAX_DIST */\n\t\t  s.block_start -= _w_size;\n  \n\t\t  /* Slide the hash table (could be avoided with 32 bit values\n\t\t   at the expense of memory usage). We slide even when level == 0\n\t\t   to keep the hash table consistent if we switch back to level > 0\n\t\t   later. (Using level 0 permanently is not an optimal usage of\n\t\t   zlib, so we don't care about this pathological case.)\n\t\t   */\n  \n\t\t  n = s.hash_size;\n\t\t  p = n;\n  \n\t\t  do {\n\t\t\tm = s.head[--p];\n\t\t\ts.head[p] = (m >= _w_size ? m - _w_size : 0);\n\t\t  } while (--n);\n  \n\t\t  n = _w_size;\n\t\t  p = n;\n  \n\t\t  do {\n\t\t\tm = s.prev[--p];\n\t\t\ts.prev[p] = (m >= _w_size ? m - _w_size : 0);\n\t\t\t/* If n is not on any hash chain, prev[n] is garbage but\n\t\t\t * its value will never be used.\n\t\t\t */\n\t\t  } while (--n);\n  \n\t\t  more += _w_size;\n\t\t}\n\t\tif (s.strm.avail_in === 0) {\n\t\t  break;\n\t\t}\n  \n\t\t/* If there was no sliding:\n\t\t *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n\t\t *    more == window_size - lookahead - strstart\n\t\t * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n\t\t * => more >= window_size - 2*WSIZE + 2\n\t\t * In the BIG_MEM or MMAP case (not yet supported),\n\t\t *   window_size == input_size + MIN_LOOKAHEAD  &&\n\t\t *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n\t\t * Otherwise, window_size == 2*WSIZE so more >= 2.\n\t\t * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n\t\t */\n\t\t//Assert(more >= 2, \"more < 2\");\n\t\tn = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n\t\ts.lookahead += n;\n  \n\t\t/* Initialize the hash value now that we have some input: */\n\t\tif (s.lookahead + s.insert >= MIN_MATCH) {\n\t\t  str = s.strstart - s.insert;\n\t\t  s.ins_h = s.window[str];\n  \n\t\t  /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n\t\t  s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);\n\t//#if MIN_MATCH != 3\n\t//        Call update_hash() MIN_MATCH-3 more times\n\t//#endif\n\t\t  while (s.insert) {\n\t\t\t/* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n\t\t\ts.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n  \n\t\t\ts.prev[str & s.w_mask] = s.head[s.ins_h];\n\t\t\ts.head[s.ins_h] = str;\n\t\t\tstr++;\n\t\t\ts.insert--;\n\t\t\tif (s.lookahead + s.insert < MIN_MATCH) {\n\t\t\t  break;\n\t\t\t}\n\t\t  }\n\t\t}\n\t\t/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n\t\t * but this is not important since only literal bytes will be emitted.\n\t\t */\n  \n\t  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n  \n\t  /* If the WIN_INIT bytes after the end of the current data have never been\n\t   * written, then zero those bytes in order to avoid memory check reports of\n\t   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n\t   * the longest match routines.  Update the high water mark for the next\n\t   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n\t   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n\t   */\n\t//  if (s.high_water < s.window_size) {\n\t//    const curr = s.strstart + s.lookahead;\n\t//    let init = 0;\n\t//\n\t//    if (s.high_water < curr) {\n\t//      /* Previous high water mark below current data -- zero WIN_INIT\n\t//       * bytes or up to end of window, whichever is less.\n\t//       */\n\t//      init = s.window_size - curr;\n\t//      if (init > WIN_INIT)\n\t//        init = WIN_INIT;\n\t//      zmemzero(s->window + curr, (unsigned)init);\n\t//      s->high_water = curr + init;\n\t//    }\n\t//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n\t//      /* High water mark at or above current data, but below current data\n\t//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n\t//       * to end of window, whichever is less.\n\t//       */\n\t//      init = (ulg)curr + WIN_INIT - s->high_water;\n\t//      if (init > s->window_size - s->high_water)\n\t//        init = s->window_size - s->high_water;\n\t//      zmemzero(s->window + s->high_water, (unsigned)init);\n\t//      s->high_water += init;\n\t//    }\n\t//  }\n\t//\n\t//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n\t//    \"not enough room for search\");\n\t};\n  \n\t/* ===========================================================================\n\t * Copy without compression as much as possible from the input stream, return\n\t * the current block state.\n\t * This function does not insert new strings in the dictionary since\n\t * uncompressible data is probably not useful. This function is used\n\t * only for the level=0 compression option.\n\t * NOTE: this function should be optimized to avoid extra copying from\n\t * window to pending_buf.\n\t */\n\tconst deflate_stored = (s, flush) => {\n  \n\t  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n\t   * to pending_buf_size, and each stored block has a 5 byte header:\n\t   */\n\t  let max_block_size = 0xffff;\n  \n\t  if (max_block_size > s.pending_buf_size - 5) {\n\t\tmax_block_size = s.pending_buf_size - 5;\n\t  }\n  \n\t  /* Copy as much as possible from input to output: */\n\t  for (;;) {\n\t\t/* Fill the window as much as possible: */\n\t\tif (s.lookahead <= 1) {\n  \n\t\t  //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n\t\t  //  s->block_start >= (long)s->w_size, \"slide too late\");\n\t//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n\t//        s.block_start >= s.w_size)) {\n\t//        throw  new Error(\"slide too late\");\n\t//      }\n  \n\t\t  fill_window(s);\n\t\t  if (s.lookahead === 0 && flush === Z_NO_FLUSH$2) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n  \n\t\t  if (s.lookahead === 0) {\n\t\t\tbreak;\n\t\t  }\n\t\t  /* flush the current block */\n\t\t}\n\t\t//Assert(s->block_start >= 0L, \"block gone\");\n\t//    if (s.block_start < 0) throw new Error(\"block gone\");\n  \n\t\ts.strstart += s.lookahead;\n\t\ts.lookahead = 0;\n  \n\t\t/* Emit a stored block if pending_buf will be full: */\n\t\tconst max_start = s.block_start + max_block_size;\n  \n\t\tif (s.strstart === 0 || s.strstart >= max_start) {\n\t\t  /* strstart == 0 is possible when wraparound on 16-bit machine */\n\t\t  s.lookahead = s.strstart - max_start;\n\t\t  s.strstart = max_start;\n\t\t  /*** FLUSH_BLOCK(s, 0); ***/\n\t\t  flush_block_only(s, false);\n\t\t  if (s.strm.avail_out === 0) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n\t\t  /***/\n  \n  \n\t\t}\n\t\t/* Flush if we may have to slide, otherwise block_start may become\n\t\t * negative and the data will be gone:\n\t\t */\n\t\tif (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n\t\t  /*** FLUSH_BLOCK(s, 0); ***/\n\t\t  flush_block_only(s, false);\n\t\t  if (s.strm.avail_out === 0) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n\t\t  /***/\n\t\t}\n\t  }\n  \n\t  s.insert = 0;\n  \n\t  if (flush === Z_FINISH$3) {\n\t\t/*** FLUSH_BLOCK(s, 1); ***/\n\t\tflush_block_only(s, true);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_FINISH_STARTED;\n\t\t}\n\t\t/***/\n\t\treturn BS_FINISH_DONE;\n\t  }\n  \n\t  if (s.strstart > s.block_start) {\n\t\t/*** FLUSH_BLOCK(s, 0); ***/\n\t\tflush_block_only(s, false);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_NEED_MORE;\n\t\t}\n\t\t/***/\n\t  }\n  \n\t  return BS_NEED_MORE;\n\t};\n  \n\t/* ===========================================================================\n\t * Compress as much as possible from the input stream, return the current\n\t * block state.\n\t * This function does not perform lazy evaluation of matches and inserts\n\t * new strings in the dictionary only for unmatched strings or for short\n\t * matches. It is used only for the fast compression options.\n\t */\n\tconst deflate_fast = (s, flush) => {\n  \n\t  let hash_head;        /* head of the hash chain */\n\t  let bflush;           /* set if current block must be flushed */\n  \n\t  for (;;) {\n\t\t/* Make sure that we always have enough lookahead, except\n\t\t * at the end of the input file. We need MAX_MATCH bytes\n\t\t * for the next match, plus MIN_MATCH bytes to insert the\n\t\t * string following the next match.\n\t\t */\n\t\tif (s.lookahead < MIN_LOOKAHEAD) {\n\t\t  fill_window(s);\n\t\t  if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n\t\t  if (s.lookahead === 0) {\n\t\t\tbreak; /* flush the current block */\n\t\t  }\n\t\t}\n  \n\t\t/* Insert the string window[strstart .. strstart+2] in the\n\t\t * dictionary, and set hash_head to the head of the hash chain:\n\t\t */\n\t\thash_head = 0/*NIL*/;\n\t\tif (s.lookahead >= MIN_MATCH) {\n\t\t  /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n\t\t  s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n\t\t  hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t\t  s.head[s.ins_h] = s.strstart;\n\t\t  /***/\n\t\t}\n  \n\t\t/* Find the longest match, discarding those <= prev_length.\n\t\t * At this point we have always match_length < MIN_MATCH\n\t\t */\n\t\tif (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n\t\t  /* To simplify the code, we prevent matches with the string\n\t\t   * of window index 0 (in particular we have to avoid a match\n\t\t   * of the string with itself at the start of the input file).\n\t\t   */\n\t\t  s.match_length = longest_match(s, hash_head);\n\t\t  /* longest_match() sets match_start */\n\t\t}\n\t\tif (s.match_length >= MIN_MATCH) {\n\t\t  // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n  \n\t\t  /*** _tr_tally_dist(s, s.strstart - s.match_start,\n\t\t\t\t\t\t s.match_length - MIN_MATCH, bflush); ***/\n\t\t  bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n  \n\t\t  s.lookahead -= s.match_length;\n  \n\t\t  /* Insert new strings in the hash table only if the match length\n\t\t   * is not too large. This saves time but degrades compression.\n\t\t   */\n\t\t  if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n\t\t\ts.match_length--; /* string at strstart already in table */\n\t\t\tdo {\n\t\t\t  s.strstart++;\n\t\t\t  /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n\t\t\t  s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n\t\t\t  hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t\t\t  s.head[s.ins_h] = s.strstart;\n\t\t\t  /***/\n\t\t\t  /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n\t\t\t   * always MIN_MATCH bytes ahead.\n\t\t\t   */\n\t\t\t} while (--s.match_length !== 0);\n\t\t\ts.strstart++;\n\t\t  } else\n\t\t  {\n\t\t\ts.strstart += s.match_length;\n\t\t\ts.match_length = 0;\n\t\t\ts.ins_h = s.window[s.strstart];\n\t\t\t/* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n\t\t\ts.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);\n  \n\t//#if MIN_MATCH != 3\n\t//                Call UPDATE_HASH() MIN_MATCH-3 more times\n\t//#endif\n\t\t\t/* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n\t\t\t * matter since it will be recomputed at next deflate call.\n\t\t\t */\n\t\t  }\n\t\t} else {\n\t\t  /* No match, output a literal byte */\n\t\t  //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n\t\t  /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n\t\t  bflush = _tr_tally(s, 0, s.window[s.strstart]);\n  \n\t\t  s.lookahead--;\n\t\t  s.strstart++;\n\t\t}\n\t\tif (bflush) {\n\t\t  /*** FLUSH_BLOCK(s, 0); ***/\n\t\t  flush_block_only(s, false);\n\t\t  if (s.strm.avail_out === 0) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n\t\t  /***/\n\t\t}\n\t  }\n\t  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n\t  if (flush === Z_FINISH$3) {\n\t\t/*** FLUSH_BLOCK(s, 1); ***/\n\t\tflush_block_only(s, true);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_FINISH_STARTED;\n\t\t}\n\t\t/***/\n\t\treturn BS_FINISH_DONE;\n\t  }\n\t  if (s.last_lit) {\n\t\t/*** FLUSH_BLOCK(s, 0); ***/\n\t\tflush_block_only(s, false);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_NEED_MORE;\n\t\t}\n\t\t/***/\n\t  }\n\t  return BS_BLOCK_DONE;\n\t};\n  \n\t/* ===========================================================================\n\t * Same as above, but achieves better compression. We use a lazy\n\t * evaluation for matches: a match is finally adopted only if there is\n\t * no better match at the next window position.\n\t */\n\tconst deflate_slow = (s, flush) => {\n  \n\t  let hash_head;          /* head of hash chain */\n\t  let bflush;              /* set if current block must be flushed */\n  \n\t  let max_insert;\n  \n\t  /* Process the input block. */\n\t  for (;;) {\n\t\t/* Make sure that we always have enough lookahead, except\n\t\t * at the end of the input file. We need MAX_MATCH bytes\n\t\t * for the next match, plus MIN_MATCH bytes to insert the\n\t\t * string following the next match.\n\t\t */\n\t\tif (s.lookahead < MIN_LOOKAHEAD) {\n\t\t  fill_window(s);\n\t\t  if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n\t\t  if (s.lookahead === 0) { break; } /* flush the current block */\n\t\t}\n  \n\t\t/* Insert the string window[strstart .. strstart+2] in the\n\t\t * dictionary, and set hash_head to the head of the hash chain:\n\t\t */\n\t\thash_head = 0/*NIL*/;\n\t\tif (s.lookahead >= MIN_MATCH) {\n\t\t  /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n\t\t  s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n\t\t  hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t\t  s.head[s.ins_h] = s.strstart;\n\t\t  /***/\n\t\t}\n  \n\t\t/* Find the longest match, discarding those <= prev_length.\n\t\t */\n\t\ts.prev_length = s.match_length;\n\t\ts.prev_match = s.match_start;\n\t\ts.match_length = MIN_MATCH - 1;\n  \n\t\tif (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n\t\t\ts.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n\t\t  /* To simplify the code, we prevent matches with the string\n\t\t   * of window index 0 (in particular we have to avoid a match\n\t\t   * of the string with itself at the start of the input file).\n\t\t   */\n\t\t  s.match_length = longest_match(s, hash_head);\n\t\t  /* longest_match() sets match_start */\n  \n\t\t  if (s.match_length <= 5 &&\n\t\t\t (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n  \n\t\t\t/* If prev_match is also MIN_MATCH, match_start is garbage\n\t\t\t * but we will ignore the current match anyway.\n\t\t\t */\n\t\t\ts.match_length = MIN_MATCH - 1;\n\t\t  }\n\t\t}\n\t\t/* If there was a match at the previous step and the current\n\t\t * match is not better, output the previous match:\n\t\t */\n\t\tif (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n\t\t  max_insert = s.strstart + s.lookahead - MIN_MATCH;\n\t\t  /* Do not insert strings in hash table beyond this. */\n  \n\t\t  //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n  \n\t\t  /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n\t\t\t\t\t\t s.prev_length - MIN_MATCH, bflush);***/\n\t\t  bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n\t\t  /* Insert in hash table all strings up to the end of the match.\n\t\t   * strstart-1 and strstart are already inserted. If there is not\n\t\t   * enough lookahead, the last two strings are not inserted in\n\t\t   * the hash table.\n\t\t   */\n\t\t  s.lookahead -= s.prev_length - 1;\n\t\t  s.prev_length -= 2;\n\t\t  do {\n\t\t\tif (++s.strstart <= max_insert) {\n\t\t\t  /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n\t\t\t  s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n\t\t\t  hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t\t\t  s.head[s.ins_h] = s.strstart;\n\t\t\t  /***/\n\t\t\t}\n\t\t  } while (--s.prev_length !== 0);\n\t\t  s.match_available = 0;\n\t\t  s.match_length = MIN_MATCH - 1;\n\t\t  s.strstart++;\n  \n\t\t  if (bflush) {\n\t\t\t/*** FLUSH_BLOCK(s, 0); ***/\n\t\t\tflush_block_only(s, false);\n\t\t\tif (s.strm.avail_out === 0) {\n\t\t\t  return BS_NEED_MORE;\n\t\t\t}\n\t\t\t/***/\n\t\t  }\n  \n\t\t} else if (s.match_available) {\n\t\t  /* If there was no match at the previous position, output a\n\t\t   * single literal. If there was a match but the current match\n\t\t   * is longer, truncate the previous match to a single literal.\n\t\t   */\n\t\t  //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\t\t  /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n\t\t  bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n  \n\t\t  if (bflush) {\n\t\t\t/*** FLUSH_BLOCK_ONLY(s, 0) ***/\n\t\t\tflush_block_only(s, false);\n\t\t\t/***/\n\t\t  }\n\t\t  s.strstart++;\n\t\t  s.lookahead--;\n\t\t  if (s.strm.avail_out === 0) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n\t\t} else {\n\t\t  /* There is no previous match to compare with, wait for\n\t\t   * the next step to decide.\n\t\t   */\n\t\t  s.match_available = 1;\n\t\t  s.strstart++;\n\t\t  s.lookahead--;\n\t\t}\n\t  }\n\t  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n\t  if (s.match_available) {\n\t\t//Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\t\t/*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n\t\tbflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n  \n\t\ts.match_available = 0;\n\t  }\n\t  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n\t  if (flush === Z_FINISH$3) {\n\t\t/*** FLUSH_BLOCK(s, 1); ***/\n\t\tflush_block_only(s, true);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_FINISH_STARTED;\n\t\t}\n\t\t/***/\n\t\treturn BS_FINISH_DONE;\n\t  }\n\t  if (s.last_lit) {\n\t\t/*** FLUSH_BLOCK(s, 0); ***/\n\t\tflush_block_only(s, false);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_NEED_MORE;\n\t\t}\n\t\t/***/\n\t  }\n  \n\t  return BS_BLOCK_DONE;\n\t};\n  \n  \n\t/* ===========================================================================\n\t * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n\t * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n\t * deflate switches away from Z_RLE.)\n\t */\n\tconst deflate_rle = (s, flush) => {\n  \n\t  let bflush;            /* set if current block must be flushed */\n\t  let prev;              /* byte at distance one to match */\n\t  let scan, strend;      /* scan goes up to strend for length of run */\n  \n\t  const _win = s.window;\n  \n\t  for (;;) {\n\t\t/* Make sure that we always have enough lookahead, except\n\t\t * at the end of the input file. We need MAX_MATCH bytes\n\t\t * for the longest run, plus one for the unrolled loop.\n\t\t */\n\t\tif (s.lookahead <= MAX_MATCH) {\n\t\t  fill_window(s);\n\t\t  if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n\t\t  if (s.lookahead === 0) { break; } /* flush the current block */\n\t\t}\n  \n\t\t/* See how many times the previous byte repeats */\n\t\ts.match_length = 0;\n\t\tif (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n\t\t  scan = s.strstart - 1;\n\t\t  prev = _win[scan];\n\t\t  if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n\t\t\tstrend = s.strstart + MAX_MATCH;\n\t\t\tdo {\n\t\t\t  /*jshint noempty:false*/\n\t\t\t} while (prev === _win[++scan] && prev === _win[++scan] &&\n\t\t\t\t\t prev === _win[++scan] && prev === _win[++scan] &&\n\t\t\t\t\t prev === _win[++scan] && prev === _win[++scan] &&\n\t\t\t\t\t prev === _win[++scan] && prev === _win[++scan] &&\n\t\t\t\t\t scan < strend);\n\t\t\ts.match_length = MAX_MATCH - (strend - scan);\n\t\t\tif (s.match_length > s.lookahead) {\n\t\t\t  s.match_length = s.lookahead;\n\t\t\t}\n\t\t  }\n\t\t  //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n\t\t}\n  \n\t\t/* Emit match if have run of MIN_MATCH or longer, else emit literal */\n\t\tif (s.match_length >= MIN_MATCH) {\n\t\t  //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n  \n\t\t  /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n\t\t  bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n  \n\t\t  s.lookahead -= s.match_length;\n\t\t  s.strstart += s.match_length;\n\t\t  s.match_length = 0;\n\t\t} else {\n\t\t  /* No match, output a literal byte */\n\t\t  //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\t\t  /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n\t\t  bflush = _tr_tally(s, 0, s.window[s.strstart]);\n  \n\t\t  s.lookahead--;\n\t\t  s.strstart++;\n\t\t}\n\t\tif (bflush) {\n\t\t  /*** FLUSH_BLOCK(s, 0); ***/\n\t\t  flush_block_only(s, false);\n\t\t  if (s.strm.avail_out === 0) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n\t\t  /***/\n\t\t}\n\t  }\n\t  s.insert = 0;\n\t  if (flush === Z_FINISH$3) {\n\t\t/*** FLUSH_BLOCK(s, 1); ***/\n\t\tflush_block_only(s, true);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_FINISH_STARTED;\n\t\t}\n\t\t/***/\n\t\treturn BS_FINISH_DONE;\n\t  }\n\t  if (s.last_lit) {\n\t\t/*** FLUSH_BLOCK(s, 0); ***/\n\t\tflush_block_only(s, false);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_NEED_MORE;\n\t\t}\n\t\t/***/\n\t  }\n\t  return BS_BLOCK_DONE;\n\t};\n  \n\t/* ===========================================================================\n\t * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n\t * (It will be regenerated if this run of deflate switches away from Huffman.)\n\t */\n\tconst deflate_huff = (s, flush) => {\n  \n\t  let bflush;             /* set if current block must be flushed */\n  \n\t  for (;;) {\n\t\t/* Make sure that we have a literal to write. */\n\t\tif (s.lookahead === 0) {\n\t\t  fill_window(s);\n\t\t  if (s.lookahead === 0) {\n\t\t\tif (flush === Z_NO_FLUSH$2) {\n\t\t\t  return BS_NEED_MORE;\n\t\t\t}\n\t\t\tbreak;      /* flush the current block */\n\t\t  }\n\t\t}\n  \n\t\t/* Output a literal byte */\n\t\ts.match_length = 0;\n\t\t//Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\t\t/*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n\t\tbflush = _tr_tally(s, 0, s.window[s.strstart]);\n\t\ts.lookahead--;\n\t\ts.strstart++;\n\t\tif (bflush) {\n\t\t  /*** FLUSH_BLOCK(s, 0); ***/\n\t\t  flush_block_only(s, false);\n\t\t  if (s.strm.avail_out === 0) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n\t\t  /***/\n\t\t}\n\t  }\n\t  s.insert = 0;\n\t  if (flush === Z_FINISH$3) {\n\t\t/*** FLUSH_BLOCK(s, 1); ***/\n\t\tflush_block_only(s, true);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_FINISH_STARTED;\n\t\t}\n\t\t/***/\n\t\treturn BS_FINISH_DONE;\n\t  }\n\t  if (s.last_lit) {\n\t\t/*** FLUSH_BLOCK(s, 0); ***/\n\t\tflush_block_only(s, false);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_NEED_MORE;\n\t\t}\n\t\t/***/\n\t  }\n\t  return BS_BLOCK_DONE;\n\t};\n  \n\t/* Values for max_lazy_match, good_match and max_chain_length, depending on\n\t * the desired pack level (0..9). The values given below have been tuned to\n\t * exclude worst case performance for pathological files. Better values may be\n\t * found for specific files.\n\t */\n\tfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  \n\t  this.good_length = good_length;\n\t  this.max_lazy = max_lazy;\n\t  this.nice_length = nice_length;\n\t  this.max_chain = max_chain;\n\t  this.func = func;\n\t}\n  \n\tconst configuration_table = [\n\t  /*      good lazy nice chain */\n\t  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n\t  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n\t  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n\t  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n  \n\t  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n\t  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n\t  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n\t  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n\t  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n\t  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n\t];\n  \n  \n\t/* ===========================================================================\n\t * Initialize the \"longest match\" routines for a new zlib stream\n\t */\n\tconst lm_init = (s) => {\n  \n\t  s.window_size = 2 * s.w_size;\n  \n\t  /*** CLEAR_HASH(s); ***/\n\t  zero(s.head); // Fill with NIL (= 0);\n  \n\t  /* Set the default configuration parameters:\n\t   */\n\t  s.max_lazy_match = configuration_table[s.level].max_lazy;\n\t  s.good_match = configuration_table[s.level].good_length;\n\t  s.nice_match = configuration_table[s.level].nice_length;\n\t  s.max_chain_length = configuration_table[s.level].max_chain;\n  \n\t  s.strstart = 0;\n\t  s.block_start = 0;\n\t  s.lookahead = 0;\n\t  s.insert = 0;\n\t  s.match_length = s.prev_length = MIN_MATCH - 1;\n\t  s.match_available = 0;\n\t  s.ins_h = 0;\n\t};\n  \n  \n\tfunction DeflateState() {\n\t  this.strm = null;            /* pointer back to this zlib stream */\n\t  this.status = 0;            /* as the name implies */\n\t  this.pending_buf = null;      /* output still pending */\n\t  this.pending_buf_size = 0;  /* size of pending_buf */\n\t  this.pending_out = 0;       /* next pending byte to output to the stream */\n\t  this.pending = 0;           /* nb of bytes in the pending buffer */\n\t  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n\t  this.gzhead = null;         /* gzip header information to write */\n\t  this.gzindex = 0;           /* where in extra, name, or comment */\n\t  this.method = Z_DEFLATED$2; /* can only be DEFLATED */\n\t  this.last_flush = -1;   /* value of flush param for previous deflate call */\n  \n\t  this.w_size = 0;  /* LZ77 window size (32K by default) */\n\t  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n\t  this.w_mask = 0;  /* w_size - 1 */\n  \n\t  this.window = null;\n\t  /* Sliding window. Input bytes are read into the second half of the window,\n\t   * and move to the first half later to keep a dictionary of at least wSize\n\t   * bytes. With this organization, matches are limited to a distance of\n\t   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n\t   * performed with a length multiple of the block size.\n\t   */\n  \n\t  this.window_size = 0;\n\t  /* Actual size of window: 2*wSize, except when the user input buffer\n\t   * is directly used as sliding window.\n\t   */\n  \n\t  this.prev = null;\n\t  /* Link to older string with same hash index. To limit the size of this\n\t   * array to 64K, this link is maintained only for the last 32K strings.\n\t   * An index in this array is thus a window index modulo 32K.\n\t   */\n  \n\t  this.head = null;   /* Heads of the hash chains or NIL. */\n  \n\t  this.ins_h = 0;       /* hash index of string to be inserted */\n\t  this.hash_size = 0;   /* number of elements in hash table */\n\t  this.hash_bits = 0;   /* log2(hash_size) */\n\t  this.hash_mask = 0;   /* hash_size-1 */\n  \n\t  this.hash_shift = 0;\n\t  /* Number of bits by which ins_h must be shifted at each input\n\t   * step. It must be such that after MIN_MATCH steps, the oldest\n\t   * byte no longer takes part in the hash key, that is:\n\t   *   hash_shift * MIN_MATCH >= hash_bits\n\t   */\n  \n\t  this.block_start = 0;\n\t  /* Window position at the beginning of the current output block. Gets\n\t   * negative when the window is moved backwards.\n\t   */\n  \n\t  this.match_length = 0;      /* length of best match */\n\t  this.prev_match = 0;        /* previous match */\n\t  this.match_available = 0;   /* set if previous match exists */\n\t  this.strstart = 0;          /* start of string to insert */\n\t  this.match_start = 0;       /* start of matching string */\n\t  this.lookahead = 0;         /* number of valid bytes ahead in window */\n  \n\t  this.prev_length = 0;\n\t  /* Length of the best match at previous step. Matches not greater than this\n\t   * are discarded. This is used in the lazy match evaluation.\n\t   */\n  \n\t  this.max_chain_length = 0;\n\t  /* To speed up deflation, hash chains are never searched beyond this\n\t   * length.  A higher limit improves compression ratio but degrades the\n\t   * speed.\n\t   */\n  \n\t  this.max_lazy_match = 0;\n\t  /* Attempt to find a better match only when the current match is strictly\n\t   * smaller than this value. This mechanism is used only for compression\n\t   * levels >= 4.\n\t   */\n\t  // That's alias to max_lazy_match, don't use directly\n\t  //this.max_insert_length = 0;\n\t  /* Insert new strings in the hash table only if the match length is not\n\t   * greater than this length. This saves time but degrades compression.\n\t   * max_insert_length is used only for compression levels <= 3.\n\t   */\n  \n\t  this.level = 0;     /* compression level (1..9) */\n\t  this.strategy = 0;  /* favor or force Huffman coding*/\n  \n\t  this.good_match = 0;\n\t  /* Use a faster search when the previous match is longer than this */\n  \n\t  this.nice_match = 0; /* Stop searching when current match exceeds this */\n  \n\t\t\t\t  /* used by trees.c: */\n  \n\t  /* Didn't use ct_data typedef below to suppress compiler warning */\n  \n\t  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n\t  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n\t  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n  \n\t  // Use flat array of DOUBLE size, with interleaved fata,\n\t  // because JS does not support effective\n\t  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);\n\t  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);\n\t  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);\n\t  zero(this.dyn_ltree);\n\t  zero(this.dyn_dtree);\n\t  zero(this.bl_tree);\n  \n\t  this.l_desc   = null;         /* desc. for literal tree */\n\t  this.d_desc   = null;         /* desc. for distance tree */\n\t  this.bl_desc  = null;         /* desc. for bit length tree */\n  \n\t  //ush bl_count[MAX_BITS+1];\n\t  this.bl_count = new Uint16Array(MAX_BITS + 1);\n\t  /* number of codes at each bit length for an optimal tree */\n  \n\t  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n\t  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n\t  zero(this.heap);\n  \n\t  this.heap_len = 0;               /* number of elements in the heap */\n\t  this.heap_max = 0;               /* element of largest frequency */\n\t  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n\t   * The same heap array is used to build all trees.\n\t   */\n  \n\t  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n\t  zero(this.depth);\n\t  /* Depth of each subtree used as tie breaker for trees of equal frequency\n\t   */\n  \n\t  this.l_buf = 0;          /* buffer index for literals or lengths */\n  \n\t  this.lit_bufsize = 0;\n\t  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n\t   * limiting lit_bufsize to 64K:\n\t   *   - frequencies can be kept in 16 bit counters\n\t   *   - if compression is not successful for the first block, all input\n\t   *     data is still in the window so we can still emit a stored block even\n\t   *     when input comes from standard input.  (This can also be done for\n\t   *     all blocks if lit_bufsize is not greater than 32K.)\n\t   *   - if compression is not successful for a file smaller than 64K, we can\n\t   *     even emit a stored file instead of a stored block (saving 5 bytes).\n\t   *     This is applicable only for zip (not gzip or zlib).\n\t   *   - creating new Huffman trees less frequently may not provide fast\n\t   *     adaptation to changes in the input data statistics. (Take for\n\t   *     example a binary file with poorly compressible code followed by\n\t   *     a highly compressible string table.) Smaller buffer sizes give\n\t   *     fast adaptation but have of course the overhead of transmitting\n\t   *     trees more frequently.\n\t   *   - I can't count above 4\n\t   */\n  \n\t  this.last_lit = 0;      /* running index in l_buf */\n  \n\t  this.d_buf = 0;\n\t  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n\t   * the same number of elements. To use different lengths, an extra flag\n\t   * array would be necessary.\n\t   */\n  \n\t  this.opt_len = 0;       /* bit length of current block with optimal trees */\n\t  this.static_len = 0;    /* bit length of current block with static trees */\n\t  this.matches = 0;       /* number of string matches in current block */\n\t  this.insert = 0;        /* bytes at end of window left to insert */\n  \n  \n\t  this.bi_buf = 0;\n\t  /* Output buffer. bits are inserted starting at the bottom (least\n\t   * significant bits).\n\t   */\n\t  this.bi_valid = 0;\n\t  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n\t   * are always zero.\n\t   */\n  \n\t  // Used for window memory init. We safely ignore it for JS. That makes\n\t  // sense only for pointers and memory check tools.\n\t  //this.high_water = 0;\n\t  /* High water mark offset in window for initialized bytes -- bytes above\n\t   * this are set to zero in order to avoid memory check warnings when\n\t   * longest match routines access bytes past the input.  This is then\n\t   * updated to the new high water mark.\n\t   */\n\t}\n  \n  \n\tconst deflateResetKeep = (strm) => {\n  \n\t  if (!strm || !strm.state) {\n\t\treturn err(strm, Z_STREAM_ERROR$2);\n\t  }\n  \n\t  strm.total_in = strm.total_out = 0;\n\t  strm.data_type = Z_UNKNOWN;\n  \n\t  const s = strm.state;\n\t  s.pending = 0;\n\t  s.pending_out = 0;\n  \n\t  if (s.wrap < 0) {\n\t\ts.wrap = -s.wrap;\n\t\t/* was made negative by deflate(..., Z_FINISH); */\n\t  }\n\t  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n\t  strm.adler = (s.wrap === 2) ?\n\t\t0  // crc32(0, Z_NULL, 0)\n\t  :\n\t\t1; // adler32(0, Z_NULL, 0)\n\t  s.last_flush = Z_NO_FLUSH$2;\n\t  _tr_init(s);\n\t  return Z_OK$3;\n\t};\n  \n  \n\tconst deflateReset = (strm) => {\n  \n\t  const ret = deflateResetKeep(strm);\n\t  if (ret === Z_OK$3) {\n\t\tlm_init(strm.state);\n\t  }\n\t  return ret;\n\t};\n  \n  \n\tconst deflateSetHeader = (strm, head) => {\n  \n\t  if (!strm || !strm.state) { return Z_STREAM_ERROR$2; }\n\t  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR$2; }\n\t  strm.state.gzhead = head;\n\t  return Z_OK$3;\n\t};\n  \n  \n\tconst deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n  \n\t  if (!strm) { // === Z_NULL\n\t\treturn Z_STREAM_ERROR$2;\n\t  }\n\t  let wrap = 1;\n  \n\t  if (level === Z_DEFAULT_COMPRESSION$1) {\n\t\tlevel = 6;\n\t  }\n  \n\t  if (windowBits < 0) { /* suppress zlib wrapper */\n\t\twrap = 0;\n\t\twindowBits = -windowBits;\n\t  }\n  \n\t  else if (windowBits > 15) {\n\t\twrap = 2;           /* write gzip wrapper instead */\n\t\twindowBits -= 16;\n\t  }\n  \n  \n\t  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||\n\t\twindowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n\t\tstrategy < 0 || strategy > Z_FIXED) {\n\t\treturn err(strm, Z_STREAM_ERROR$2);\n\t  }\n  \n  \n\t  if (windowBits === 8) {\n\t\twindowBits = 9;\n\t  }\n\t  /* until 256-byte window bug fixed */\n  \n\t  const s = new DeflateState();\n  \n\t  strm.state = s;\n\t  s.strm = strm;\n  \n\t  s.wrap = wrap;\n\t  s.gzhead = null;\n\t  s.w_bits = windowBits;\n\t  s.w_size = 1 << s.w_bits;\n\t  s.w_mask = s.w_size - 1;\n  \n\t  s.hash_bits = memLevel + 7;\n\t  s.hash_size = 1 << s.hash_bits;\n\t  s.hash_mask = s.hash_size - 1;\n\t  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n  \n\t  s.window = new Uint8Array(s.w_size * 2);\n\t  s.head = new Uint16Array(s.hash_size);\n\t  s.prev = new Uint16Array(s.w_size);\n  \n\t  // Don't need mem init magic for JS.\n\t  //s.high_water = 0;  /* nothing written to s->window yet */\n  \n\t  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n  \n\t  s.pending_buf_size = s.lit_bufsize * 4;\n  \n\t  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n\t  //s->pending_buf = (uchf *) overlay;\n\t  s.pending_buf = new Uint8Array(s.pending_buf_size);\n  \n\t  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n\t  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n\t  s.d_buf = 1 * s.lit_bufsize;\n  \n\t  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n\t  s.l_buf = (1 + 2) * s.lit_bufsize;\n  \n\t  s.level = level;\n\t  s.strategy = strategy;\n\t  s.method = method;\n  \n\t  return deflateReset(strm);\n\t};\n  \n\tconst deflateInit = (strm, level) => {\n  \n\t  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);\n\t};\n  \n  \n\tconst deflate$2 = (strm, flush) => {\n  \n\t  let beg, val; // for gzip header write only\n  \n\t  if (!strm || !strm.state ||\n\t\tflush > Z_BLOCK$1 || flush < 0) {\n\t\treturn strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;\n\t  }\n  \n\t  const s = strm.state;\n  \n\t  if (!strm.output ||\n\t\t  (!strm.input && strm.avail_in !== 0) ||\n\t\t  (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {\n\t\treturn err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);\n\t  }\n  \n\t  s.strm = strm; /* just in case */\n\t  const old_flush = s.last_flush;\n\t  s.last_flush = flush;\n  \n\t  /* Write the header */\n\t  if (s.status === INIT_STATE) {\n  \n\t\tif (s.wrap === 2) { // GZIP header\n\t\t  strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n\t\t  put_byte(s, 31);\n\t\t  put_byte(s, 139);\n\t\t  put_byte(s, 8);\n\t\t  if (!s.gzhead) { // s->gzhead == Z_NULL\n\t\t\tput_byte(s, 0);\n\t\t\tput_byte(s, 0);\n\t\t\tput_byte(s, 0);\n\t\t\tput_byte(s, 0);\n\t\t\tput_byte(s, 0);\n\t\t\tput_byte(s, s.level === 9 ? 2 :\n\t\t\t\t\t\t(s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n\t\t\t\t\t\t 4 : 0));\n\t\t\tput_byte(s, OS_CODE);\n\t\t\ts.status = BUSY_STATE;\n\t\t  }\n\t\t  else {\n\t\t\tput_byte(s, (s.gzhead.text ? 1 : 0) +\n\t\t\t\t\t\t(s.gzhead.hcrc ? 2 : 0) +\n\t\t\t\t\t\t(!s.gzhead.extra ? 0 : 4) +\n\t\t\t\t\t\t(!s.gzhead.name ? 0 : 8) +\n\t\t\t\t\t\t(!s.gzhead.comment ? 0 : 16)\n\t\t\t);\n\t\t\tput_byte(s, s.gzhead.time & 0xff);\n\t\t\tput_byte(s, (s.gzhead.time >> 8) & 0xff);\n\t\t\tput_byte(s, (s.gzhead.time >> 16) & 0xff);\n\t\t\tput_byte(s, (s.gzhead.time >> 24) & 0xff);\n\t\t\tput_byte(s, s.level === 9 ? 2 :\n\t\t\t\t\t\t(s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n\t\t\t\t\t\t 4 : 0));\n\t\t\tput_byte(s, s.gzhead.os & 0xff);\n\t\t\tif (s.gzhead.extra && s.gzhead.extra.length) {\n\t\t\t  put_byte(s, s.gzhead.extra.length & 0xff);\n\t\t\t  put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n\t\t\t}\n\t\t\tif (s.gzhead.hcrc) {\n\t\t\t  strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);\n\t\t\t}\n\t\t\ts.gzindex = 0;\n\t\t\ts.status = EXTRA_STATE;\n\t\t  }\n\t\t}\n\t\telse // DEFLATE header\n\t\t{\n\t\t  let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;\n\t\t  let level_flags = -1;\n  \n\t\t  if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n\t\t\tlevel_flags = 0;\n\t\t  } else if (s.level < 6) {\n\t\t\tlevel_flags = 1;\n\t\t  } else if (s.level === 6) {\n\t\t\tlevel_flags = 2;\n\t\t  } else {\n\t\t\tlevel_flags = 3;\n\t\t  }\n\t\t  header |= (level_flags << 6);\n\t\t  if (s.strstart !== 0) { header |= PRESET_DICT; }\n\t\t  header += 31 - (header % 31);\n  \n\t\t  s.status = BUSY_STATE;\n\t\t  putShortMSB(s, header);\n  \n\t\t  /* Save the adler32 of the preset dictionary: */\n\t\t  if (s.strstart !== 0) {\n\t\t\tputShortMSB(s, strm.adler >>> 16);\n\t\t\tputShortMSB(s, strm.adler & 0xffff);\n\t\t  }\n\t\t  strm.adler = 1; // adler32(0L, Z_NULL, 0);\n\t\t}\n\t  }\n  \n\t//#ifdef GZIP\n\t  if (s.status === EXTRA_STATE) {\n\t\tif (s.gzhead.extra/* != Z_NULL*/) {\n\t\t  beg = s.pending;  /* start of bytes to update crc */\n  \n\t\t  while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n\t\t\tif (s.pending === s.pending_buf_size) {\n\t\t\t  if (s.gzhead.hcrc && s.pending > beg) {\n\t\t\t\tstrm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t\t\t  }\n\t\t\t  flush_pending(strm);\n\t\t\t  beg = s.pending;\n\t\t\t  if (s.pending === s.pending_buf_size) {\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t}\n\t\t\tput_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n\t\t\ts.gzindex++;\n\t\t  }\n\t\t  if (s.gzhead.hcrc && s.pending > beg) {\n\t\t\tstrm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t\t  }\n\t\t  if (s.gzindex === s.gzhead.extra.length) {\n\t\t\ts.gzindex = 0;\n\t\t\ts.status = NAME_STATE;\n\t\t  }\n\t\t}\n\t\telse {\n\t\t  s.status = NAME_STATE;\n\t\t}\n\t  }\n\t  if (s.status === NAME_STATE) {\n\t\tif (s.gzhead.name/* != Z_NULL*/) {\n\t\t  beg = s.pending;  /* start of bytes to update crc */\n\t\t  //int val;\n  \n\t\t  do {\n\t\t\tif (s.pending === s.pending_buf_size) {\n\t\t\t  if (s.gzhead.hcrc && s.pending > beg) {\n\t\t\t\tstrm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t\t\t  }\n\t\t\t  flush_pending(strm);\n\t\t\t  beg = s.pending;\n\t\t\t  if (s.pending === s.pending_buf_size) {\n\t\t\t\tval = 1;\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t}\n\t\t\t// JS specific: little magic to add zero terminator to end of string\n\t\t\tif (s.gzindex < s.gzhead.name.length) {\n\t\t\t  val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n\t\t\t} else {\n\t\t\t  val = 0;\n\t\t\t}\n\t\t\tput_byte(s, val);\n\t\t  } while (val !== 0);\n  \n\t\t  if (s.gzhead.hcrc && s.pending > beg) {\n\t\t\tstrm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t\t  }\n\t\t  if (val === 0) {\n\t\t\ts.gzindex = 0;\n\t\t\ts.status = COMMENT_STATE;\n\t\t  }\n\t\t}\n\t\telse {\n\t\t  s.status = COMMENT_STATE;\n\t\t}\n\t  }\n\t  if (s.status === COMMENT_STATE) {\n\t\tif (s.gzhead.comment/* != Z_NULL*/) {\n\t\t  beg = s.pending;  /* start of bytes to update crc */\n\t\t  //int val;\n  \n\t\t  do {\n\t\t\tif (s.pending === s.pending_buf_size) {\n\t\t\t  if (s.gzhead.hcrc && s.pending > beg) {\n\t\t\t\tstrm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t\t\t  }\n\t\t\t  flush_pending(strm);\n\t\t\t  beg = s.pending;\n\t\t\t  if (s.pending === s.pending_buf_size) {\n\t\t\t\tval = 1;\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t}\n\t\t\t// JS specific: little magic to add zero terminator to end of string\n\t\t\tif (s.gzindex < s.gzhead.comment.length) {\n\t\t\t  val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n\t\t\t} else {\n\t\t\t  val = 0;\n\t\t\t}\n\t\t\tput_byte(s, val);\n\t\t  } while (val !== 0);\n  \n\t\t  if (s.gzhead.hcrc && s.pending > beg) {\n\t\t\tstrm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t\t  }\n\t\t  if (val === 0) {\n\t\t\ts.status = HCRC_STATE;\n\t\t  }\n\t\t}\n\t\telse {\n\t\t  s.status = HCRC_STATE;\n\t\t}\n\t  }\n\t  if (s.status === HCRC_STATE) {\n\t\tif (s.gzhead.hcrc) {\n\t\t  if (s.pending + 2 > s.pending_buf_size) {\n\t\t\tflush_pending(strm);\n\t\t  }\n\t\t  if (s.pending + 2 <= s.pending_buf_size) {\n\t\t\tput_byte(s, strm.adler & 0xff);\n\t\t\tput_byte(s, (strm.adler >> 8) & 0xff);\n\t\t\tstrm.adler = 0; //crc32(0L, Z_NULL, 0);\n\t\t\ts.status = BUSY_STATE;\n\t\t  }\n\t\t}\n\t\telse {\n\t\t  s.status = BUSY_STATE;\n\t\t}\n\t  }\n\t//#endif\n  \n\t  /* Flush as much pending output as possible */\n\t  if (s.pending !== 0) {\n\t\tflush_pending(strm);\n\t\tif (strm.avail_out === 0) {\n\t\t  /* Since avail_out is 0, deflate will be called again with\n\t\t   * more output space, but possibly with both pending and\n\t\t   * avail_in equal to zero. There won't be anything to do,\n\t\t   * but this is not an error situation so make sure we\n\t\t   * return OK instead of BUF_ERROR at next call of deflate:\n\t\t   */\n\t\t  s.last_flush = -1;\n\t\t  return Z_OK$3;\n\t\t}\n  \n\t\t/* Make sure there is something to do and avoid duplicate consecutive\n\t\t * flushes. For repeated and useless calls with Z_FINISH, we keep\n\t\t * returning Z_STREAM_END instead of Z_BUF_ERROR.\n\t\t */\n\t  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n\t\tflush !== Z_FINISH$3) {\n\t\treturn err(strm, Z_BUF_ERROR$1);\n\t  }\n  \n\t  /* User must not provide more input after the first FINISH: */\n\t  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n\t\treturn err(strm, Z_BUF_ERROR$1);\n\t  }\n  \n\t  /* Start a new block or continue the current one.\n\t   */\n\t  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n\t\t(flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {\n\t\tlet bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n\t\t  (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n\t\t\tconfiguration_table[s.level].func(s, flush));\n  \n\t\tif (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n\t\t  s.status = FINISH_STATE;\n\t\t}\n\t\tif (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n\t\t  if (strm.avail_out === 0) {\n\t\t\ts.last_flush = -1;\n\t\t\t/* avoid BUF_ERROR next call, see above */\n\t\t  }\n\t\t  return Z_OK$3;\n\t\t  /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n\t\t   * of deflate should use the same flush parameter to make sure\n\t\t   * that the flush is complete. So we don't have to output an\n\t\t   * empty block here, this will be done at next call. This also\n\t\t   * ensures that for a very small output buffer, we emit at most\n\t\t   * one empty block.\n\t\t   */\n\t\t}\n\t\tif (bstate === BS_BLOCK_DONE) {\n\t\t  if (flush === Z_PARTIAL_FLUSH) {\n\t\t\t_tr_align(s);\n\t\t  }\n\t\t  else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */\n  \n\t\t\t_tr_stored_block(s, 0, 0, false);\n\t\t\t/* For a full flush, this empty block will be recognized\n\t\t\t * as a special marker by inflate_sync().\n\t\t\t */\n\t\t\tif (flush === Z_FULL_FLUSH$1) {\n\t\t\t  /*** CLEAR_HASH(s); ***/             /* forget history */\n\t\t\t  zero(s.head); // Fill with NIL (= 0);\n  \n\t\t\t  if (s.lookahead === 0) {\n\t\t\t\ts.strstart = 0;\n\t\t\t\ts.block_start = 0;\n\t\t\t\ts.insert = 0;\n\t\t\t  }\n\t\t\t}\n\t\t  }\n\t\t  flush_pending(strm);\n\t\t  if (strm.avail_out === 0) {\n\t\t\ts.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n\t\t\treturn Z_OK$3;\n\t\t  }\n\t\t}\n\t  }\n\t  //Assert(strm->avail_out > 0, \"bug2\");\n\t  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n  \n\t  if (flush !== Z_FINISH$3) { return Z_OK$3; }\n\t  if (s.wrap <= 0) { return Z_STREAM_END$3; }\n  \n\t  /* Write the trailer */\n\t  if (s.wrap === 2) {\n\t\tput_byte(s, strm.adler & 0xff);\n\t\tput_byte(s, (strm.adler >> 8) & 0xff);\n\t\tput_byte(s, (strm.adler >> 16) & 0xff);\n\t\tput_byte(s, (strm.adler >> 24) & 0xff);\n\t\tput_byte(s, strm.total_in & 0xff);\n\t\tput_byte(s, (strm.total_in >> 8) & 0xff);\n\t\tput_byte(s, (strm.total_in >> 16) & 0xff);\n\t\tput_byte(s, (strm.total_in >> 24) & 0xff);\n\t  }\n\t  else\n\t  {\n\t\tputShortMSB(s, strm.adler >>> 16);\n\t\tputShortMSB(s, strm.adler & 0xffff);\n\t  }\n  \n\t  flush_pending(strm);\n\t  /* If avail_out is zero, the application will call deflate again\n\t   * to flush the rest.\n\t   */\n\t  if (s.wrap > 0) { s.wrap = -s.wrap; }\n\t  /* write the trailer only once! */\n\t  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;\n\t};\n  \n  \n\tconst deflateEnd = (strm) => {\n  \n\t  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n\t\treturn Z_STREAM_ERROR$2;\n\t  }\n  \n\t  const status = strm.state.status;\n\t  if (status !== INIT_STATE &&\n\t\tstatus !== EXTRA_STATE &&\n\t\tstatus !== NAME_STATE &&\n\t\tstatus !== COMMENT_STATE &&\n\t\tstatus !== HCRC_STATE &&\n\t\tstatus !== BUSY_STATE &&\n\t\tstatus !== FINISH_STATE\n\t  ) {\n\t\treturn err(strm, Z_STREAM_ERROR$2);\n\t  }\n  \n\t  strm.state = null;\n  \n\t  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;\n\t};\n  \n  \n\t/* =========================================================================\n\t * Initializes the compression dictionary from the given byte\n\t * sequence without producing any compressed output.\n\t */\n\tconst deflateSetDictionary = (strm, dictionary) => {\n  \n\t  let dictLength = dictionary.length;\n  \n\t  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n\t\treturn Z_STREAM_ERROR$2;\n\t  }\n  \n\t  const s = strm.state;\n\t  const wrap = s.wrap;\n  \n\t  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n\t\treturn Z_STREAM_ERROR$2;\n\t  }\n  \n\t  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n\t  if (wrap === 1) {\n\t\t/* adler32(strm->adler, dictionary, dictLength); */\n\t\tstrm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);\n\t  }\n  \n\t  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n  \n\t  /* if dictionary would fill window, just replace the history */\n\t  if (dictLength >= s.w_size) {\n\t\tif (wrap === 0) {            /* already empty otherwise */\n\t\t  /*** CLEAR_HASH(s); ***/\n\t\t  zero(s.head); // Fill with NIL (= 0);\n\t\t  s.strstart = 0;\n\t\t  s.block_start = 0;\n\t\t  s.insert = 0;\n\t\t}\n\t\t/* use the tail */\n\t\t// dictionary = dictionary.slice(dictLength - s.w_size);\n\t\tlet tmpDict = new Uint8Array(s.w_size);\n\t\ttmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n\t\tdictionary = tmpDict;\n\t\tdictLength = s.w_size;\n\t  }\n\t  /* insert dictionary into window and hash */\n\t  const avail = strm.avail_in;\n\t  const next = strm.next_in;\n\t  const input = strm.input;\n\t  strm.avail_in = dictLength;\n\t  strm.next_in = 0;\n\t  strm.input = dictionary;\n\t  fill_window(s);\n\t  while (s.lookahead >= MIN_MATCH) {\n\t\tlet str = s.strstart;\n\t\tlet n = s.lookahead - (MIN_MATCH - 1);\n\t\tdo {\n\t\t  /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n\t\t  s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n  \n\t\t  s.prev[str & s.w_mask] = s.head[s.ins_h];\n  \n\t\t  s.head[s.ins_h] = str;\n\t\t  str++;\n\t\t} while (--n);\n\t\ts.strstart = str;\n\t\ts.lookahead = MIN_MATCH - 1;\n\t\tfill_window(s);\n\t  }\n\t  s.strstart += s.lookahead;\n\t  s.block_start = s.strstart;\n\t  s.insert = s.lookahead;\n\t  s.lookahead = 0;\n\t  s.match_length = s.prev_length = MIN_MATCH - 1;\n\t  s.match_available = 0;\n\t  strm.next_in = next;\n\t  strm.input = input;\n\t  strm.avail_in = avail;\n\t  s.wrap = wrap;\n\t  return Z_OK$3;\n\t};\n  \n  \n\tvar deflateInit_1 = deflateInit;\n\tvar deflateInit2_1 = deflateInit2;\n\tvar deflateReset_1 = deflateReset;\n\tvar deflateResetKeep_1 = deflateResetKeep;\n\tvar deflateSetHeader_1 = deflateSetHeader;\n\tvar deflate_2$1 = deflate$2;\n\tvar deflateEnd_1 = deflateEnd;\n\tvar deflateSetDictionary_1 = deflateSetDictionary;\n\tvar deflateInfo = 'pako deflate (from Nodeca project)';\n  \n\t/* Not implemented\n\tmodule.exports.deflateBound = deflateBound;\n\tmodule.exports.deflateCopy = deflateCopy;\n\tmodule.exports.deflateParams = deflateParams;\n\tmodule.exports.deflatePending = deflatePending;\n\tmodule.exports.deflatePrime = deflatePrime;\n\tmodule.exports.deflateTune = deflateTune;\n\t*/\n  \n\tvar deflate_1$2 = {\n\t\tdeflateInit: deflateInit_1,\n\t\tdeflateInit2: deflateInit2_1,\n\t\tdeflateReset: deflateReset_1,\n\t\tdeflateResetKeep: deflateResetKeep_1,\n\t\tdeflateSetHeader: deflateSetHeader_1,\n\t\tdeflate: deflate_2$1,\n\t\tdeflateEnd: deflateEnd_1,\n\t\tdeflateSetDictionary: deflateSetDictionary_1,\n\t\tdeflateInfo: deflateInfo\n\t};\n  \n\tconst _has = (obj, key) => {\n\t  return Object.prototype.hasOwnProperty.call(obj, key);\n\t};\n  \n\tvar assign = function (obj /*from1, from2, from3, ...*/) {\n\t  const sources = Array.prototype.slice.call(arguments, 1);\n\t  while (sources.length) {\n\t\tconst source = sources.shift();\n\t\tif (!source) { continue; }\n  \n\t\tif (typeof source !== 'object') {\n\t\t  throw new TypeError(source + 'must be non-object');\n\t\t}\n  \n\t\tfor (const p in source) {\n\t\t  if (_has(source, p)) {\n\t\t\tobj[p] = source[p];\n\t\t  }\n\t\t}\n\t  }\n  \n\t  return obj;\n\t};\n  \n  \n\t// Join array of chunks to single array.\n\tvar flattenChunks = (chunks) => {\n\t  // calculate data length\n\t  let len = 0;\n  \n\t  for (let i = 0, l = chunks.length; i < l; i++) {\n\t\tlen += chunks[i].length;\n\t  }\n  \n\t  // join chunks\n\t  const result = new Uint8Array(len);\n  \n\t  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {\n\t\tlet chunk = chunks[i];\n\t\tresult.set(chunk, pos);\n\t\tpos += chunk.length;\n\t  }\n  \n\t  return result;\n\t};\n  \n\tvar common = {\n\t\tassign: assign,\n\t\tflattenChunks: flattenChunks\n\t};\n  \n\t// String encode/decode helpers\n  \n  \n\t// Quick check if we can use fast array to bin string conversion\n\t//\n\t// - apply(Array) can fail on Android 2.2\n\t// - apply(Uint8Array) can fail on iOS 5.1 Safari\n\t//\n\tlet STR_APPLY_UIA_OK = true;\n  \n\ttry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n  \n  \n\t// Table with utf8 lengths (calculated by first byte of sequence)\n\t// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n\t// because max possible codepoint is 0x10ffff\n\tconst _utf8len = new Uint8Array(256);\n\tfor (let q = 0; q < 256; q++) {\n\t  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n\t}\n\t_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n  \n  \n\t// convert string to array (typed, when possible)\n\tvar string2buf = (str) => {\n\t  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {\n\t\treturn new TextEncoder().encode(str);\n\t  }\n  \n\t  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n  \n\t  // count binary size\n\t  for (m_pos = 0; m_pos < str_len; m_pos++) {\n\t\tc = str.charCodeAt(m_pos);\n\t\tif ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n\t\t  c2 = str.charCodeAt(m_pos + 1);\n\t\t  if ((c2 & 0xfc00) === 0xdc00) {\n\t\t\tc = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n\t\t\tm_pos++;\n\t\t  }\n\t\t}\n\t\tbuf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n\t  }\n  \n\t  // allocate buffer\n\t  buf = new Uint8Array(buf_len);\n  \n\t  // convert\n\t  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n\t\tc = str.charCodeAt(m_pos);\n\t\tif ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n\t\t  c2 = str.charCodeAt(m_pos + 1);\n\t\t  if ((c2 & 0xfc00) === 0xdc00) {\n\t\t\tc = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n\t\t\tm_pos++;\n\t\t  }\n\t\t}\n\t\tif (c < 0x80) {\n\t\t  /* one byte */\n\t\t  buf[i++] = c;\n\t\t} else if (c < 0x800) {\n\t\t  /* two bytes */\n\t\t  buf[i++] = 0xC0 | (c >>> 6);\n\t\t  buf[i++] = 0x80 | (c & 0x3f);\n\t\t} else if (c < 0x10000) {\n\t\t  /* three bytes */\n\t\t  buf[i++] = 0xE0 | (c >>> 12);\n\t\t  buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n\t\t  buf[i++] = 0x80 | (c & 0x3f);\n\t\t} else {\n\t\t  /* four bytes */\n\t\t  buf[i++] = 0xf0 | (c >>> 18);\n\t\t  buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n\t\t  buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n\t\t  buf[i++] = 0x80 | (c & 0x3f);\n\t\t}\n\t  }\n  \n\t  return buf;\n\t};\n  \n\t// Helper\n\tconst buf2binstring = (buf, len) => {\n\t  // On Chrome, the arguments in a function call that are allowed is `65534`.\n\t  // If the length of the buffer is smaller than that, we can use this optimization,\n\t  // otherwise we will take a slower path.\n\t  if (len < 65534) {\n\t\tif (buf.subarray && STR_APPLY_UIA_OK) {\n\t\t  return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));\n\t\t}\n\t  }\n  \n\t  let result = '';\n\t  for (let i = 0; i < len; i++) {\n\t\tresult += String.fromCharCode(buf[i]);\n\t  }\n\t  return result;\n\t};\n  \n  \n\t// convert array to string\n\tvar buf2string = (buf, max) => {\n\t  const len = max || buf.length;\n  \n\t  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {\n\t\treturn new TextDecoder().decode(buf.subarray(0, max));\n\t  }\n  \n\t  let i, out;\n  \n\t  // Reserve max possible length (2 words per char)\n\t  // NB: by unknown reasons, Array is significantly faster for\n\t  //     String.fromCharCode.apply than Uint16Array.\n\t  const utf16buf = new Array(len * 2);\n  \n\t  for (out = 0, i = 0; i < len;) {\n\t\tlet c = buf[i++];\n\t\t// quick process ascii\n\t\tif (c < 0x80) { utf16buf[out++] = c; continue; }\n  \n\t\tlet c_len = _utf8len[c];\n\t\t// skip 5 & 6 byte codes\n\t\tif (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n  \n\t\t// apply mask on first byte\n\t\tc &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n\t\t// join the rest\n\t\twhile (c_len > 1 && i < len) {\n\t\t  c = (c << 6) | (buf[i++] & 0x3f);\n\t\t  c_len--;\n\t\t}\n  \n\t\t// terminated by end of string?\n\t\tif (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n  \n\t\tif (c < 0x10000) {\n\t\t  utf16buf[out++] = c;\n\t\t} else {\n\t\t  c -= 0x10000;\n\t\t  utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n\t\t  utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n\t\t}\n\t  }\n  \n\t  return buf2binstring(utf16buf, out);\n\t};\n  \n  \n\t// Calculate max possible position in utf8 buffer,\n\t// that will not break sequence. If that's not possible\n\t// - (very small limits) return max size as is.\n\t//\n\t// buf[] - utf8 bytes array\n\t// max   - length limit (mandatory);\n\tvar utf8border = (buf, max) => {\n  \n\t  max = max || buf.length;\n\t  if (max > buf.length) { max = buf.length; }\n  \n\t  // go back from last position, until start of sequence found\n\t  let pos = max - 1;\n\t  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n  \n\t  // Very small and broken sequence,\n\t  // return max, because we should return something anyway.\n\t  if (pos < 0) { return max; }\n  \n\t  // If we came to start of buffer - that means buffer is too small,\n\t  // return max too.\n\t  if (pos === 0) { return max; }\n  \n\t  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n\t};\n  \n\tvar strings = {\n\t\tstring2buf: string2buf,\n\t\tbuf2string: buf2string,\n\t\tutf8border: utf8border\n\t};\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\tfunction ZStream() {\n\t  /* next input byte */\n\t  this.input = null; // JS specific, because we have no pointers\n\t  this.next_in = 0;\n\t  /* number of bytes available at input */\n\t  this.avail_in = 0;\n\t  /* total number of input bytes read so far */\n\t  this.total_in = 0;\n\t  /* next output byte should be put there */\n\t  this.output = null; // JS specific, because we have no pointers\n\t  this.next_out = 0;\n\t  /* remaining free space at output */\n\t  this.avail_out = 0;\n\t  /* total number of bytes output so far */\n\t  this.total_out = 0;\n\t  /* last error message, NULL if no error */\n\t  this.msg = ''/*Z_NULL*/;\n\t  /* not visible by applications */\n\t  this.state = null;\n\t  /* best guess about the data type: binary or text */\n\t  this.data_type = 2/*Z_UNKNOWN*/;\n\t  /* adler32 value of the uncompressed data */\n\t  this.adler = 0;\n\t}\n  \n\tvar zstream = ZStream;\n  \n\tconst toString$1 = Object.prototype.toString;\n  \n\t/* Public constants ==========================================================*/\n\t/* ===========================================================================*/\n  \n\tconst {\n\t  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,\n\t  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,\n\t  Z_DEFAULT_COMPRESSION,\n\t  Z_DEFAULT_STRATEGY,\n\t  Z_DEFLATED: Z_DEFLATED$1\n\t} = constants$2;\n  \n\t/* ===========================================================================*/\n  \n  \n\t/**\n\t * class Deflate\n\t *\n\t * Generic JS-style wrapper for zlib calls. If you don't need\n\t * streaming behaviour - use more simple functions: [[deflate]],\n\t * [[deflateRaw]] and [[gzip]].\n\t **/\n  \n\t/* internal\n\t * Deflate.chunks -> Array\n\t *\n\t * Chunks of output data, if [[Deflate#onData]] not overridden.\n\t **/\n  \n\t/**\n\t * Deflate.result -> Uint8Array\n\t *\n\t * Compressed result, generated by default [[Deflate#onData]]\n\t * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n\t * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n\t **/\n  \n\t/**\n\t * Deflate.err -> Number\n\t *\n\t * Error code after deflate finished. 0 (Z_OK) on success.\n\t * You will not need it in real life, because deflate errors\n\t * are possible only on wrong options or bad `onData` / `onEnd`\n\t * custom handlers.\n\t **/\n  \n\t/**\n\t * Deflate.msg -> String\n\t *\n\t * Error message, if [[Deflate.err]] != 0\n\t **/\n  \n  \n\t/**\n\t * new Deflate(options)\n\t * - options (Object): zlib deflate options.\n\t *\n\t * Creates new deflator instance with specified params. Throws exception\n\t * on bad params. Supported options:\n\t *\n\t * - `level`\n\t * - `windowBits`\n\t * - `memLevel`\n\t * - `strategy`\n\t * - `dictionary`\n\t *\n\t * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n\t * for more information on these.\n\t *\n\t * Additional options, for internal needs:\n\t *\n\t * - `chunkSize` - size of generated data chunks (16K by default)\n\t * - `raw` (Boolean) - do raw deflate\n\t * - `gzip` (Boolean) - create gzip wrapper\n\t * - `header` (Object) - custom header for gzip\n\t *   - `text` (Boolean) - true if compressed data believed to be text\n\t *   - `time` (Number) - modification time, unix timestamp\n\t *   - `os` (Number) - operation system code\n\t *   - `extra` (Array) - array of bytes with extra data (max 65536)\n\t *   - `name` (String) - file name (binary string)\n\t *   - `comment` (String) - comment (binary string)\n\t *   - `hcrc` (Boolean) - true if header crc should be added\n\t *\n\t * ##### Example:\n\t *\n\t * ```javascript\n\t * const pako = require('pako')\n\t *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n\t *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n\t *\n\t * const deflate = new pako.Deflate({ level: 3});\n\t *\n\t * deflate.push(chunk1, false);\n\t * deflate.push(chunk2, true);  // true -> last chunk\n\t *\n\t * if (deflate.err) { throw new Error(deflate.err); }\n\t *\n\t * console.log(deflate.result);\n\t * ```\n\t **/\n\tfunction Deflate$1(options) {\n\t  this.options = common.assign({\n\t\tlevel: Z_DEFAULT_COMPRESSION,\n\t\tmethod: Z_DEFLATED$1,\n\t\tchunkSize: 16384,\n\t\twindowBits: 15,\n\t\tmemLevel: 8,\n\t\tstrategy: Z_DEFAULT_STRATEGY\n\t  }, options || {});\n  \n\t  let opt = this.options;\n  \n\t  if (opt.raw && (opt.windowBits > 0)) {\n\t\topt.windowBits = -opt.windowBits;\n\t  }\n  \n\t  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n\t\topt.windowBits += 16;\n\t  }\n  \n\t  this.err    = 0;      // error code, if happens (0 = Z_OK)\n\t  this.msg    = '';     // error message\n\t  this.ended  = false;  // used to avoid multiple onEnd() calls\n\t  this.chunks = [];     // chunks of compressed data\n  \n\t  this.strm = new zstream();\n\t  this.strm.avail_out = 0;\n  \n\t  let status = deflate_1$2.deflateInit2(\n\t\tthis.strm,\n\t\topt.level,\n\t\topt.method,\n\t\topt.windowBits,\n\t\topt.memLevel,\n\t\topt.strategy\n\t  );\n  \n\t  if (status !== Z_OK$2) {\n\t\tthrow new Error(messages[status]);\n\t  }\n  \n\t  if (opt.header) {\n\t\tdeflate_1$2.deflateSetHeader(this.strm, opt.header);\n\t  }\n  \n\t  if (opt.dictionary) {\n\t\tlet dict;\n\t\t// Convert data if needed\n\t\tif (typeof opt.dictionary === 'string') {\n\t\t  // If we need to compress text, change encoding to utf8.\n\t\t  dict = strings.string2buf(opt.dictionary);\n\t\t} else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {\n\t\t  dict = new Uint8Array(opt.dictionary);\n\t\t} else {\n\t\t  dict = opt.dictionary;\n\t\t}\n  \n\t\tstatus = deflate_1$2.deflateSetDictionary(this.strm, dict);\n  \n\t\tif (status !== Z_OK$2) {\n\t\t  throw new Error(messages[status]);\n\t\t}\n  \n\t\tthis._dict_set = true;\n\t  }\n\t}\n  \n\t/**\n\t * Deflate#push(data[, flush_mode]) -> Boolean\n\t * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n\t *   converted to utf8 byte sequence.\n\t * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n\t *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n\t *\n\t * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n\t * new compressed chunks. Returns `true` on success. The last data block must\n\t * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n\t * buffers and call [[Deflate#onEnd]].\n\t *\n\t * On fail call [[Deflate#onEnd]] with error code and return false.\n\t *\n\t * ##### Example\n\t *\n\t * ```javascript\n\t * push(chunk, false); // push one of data chunks\n\t * ...\n\t * push(chunk, true);  // push last chunk\n\t * ```\n\t **/\n\tDeflate$1.prototype.push = function (data, flush_mode) {\n\t  const strm = this.strm;\n\t  const chunkSize = this.options.chunkSize;\n\t  let status, _flush_mode;\n  \n\t  if (this.ended) { return false; }\n  \n\t  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n\t  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;\n  \n\t  // Convert data if needed\n\t  if (typeof data === 'string') {\n\t\t// If we need to compress text, change encoding to utf8.\n\t\tstrm.input = strings.string2buf(data);\n\t  } else if (toString$1.call(data) === '[object ArrayBuffer]') {\n\t\tstrm.input = new Uint8Array(data);\n\t  } else {\n\t\tstrm.input = data;\n\t  }\n  \n\t  strm.next_in = 0;\n\t  strm.avail_in = strm.input.length;\n  \n\t  for (;;) {\n\t\tif (strm.avail_out === 0) {\n\t\t  strm.output = new Uint8Array(chunkSize);\n\t\t  strm.next_out = 0;\n\t\t  strm.avail_out = chunkSize;\n\t\t}\n  \n\t\t// Make sure avail_out > 6 to avoid repeating markers\n\t\tif ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {\n\t\t  this.onData(strm.output.subarray(0, strm.next_out));\n\t\t  strm.avail_out = 0;\n\t\t  continue;\n\t\t}\n  \n\t\tstatus = deflate_1$2.deflate(strm, _flush_mode);\n  \n\t\t// Ended => flush and finish\n\t\tif (status === Z_STREAM_END$2) {\n\t\t  if (strm.next_out > 0) {\n\t\t\tthis.onData(strm.output.subarray(0, strm.next_out));\n\t\t  }\n\t\t  status = deflate_1$2.deflateEnd(this.strm);\n\t\t  this.onEnd(status);\n\t\t  this.ended = true;\n\t\t  return status === Z_OK$2;\n\t\t}\n  \n\t\t// Flush if out buffer full\n\t\tif (strm.avail_out === 0) {\n\t\t  this.onData(strm.output);\n\t\t  continue;\n\t\t}\n  \n\t\t// Flush if requested and has data\n\t\tif (_flush_mode > 0 && strm.next_out > 0) {\n\t\t  this.onData(strm.output.subarray(0, strm.next_out));\n\t\t  strm.avail_out = 0;\n\t\t  continue;\n\t\t}\n  \n\t\tif (strm.avail_in === 0) break;\n\t  }\n  \n\t  return true;\n\t};\n  \n  \n\t/**\n\t * Deflate#onData(chunk) -> Void\n\t * - chunk (Uint8Array): output data.\n\t *\n\t * By default, stores data blocks in `chunks[]` property and glue\n\t * those in `onEnd`. Override this handler, if you need another behaviour.\n\t **/\n\tDeflate$1.prototype.onData = function (chunk) {\n\t  this.chunks.push(chunk);\n\t};\n  \n  \n\t/**\n\t * Deflate#onEnd(status) -> Void\n\t * - status (Number): deflate status. 0 (Z_OK) on success,\n\t *   other if not.\n\t *\n\t * Called once after you tell deflate that the input stream is\n\t * complete (Z_FINISH). By default - join collected chunks,\n\t * free memory and fill `results` / `err` properties.\n\t **/\n\tDeflate$1.prototype.onEnd = function (status) {\n\t  // On success - join\n\t  if (status === Z_OK$2) {\n\t\tthis.result = common.flattenChunks(this.chunks);\n\t  }\n\t  this.chunks = [];\n\t  this.err = status;\n\t  this.msg = this.strm.msg;\n\t};\n  \n  \n\t/**\n\t * deflate(data[, options]) -> Uint8Array\n\t * - data (Uint8Array|String): input data to compress.\n\t * - options (Object): zlib deflate options.\n\t *\n\t * Compress `data` with deflate algorithm and `options`.\n\t *\n\t * Supported options are:\n\t *\n\t * - level\n\t * - windowBits\n\t * - memLevel\n\t * - strategy\n\t * - dictionary\n\t *\n\t * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n\t * for more information on these.\n\t *\n\t * Sugar (options):\n\t *\n\t * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n\t *   negative windowBits implicitly.\n\t *\n\t * ##### Example:\n\t *\n\t * ```javascript\n\t * const pako = require('pako')\n\t * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);\n\t *\n\t * console.log(pako.deflate(data));\n\t * ```\n\t **/\n\tfunction deflate$1(input, options) {\n\t  const deflator = new Deflate$1(options);\n  \n\t  deflator.push(input, true);\n  \n\t  // That will never happens, if you don't cheat with options :)\n\t  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }\n  \n\t  return deflator.result;\n\t}\n  \n  \n\t/**\n\t * deflateRaw(data[, options]) -> Uint8Array\n\t * - data (Uint8Array|String): input data to compress.\n\t * - options (Object): zlib deflate options.\n\t *\n\t * The same as [[deflate]], but creates raw data, without wrapper\n\t * (header and adler32 crc).\n\t **/\n\tfunction deflateRaw$1(input, options) {\n\t  options = options || {};\n\t  options.raw = true;\n\t  return deflate$1(input, options);\n\t}\n  \n  \n\t/**\n\t * gzip(data[, options]) -> Uint8Array\n\t * - data (Uint8Array|String): input data to compress.\n\t * - options (Object): zlib deflate options.\n\t *\n\t * The same as [[deflate]], but create gzip wrapper instead of\n\t * deflate one.\n\t **/\n\tfunction gzip$1(input, options) {\n\t  options = options || {};\n\t  options.gzip = true;\n\t  return deflate$1(input, options);\n\t}\n  \n  \n\tvar Deflate_1$1 = Deflate$1;\n\tvar deflate_2 = deflate$1;\n\tvar deflateRaw_1$1 = deflateRaw$1;\n\tvar gzip_1$1 = gzip$1;\n\tvar constants$1 = constants$2;\n  \n\tvar deflate_1$1 = {\n\t\tDeflate: Deflate_1$1,\n\t\tdeflate: deflate_2,\n\t\tdeflateRaw: deflateRaw_1$1,\n\t\tgzip: gzip_1$1,\n\t\tconstants: constants$1\n\t};\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\t// See state defs from inflate.js\n\tconst BAD$1 = 30;       /* got a data error -- remain here until reset */\n\tconst TYPE$1 = 12;      /* i: waiting for type bits, including last-flag bit */\n  \n\t/*\n\t   Decode literal, length, and distance codes and write out the resulting\n\t   literal and match bytes until either not enough input or output is\n\t   available, an end-of-block is encountered, or a data error is encountered.\n\t   When large enough input and output buffers are supplied to inflate(), for\n\t   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n\t   inflate execution time is spent in this routine.\n  \n\t   Entry assumptions:\n  \n\t\t\tstate.mode === LEN\n\t\t\tstrm.avail_in >= 6\n\t\t\tstrm.avail_out >= 258\n\t\t\tstart >= strm.avail_out\n\t\t\tstate.bits < 8\n  \n\t   On return, state.mode is one of:\n  \n\t\t\tLEN -- ran out of enough output space or enough available input\n\t\t\tTYPE -- reached end of block code, inflate() to interpret next block\n\t\t\tBAD -- error in block data\n  \n\t   Notes:\n  \n\t\t- The maximum input bits used by a length/distance pair is 15 bits for the\n\t\t  length code, 5 bits for the length extra, 15 bits for the distance code,\n\t\t  and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n\t\t  Therefore if strm.avail_in >= 6, then there is enough input to avoid\n\t\t  checking for available input while decoding.\n  \n\t\t- The maximum bytes that a single length/distance pair can output is 258\n\t\t  bytes, which is the maximum length that can be coded.  inflate_fast()\n\t\t  requires strm.avail_out >= 258 for each loop to avoid checking for\n\t\t  output space.\n\t */\n\tvar inffast = function inflate_fast(strm, start) {\n\t  let _in;                    /* local strm.input */\n\t  let last;                   /* have enough input while in < last */\n\t  let _out;                   /* local strm.output */\n\t  let beg;                    /* inflate()'s initial strm.output */\n\t  let end;                    /* while out < end, enough space available */\n\t//#ifdef INFLATE_STRICT\n\t  let dmax;                   /* maximum distance from zlib header */\n\t//#endif\n\t  let wsize;                  /* window size or zero if not using window */\n\t  let whave;                  /* valid bytes in the window */\n\t  let wnext;                  /* window write index */\n\t  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n\t  let s_window;               /* allocated sliding window, if wsize != 0 */\n\t  let hold;                   /* local strm.hold */\n\t  let bits;                   /* local strm.bits */\n\t  let lcode;                  /* local strm.lencode */\n\t  let dcode;                  /* local strm.distcode */\n\t  let lmask;                  /* mask for first level of length codes */\n\t  let dmask;                  /* mask for first level of distance codes */\n\t  let here;                   /* retrieved table entry */\n\t  let op;                     /* code bits, operation, extra bits, or */\n\t\t\t\t\t\t\t\t  /*  window position, window bytes to copy */\n\t  let len;                    /* match length, unused bytes */\n\t  let dist;                   /* match distance */\n\t  let from;                   /* where to copy match from */\n\t  let from_source;\n  \n  \n\t  let input, output; // JS specific, because we have no pointers\n  \n\t  /* copy state to local variables */\n\t  const state = strm.state;\n\t  //here = state.here;\n\t  _in = strm.next_in;\n\t  input = strm.input;\n\t  last = _in + (strm.avail_in - 5);\n\t  _out = strm.next_out;\n\t  output = strm.output;\n\t  beg = _out - (start - strm.avail_out);\n\t  end = _out + (strm.avail_out - 257);\n\t//#ifdef INFLATE_STRICT\n\t  dmax = state.dmax;\n\t//#endif\n\t  wsize = state.wsize;\n\t  whave = state.whave;\n\t  wnext = state.wnext;\n\t  s_window = state.window;\n\t  hold = state.hold;\n\t  bits = state.bits;\n\t  lcode = state.lencode;\n\t  dcode = state.distcode;\n\t  lmask = (1 << state.lenbits) - 1;\n\t  dmask = (1 << state.distbits) - 1;\n  \n  \n\t  /* decode literals and length/distances until end-of-block or not enough\n\t\t input data or output space */\n  \n\t  top:\n\t  do {\n\t\tif (bits < 15) {\n\t\t  hold += input[_in++] << bits;\n\t\t  bits += 8;\n\t\t  hold += input[_in++] << bits;\n\t\t  bits += 8;\n\t\t}\n  \n\t\there = lcode[hold & lmask];\n  \n\t\tdolen:\n\t\tfor (;;) { // Goto emulation\n\t\t  op = here >>> 24/*here.bits*/;\n\t\t  hold >>>= op;\n\t\t  bits -= op;\n\t\t  op = (here >>> 16) & 0xff/*here.op*/;\n\t\t  if (op === 0) {                          /* literal */\n\t\t\t//Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n\t\t\t//        \"inflate:         literal '%c'\\n\" :\n\t\t\t//        \"inflate:         literal 0x%02x\\n\", here.val));\n\t\t\toutput[_out++] = here & 0xffff/*here.val*/;\n\t\t  }\n\t\t  else if (op & 16) {                     /* length base */\n\t\t\tlen = here & 0xffff/*here.val*/;\n\t\t\top &= 15;                           /* number of extra bits */\n\t\t\tif (op) {\n\t\t\t  if (bits < op) {\n\t\t\t\thold += input[_in++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t  }\n\t\t\t  len += hold & ((1 << op) - 1);\n\t\t\t  hold >>>= op;\n\t\t\t  bits -= op;\n\t\t\t}\n\t\t\t//Tracevv((stderr, \"inflate:         length %u\\n\", len));\n\t\t\tif (bits < 15) {\n\t\t\t  hold += input[_in++] << bits;\n\t\t\t  bits += 8;\n\t\t\t  hold += input[_in++] << bits;\n\t\t\t  bits += 8;\n\t\t\t}\n\t\t\there = dcode[hold & dmask];\n  \n\t\t\tdodist:\n\t\t\tfor (;;) { // goto emulation\n\t\t\t  op = here >>> 24/*here.bits*/;\n\t\t\t  hold >>>= op;\n\t\t\t  bits -= op;\n\t\t\t  op = (here >>> 16) & 0xff/*here.op*/;\n  \n\t\t\t  if (op & 16) {                      /* distance base */\n\t\t\t\tdist = here & 0xffff/*here.val*/;\n\t\t\t\top &= 15;                       /* number of extra bits */\n\t\t\t\tif (bits < op) {\n\t\t\t\t  hold += input[_in++] << bits;\n\t\t\t\t  bits += 8;\n\t\t\t\t  if (bits < op) {\n\t\t\t\t\thold += input[_in++] << bits;\n\t\t\t\t\tbits += 8;\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t\tdist += hold & ((1 << op) - 1);\n\t//#ifdef INFLATE_STRICT\n\t\t\t\tif (dist > dmax) {\n\t\t\t\t  strm.msg = 'invalid distance too far back';\n\t\t\t\t  state.mode = BAD$1;\n\t\t\t\t  break top;\n\t\t\t\t}\n\t//#endif\n\t\t\t\thold >>>= op;\n\t\t\t\tbits -= op;\n\t\t\t\t//Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n\t\t\t\top = _out - beg;                /* max distance in output */\n\t\t\t\tif (dist > op) {                /* see if copy from window */\n\t\t\t\t  op = dist - op;               /* distance back in window */\n\t\t\t\t  if (op > whave) {\n\t\t\t\t\tif (state.sane) {\n\t\t\t\t\t  strm.msg = 'invalid distance too far back';\n\t\t\t\t\t  state.mode = BAD$1;\n\t\t\t\t\t  break top;\n\t\t\t\t\t}\n  \n\t// (!) This block is disabled in zlib defaults,\n\t// don't enable it for binary compatibility\n\t//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n\t//                if (len <= op - whave) {\n\t//                  do {\n\t//                    output[_out++] = 0;\n\t//                  } while (--len);\n\t//                  continue top;\n\t//                }\n\t//                len -= op - whave;\n\t//                do {\n\t//                  output[_out++] = 0;\n\t//                } while (--op > whave);\n\t//                if (op === 0) {\n\t//                  from = _out - dist;\n\t//                  do {\n\t//                    output[_out++] = output[from++];\n\t//                  } while (--len);\n\t//                  continue top;\n\t//                }\n\t//#endif\n\t\t\t\t  }\n\t\t\t\t  from = 0; // window index\n\t\t\t\t  from_source = s_window;\n\t\t\t\t  if (wnext === 0) {           /* very common case */\n\t\t\t\t\tfrom += wsize - op;\n\t\t\t\t\tif (op < len) {         /* some from window */\n\t\t\t\t\t  len -= op;\n\t\t\t\t\t  do {\n\t\t\t\t\t\toutput[_out++] = s_window[from++];\n\t\t\t\t\t  } while (--op);\n\t\t\t\t\t  from = _out - dist;  /* rest from output */\n\t\t\t\t\t  from_source = output;\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t  else if (wnext < op) {      /* wrap around window */\n\t\t\t\t\tfrom += wsize + wnext - op;\n\t\t\t\t\top -= wnext;\n\t\t\t\t\tif (op < len) {         /* some from end of window */\n\t\t\t\t\t  len -= op;\n\t\t\t\t\t  do {\n\t\t\t\t\t\toutput[_out++] = s_window[from++];\n\t\t\t\t\t  } while (--op);\n\t\t\t\t\t  from = 0;\n\t\t\t\t\t  if (wnext < len) {  /* some from start of window */\n\t\t\t\t\t\top = wnext;\n\t\t\t\t\t\tlen -= op;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t  output[_out++] = s_window[from++];\n\t\t\t\t\t\t} while (--op);\n\t\t\t\t\t\tfrom = _out - dist;      /* rest from output */\n\t\t\t\t\t\tfrom_source = output;\n\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t  else {                      /* contiguous in window */\n\t\t\t\t\tfrom += wnext - op;\n\t\t\t\t\tif (op < len) {         /* some from window */\n\t\t\t\t\t  len -= op;\n\t\t\t\t\t  do {\n\t\t\t\t\t\toutput[_out++] = s_window[from++];\n\t\t\t\t\t  } while (--op);\n\t\t\t\t\t  from = _out - dist;  /* rest from output */\n\t\t\t\t\t  from_source = output;\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t  while (len > 2) {\n\t\t\t\t\toutput[_out++] = from_source[from++];\n\t\t\t\t\toutput[_out++] = from_source[from++];\n\t\t\t\t\toutput[_out++] = from_source[from++];\n\t\t\t\t\tlen -= 3;\n\t\t\t\t  }\n\t\t\t\t  if (len) {\n\t\t\t\t\toutput[_out++] = from_source[from++];\n\t\t\t\t\tif (len > 1) {\n\t\t\t\t\t  output[_out++] = from_source[from++];\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t  from = _out - dist;          /* copy direct from output */\n\t\t\t\t  do {                        /* minimum length is three */\n\t\t\t\t\toutput[_out++] = output[from++];\n\t\t\t\t\toutput[_out++] = output[from++];\n\t\t\t\t\toutput[_out++] = output[from++];\n\t\t\t\t\tlen -= 3;\n\t\t\t\t  } while (len > 2);\n\t\t\t\t  if (len) {\n\t\t\t\t\toutput[_out++] = output[from++];\n\t\t\t\t\tif (len > 1) {\n\t\t\t\t\t  output[_out++] = output[from++];\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t  }\n\t\t\t  else if ((op & 64) === 0) {          /* 2nd level distance code */\n\t\t\t\there = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n\t\t\t\tcontinue dodist;\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\tstrm.msg = 'invalid distance code';\n\t\t\t\tstate.mode = BAD$1;\n\t\t\t\tbreak top;\n\t\t\t  }\n  \n\t\t\t  break; // need to emulate goto via \"continue\"\n\t\t\t}\n\t\t  }\n\t\t  else if ((op & 64) === 0) {              /* 2nd level length code */\n\t\t\there = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n\t\t\tcontinue dolen;\n\t\t  }\n\t\t  else if (op & 32) {                     /* end-of-block */\n\t\t\t//Tracevv((stderr, \"inflate:         end of block\\n\"));\n\t\t\tstate.mode = TYPE$1;\n\t\t\tbreak top;\n\t\t  }\n\t\t  else {\n\t\t\tstrm.msg = 'invalid literal/length code';\n\t\t\tstate.mode = BAD$1;\n\t\t\tbreak top;\n\t\t  }\n  \n\t\t  break; // need to emulate goto via \"continue\"\n\t\t}\n\t  } while (_in < last && _out < end);\n  \n\t  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n\t  len = bits >> 3;\n\t  _in -= len;\n\t  bits -= len << 3;\n\t  hold &= (1 << bits) - 1;\n  \n\t  /* update state and return */\n\t  strm.next_in = _in;\n\t  strm.next_out = _out;\n\t  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n\t  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n\t  state.hold = hold;\n\t  state.bits = bits;\n\t  return;\n\t};\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\tconst MAXBITS = 15;\n\tconst ENOUGH_LENS$1 = 852;\n\tconst ENOUGH_DISTS$1 = 592;\n\t//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n  \n\tconst CODES$1 = 0;\n\tconst LENS$1 = 1;\n\tconst DISTS$1 = 2;\n  \n\tconst lbase = new Uint16Array([ /* Length codes 257..285 base */\n\t  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n\t  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n\t]);\n  \n\tconst lext = new Uint8Array([ /* Length codes 257..285 extra */\n\t  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n\t  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n\t]);\n  \n\tconst dbase = new Uint16Array([ /* Distance codes 0..29 base */\n\t  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n\t  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n\t  8193, 12289, 16385, 24577, 0, 0\n\t]);\n  \n\tconst dext = new Uint8Array([ /* Distance codes 0..29 extra */\n\t  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n\t  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n\t  28, 28, 29, 29, 64, 64\n\t]);\n  \n\tconst inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>\n\t{\n\t  const bits = opts.bits;\n\t\t  //here = opts.here; /* table entry for duplication */\n  \n\t  let len = 0;               /* a code's length in bits */\n\t  let sym = 0;               /* index of code symbols */\n\t  let min = 0, max = 0;          /* minimum and maximum code lengths */\n\t  let root = 0;              /* number of index bits for root table */\n\t  let curr = 0;              /* number of index bits for current table */\n\t  let drop = 0;              /* code bits to drop for sub-table */\n\t  let left = 0;                   /* number of prefix codes available */\n\t  let used = 0;              /* code entries in table used */\n\t  let huff = 0;              /* Huffman code */\n\t  let incr;              /* for incrementing code, index */\n\t  let fill;              /* index for replicating entries */\n\t  let low;               /* low bits for current root entry */\n\t  let mask;              /* mask for low root bits */\n\t  let next;             /* next available space in table */\n\t  let base = null;     /* base value table to use */\n\t  let base_index = 0;\n\t//  let shoextra;    /* extra bits table to use */\n\t  let end;                    /* use base and extra for symbol > end */\n\t  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n\t  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n\t  let extra = null;\n\t  let extra_index = 0;\n  \n\t  let here_bits, here_op, here_val;\n  \n\t  /*\n\t   Process a set of code lengths to create a canonical Huffman code.  The\n\t   code lengths are lens[0..codes-1].  Each length corresponds to the\n\t   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n\t   symbols by length from short to long, and retaining the symbol order\n\t   for codes with equal lengths.  Then the code starts with all zero bits\n\t   for the first code of the shortest length, and the codes are integer\n\t   increments for the same length, and zeros are appended as the length\n\t   increases.  For the deflate format, these bits are stored backwards\n\t   from their more natural integer increment ordering, and so when the\n\t   decoding tables are built in the large loop below, the integer codes\n\t   are incremented backwards.\n  \n\t   This routine assumes, but does not check, that all of the entries in\n\t   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n\t   1..MAXBITS is interpreted as that code length.  zero means that that\n\t   symbol does not occur in this code.\n  \n\t   The codes are sorted by computing a count of codes for each length,\n\t   creating from that a table of starting indices for each length in the\n\t   sorted table, and then entering the symbols in order in the sorted\n\t   table.  The sorted table is work[], with that space being provided by\n\t   the caller.\n  \n\t   The length counts are used for other purposes as well, i.e. finding\n\t   the minimum and maximum length codes, determining if there are any\n\t   codes at all, checking for a valid set of lengths, and looking ahead\n\t   at length counts to determine sub-table sizes when building the\n\t   decoding tables.\n\t   */\n  \n\t  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n\t  for (len = 0; len <= MAXBITS; len++) {\n\t\tcount[len] = 0;\n\t  }\n\t  for (sym = 0; sym < codes; sym++) {\n\t\tcount[lens[lens_index + sym]]++;\n\t  }\n  \n\t  /* bound code lengths, force root to be within code lengths */\n\t  root = bits;\n\t  for (max = MAXBITS; max >= 1; max--) {\n\t\tif (count[max] !== 0) { break; }\n\t  }\n\t  if (root > max) {\n\t\troot = max;\n\t  }\n\t  if (max === 0) {                     /* no symbols to code at all */\n\t\t//table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n\t\t//table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n\t\t//table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n\t\ttable[table_index++] = (1 << 24) | (64 << 16) | 0;\n  \n  \n\t\t//table.op[opts.table_index] = 64;\n\t\t//table.bits[opts.table_index] = 1;\n\t\t//table.val[opts.table_index++] = 0;\n\t\ttable[table_index++] = (1 << 24) | (64 << 16) | 0;\n  \n\t\topts.bits = 1;\n\t\treturn 0;     /* no symbols, but wait for decoding to report error */\n\t  }\n\t  for (min = 1; min < max; min++) {\n\t\tif (count[min] !== 0) { break; }\n\t  }\n\t  if (root < min) {\n\t\troot = min;\n\t  }\n  \n\t  /* check for an over-subscribed or incomplete set of lengths */\n\t  left = 1;\n\t  for (len = 1; len <= MAXBITS; len++) {\n\t\tleft <<= 1;\n\t\tleft -= count[len];\n\t\tif (left < 0) {\n\t\t  return -1;\n\t\t}        /* over-subscribed */\n\t  }\n\t  if (left > 0 && (type === CODES$1 || max !== 1)) {\n\t\treturn -1;                      /* incomplete set */\n\t  }\n  \n\t  /* generate offsets into symbol table for each length for sorting */\n\t  offs[1] = 0;\n\t  for (len = 1; len < MAXBITS; len++) {\n\t\toffs[len + 1] = offs[len] + count[len];\n\t  }\n  \n\t  /* sort symbols by length, by symbol order within each length */\n\t  for (sym = 0; sym < codes; sym++) {\n\t\tif (lens[lens_index + sym] !== 0) {\n\t\t  work[offs[lens[lens_index + sym]]++] = sym;\n\t\t}\n\t  }\n  \n\t  /*\n\t   Create and fill in decoding tables.  In this loop, the table being\n\t   filled is at next and has curr index bits.  The code being used is huff\n\t   with length len.  That code is converted to an index by dropping drop\n\t   bits off of the bottom.  For codes where len is less than drop + curr,\n\t   those top drop + curr - len bits are incremented through all values to\n\t   fill the table with replicated entries.\n  \n\t   root is the number of index bits for the root table.  When len exceeds\n\t   root, sub-tables are created pointed to by the root entry with an index\n\t   of the low root bits of huff.  This is saved in low to check for when a\n\t   new sub-table should be started.  drop is zero when the root table is\n\t   being filled, and drop is root when sub-tables are being filled.\n  \n\t   When a new sub-table is needed, it is necessary to look ahead in the\n\t   code lengths to determine what size sub-table is needed.  The length\n\t   counts are used for this, and so count[] is decremented as codes are\n\t   entered in the tables.\n  \n\t   used keeps track of how many table entries have been allocated from the\n\t   provided *table space.  It is checked for LENS and DIST tables against\n\t   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n\t   the initial root table size constants.  See the comments in inftrees.h\n\t   for more information.\n  \n\t   sym increments through all symbols, and the loop terminates when\n\t   all codes of length max, i.e. all codes, have been processed.  This\n\t   routine permits incomplete codes, so another loop after this one fills\n\t   in the rest of the decoding tables with invalid code markers.\n\t   */\n  \n\t  /* set up for code type */\n\t  // poor man optimization - use if-else instead of switch,\n\t  // to avoid deopts in old v8\n\t  if (type === CODES$1) {\n\t\tbase = extra = work;    /* dummy value--not used */\n\t\tend = 19;\n  \n\t  } else if (type === LENS$1) {\n\t\tbase = lbase;\n\t\tbase_index -= 257;\n\t\textra = lext;\n\t\textra_index -= 257;\n\t\tend = 256;\n  \n\t  } else {                    /* DISTS */\n\t\tbase = dbase;\n\t\textra = dext;\n\t\tend = -1;\n\t  }\n  \n\t  /* initialize opts for loop */\n\t  huff = 0;                   /* starting code */\n\t  sym = 0;                    /* starting code symbol */\n\t  len = min;                  /* starting code length */\n\t  next = table_index;              /* current table to fill in */\n\t  curr = root;                /* current table index bits */\n\t  drop = 0;                   /* current bits to drop from code for index */\n\t  low = -1;                   /* trigger new sub-table when len > root */\n\t  used = 1 << root;          /* use root table entries */\n\t  mask = used - 1;            /* mask for comparing low */\n  \n\t  /* check available table space */\n\t  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||\n\t\t(type === DISTS$1 && used > ENOUGH_DISTS$1)) {\n\t\treturn 1;\n\t  }\n  \n\t  /* process all codes and make table entries */\n\t  for (;;) {\n\t\t/* create table entry */\n\t\there_bits = len - drop;\n\t\tif (work[sym] < end) {\n\t\t  here_op = 0;\n\t\t  here_val = work[sym];\n\t\t}\n\t\telse if (work[sym] > end) {\n\t\t  here_op = extra[extra_index + work[sym]];\n\t\t  here_val = base[base_index + work[sym]];\n\t\t}\n\t\telse {\n\t\t  here_op = 32 + 64;         /* end of block */\n\t\t  here_val = 0;\n\t\t}\n  \n\t\t/* replicate for those indices with low len bits equal to huff */\n\t\tincr = 1 << (len - drop);\n\t\tfill = 1 << curr;\n\t\tmin = fill;                 /* save offset to next table */\n\t\tdo {\n\t\t  fill -= incr;\n\t\t  table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n\t\t} while (fill !== 0);\n  \n\t\t/* backwards increment the len-bit code huff */\n\t\tincr = 1 << (len - 1);\n\t\twhile (huff & incr) {\n\t\t  incr >>= 1;\n\t\t}\n\t\tif (incr !== 0) {\n\t\t  huff &= incr - 1;\n\t\t  huff += incr;\n\t\t} else {\n\t\t  huff = 0;\n\t\t}\n  \n\t\t/* go to next symbol, update count, len */\n\t\tsym++;\n\t\tif (--count[len] === 0) {\n\t\t  if (len === max) { break; }\n\t\t  len = lens[lens_index + work[sym]];\n\t\t}\n  \n\t\t/* create new sub-table if needed */\n\t\tif (len > root && (huff & mask) !== low) {\n\t\t  /* if first time, transition to sub-tables */\n\t\t  if (drop === 0) {\n\t\t\tdrop = root;\n\t\t  }\n  \n\t\t  /* increment past last table */\n\t\t  next += min;            /* here min is 1 << curr */\n  \n\t\t  /* determine length of next table */\n\t\t  curr = len - drop;\n\t\t  left = 1 << curr;\n\t\t  while (curr + drop < max) {\n\t\t\tleft -= count[curr + drop];\n\t\t\tif (left <= 0) { break; }\n\t\t\tcurr++;\n\t\t\tleft <<= 1;\n\t\t  }\n  \n\t\t  /* check for enough space */\n\t\t  used += 1 << curr;\n\t\t  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||\n\t\t\t(type === DISTS$1 && used > ENOUGH_DISTS$1)) {\n\t\t\treturn 1;\n\t\t  }\n  \n\t\t  /* point entry in root table to sub-table */\n\t\t  low = huff & mask;\n\t\t  /*table.op[low] = curr;\n\t\t  table.bits[low] = root;\n\t\t  table.val[low] = next - opts.table_index;*/\n\t\t  table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n\t\t}\n\t  }\n  \n\t  /* fill in remaining table entry if code is incomplete (guaranteed to have\n\t   at most one remaining entry, since if the code is incomplete, the\n\t   maximum code length that was allowed to get this far is one bit) */\n\t  if (huff !== 0) {\n\t\t//table.op[next + huff] = 64;            /* invalid code marker */\n\t\t//table.bits[next + huff] = len - drop;\n\t\t//table.val[next + huff] = 0;\n\t\ttable[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n\t  }\n  \n\t  /* set return parameters */\n\t  //opts.table_index += used;\n\t  opts.bits = root;\n\t  return 0;\n\t};\n  \n  \n\tvar inftrees = inflate_table;\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n  \n  \n  \n  \n  \n\tconst CODES = 0;\n\tconst LENS = 1;\n\tconst DISTS = 2;\n  \n\t/* Public constants ==========================================================*/\n\t/* ===========================================================================*/\n  \n\tconst {\n\t  Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,\n\t  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,\n\t  Z_DEFLATED\n\t} = constants$2;\n  \n  \n\t/* STATES ====================================================================*/\n\t/* ===========================================================================*/\n  \n  \n\tconst    HEAD = 1;       /* i: waiting for magic header */\n\tconst    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\n\tconst    TIME = 3;       /* i: waiting for modification time (gzip) */\n\tconst    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\n\tconst    EXLEN = 5;      /* i: waiting for extra length (gzip) */\n\tconst    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\n\tconst    NAME = 7;       /* i: waiting for end of file name (gzip) */\n\tconst    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\n\tconst    HCRC = 9;       /* i: waiting for header crc (gzip) */\n\tconst    DICTID = 10;    /* i: waiting for dictionary check value */\n\tconst    DICT = 11;      /* waiting for inflateSetDictionary() call */\n\tconst        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\tconst        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\n\tconst        STORED = 14;    /* i: waiting for stored size (length and complement) */\n\tconst        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\n\tconst        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\n\tconst        TABLE = 17;     /* i: waiting for dynamic block table lengths */\n\tconst        LENLENS = 18;   /* i: waiting for code length code lengths */\n\tconst        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\n\tconst            LEN_ = 20;      /* i: same as LEN below, but only first time in */\n\tconst            LEN = 21;       /* i: waiting for length/lit/eob code */\n\tconst            LENEXT = 22;    /* i: waiting for length extra bits */\n\tconst            DIST = 23;      /* i: waiting for distance code */\n\tconst            DISTEXT = 24;   /* i: waiting for distance extra bits */\n\tconst            MATCH = 25;     /* o: waiting for output space to copy string */\n\tconst            LIT = 26;       /* o: waiting for output space to write literal */\n\tconst    CHECK = 27;     /* i: waiting for 32-bit check value */\n\tconst    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\n\tconst    DONE = 29;      /* finished check, done -- remain here until reset */\n\tconst    BAD = 30;       /* got a data error -- remain here until reset */\n\tconst    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\n\tconst    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n  \n\t/* ===========================================================================*/\n  \n  \n  \n\tconst ENOUGH_LENS = 852;\n\tconst ENOUGH_DISTS = 592;\n\t//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n  \n\tconst MAX_WBITS = 15;\n\t/* 32K LZ77 window */\n\tconst DEF_WBITS = MAX_WBITS;\n  \n  \n\tconst zswap32 = (q) => {\n  \n\t  return  (((q >>> 24) & 0xff) +\n\t\t\t  ((q >>> 8) & 0xff00) +\n\t\t\t  ((q & 0xff00) << 8) +\n\t\t\t  ((q & 0xff) << 24));\n\t};\n  \n  \n\tfunction InflateState() {\n\t  this.mode = 0;             /* current inflate mode */\n\t  this.last = false;          /* true if processing last block */\n\t  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n\t  this.havedict = false;      /* true if dictionary provided */\n\t  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n\t  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n\t  this.check = 0;             /* protected copy of check value */\n\t  this.total = 0;             /* protected copy of output count */\n\t  // TODO: may be {}\n\t  this.head = null;           /* where to save gzip header information */\n  \n\t  /* sliding window */\n\t  this.wbits = 0;             /* log base 2 of requested window size */\n\t  this.wsize = 0;             /* window size or zero if not using window */\n\t  this.whave = 0;             /* valid bytes in the window */\n\t  this.wnext = 0;             /* window write index */\n\t  this.window = null;         /* allocated sliding window, if needed */\n  \n\t  /* bit accumulator */\n\t  this.hold = 0;              /* input bit accumulator */\n\t  this.bits = 0;              /* number of bits in \"in\" */\n  \n\t  /* for string and stored block copying */\n\t  this.length = 0;            /* literal or length of data to copy */\n\t  this.offset = 0;            /* distance back to copy string from */\n  \n\t  /* for table and code decoding */\n\t  this.extra = 0;             /* extra bits needed */\n  \n\t  /* fixed and dynamic code tables */\n\t  this.lencode = null;          /* starting table for length/literal codes */\n\t  this.distcode = null;         /* starting table for distance codes */\n\t  this.lenbits = 0;           /* index bits for lencode */\n\t  this.distbits = 0;          /* index bits for distcode */\n  \n\t  /* dynamic table building */\n\t  this.ncode = 0;             /* number of code length code lengths */\n\t  this.nlen = 0;              /* number of length code lengths */\n\t  this.ndist = 0;             /* number of distance code lengths */\n\t  this.have = 0;              /* number of code lengths in lens[] */\n\t  this.next = null;              /* next available space in codes[] */\n  \n\t  this.lens = new Uint16Array(320); /* temporary storage for code lengths */\n\t  this.work = new Uint16Array(288); /* work area for code table building */\n  \n\t  /*\n\t   because we don't have pointers in js, we use lencode and distcode directly\n\t   as buffers so we don't need codes\n\t  */\n\t  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */\n\t  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n\t  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n\t  this.sane = 0;                   /* if false, allow invalid distance too far */\n\t  this.back = 0;                   /* bits back of last unprocessed length/lit */\n\t  this.was = 0;                    /* initial length of match */\n\t}\n  \n  \n\tconst inflateResetKeep = (strm) => {\n  \n\t  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }\n\t  const state = strm.state;\n\t  strm.total_in = strm.total_out = state.total = 0;\n\t  strm.msg = ''; /*Z_NULL*/\n\t  if (state.wrap) {       /* to support ill-conceived Java test suite */\n\t\tstrm.adler = state.wrap & 1;\n\t  }\n\t  state.mode = HEAD;\n\t  state.last = 0;\n\t  state.havedict = 0;\n\t  state.dmax = 32768;\n\t  state.head = null/*Z_NULL*/;\n\t  state.hold = 0;\n\t  state.bits = 0;\n\t  //state.lencode = state.distcode = state.next = state.codes;\n\t  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);\n\t  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);\n  \n\t  state.sane = 1;\n\t  state.back = -1;\n\t  //Tracev((stderr, \"inflate: reset\\n\"));\n\t  return Z_OK$1;\n\t};\n  \n  \n\tconst inflateReset = (strm) => {\n  \n\t  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }\n\t  const state = strm.state;\n\t  state.wsize = 0;\n\t  state.whave = 0;\n\t  state.wnext = 0;\n\t  return inflateResetKeep(strm);\n  \n\t};\n  \n  \n\tconst inflateReset2 = (strm, windowBits) => {\n\t  let wrap;\n  \n\t  /* get the state */\n\t  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }\n\t  const state = strm.state;\n  \n\t  /* extract wrap request from windowBits parameter */\n\t  if (windowBits < 0) {\n\t\twrap = 0;\n\t\twindowBits = -windowBits;\n\t  }\n\t  else {\n\t\twrap = (windowBits >> 4) + 1;\n\t\tif (windowBits < 48) {\n\t\t  windowBits &= 15;\n\t\t}\n\t  }\n  \n\t  /* set number of window bits, free window if different */\n\t  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n\t\treturn Z_STREAM_ERROR$1;\n\t  }\n\t  if (state.window !== null && state.wbits !== windowBits) {\n\t\tstate.window = null;\n\t  }\n  \n\t  /* update state and reset the rest of it */\n\t  state.wrap = wrap;\n\t  state.wbits = windowBits;\n\t  return inflateReset(strm);\n\t};\n  \n  \n\tconst inflateInit2 = (strm, windowBits) => {\n  \n\t  if (!strm) { return Z_STREAM_ERROR$1; }\n\t  //strm.msg = Z_NULL;                 /* in case we return an error */\n  \n\t  const state = new InflateState();\n  \n\t  //if (state === Z_NULL) return Z_MEM_ERROR;\n\t  //Tracev((stderr, \"inflate: allocated\\n\"));\n\t  strm.state = state;\n\t  state.window = null/*Z_NULL*/;\n\t  const ret = inflateReset2(strm, windowBits);\n\t  if (ret !== Z_OK$1) {\n\t\tstrm.state = null/*Z_NULL*/;\n\t  }\n\t  return ret;\n\t};\n  \n  \n\tconst inflateInit = (strm) => {\n  \n\t  return inflateInit2(strm, DEF_WBITS);\n\t};\n  \n  \n\t/*\n\t Return state with length and distance decoding tables and index sizes set to\n\t fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n\t If BUILDFIXED is defined, then instead this routine builds the tables the\n\t first time it's called, and returns those tables the first time and\n\t thereafter.  This reduces the size of the code by about 2K bytes, in\n\t exchange for a little execution time.  However, BUILDFIXED should not be\n\t used for threaded applications, since the rewriting of the tables and virgin\n\t may not be thread-safe.\n\t */\n\tlet virgin = true;\n  \n\tlet lenfix, distfix; // We have no pointers in JS, so keep tables separate\n  \n  \n\tconst fixedtables = (state) => {\n  \n\t  /* build fixed huffman tables if first call (may not be thread safe) */\n\t  if (virgin) {\n\t\tlenfix = new Int32Array(512);\n\t\tdistfix = new Int32Array(32);\n  \n\t\t/* literal/length table */\n\t\tlet sym = 0;\n\t\twhile (sym < 144) { state.lens[sym++] = 8; }\n\t\twhile (sym < 256) { state.lens[sym++] = 9; }\n\t\twhile (sym < 280) { state.lens[sym++] = 7; }\n\t\twhile (sym < 288) { state.lens[sym++] = 8; }\n  \n\t\tinftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n  \n\t\t/* distance table */\n\t\tsym = 0;\n\t\twhile (sym < 32) { state.lens[sym++] = 5; }\n  \n\t\tinftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n  \n\t\t/* do this just once */\n\t\tvirgin = false;\n\t  }\n  \n\t  state.lencode = lenfix;\n\t  state.lenbits = 9;\n\t  state.distcode = distfix;\n\t  state.distbits = 5;\n\t};\n  \n  \n\t/*\n\t Update the window with the last wsize (normally 32K) bytes written before\n\t returning.  If window does not exist yet, create it.  This is only called\n\t when a window is already in use, or when output has been written during this\n\t inflate call, but the end of the deflate stream has not been reached yet.\n\t It is also called to create a window for dictionary data when a dictionary\n\t is loaded.\n  \n\t Providing output buffers larger than 32K to inflate() should provide a speed\n\t advantage, since only the last 32K of output is copied to the sliding window\n\t upon return from inflate(), and since all distances after the first 32K of\n\t output will fall in the output data, making match copies simpler and faster.\n\t The advantage may be dependent on the size of the processor's data caches.\n\t */\n\tconst updatewindow = (strm, src, end, copy) => {\n  \n\t  let dist;\n\t  const state = strm.state;\n  \n\t  /* if it hasn't been done already, allocate space for the window */\n\t  if (state.window === null) {\n\t\tstate.wsize = 1 << state.wbits;\n\t\tstate.wnext = 0;\n\t\tstate.whave = 0;\n  \n\t\tstate.window = new Uint8Array(state.wsize);\n\t  }\n  \n\t  /* copy state->wsize or less output bytes into the circular window */\n\t  if (copy >= state.wsize) {\n\t\tstate.window.set(src.subarray(end - state.wsize, end), 0);\n\t\tstate.wnext = 0;\n\t\tstate.whave = state.wsize;\n\t  }\n\t  else {\n\t\tdist = state.wsize - state.wnext;\n\t\tif (dist > copy) {\n\t\t  dist = copy;\n\t\t}\n\t\t//zmemcpy(state->window + state->wnext, end - copy, dist);\n\t\tstate.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);\n\t\tcopy -= dist;\n\t\tif (copy) {\n\t\t  //zmemcpy(state->window, end - copy, copy);\n\t\t  state.window.set(src.subarray(end - copy, end), 0);\n\t\t  state.wnext = copy;\n\t\t  state.whave = state.wsize;\n\t\t}\n\t\telse {\n\t\t  state.wnext += dist;\n\t\t  if (state.wnext === state.wsize) { state.wnext = 0; }\n\t\t  if (state.whave < state.wsize) { state.whave += dist; }\n\t\t}\n\t  }\n\t  return 0;\n\t};\n  \n  \n\tconst inflate$2 = (strm, flush) => {\n  \n\t  let state;\n\t  let input, output;          // input/output buffers\n\t  let next;                   /* next input INDEX */\n\t  let put;                    /* next output INDEX */\n\t  let have, left;             /* available input and output */\n\t  let hold;                   /* bit buffer */\n\t  let bits;                   /* bits in bit buffer */\n\t  let _in, _out;              /* save starting available input and output */\n\t  let copy;                   /* number of stored or match bytes to copy */\n\t  let from;                   /* where to copy match bytes from */\n\t  let from_source;\n\t  let here = 0;               /* current decoding table entry */\n\t  let here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n\t  //let last;                   /* parent table entry */\n\t  let last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n\t  let len;                    /* length to copy for repeats, bits to drop */\n\t  let ret;                    /* return code */\n\t  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */\n\t  let opts;\n  \n\t  let n; // temporary variable for NEED_BITS\n  \n\t  const order = /* permutation of code lengths */\n\t\tnew Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);\n  \n  \n\t  if (!strm || !strm.state || !strm.output ||\n\t\t  (!strm.input && strm.avail_in !== 0)) {\n\t\treturn Z_STREAM_ERROR$1;\n\t  }\n  \n\t  state = strm.state;\n\t  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n  \n  \n\t  //--- LOAD() ---\n\t  put = strm.next_out;\n\t  output = strm.output;\n\t  left = strm.avail_out;\n\t  next = strm.next_in;\n\t  input = strm.input;\n\t  have = strm.avail_in;\n\t  hold = state.hold;\n\t  bits = state.bits;\n\t  //---\n  \n\t  _in = have;\n\t  _out = left;\n\t  ret = Z_OK$1;\n  \n\t  inf_leave: // goto emulation\n\t  for (;;) {\n\t\tswitch (state.mode) {\n\t\t  case HEAD:\n\t\t\tif (state.wrap === 0) {\n\t\t\t  state.mode = TYPEDO;\n\t\t\t  break;\n\t\t\t}\n\t\t\t//=== NEEDBITS(16);\n\t\t\twhile (bits < 16) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t}\n\t\t\t//===//\n\t\t\tif ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n\t\t\t  state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n\t\t\t  //=== CRC2(state.check, hold);\n\t\t\t  hbuf[0] = hold & 0xff;\n\t\t\t  hbuf[1] = (hold >>> 8) & 0xff;\n\t\t\t  state.check = crc32_1(state.check, hbuf, 2, 0);\n\t\t\t  //===//\n  \n\t\t\t  //=== INITBITS();\n\t\t\t  hold = 0;\n\t\t\t  bits = 0;\n\t\t\t  //===//\n\t\t\t  state.mode = FLAGS;\n\t\t\t  break;\n\t\t\t}\n\t\t\tstate.flags = 0;           /* expect zlib header */\n\t\t\tif (state.head) {\n\t\t\t  state.head.done = false;\n\t\t\t}\n\t\t\tif (!(state.wrap & 1) ||   /* check if zlib header allowed */\n\t\t\t  (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n\t\t\t  strm.msg = 'incorrect header check';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t\t\tif ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n\t\t\t  strm.msg = 'unknown compression method';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t\t\t//--- DROPBITS(4) ---//\n\t\t\thold >>>= 4;\n\t\t\tbits -= 4;\n\t\t\t//---//\n\t\t\tlen = (hold & 0x0f)/*BITS(4)*/ + 8;\n\t\t\tif (state.wbits === 0) {\n\t\t\t  state.wbits = len;\n\t\t\t}\n\t\t\telse if (len > state.wbits) {\n\t\t\t  strm.msg = 'invalid window size';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n  \n\t\t\t// !!! pako patch. Force use `options.windowBits` if passed.\n\t\t\t// Required to always use max window size by default.\n\t\t\tstate.dmax = 1 << state.wbits;\n\t\t\t//state.dmax = 1 << len;\n  \n\t\t\t//Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n\t\t\tstrm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n\t\t\tstate.mode = hold & 0x200 ? DICTID : TYPE;\n\t\t\t//=== INITBITS();\n\t\t\thold = 0;\n\t\t\tbits = 0;\n\t\t\t//===//\n\t\t\tbreak;\n\t\t  case FLAGS:\n\t\t\t//=== NEEDBITS(16); */\n\t\t\twhile (bits < 16) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t}\n\t\t\t//===//\n\t\t\tstate.flags = hold;\n\t\t\tif ((state.flags & 0xff) !== Z_DEFLATED) {\n\t\t\t  strm.msg = 'unknown compression method';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t\t\tif (state.flags & 0xe000) {\n\t\t\t  strm.msg = 'unknown header flags set';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t\t\tif (state.head) {\n\t\t\t  state.head.text = ((hold >> 8) & 1);\n\t\t\t}\n\t\t\tif (state.flags & 0x0200) {\n\t\t\t  //=== CRC2(state.check, hold);\n\t\t\t  hbuf[0] = hold & 0xff;\n\t\t\t  hbuf[1] = (hold >>> 8) & 0xff;\n\t\t\t  state.check = crc32_1(state.check, hbuf, 2, 0);\n\t\t\t  //===//\n\t\t\t}\n\t\t\t//=== INITBITS();\n\t\t\thold = 0;\n\t\t\tbits = 0;\n\t\t\t//===//\n\t\t\tstate.mode = TIME;\n\t\t\t/* falls through */\n\t\t  case TIME:\n\t\t\t//=== NEEDBITS(32); */\n\t\t\twhile (bits < 32) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t}\n\t\t\t//===//\n\t\t\tif (state.head) {\n\t\t\t  state.head.time = hold;\n\t\t\t}\n\t\t\tif (state.flags & 0x0200) {\n\t\t\t  //=== CRC4(state.check, hold)\n\t\t\t  hbuf[0] = hold & 0xff;\n\t\t\t  hbuf[1] = (hold >>> 8) & 0xff;\n\t\t\t  hbuf[2] = (hold >>> 16) & 0xff;\n\t\t\t  hbuf[3] = (hold >>> 24) & 0xff;\n\t\t\t  state.check = crc32_1(state.check, hbuf, 4, 0);\n\t\t\t  //===\n\t\t\t}\n\t\t\t//=== INITBITS();\n\t\t\thold = 0;\n\t\t\tbits = 0;\n\t\t\t//===//\n\t\t\tstate.mode = OS;\n\t\t\t/* falls through */\n\t\t  case OS:\n\t\t\t//=== NEEDBITS(16); */\n\t\t\twhile (bits < 16) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t}\n\t\t\t//===//\n\t\t\tif (state.head) {\n\t\t\t  state.head.xflags = (hold & 0xff);\n\t\t\t  state.head.os = (hold >> 8);\n\t\t\t}\n\t\t\tif (state.flags & 0x0200) {\n\t\t\t  //=== CRC2(state.check, hold);\n\t\t\t  hbuf[0] = hold & 0xff;\n\t\t\t  hbuf[1] = (hold >>> 8) & 0xff;\n\t\t\t  state.check = crc32_1(state.check, hbuf, 2, 0);\n\t\t\t  //===//\n\t\t\t}\n\t\t\t//=== INITBITS();\n\t\t\thold = 0;\n\t\t\tbits = 0;\n\t\t\t//===//\n\t\t\tstate.mode = EXLEN;\n\t\t\t/* falls through */\n\t\t  case EXLEN:\n\t\t\tif (state.flags & 0x0400) {\n\t\t\t  //=== NEEDBITS(16); */\n\t\t\t  while (bits < 16) {\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\thold += input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t  }\n\t\t\t  //===//\n\t\t\t  state.length = hold;\n\t\t\t  if (state.head) {\n\t\t\t\tstate.head.extra_len = hold;\n\t\t\t  }\n\t\t\t  if (state.flags & 0x0200) {\n\t\t\t\t//=== CRC2(state.check, hold);\n\t\t\t\thbuf[0] = hold & 0xff;\n\t\t\t\thbuf[1] = (hold >>> 8) & 0xff;\n\t\t\t\tstate.check = crc32_1(state.check, hbuf, 2, 0);\n\t\t\t\t//===//\n\t\t\t  }\n\t\t\t  //=== INITBITS();\n\t\t\t  hold = 0;\n\t\t\t  bits = 0;\n\t\t\t  //===//\n\t\t\t}\n\t\t\telse if (state.head) {\n\t\t\t  state.head.extra = null/*Z_NULL*/;\n\t\t\t}\n\t\t\tstate.mode = EXTRA;\n\t\t\t/* falls through */\n\t\t  case EXTRA:\n\t\t\tif (state.flags & 0x0400) {\n\t\t\t  copy = state.length;\n\t\t\t  if (copy > have) { copy = have; }\n\t\t\t  if (copy) {\n\t\t\t\tif (state.head) {\n\t\t\t\t  len = state.head.extra_len - state.length;\n\t\t\t\t  if (!state.head.extra) {\n\t\t\t\t\t// Use untyped array for more convenient processing later\n\t\t\t\t\tstate.head.extra = new Uint8Array(state.head.extra_len);\n\t\t\t\t  }\n\t\t\t\t  state.head.extra.set(\n\t\t\t\t\tinput.subarray(\n\t\t\t\t\t  next,\n\t\t\t\t\t  // extra field is limited to 65536 bytes\n\t\t\t\t\t  // - no need for additional size check\n\t\t\t\t\t  next + copy\n\t\t\t\t\t),\n\t\t\t\t\t/*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n\t\t\t\t\tlen\n\t\t\t\t  );\n\t\t\t\t  //zmemcpy(state.head.extra + len, next,\n\t\t\t\t  //        len + copy > state.head.extra_max ?\n\t\t\t\t  //        state.head.extra_max - len : copy);\n\t\t\t\t}\n\t\t\t\tif (state.flags & 0x0200) {\n\t\t\t\t  state.check = crc32_1(state.check, input, copy, next);\n\t\t\t\t}\n\t\t\t\thave -= copy;\n\t\t\t\tnext += copy;\n\t\t\t\tstate.length -= copy;\n\t\t\t  }\n\t\t\t  if (state.length) { break inf_leave; }\n\t\t\t}\n\t\t\tstate.length = 0;\n\t\t\tstate.mode = NAME;\n\t\t\t/* falls through */\n\t\t  case NAME:\n\t\t\tif (state.flags & 0x0800) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  copy = 0;\n\t\t\t  do {\n\t\t\t\t// TODO: 2 or 1 bytes?\n\t\t\t\tlen = input[next + copy++];\n\t\t\t\t/* use constant limit because in js we should not preallocate memory */\n\t\t\t\tif (state.head && len &&\n\t\t\t\t\t(state.length < 65536 /*state.head.name_max*/)) {\n\t\t\t\t  state.head.name += String.fromCharCode(len);\n\t\t\t\t}\n\t\t\t  } while (len && copy < have);\n  \n\t\t\t  if (state.flags & 0x0200) {\n\t\t\t\tstate.check = crc32_1(state.check, input, copy, next);\n\t\t\t  }\n\t\t\t  have -= copy;\n\t\t\t  next += copy;\n\t\t\t  if (len) { break inf_leave; }\n\t\t\t}\n\t\t\telse if (state.head) {\n\t\t\t  state.head.name = null;\n\t\t\t}\n\t\t\tstate.length = 0;\n\t\t\tstate.mode = COMMENT;\n\t\t\t/* falls through */\n\t\t  case COMMENT:\n\t\t\tif (state.flags & 0x1000) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  copy = 0;\n\t\t\t  do {\n\t\t\t\tlen = input[next + copy++];\n\t\t\t\t/* use constant limit because in js we should not preallocate memory */\n\t\t\t\tif (state.head && len &&\n\t\t\t\t\t(state.length < 65536 /*state.head.comm_max*/)) {\n\t\t\t\t  state.head.comment += String.fromCharCode(len);\n\t\t\t\t}\n\t\t\t  } while (len && copy < have);\n\t\t\t  if (state.flags & 0x0200) {\n\t\t\t\tstate.check = crc32_1(state.check, input, copy, next);\n\t\t\t  }\n\t\t\t  have -= copy;\n\t\t\t  next += copy;\n\t\t\t  if (len) { break inf_leave; }\n\t\t\t}\n\t\t\telse if (state.head) {\n\t\t\t  state.head.comment = null;\n\t\t\t}\n\t\t\tstate.mode = HCRC;\n\t\t\t/* falls through */\n\t\t  case HCRC:\n\t\t\tif (state.flags & 0x0200) {\n\t\t\t  //=== NEEDBITS(16); */\n\t\t\t  while (bits < 16) {\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\thold += input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t  }\n\t\t\t  //===//\n\t\t\t  if (hold !== (state.check & 0xffff)) {\n\t\t\t\tstrm.msg = 'header crc mismatch';\n\t\t\t\tstate.mode = BAD;\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t  //=== INITBITS();\n\t\t\t  hold = 0;\n\t\t\t  bits = 0;\n\t\t\t  //===//\n\t\t\t}\n\t\t\tif (state.head) {\n\t\t\t  state.head.hcrc = ((state.flags >> 9) & 1);\n\t\t\t  state.head.done = true;\n\t\t\t}\n\t\t\tstrm.adler = state.check = 0;\n\t\t\tstate.mode = TYPE;\n\t\t\tbreak;\n\t\t  case DICTID:\n\t\t\t//=== NEEDBITS(32); */\n\t\t\twhile (bits < 32) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t}\n\t\t\t//===//\n\t\t\tstrm.adler = state.check = zswap32(hold);\n\t\t\t//=== INITBITS();\n\t\t\thold = 0;\n\t\t\tbits = 0;\n\t\t\t//===//\n\t\t\tstate.mode = DICT;\n\t\t\t/* falls through */\n\t\t  case DICT:\n\t\t\tif (state.havedict === 0) {\n\t\t\t  //--- RESTORE() ---\n\t\t\t  strm.next_out = put;\n\t\t\t  strm.avail_out = left;\n\t\t\t  strm.next_in = next;\n\t\t\t  strm.avail_in = have;\n\t\t\t  state.hold = hold;\n\t\t\t  state.bits = bits;\n\t\t\t  //---\n\t\t\t  return Z_NEED_DICT$1;\n\t\t\t}\n\t\t\tstrm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n\t\t\tstate.mode = TYPE;\n\t\t\t/* falls through */\n\t\t  case TYPE:\n\t\t\tif (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n\t\t\t/* falls through */\n\t\t  case TYPEDO:\n\t\t\tif (state.last) {\n\t\t\t  //--- BYTEBITS() ---//\n\t\t\t  hold >>>= bits & 7;\n\t\t\t  bits -= bits & 7;\n\t\t\t  //---//\n\t\t\t  state.mode = CHECK;\n\t\t\t  break;\n\t\t\t}\n\t\t\t//=== NEEDBITS(3); */\n\t\t\twhile (bits < 3) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t}\n\t\t\t//===//\n\t\t\tstate.last = (hold & 0x01)/*BITS(1)*/;\n\t\t\t//--- DROPBITS(1) ---//\n\t\t\thold >>>= 1;\n\t\t\tbits -= 1;\n\t\t\t//---//\n  \n\t\t\tswitch ((hold & 0x03)/*BITS(2)*/) {\n\t\t\t  case 0:                             /* stored block */\n\t\t\t\t//Tracev((stderr, \"inflate:     stored block%s\\n\",\n\t\t\t\t//        state.last ? \" (last)\" : \"\"));\n\t\t\t\tstate.mode = STORED;\n\t\t\t\tbreak;\n\t\t\t  case 1:                             /* fixed block */\n\t\t\t\tfixedtables(state);\n\t\t\t\t//Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n\t\t\t\t//        state.last ? \" (last)\" : \"\"));\n\t\t\t\tstate.mode = LEN_;             /* decode codes */\n\t\t\t\tif (flush === Z_TREES) {\n\t\t\t\t  //--- DROPBITS(2) ---//\n\t\t\t\t  hold >>>= 2;\n\t\t\t\t  bits -= 2;\n\t\t\t\t  //---//\n\t\t\t\t  break inf_leave;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t  case 2:                             /* dynamic block */\n\t\t\t\t//Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n\t\t\t\t//        state.last ? \" (last)\" : \"\"));\n\t\t\t\tstate.mode = TABLE;\n\t\t\t\tbreak;\n\t\t\t  case 3:\n\t\t\t\tstrm.msg = 'invalid block type';\n\t\t\t\tstate.mode = BAD;\n\t\t\t}\n\t\t\t//--- DROPBITS(2) ---//\n\t\t\thold >>>= 2;\n\t\t\tbits -= 2;\n\t\t\t//---//\n\t\t\tbreak;\n\t\t  case STORED:\n\t\t\t//--- BYTEBITS() ---// /* go to byte boundary */\n\t\t\thold >>>= bits & 7;\n\t\t\tbits -= bits & 7;\n\t\t\t//---//\n\t\t\t//=== NEEDBITS(32); */\n\t\t\twhile (bits < 32) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t}\n\t\t\t//===//\n\t\t\tif ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n\t\t\t  strm.msg = 'invalid stored block lengths';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t\t\tstate.length = hold & 0xffff;\n\t\t\t//Tracev((stderr, \"inflate:       stored length %u\\n\",\n\t\t\t//        state.length));\n\t\t\t//=== INITBITS();\n\t\t\thold = 0;\n\t\t\tbits = 0;\n\t\t\t//===//\n\t\t\tstate.mode = COPY_;\n\t\t\tif (flush === Z_TREES) { break inf_leave; }\n\t\t\t/* falls through */\n\t\t  case COPY_:\n\t\t\tstate.mode = COPY;\n\t\t\t/* falls through */\n\t\t  case COPY:\n\t\t\tcopy = state.length;\n\t\t\tif (copy) {\n\t\t\t  if (copy > have) { copy = have; }\n\t\t\t  if (copy > left) { copy = left; }\n\t\t\t  if (copy === 0) { break inf_leave; }\n\t\t\t  //--- zmemcpy(put, next, copy); ---\n\t\t\t  output.set(input.subarray(next, next + copy), put);\n\t\t\t  //---//\n\t\t\t  have -= copy;\n\t\t\t  next += copy;\n\t\t\t  left -= copy;\n\t\t\t  put += copy;\n\t\t\t  state.length -= copy;\n\t\t\t  break;\n\t\t\t}\n\t\t\t//Tracev((stderr, \"inflate:       stored end\\n\"));\n\t\t\tstate.mode = TYPE;\n\t\t\tbreak;\n\t\t  case TABLE:\n\t\t\t//=== NEEDBITS(14); */\n\t\t\twhile (bits < 14) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t}\n\t\t\t//===//\n\t\t\tstate.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n\t\t\t//--- DROPBITS(5) ---//\n\t\t\thold >>>= 5;\n\t\t\tbits -= 5;\n\t\t\t//---//\n\t\t\tstate.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n\t\t\t//--- DROPBITS(5) ---//\n\t\t\thold >>>= 5;\n\t\t\tbits -= 5;\n\t\t\t//---//\n\t\t\tstate.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n\t\t\t//--- DROPBITS(4) ---//\n\t\t\thold >>>= 4;\n\t\t\tbits -= 4;\n\t\t\t//---//\n\t//#ifndef PKZIP_BUG_WORKAROUND\n\t\t\tif (state.nlen > 286 || state.ndist > 30) {\n\t\t\t  strm.msg = 'too many length or distance symbols';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t//#endif\n\t\t\t//Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n\t\t\tstate.have = 0;\n\t\t\tstate.mode = LENLENS;\n\t\t\t/* falls through */\n\t\t  case LENLENS:\n\t\t\twhile (state.have < state.ncode) {\n\t\t\t  //=== NEEDBITS(3);\n\t\t\t  while (bits < 3) {\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\thold += input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t  }\n\t\t\t  //===//\n\t\t\t  state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n\t\t\t  //--- DROPBITS(3) ---//\n\t\t\t  hold >>>= 3;\n\t\t\t  bits -= 3;\n\t\t\t  //---//\n\t\t\t}\n\t\t\twhile (state.have < 19) {\n\t\t\t  state.lens[order[state.have++]] = 0;\n\t\t\t}\n\t\t\t// We have separate tables & no pointers. 2 commented lines below not needed.\n\t\t\t//state.next = state.codes;\n\t\t\t//state.lencode = state.next;\n\t\t\t// Switch to use dynamic table\n\t\t\tstate.lencode = state.lendyn;\n\t\t\tstate.lenbits = 7;\n  \n\t\t\topts = { bits: state.lenbits };\n\t\t\tret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n\t\t\tstate.lenbits = opts.bits;\n  \n\t\t\tif (ret) {\n\t\t\t  strm.msg = 'invalid code lengths set';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t\t\t//Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n\t\t\tstate.have = 0;\n\t\t\tstate.mode = CODELENS;\n\t\t\t/* falls through */\n\t\t  case CODELENS:\n\t\t\twhile (state.have < state.nlen + state.ndist) {\n\t\t\t  for (;;) {\n\t\t\t\there = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n\t\t\t\there_bits = here >>> 24;\n\t\t\t\there_op = (here >>> 16) & 0xff;\n\t\t\t\there_val = here & 0xffff;\n  \n\t\t\t\tif ((here_bits) <= bits) { break; }\n\t\t\t\t//--- PULLBYTE() ---//\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\thold += input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t\t//---//\n\t\t\t  }\n\t\t\t  if (here_val < 16) {\n\t\t\t\t//--- DROPBITS(here.bits) ---//\n\t\t\t\thold >>>= here_bits;\n\t\t\t\tbits -= here_bits;\n\t\t\t\t//---//\n\t\t\t\tstate.lens[state.have++] = here_val;\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\tif (here_val === 16) {\n\t\t\t\t  //=== NEEDBITS(here.bits + 2);\n\t\t\t\t  n = here_bits + 2;\n\t\t\t\t  while (bits < n) {\n\t\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\t\thave--;\n\t\t\t\t\thold += input[next++] << bits;\n\t\t\t\t\tbits += 8;\n\t\t\t\t  }\n\t\t\t\t  //===//\n\t\t\t\t  //--- DROPBITS(here.bits) ---//\n\t\t\t\t  hold >>>= here_bits;\n\t\t\t\t  bits -= here_bits;\n\t\t\t\t  //---//\n\t\t\t\t  if (state.have === 0) {\n\t\t\t\t\tstrm.msg = 'invalid bit length repeat';\n\t\t\t\t\tstate.mode = BAD;\n\t\t\t\t\tbreak;\n\t\t\t\t  }\n\t\t\t\t  len = state.lens[state.have - 1];\n\t\t\t\t  copy = 3 + (hold & 0x03);//BITS(2);\n\t\t\t\t  //--- DROPBITS(2) ---//\n\t\t\t\t  hold >>>= 2;\n\t\t\t\t  bits -= 2;\n\t\t\t\t  //---//\n\t\t\t\t}\n\t\t\t\telse if (here_val === 17) {\n\t\t\t\t  //=== NEEDBITS(here.bits + 3);\n\t\t\t\t  n = here_bits + 3;\n\t\t\t\t  while (bits < n) {\n\t\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\t\thave--;\n\t\t\t\t\thold += input[next++] << bits;\n\t\t\t\t\tbits += 8;\n\t\t\t\t  }\n\t\t\t\t  //===//\n\t\t\t\t  //--- DROPBITS(here.bits) ---//\n\t\t\t\t  hold >>>= here_bits;\n\t\t\t\t  bits -= here_bits;\n\t\t\t\t  //---//\n\t\t\t\t  len = 0;\n\t\t\t\t  copy = 3 + (hold & 0x07);//BITS(3);\n\t\t\t\t  //--- DROPBITS(3) ---//\n\t\t\t\t  hold >>>= 3;\n\t\t\t\t  bits -= 3;\n\t\t\t\t  //---//\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t  //=== NEEDBITS(here.bits + 7);\n\t\t\t\t  n = here_bits + 7;\n\t\t\t\t  while (bits < n) {\n\t\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\t\thave--;\n\t\t\t\t\thold += input[next++] << bits;\n\t\t\t\t\tbits += 8;\n\t\t\t\t  }\n\t\t\t\t  //===//\n\t\t\t\t  //--- DROPBITS(here.bits) ---//\n\t\t\t\t  hold >>>= here_bits;\n\t\t\t\t  bits -= here_bits;\n\t\t\t\t  //---//\n\t\t\t\t  len = 0;\n\t\t\t\t  copy = 11 + (hold & 0x7f);//BITS(7);\n\t\t\t\t  //--- DROPBITS(7) ---//\n\t\t\t\t  hold >>>= 7;\n\t\t\t\t  bits -= 7;\n\t\t\t\t  //---//\n\t\t\t\t}\n\t\t\t\tif (state.have + copy > state.nlen + state.ndist) {\n\t\t\t\t  strm.msg = 'invalid bit length repeat';\n\t\t\t\t  state.mode = BAD;\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t\twhile (copy--) {\n\t\t\t\t  state.lens[state.have++] = len;\n\t\t\t\t}\n\t\t\t  }\n\t\t\t}\n  \n\t\t\t/* handle error breaks in while */\n\t\t\tif (state.mode === BAD) { break; }\n  \n\t\t\t/* check for end-of-block code (better have one) */\n\t\t\tif (state.lens[256] === 0) {\n\t\t\t  strm.msg = 'invalid code -- missing end-of-block';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n  \n\t\t\t/* build code tables -- note: do not change the lenbits or distbits\n\t\t\t   values here (9 and 6) without reading the comments in inftrees.h\n\t\t\t   concerning the ENOUGH constants, which depend on those values */\n\t\t\tstate.lenbits = 9;\n  \n\t\t\topts = { bits: state.lenbits };\n\t\t\tret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n\t\t\t// We have separate tables & no pointers. 2 commented lines below not needed.\n\t\t\t// state.next_index = opts.table_index;\n\t\t\tstate.lenbits = opts.bits;\n\t\t\t// state.lencode = state.next;\n  \n\t\t\tif (ret) {\n\t\t\t  strm.msg = 'invalid literal/lengths set';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n  \n\t\t\tstate.distbits = 6;\n\t\t\t//state.distcode.copy(state.codes);\n\t\t\t// Switch to use dynamic table\n\t\t\tstate.distcode = state.distdyn;\n\t\t\topts = { bits: state.distbits };\n\t\t\tret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n\t\t\t// We have separate tables & no pointers. 2 commented lines below not needed.\n\t\t\t// state.next_index = opts.table_index;\n\t\t\tstate.distbits = opts.bits;\n\t\t\t// state.distcode = state.next;\n  \n\t\t\tif (ret) {\n\t\t\t  strm.msg = 'invalid distances set';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t\t\t//Tracev((stderr, 'inflate:       codes ok\\n'));\n\t\t\tstate.mode = LEN_;\n\t\t\tif (flush === Z_TREES) { break inf_leave; }\n\t\t\t/* falls through */\n\t\t  case LEN_:\n\t\t\tstate.mode = LEN;\n\t\t\t/* falls through */\n\t\t  case LEN:\n\t\t\tif (have >= 6 && left >= 258) {\n\t\t\t  //--- RESTORE() ---\n\t\t\t  strm.next_out = put;\n\t\t\t  strm.avail_out = left;\n\t\t\t  strm.next_in = next;\n\t\t\t  strm.avail_in = have;\n\t\t\t  state.hold = hold;\n\t\t\t  state.bits = bits;\n\t\t\t  //---\n\t\t\t  inffast(strm, _out);\n\t\t\t  //--- LOAD() ---\n\t\t\t  put = strm.next_out;\n\t\t\t  output = strm.output;\n\t\t\t  left = strm.avail_out;\n\t\t\t  next = strm.next_in;\n\t\t\t  input = strm.input;\n\t\t\t  have = strm.avail_in;\n\t\t\t  hold = state.hold;\n\t\t\t  bits = state.bits;\n\t\t\t  //---\n  \n\t\t\t  if (state.mode === TYPE) {\n\t\t\t\tstate.back = -1;\n\t\t\t  }\n\t\t\t  break;\n\t\t\t}\n\t\t\tstate.back = 0;\n\t\t\tfor (;;) {\n\t\t\t  here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n\t\t\t  here_bits = here >>> 24;\n\t\t\t  here_op = (here >>> 16) & 0xff;\n\t\t\t  here_val = here & 0xffff;\n  \n\t\t\t  if (here_bits <= bits) { break; }\n\t\t\t  //--- PULLBYTE() ---//\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t  //---//\n\t\t\t}\n\t\t\tif (here_op && (here_op & 0xf0) === 0) {\n\t\t\t  last_bits = here_bits;\n\t\t\t  last_op = here_op;\n\t\t\t  last_val = here_val;\n\t\t\t  for (;;) {\n\t\t\t\there = state.lencode[last_val +\n\t\t\t\t\t\t((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n\t\t\t\there_bits = here >>> 24;\n\t\t\t\there_op = (here >>> 16) & 0xff;\n\t\t\t\there_val = here & 0xffff;\n  \n\t\t\t\tif ((last_bits + here_bits) <= bits) { break; }\n\t\t\t\t//--- PULLBYTE() ---//\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\thold += input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t\t//---//\n\t\t\t  }\n\t\t\t  //--- DROPBITS(last.bits) ---//\n\t\t\t  hold >>>= last_bits;\n\t\t\t  bits -= last_bits;\n\t\t\t  //---//\n\t\t\t  state.back += last_bits;\n\t\t\t}\n\t\t\t//--- DROPBITS(here.bits) ---//\n\t\t\thold >>>= here_bits;\n\t\t\tbits -= here_bits;\n\t\t\t//---//\n\t\t\tstate.back += here_bits;\n\t\t\tstate.length = here_val;\n\t\t\tif (here_op === 0) {\n\t\t\t  //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n\t\t\t  //        \"inflate:         literal '%c'\\n\" :\n\t\t\t  //        \"inflate:         literal 0x%02x\\n\", here.val));\n\t\t\t  state.mode = LIT;\n\t\t\t  break;\n\t\t\t}\n\t\t\tif (here_op & 32) {\n\t\t\t  //Tracevv((stderr, \"inflate:         end of block\\n\"));\n\t\t\t  state.back = -1;\n\t\t\t  state.mode = TYPE;\n\t\t\t  break;\n\t\t\t}\n\t\t\tif (here_op & 64) {\n\t\t\t  strm.msg = 'invalid literal/length code';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t\t\tstate.extra = here_op & 15;\n\t\t\tstate.mode = LENEXT;\n\t\t\t/* falls through */\n\t\t  case LENEXT:\n\t\t\tif (state.extra) {\n\t\t\t  //=== NEEDBITS(state.extra);\n\t\t\t  n = state.extra;\n\t\t\t  while (bits < n) {\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\thold += input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t  }\n\t\t\t  //===//\n\t\t\t  state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n\t\t\t  //--- DROPBITS(state.extra) ---//\n\t\t\t  hold >>>= state.extra;\n\t\t\t  bits -= state.extra;\n\t\t\t  //---//\n\t\t\t  state.back += state.extra;\n\t\t\t}\n\t\t\t//Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n\t\t\tstate.was = state.length;\n\t\t\tstate.mode = DIST;\n\t\t\t/* falls through */\n\t\t  case DIST:\n\t\t\tfor (;;) {\n\t\t\t  here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n\t\t\t  here_bits = here >>> 24;\n\t\t\t  here_op = (here >>> 16) & 0xff;\n\t\t\t  here_val = here & 0xffff;\n  \n\t\t\t  if ((here_bits) <= bits) { break; }\n\t\t\t  //--- PULLBYTE() ---//\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t  //---//\n\t\t\t}\n\t\t\tif ((here_op & 0xf0) === 0) {\n\t\t\t  last_bits = here_bits;\n\t\t\t  last_op = here_op;\n\t\t\t  last_val = here_val;\n\t\t\t  for (;;) {\n\t\t\t\there = state.distcode[last_val +\n\t\t\t\t\t\t((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n\t\t\t\there_bits = here >>> 24;\n\t\t\t\there_op = (here >>> 16) & 0xff;\n\t\t\t\there_val = here & 0xffff;\n  \n\t\t\t\tif ((last_bits + here_bits) <= bits) { break; }\n\t\t\t\t//--- PULLBYTE() ---//\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\thold += input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t\t//---//\n\t\t\t  }\n\t\t\t  //--- DROPBITS(last.bits) ---//\n\t\t\t  hold >>>= last_bits;\n\t\t\t  bits -= last_bits;\n\t\t\t  //---//\n\t\t\t  state.back += last_bits;\n\t\t\t}\n\t\t\t//--- DROPBITS(here.bits) ---//\n\t\t\thold >>>= here_bits;\n\t\t\tbits -= here_bits;\n\t\t\t//---//\n\t\t\tstate.back += here_bits;\n\t\t\tif (here_op & 64) {\n\t\t\t  strm.msg = 'invalid distance code';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t\t\tstate.offset = here_val;\n\t\t\tstate.extra = (here_op) & 15;\n\t\t\tstate.mode = DISTEXT;\n\t\t\t/* falls through */\n\t\t  case DISTEXT:\n\t\t\tif (state.extra) {\n\t\t\t  //=== NEEDBITS(state.extra);\n\t\t\t  n = state.extra;\n\t\t\t  while (bits < n) {\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\thold += input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t  }\n\t\t\t  //===//\n\t\t\t  state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n\t\t\t  //--- DROPBITS(state.extra) ---//\n\t\t\t  hold >>>= state.extra;\n\t\t\t  bits -= state.extra;\n\t\t\t  //---//\n\t\t\t  state.back += state.extra;\n\t\t\t}\n\t//#ifdef INFLATE_STRICT\n\t\t\tif (state.offset > state.dmax) {\n\t\t\t  strm.msg = 'invalid distance too far back';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t//#endif\n\t\t\t//Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n\t\t\tstate.mode = MATCH;\n\t\t\t/* falls through */\n\t\t  case MATCH:\n\t\t\tif (left === 0) { break inf_leave; }\n\t\t\tcopy = _out - left;\n\t\t\tif (state.offset > copy) {         /* copy from window */\n\t\t\t  copy = state.offset - copy;\n\t\t\t  if (copy > state.whave) {\n\t\t\t\tif (state.sane) {\n\t\t\t\t  strm.msg = 'invalid distance too far back';\n\t\t\t\t  state.mode = BAD;\n\t\t\t\t  break;\n\t\t\t\t}\n\t// (!) This block is disabled in zlib defaults,\n\t// don't enable it for binary compatibility\n\t//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n\t//          Trace((stderr, \"inflate.c too far\\n\"));\n\t//          copy -= state.whave;\n\t//          if (copy > state.length) { copy = state.length; }\n\t//          if (copy > left) { copy = left; }\n\t//          left -= copy;\n\t//          state.length -= copy;\n\t//          do {\n\t//            output[put++] = 0;\n\t//          } while (--copy);\n\t//          if (state.length === 0) { state.mode = LEN; }\n\t//          break;\n\t//#endif\n\t\t\t  }\n\t\t\t  if (copy > state.wnext) {\n\t\t\t\tcopy -= state.wnext;\n\t\t\t\tfrom = state.wsize - copy;\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\tfrom = state.wnext - copy;\n\t\t\t  }\n\t\t\t  if (copy > state.length) { copy = state.length; }\n\t\t\t  from_source = state.window;\n\t\t\t}\n\t\t\telse {                              /* copy from output */\n\t\t\t  from_source = output;\n\t\t\t  from = put - state.offset;\n\t\t\t  copy = state.length;\n\t\t\t}\n\t\t\tif (copy > left) { copy = left; }\n\t\t\tleft -= copy;\n\t\t\tstate.length -= copy;\n\t\t\tdo {\n\t\t\t  output[put++] = from_source[from++];\n\t\t\t} while (--copy);\n\t\t\tif (state.length === 0) { state.mode = LEN; }\n\t\t\tbreak;\n\t\t  case LIT:\n\t\t\tif (left === 0) { break inf_leave; }\n\t\t\toutput[put++] = state.length;\n\t\t\tleft--;\n\t\t\tstate.mode = LEN;\n\t\t\tbreak;\n\t\t  case CHECK:\n\t\t\tif (state.wrap) {\n\t\t\t  //=== NEEDBITS(32);\n\t\t\t  while (bits < 32) {\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\t// Use '|' instead of '+' to make sure that result is signed\n\t\t\t\thold |= input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t  }\n\t\t\t  //===//\n\t\t\t  _out -= left;\n\t\t\t  strm.total_out += _out;\n\t\t\t  state.total += _out;\n\t\t\t  if (_out) {\n\t\t\t\tstrm.adler = state.check =\n\t\t\t\t\t/*UPDATE(state.check, put - _out, _out);*/\n\t\t\t\t\t(state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));\n  \n\t\t\t  }\n\t\t\t  _out = left;\n\t\t\t  // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n\t\t\t  if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n\t\t\t\tstrm.msg = 'incorrect data check';\n\t\t\t\tstate.mode = BAD;\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t  //=== INITBITS();\n\t\t\t  hold = 0;\n\t\t\t  bits = 0;\n\t\t\t  //===//\n\t\t\t  //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n\t\t\t}\n\t\t\tstate.mode = LENGTH;\n\t\t\t/* falls through */\n\t\t  case LENGTH:\n\t\t\tif (state.wrap && state.flags) {\n\t\t\t  //=== NEEDBITS(32);\n\t\t\t  while (bits < 32) {\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\thold += input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t  }\n\t\t\t  //===//\n\t\t\t  if (hold !== (state.total & 0xffffffff)) {\n\t\t\t\tstrm.msg = 'incorrect length check';\n\t\t\t\tstate.mode = BAD;\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t  //=== INITBITS();\n\t\t\t  hold = 0;\n\t\t\t  bits = 0;\n\t\t\t  //===//\n\t\t\t  //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n\t\t\t}\n\t\t\tstate.mode = DONE;\n\t\t\t/* falls through */\n\t\t  case DONE:\n\t\t\tret = Z_STREAM_END$1;\n\t\t\tbreak inf_leave;\n\t\t  case BAD:\n\t\t\tret = Z_DATA_ERROR$1;\n\t\t\tbreak inf_leave;\n\t\t  case MEM:\n\t\t\treturn Z_MEM_ERROR$1;\n\t\t  case SYNC:\n\t\t\t/* falls through */\n\t\t  default:\n\t\t\treturn Z_STREAM_ERROR$1;\n\t\t}\n\t  }\n  \n\t  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n  \n\t  /*\n\t\t Return from inflate(), updating the total counts and the check value.\n\t\t If there was no progress during the inflate() call, return a buffer\n\t\t error.  Call updatewindow() to create and/or update the window state.\n\t\t Note: a memory error from inflate() is non-recoverable.\n\t   */\n  \n\t  //--- RESTORE() ---\n\t  strm.next_out = put;\n\t  strm.avail_out = left;\n\t  strm.next_in = next;\n\t  strm.avail_in = have;\n\t  state.hold = hold;\n\t  state.bits = bits;\n\t  //---\n  \n\t  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n\t\t\t\t\t\t  (state.mode < CHECK || flush !== Z_FINISH$1))) {\n\t\tif (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;\n\t  }\n\t  _in -= strm.avail_in;\n\t  _out -= strm.avail_out;\n\t  strm.total_in += _in;\n\t  strm.total_out += _out;\n\t  state.total += _out;\n\t  if (state.wrap && _out) {\n\t\tstrm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n\t\t  (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));\n\t  }\n\t  strm.data_type = state.bits + (state.last ? 64 : 0) +\n\t\t\t\t\t\t(state.mode === TYPE ? 128 : 0) +\n\t\t\t\t\t\t(state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n\t  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {\n\t\tret = Z_BUF_ERROR;\n\t  }\n\t  return ret;\n\t};\n  \n  \n\tconst inflateEnd = (strm) => {\n  \n\t  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n\t\treturn Z_STREAM_ERROR$1;\n\t  }\n  \n\t  let state = strm.state;\n\t  if (state.window) {\n\t\tstate.window = null;\n\t  }\n\t  strm.state = null;\n\t  return Z_OK$1;\n\t};\n  \n  \n\tconst inflateGetHeader = (strm, head) => {\n  \n\t  /* check state */\n\t  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }\n\t  const state = strm.state;\n\t  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }\n  \n\t  /* save header structure */\n\t  state.head = head;\n\t  head.done = false;\n\t  return Z_OK$1;\n\t};\n  \n  \n\tconst inflateSetDictionary = (strm, dictionary) => {\n\t  const dictLength = dictionary.length;\n  \n\t  let state;\n\t  let dictid;\n\t  let ret;\n  \n\t  /* check state */\n\t  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR$1; }\n\t  state = strm.state;\n  \n\t  if (state.wrap !== 0 && state.mode !== DICT) {\n\t\treturn Z_STREAM_ERROR$1;\n\t  }\n  \n\t  /* check for correct dictionary identifier */\n\t  if (state.mode === DICT) {\n\t\tdictid = 1; /* adler32(0, null, 0)*/\n\t\t/* dictid = adler32(dictid, dictionary, dictLength); */\n\t\tdictid = adler32_1(dictid, dictionary, dictLength, 0);\n\t\tif (dictid !== state.check) {\n\t\t  return Z_DATA_ERROR$1;\n\t\t}\n\t  }\n\t  /* copy dictionary to window using updatewindow(), which will amend the\n\t   existing dictionary if appropriate */\n\t  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n\t  if (ret) {\n\t\tstate.mode = MEM;\n\t\treturn Z_MEM_ERROR$1;\n\t  }\n\t  state.havedict = 1;\n\t  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n\t  return Z_OK$1;\n\t};\n  \n  \n\tvar inflateReset_1 = inflateReset;\n\tvar inflateReset2_1 = inflateReset2;\n\tvar inflateResetKeep_1 = inflateResetKeep;\n\tvar inflateInit_1 = inflateInit;\n\tvar inflateInit2_1 = inflateInit2;\n\tvar inflate_2$1 = inflate$2;\n\tvar inflateEnd_1 = inflateEnd;\n\tvar inflateGetHeader_1 = inflateGetHeader;\n\tvar inflateSetDictionary_1 = inflateSetDictionary;\n\tvar inflateInfo = 'pako inflate (from Nodeca project)';\n  \n\t/* Not implemented\n\tmodule.exports.inflateCopy = inflateCopy;\n\tmodule.exports.inflateGetDictionary = inflateGetDictionary;\n\tmodule.exports.inflateMark = inflateMark;\n\tmodule.exports.inflatePrime = inflatePrime;\n\tmodule.exports.inflateSync = inflateSync;\n\tmodule.exports.inflateSyncPoint = inflateSyncPoint;\n\tmodule.exports.inflateUndermine = inflateUndermine;\n\t*/\n  \n\tvar inflate_1$2 = {\n\t\tinflateReset: inflateReset_1,\n\t\tinflateReset2: inflateReset2_1,\n\t\tinflateResetKeep: inflateResetKeep_1,\n\t\tinflateInit: inflateInit_1,\n\t\tinflateInit2: inflateInit2_1,\n\t\tinflate: inflate_2$1,\n\t\tinflateEnd: inflateEnd_1,\n\t\tinflateGetHeader: inflateGetHeader_1,\n\t\tinflateSetDictionary: inflateSetDictionary_1,\n\t\tinflateInfo: inflateInfo\n\t};\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\tfunction GZheader() {\n\t  /* true if compressed data believed to be text */\n\t  this.text       = 0;\n\t  /* modification time */\n\t  this.time       = 0;\n\t  /* extra flags (not used when writing a gzip file) */\n\t  this.xflags     = 0;\n\t  /* operating system */\n\t  this.os         = 0;\n\t  /* pointer to extra field or Z_NULL if none */\n\t  this.extra      = null;\n\t  /* extra field length (valid if extra != Z_NULL) */\n\t  this.extra_len  = 0; // Actually, we don't need it in JS,\n\t\t\t\t\t\t   // but leave for few code modifications\n  \n\t  //\n\t  // Setup limits is not necessary because in js we should not preallocate memory\n\t  // for inflate use constant limit in 65536 bytes\n\t  //\n  \n\t  /* space at extra (only when reading header) */\n\t  // this.extra_max  = 0;\n\t  /* pointer to zero-terminated file name or Z_NULL */\n\t  this.name       = '';\n\t  /* space at name (only when reading header) */\n\t  // this.name_max   = 0;\n\t  /* pointer to zero-terminated comment or Z_NULL */\n\t  this.comment    = '';\n\t  /* space at comment (only when reading header) */\n\t  // this.comm_max   = 0;\n\t  /* true if there was or will be a header crc */\n\t  this.hcrc       = 0;\n\t  /* true when done reading gzip header (not used when writing a gzip file) */\n\t  this.done       = false;\n\t}\n  \n\tvar gzheader = GZheader;\n  \n\tconst toString = Object.prototype.toString;\n  \n\t/* Public constants ==========================================================*/\n\t/* ===========================================================================*/\n  \n\tconst {\n\t  Z_NO_FLUSH, Z_FINISH,\n\t  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR\n\t} = constants$2;\n  \n\t/* ===========================================================================*/\n  \n  \n\t/**\n\t * class Inflate\n\t *\n\t * Generic JS-style wrapper for zlib calls. If you don't need\n\t * streaming behaviour - use more simple functions: [[inflate]]\n\t * and [[inflateRaw]].\n\t **/\n  \n\t/* internal\n\t * inflate.chunks -> Array\n\t *\n\t * Chunks of output data, if [[Inflate#onData]] not overridden.\n\t **/\n  \n\t/**\n\t * Inflate.result -> Uint8Array|String\n\t *\n\t * Uncompressed result, generated by default [[Inflate#onData]]\n\t * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n\t * (call [[Inflate#push]] with `Z_FINISH` / `true` param).\n\t **/\n  \n\t/**\n\t * Inflate.err -> Number\n\t *\n\t * Error code after inflate finished. 0 (Z_OK) on success.\n\t * Should be checked if broken data possible.\n\t **/\n  \n\t/**\n\t * Inflate.msg -> String\n\t *\n\t * Error message, if [[Inflate.err]] != 0\n\t **/\n  \n  \n\t/**\n\t * new Inflate(options)\n\t * - options (Object): zlib inflate options.\n\t *\n\t * Creates new inflator instance with specified params. Throws exception\n\t * on bad params. Supported options:\n\t *\n\t * - `windowBits`\n\t * - `dictionary`\n\t *\n\t * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n\t * for more information on these.\n\t *\n\t * Additional options, for internal needs:\n\t *\n\t * - `chunkSize` - size of generated data chunks (16K by default)\n\t * - `raw` (Boolean) - do raw inflate\n\t * - `to` (String) - if equal to 'string', then result will be converted\n\t *   from utf8 to utf16 (javascript) string. When string output requested,\n\t *   chunk length can differ from `chunkSize`, depending on content.\n\t *\n\t * By default, when no options set, autodetect deflate/gzip data format via\n\t * wrapper header.\n\t *\n\t * ##### Example:\n\t *\n\t * ```javascript\n\t * const pako = require('pako')\n\t * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n\t * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n\t *\n\t * const inflate = new pako.Inflate({ level: 3});\n\t *\n\t * inflate.push(chunk1, false);\n\t * inflate.push(chunk2, true);  // true -> last chunk\n\t *\n\t * if (inflate.err) { throw new Error(inflate.err); }\n\t *\n\t * console.log(inflate.result);\n\t * ```\n\t **/\n\tfunction Inflate$1(options) {\n\t  this.options = common.assign({\n\t\tchunkSize: 1024 * 64,\n\t\twindowBits: 15,\n\t\tto: ''\n\t  }, options || {});\n  \n\t  const opt = this.options;\n  \n\t  // Force window size for `raw` data, if not set directly,\n\t  // because we have no header for autodetect.\n\t  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n\t\topt.windowBits = -opt.windowBits;\n\t\tif (opt.windowBits === 0) { opt.windowBits = -15; }\n\t  }\n  \n\t  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n\t  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n\t\t  !(options && options.windowBits)) {\n\t\topt.windowBits += 32;\n\t  }\n  \n\t  // Gzip header has no info about windows size, we can do autodetect only\n\t  // for deflate. So, if window size not set, force it to max when gzip possible\n\t  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n\t\t// bit 3 (16) -> gzipped data\n\t\t// bit 4 (32) -> autodetect gzip/deflate\n\t\tif ((opt.windowBits & 15) === 0) {\n\t\t  opt.windowBits |= 15;\n\t\t}\n\t  }\n  \n\t  this.err    = 0;      // error code, if happens (0 = Z_OK)\n\t  this.msg    = '';     // error message\n\t  this.ended  = false;  // used to avoid multiple onEnd() calls\n\t  this.chunks = [];     // chunks of compressed data\n  \n\t  this.strm   = new zstream();\n\t  this.strm.avail_out = 0;\n  \n\t  let status  = inflate_1$2.inflateInit2(\n\t\tthis.strm,\n\t\topt.windowBits\n\t  );\n  \n\t  if (status !== Z_OK) {\n\t\tthrow new Error(messages[status]);\n\t  }\n  \n\t  this.header = new gzheader();\n  \n\t  inflate_1$2.inflateGetHeader(this.strm, this.header);\n  \n\t  // Setup dictionary\n\t  if (opt.dictionary) {\n\t\t// Convert data if needed\n\t\tif (typeof opt.dictionary === 'string') {\n\t\t  opt.dictionary = strings.string2buf(opt.dictionary);\n\t\t} else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n\t\t  opt.dictionary = new Uint8Array(opt.dictionary);\n\t\t}\n\t\tif (opt.raw) { //In raw mode we need to set the dictionary early\n\t\t  status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);\n\t\t  if (status !== Z_OK) {\n\t\t\tthrow new Error(messages[status]);\n\t\t  }\n\t\t}\n\t  }\n\t}\n  \n\t/**\n\t * Inflate#push(data[, flush_mode]) -> Boolean\n\t * - data (Uint8Array|ArrayBuffer): input data\n\t * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE\n\t *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,\n\t *   `true` means Z_FINISH.\n\t *\n\t * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n\t * new output chunks. Returns `true` on success. If end of stream detected,\n\t * [[Inflate#onEnd]] will be called.\n\t *\n\t * `flush_mode` is not needed for normal operation, because end of stream\n\t * detected automatically. You may try to use it for advanced things, but\n\t * this functionality was not tested.\n\t *\n\t * On fail call [[Inflate#onEnd]] with error code and return false.\n\t *\n\t * ##### Example\n\t *\n\t * ```javascript\n\t * push(chunk, false); // push one of data chunks\n\t * ...\n\t * push(chunk, true);  // push last chunk\n\t * ```\n\t **/\n\tInflate$1.prototype.push = function (data, flush_mode) {\n\t  const strm = this.strm;\n\t  const chunkSize = this.options.chunkSize;\n\t  const dictionary = this.options.dictionary;\n\t  let status, _flush_mode, last_avail_out;\n  \n\t  if (this.ended) return false;\n  \n\t  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n\t  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;\n  \n\t  // Convert data if needed\n\t  if (toString.call(data) === '[object ArrayBuffer]') {\n\t\tstrm.input = new Uint8Array(data);\n\t  } else {\n\t\tstrm.input = data;\n\t  }\n  \n\t  strm.next_in = 0;\n\t  strm.avail_in = strm.input.length;\n  \n\t  for (;;) {\n\t\tif (strm.avail_out === 0) {\n\t\t  strm.output = new Uint8Array(chunkSize);\n\t\t  strm.next_out = 0;\n\t\t  strm.avail_out = chunkSize;\n\t\t}\n  \n\t\tstatus = inflate_1$2.inflate(strm, _flush_mode);\n  \n\t\tif (status === Z_NEED_DICT && dictionary) {\n\t\t  status = inflate_1$2.inflateSetDictionary(strm, dictionary);\n  \n\t\t  if (status === Z_OK) {\n\t\t\tstatus = inflate_1$2.inflate(strm, _flush_mode);\n\t\t  } else if (status === Z_DATA_ERROR) {\n\t\t\t// Replace code with more verbose\n\t\t\tstatus = Z_NEED_DICT;\n\t\t  }\n\t\t}\n  \n\t\t// Skip snyc markers if more data follows and not raw mode\n\t\twhile (strm.avail_in > 0 &&\n\t\t\t   status === Z_STREAM_END &&\n\t\t\t   strm.state.wrap > 0 &&\n\t\t\t   data[strm.next_in] !== 0)\n\t\t{\n\t\t  inflate_1$2.inflateReset(strm);\n\t\t  status = inflate_1$2.inflate(strm, _flush_mode);\n\t\t}\n  \n\t\tswitch (status) {\n\t\t  case Z_STREAM_ERROR:\n\t\t  case Z_DATA_ERROR:\n\t\t  case Z_NEED_DICT:\n\t\t  case Z_MEM_ERROR:\n\t\t\tthis.onEnd(status);\n\t\t\tthis.ended = true;\n\t\t\treturn false;\n\t\t}\n  \n\t\t// Remember real `avail_out` value, because we may patch out buffer content\n\t\t// to align utf8 strings boundaries.\n\t\tlast_avail_out = strm.avail_out;\n  \n\t\tif (strm.next_out) {\n\t\t  if (strm.avail_out === 0 || status === Z_STREAM_END) {\n  \n\t\t\tif (this.options.to === 'string') {\n  \n\t\t\t  let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n  \n\t\t\t  let tail = strm.next_out - next_out_utf8;\n\t\t\t  let utf8str = strings.buf2string(strm.output, next_out_utf8);\n  \n\t\t\t  // move tail & realign counters\n\t\t\t  strm.next_out = tail;\n\t\t\t  strm.avail_out = chunkSize - tail;\n\t\t\t  if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);\n  \n\t\t\t  this.onData(utf8str);\n  \n\t\t\t} else {\n\t\t\t  this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));\n\t\t\t}\n\t\t  }\n\t\t}\n  \n\t\t// Must repeat iteration if out buffer is full\n\t\tif (status === Z_OK && last_avail_out === 0) continue;\n  \n\t\t// Finalize if end of stream reached.\n\t\tif (status === Z_STREAM_END) {\n\t\t  status = inflate_1$2.inflateEnd(this.strm);\n\t\t  this.onEnd(status);\n\t\t  this.ended = true;\n\t\t  return true;\n\t\t}\n  \n\t\tif (strm.avail_in === 0) break;\n\t  }\n  \n\t  return true;\n\t};\n  \n  \n\t/**\n\t * Inflate#onData(chunk) -> Void\n\t * - chunk (Uint8Array|String): output data. When string output requested,\n\t *   each chunk will be string.\n\t *\n\t * By default, stores data blocks in `chunks[]` property and glue\n\t * those in `onEnd`. Override this handler, if you need another behaviour.\n\t **/\n\tInflate$1.prototype.onData = function (chunk) {\n\t  this.chunks.push(chunk);\n\t};\n  \n  \n\t/**\n\t * Inflate#onEnd(status) -> Void\n\t * - status (Number): inflate status. 0 (Z_OK) on success,\n\t *   other if not.\n\t *\n\t * Called either after you tell inflate that the input stream is\n\t * complete (Z_FINISH). By default - join collected chunks,\n\t * free memory and fill `results` / `err` properties.\n\t **/\n\tInflate$1.prototype.onEnd = function (status) {\n\t  // On success - join\n\t  if (status === Z_OK) {\n\t\tif (this.options.to === 'string') {\n\t\t  this.result = this.chunks.join('');\n\t\t} else {\n\t\t  this.result = common.flattenChunks(this.chunks);\n\t\t}\n\t  }\n\t  this.chunks = [];\n\t  this.err = status;\n\t  this.msg = this.strm.msg;\n\t};\n  \n  \n\t/**\n\t * inflate(data[, options]) -> Uint8Array|String\n\t * - data (Uint8Array): input data to decompress.\n\t * - options (Object): zlib inflate options.\n\t *\n\t * Decompress `data` with inflate/ungzip and `options`. Autodetect\n\t * format via wrapper header by default. That's why we don't provide\n\t * separate `ungzip` method.\n\t *\n\t * Supported options are:\n\t *\n\t * - windowBits\n\t *\n\t * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n\t * for more information.\n\t *\n\t * Sugar (options):\n\t *\n\t * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n\t *   negative windowBits implicitly.\n\t * - `to` (String) - if equal to 'string', then result will be converted\n\t *   from utf8 to utf16 (javascript) string. When string output requested,\n\t *   chunk length can differ from `chunkSize`, depending on content.\n\t *\n\t *\n\t * ##### Example:\n\t *\n\t * ```javascript\n\t * const pako = require('pako');\n\t * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));\n\t * let output;\n\t *\n\t * try {\n\t *   output = pako.inflate(input);\n\t * } catch (err) {\n\t *   console.log(err);\n\t * }\n\t * ```\n\t **/\n\tfunction inflate$1(input, options) {\n\t  const inflator = new Inflate$1(options);\n  \n\t  inflator.push(input);\n  \n\t  // That will never happens, if you don't cheat with options :)\n\t  if (inflator.err) throw inflator.msg || messages[inflator.err];\n  \n\t  return inflator.result;\n\t}\n  \n  \n\t/**\n\t * inflateRaw(data[, options]) -> Uint8Array|String\n\t * - data (Uint8Array): input data to decompress.\n\t * - options (Object): zlib inflate options.\n\t *\n\t * The same as [[inflate]], but creates raw data, without wrapper\n\t * (header and adler32 crc).\n\t **/\n\tfunction inflateRaw$1(input, options) {\n\t  options = options || {};\n\t  options.raw = true;\n\t  return inflate$1(input, options);\n\t}\n  \n  \n\t/**\n\t * ungzip(data[, options]) -> Uint8Array|String\n\t * - data (Uint8Array): input data to decompress.\n\t * - options (Object): zlib inflate options.\n\t *\n\t * Just shortcut to [[inflate]], because it autodetects format\n\t * by header.content. Done for convenience.\n\t **/\n  \n  \n\tvar Inflate_1$1 = Inflate$1;\n\tvar inflate_2 = inflate$1;\n\tvar inflateRaw_1$1 = inflateRaw$1;\n\tvar ungzip$1 = inflate$1;\n\tvar constants = constants$2;\n  \n\tvar inflate_1$1 = {\n\t\tInflate: Inflate_1$1,\n\t\tinflate: inflate_2,\n\t\tinflateRaw: inflateRaw_1$1,\n\t\tungzip: ungzip$1,\n\t\tconstants: constants\n\t};\n  \n\tconst { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;\n  \n\tconst { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;\n  \n  \n  \n\tvar Deflate_1 = Deflate;\n\tvar deflate_1 = deflate;\n\tvar deflateRaw_1 = deflateRaw;\n\tvar gzip_1 = gzip;\n\tvar Inflate_1 = Inflate;\n\tvar inflate_1 = inflate;\n\tvar inflateRaw_1 = inflateRaw;\n\tvar ungzip_1 = ungzip;\n\tvar constants_1 = constants$2;\n  \n\tvar pako = {\n\t\tDeflate: Deflate_1,\n\t\tdeflate: deflate_1,\n\t\tdeflateRaw: deflateRaw_1,\n\t\tgzip: gzip_1,\n\t\tInflate: Inflate_1,\n\t\tinflate: inflate_1,\n\t\tinflateRaw: inflateRaw_1,\n\t\tungzip: ungzip_1,\n\t\tconstants: constants_1\n\t};\n  \n\texports.Deflate = Deflate_1;\n\texports.Inflate = Inflate_1;\n\texports.constants = constants_1;\n\texports['default'] = pako;\n\texports.deflate = deflate_1;\n\texports.deflateRaw = deflateRaw_1;\n\texports.gzip = gzip_1;\n\texports.inflate = inflate_1;\n\texports.inflateRaw = inflateRaw_1;\n\texports.ungzip = ungzip_1;\n  \n\tObject.defineProperty(exports, '__esModule', { value: true });\n  \n  })));",
  "B7f9wua8VlO7KYuXdd82CetNi1jTZ22s6Op+eunEBEE=": "\n\"use strict\";\n\n// A single function to access globals that works\n// in the browser (which uses 'window') and on node.js (which uses 'global')\n\n\nfunction getGlobalThis () {\n\n\tconst isDefined = function (v) {\n\t\treturn typeof(v) !== \"undefined\"\n\t}\n\n\tif (isDefined(globalThis)) {\n        return globalThis;\n    }\n\n\tif (isDefined(self)) {\n        return self;\n    }\n\n\tif (isDefined(window)) {\n\t\twindow.global = window;\n\t\treturn window;\n\t}\n\n\tif (isDefined(global)) {\n\t\tglobal.window = global;\n\t\treturn global;\n\t}\n\n\t// Note: this might still return the wrong result!\n\tif (isDefined(this)) {\n        return this;\n    }\n    \n\tthrow new Error(\"Unable to locate global `this`\");\n  };\n\n  getGlobalThis().getGlobalThis = getGlobalThis;",
  "I4nt0QakXfVqEJ+SBZ+LK6b9762m1HdKeXWPovcow4Q=": "\n\"use strict\";\n\n// ------------------------------------------------------------------\n\nObject.defineSlot = function (obj, slotName, slotValue) {\n    const descriptor = {\n        configurable: true,\n        enumerable: false,\n        value: slotValue,\n        writable: true,\n    }\n\n    if (typeof(slotValue) === \"function\") {\n        slotValue.displayName = slotName\n    }\n    \n    Object.defineProperty(obj, slotName, descriptor)\n    //}\n}\n\nif (!String.prototype.capitalized) {\n    Object.defineSlot(String.prototype, \"capitalized\",\n        function () {\n            return this.replace(/\\b[a-z]/g, function (match) {\n                return match.toUpperCase();\n            });\n        }\n    )\n}\n// ------------------------------------------------------------------\n\n(class Base {\n    // Base class with helpful methods for cloning and slot creation \n\n    static isInBrowser () {\n        return (typeof (document) !== 'undefined')\n    }\n\n    isInBrowser () {\n        return (typeof (document) !== 'undefined')\n    }\n\n    static shared () {\n        if (!this._shared) {\n            this._shared = this.clone()\n        }\n        return this._shared\n    }\n\n    static type () {\n        return this.name\n    }\n\n    static initThisClass () {\n        //console.log(\"this.classType() = \", this.classType())\n        /*\n        if (typeof(getGlobalThis()[this.type()]) !== \"undefined\") {\n            const msg = \"WARNING: Attempt to redefine getGlobalThis()['\" + this.type() + \"']\"\n            console.warn(msg)\n            throw new Error(msg)\n        }*/\n\n        getGlobalThis()[this.type()] = this\n\n        if (this.prototype.hasOwnProperty(\"initPrototype\")) {\n            // each class inits it's own prototype, so make sure we only call our own initPrototype()\n            //this.prototype.initPrototype.apply(this.prototype)\n            this.prototype.initPrototype()\n        }\n        return this\n    }\n\n    static type () {\n        return this.name\n    }\n\n    type () {\n        return this.constructor.name\n    }\n\n    static clone () {\n        const obj = new this()\n        obj.init()\n        return obj\n    }\n\n    init () {\n        // subclasses should override to initialize\n    }\n\n    newSlot(slotName, initialValue) {\n        if (typeof (slotName) !== \"string\") {\n            throw new Error(\"slot name must be a string\");\n        }\n\n        if (initialValue === undefined) {\n            initialValue = null\n        };\n\n        const privateName = \"_\" + slotName;\n        this[privateName] = initialValue;\n\n        if (!this[slotName]) {\n            this[slotName] = function () {\n                return this[privateName];\n            }\n        }\n\n        const setterName = \"set\" + slotName.capitalized()\n\n        if (!this[setterName]) {\n            this[setterName] = function (newValue) {\n                this[privateName] = newValue;\n                return this;\n            }\n        }\n\n        return this;\n    }\n\n\n}.initThisClass());\n\n",
  "a4i6nBPaMK8jhd+C8rGo4G8X5sOZlyIk56Kf7PuQpwU=": "\"use strict\";\n\n/*\n\n  EnumerableWeakMap\n\n  A Map with WeakRef values internally, but external API looks normal (gets and sets values).\n  Unlike WeakMap, the keys can be strings, and it's entries are enumerable.\n\n  Unlike WeakMap, keys can be primitives such as strings and numbers.\n  All values should be objects (or null, numbers, strings) but cannot be undefined.\n\n*/\n\ngetGlobalThis().EnumerableWeakMap = (class EnumerableWeakMap {\n\n  constructor() {\n    this._refs = new Map()\n  }\n\n  assertValidValue (v) {\n    if (v === undefined) {\n      throw new Error(\"values cannot be undefined as unref returns undefined after collection\")\n      return\n    }\n  }\n\n  clear () {\n    this._refs.clear()\n  }\n\n  has (k) {\n    return this.get(k) !== undefined\n  }\n\n  get (k) {\n    const refs = this._refs\n    const wr = refs.get(k)\n    if (wr) { \n      // make sure it's not collected yet\n      const v = wr.deref()\n      if (v === undefined) {\n        refs.delete(k)\n        return undefined\n      }\n      return v\n    }\n    return undefined\n  }\n\n  set (k, v) {\n    this.assertValidValue(v)\n\n    if (this.get(k) !== v) {\n      this._refs.set(k, new WeakRef(v))\n    }\n    return this\n  }\n\n  delete (k) {\n    const hasKey = this.has(k) // this may delete it if weakref is stale\n    if (hasKey) {\n      this._refs.delete(k)\n    }\n    return hasKey\n  }\n\n  forEach (fn) { // fn (value, key, map)\n    // also removes collected keys\n    const refs = this._refs\n    let keysToRemove = null\n    // fn(value, key, set)\n    if (refs.size) {\n      refs.forEach((wr, k) => {\n        const v = wr.deref()\n        if (v !== undefined) {\n          fn(v, k, this)\n        } else {\n          if (!keysToRemove) {\n            keysToRemove = []\n          }\n          keysToRemove.push(k)\n        }\n      })\n    }\n    if (keysToRemove) {\n      keysToRemove.forEach(k => refs.delete(k))\n    }\n  }\n\n  removeCollectedValues () {\n    const refs = this._refs\n    const keysToRemove = []\n    if (refs.size) {\n      refs.forEach((wr, k) => {\n        const v = wr.deref()\n        if (v === undefined) {\n          keysToRemove.push(k)\n        }\n      })\n    }\n    keysToRemove.forEach(k => refs.delete(k))\n  }\n\n  count () {\n    this.removeCollectedValues()\n    // since weakrefs are only removed after a collection cycle, \n    // actual size of reachable objects may be lower than this \n    return this._refs.size \n  }\n\n  keysArray () {\n    const keys = []\n    this.forEach((v, k) => {\n      keys.push(k)\n    })\n    return keys\n    //return this._refs.keysArray()\n  }\n\n  /*\n  valuesSet () {\n    return new Set(this._refs.values())\n  }\n\n  hasValue (v) {\n    return this.valuesSet().has(v)\n  }\n\n  values () {\n    const weakValues = this._refs.values()\n    const values = weakValues.map(ref => ref.deref())\n    return values.filter(v => v !== undefined)\n  }\n  */\n});\n\n//EnumerableWeakMap.selfTest()\n\n",
  "jlEBmfmA7vRFQs6V/WUITyZ+fJQvtrRDkW5jp5tIx1U=": "\"use strict\";\n\n/*\n\n  EnumerableWeakSet\n\n  A Set with WeakRef values internally, but external API looks normal (gets and sets values).\n  Unlike WeakSet, it's values are enumerable.\n  \n  Internally, a EnumerableWeakMap of value puuid keys to weakrefs is used so we can\n  implement add(), has(), delete() etc quickly (i.e. without enumerating all weakref values).\n\n*/\n\ngetGlobalThis().EnumerableWeakSet = (class EnumerableWeakSet {\n\n  constructor () {\n    this._refs = new EnumerableWeakMap()\n  }\n\n  assertValidValue (v) {\n    if (v === undefined) {\n      throw new Error(\"values cannot be undefined as unref returns undefined after collection\")\n      return\n    }\n  }\n\n  add (v) {\n    this.assertValidValue(v)\n\n    const refs = this._refs\n    const pid = v.puuid()\n    if (!refs.has(pid)) {\n      refs.set(pid, v)\n    }\n\n    return this\n  }\n\n  clear () {\n    this._refs.clear()\n  }\n\n  delete (v) {\n    this.assertValidValue(v)\n\n    const hadValue = this.has(v)\n    if (hadValue) {\n      this._refs.delete(v.puuid())\n    }\n    return hadValue\n  }\n\n  has (v) {\n    this.assertValidValue(v)\n    return this._refs.has(v.puuid())\n  }\n\n  keys () {\n    return this.valuesArray()\n  }\n\n  values () {\n    return this.valuesArray()\n  }\n\n  count () {\n    return this._refs.count() // IMPORTANT: due to nature of WeakRefs, size may be smaller when actually used\n  }\n\n  forEach (fn) {\n    this._refs.forEach(v => fn(v, v, this))\n  }\n\n  // --- extras ---\n\n  entries () {\n    throw new Error(\"unimplemented\")\n  }\n\n  clearCollected () {\n    this.forEach(v => {}) // forEach will remove any stale weakrefs\n  }\n\n  valuesSet () {\n    const set = new Set()\n    this.forEach(v => set.add(v))\n    return set\n  }\n\n  valuesArray () {\n    const a = new Array()\n    this.forEach(v => a.push(v))\n    return a\n  }\n\n  keysArray () {\n    return this._refs.keysArray()\n  }\n\n});\n\n//EnumerableWeakSet.selfTest()\n\n",
  "FwqwkiBHpARHMfAo9WrAtA0W0czZRXTTbJbU9mbNkN0=": "/*\n\n\tAn object wrapper for the Reflect functions\n\n*/\n\ngetGlobalThis().Mirror = class Mirror extends Object {\n\t\n\tstatic reflectOn (aTarget) {\n\t\treturn this.clone().setTarget(aTarget)\n\t}\n\t\n\t// target \n\t\n\tsetTarget (aTarget) {\n\t\tthis._target = aTarget\n\t\treturn this\n\t}\n\t\n\ttarget () {\n\t\treturn this._target\n\t}\n\n\t// reflect methods\n\n\tdefineProperty (propertyKey, attributes) {\n\t\treturn Reflect.defineProperty(this.target(), propertyKey, attributes)\t\t\n\t}\n\t\n\tdeleteProperty (propertyKey) {\n\t\treturn Reflect.deleteProperty(this.target(), propertyKey)\n\t}\n\t\n\tget (propertyKey, optionalReceiver) {\n\t\treturn Reflect.get(this.target(), propertyKey, optionalReceiver)\n\t}\n\n\tgetOwnPropertyDescriptor (propertyKey) {\n\t\treturn Reflect.getOwnPropertyDescriptor(this.target(), propertyKey)\n\t}\n\t\n\tgetPrototype () {\n\t\treturn Reflect.getPrototypeOf(this.target())\n\t}\n\n\thas (propertyKey) {\n\t\treturn Reflect.has(this.target(), propertyKey)\n\t}\n\n\tisExtensible () {\n\t\treturn Reflect.isExtensible(this.target())\n\t}\n\n\townKeys () {\n\t\treturn Reflect.ownKeys(this.target())\n\t}\n\n\tpreventExtensions () {\n\t\treturn Reflect.preventExtensions(target)\n\t}\n\n\tset (propertyKey, value, optionalReceiver) {\n\t\treturn Reflect.set(this.target(), propertyKey, value, optionalReceiver)\n\t}\n\n\tsetPrototype (prototype) {\n\t\treturn Reflect.setPrototypeOf(this.target(), prototype)\n\t}\n\t\n}\n",
  "61Yu5kndMQcDtMkYjFmPkvrXTKHHtWglh2occFtJtGE=": "\"use strict\";\n\n/*\n\n    Type-ideal\n\n    Value/reference type related functions.\n\n    Example use:\n\n        if (Type.isNullOrUndefined(value)) { ...}\n\n\n    Known types:\n\n        Literals:\n\n            null\n            undefined\n            string\n            symbol\n            number\n\n        Other types:\n\n            object\n            array\n\n            Int8Array\n            Uint8Array\n            Uint8ClampedArray\n            Int16Array\n            Uint16Array\n            Int32Array\n            Uint32Array\n            Float32Array\n            Float64Array\n            BigInt64Array\n            BigUint64Array\n\n\n    More example uses:\n\n        const i8a = new Int8Array(6);   \n        console.log(\"is a Int8Array: \", Type.isInt8Array(i8a))\n\n*/\n\n\ngetGlobalThis().Type = (class Type extends Object {\n\n    static allTypeNames () {\n        return [\n            \"Array\",\n            \"Boolean\",\n            \"Map\",\n            \"Null\",\n            \"Number\",\n            \"Set\",\n            \"String\",\n            \"Symbol\",\n            \"Int8Array\",\n            \"Uint8Array\",\n            \"Uint8ClampedArray\",\n            \"Int16Array\",\n            \"Uint16Array\",\n            \"Int32Array\",\n            \"Uint32Array\",\n            \"Float32Array\",\n            \"Float64Array\",\n            \"BigInt64Array\",\n            \"BigUint64Array\",\n            //\"TypedArray\",\n            \"Undefined\",\n            \"Object\", // put object last so other types have preference\n        ]\n    }\n\n    static typedArrayTypeNames () {\n        return [\n            \"Int8Array\",\n            \"Uint8Array\",\n            \"Uint8ClampedArray\",\n            \"Int16Array\",\n            \"Uint16Array\",\n            \"Int32Array\",\n            \"Uint32Array\",\n            \"Float32Array\",\n            \"Float64Array\",\n            \"BigInt64Array\",\n            \"BigUint64Array\",\n        ]\n    }\n\n    static isClass (v) {\n        const result = typeof(v) === \"function\"\n            && /^class\\s/.test(Function.prototype.toString.call(v));\n\n        return result\n    }\n\n    static isLiteral (v) {\n        return  Type.isString(v) ||\n                Type.isNumber(v) ||\n                Type.isBoolean(v) ||\n                Type.isNull(v) ||\n                Type.isUndefined(v);\n    }\n\n    static isArray (value) {\n        return !Type.isNull(value) && \n                Type.isObject(value) && \n                value.__proto__ === ([]).__proto__ &&\n                !Type.isUndefined(value.length)\n    }\n\n    static isSet (value) {\n        return !Type.isNull(value) && \n            Type.isObject(value) && \n            value.__proto__ === Set.prototype \n    }\n\n    static isMap (value) {\n        return !Type.isNull(value) && \n            Type.isObject(value) && \n            value.__proto__ === Map.prototype \n    }  \n\n    static isIterator (value) {\n        return !Type.isNull(value) && \n                Type.isObject(value) && \n                typeof(value[Symbol.iterator]) === \"function\";\n    }\n\n    static isBoolean (value) {\n        return typeof(value) === \"boolean\"\n    }   \n\n    static isFunction (value) {\n        return typeof(value) === \"function\"\n    }  \n\n    static isUndefined (value) {\n        return value === undefined // safe in modern browsers, even safe in older browsers if undefined is not redefined\n    }\n\n    static isNull (value) {\n        return value === null\n    }\n\n    static isNullOrUndefined (value) {\n        return this.isUndefined(value) || this.isNull(value)\n    }\n\n    static isNaN (value) {\n        return isNaN(value)\n    }\n\n    static isNumber (value) {\n        return typeof(value) === \"number\"\n    }\n\n    static isObject (value) { \n        // WARNING: true for array and dictionary too!\n        return typeof(value) === \"object\" \n    }\n\n    static isString (value) {\n        return typeof(value) === \"string\"\n    } \n\n    static isSymbol (value) {\n        return typeof(value) === \"symbol\"\n    } \n\n    static isArrayBuffer (value) {\n        return Type.valueHasConstructor(value, ArrayBuffer);\n    }\n\n    // typed arrays \n\n    static valueHasConstructor (v, constructor) {  // private\n        return !Type.isNullOrUndefined(v) && (Object.getPrototypeOf(v) === constructor.prototype);\n    }\n\n    static isInt8Array (v) {\n        return Type.valueHasConstructor(v, Int8Array);\n    }\n\n    static isUint8Array (v) {\n        return Type.valueHasConstructor(v, Uint8Array);\n    }\n\n    static isUint8ClampedArray (v) {\n        return Type.valueHasConstructor(v, Uint8ClampedArray);\n    }\n\n    static isInt16Array (v) {\n        return Type.valueHasConstructor(v, Int16Array);\n    }\n\n    static isUint16Array (v) {\n        return Type.valueHasConstructor(v, Uint16Array);\n    }\n\n    static isInt32Array (v) {\n        return Type.valueHasConstructor(v, Int32Array);\n    }\n\n    static isUint32Array (v) {\n        return Type.valueHasConstructor(v, Uint32Array);\n    }\n    \n    static isFloat32Array (v) {\n        return Type.valueHasConstructor(v, Float32Array);\n    }\n\n    static isFloat64Array (v) {\n        return Type.valueHasConstructor(v, Float64Array);\n    }\n\n    static isBigInt64Array (v) {\n        return Type.valueHasConstructor(v, BigInt64Array);\n    }\n\n    static isBigUint64Array (v) {\n        return Type.valueHasConstructor(v, BigUint64Array);\n    }\n\n    \n    static isTypedArray (v) {\n        return Type.valueHasConstructor(v, TypedArray);\n    }\n    \n\n    // type name\n\n    static typeName (value) {\n        if (value === null) {\n            return \"Null\"\n        }\n\n        if (Type.isObject(value)) {\n            //return value.type()\n            return value.constructor.name\n        }\n\n        const typeNames = this.allTypeNames()\n        for (let i = 0; i < typeNames.length; i++) {\n            const typeName = typeNames[i]\n            const methodName = \"is\" + typeName\n            if (this[methodName].call(this, value)) {\n                return typeName\n            }\n        }\n        throw new Error(\"unable to identify type for value: \", value)\n    }\n\n    static typeNamesForValue (value) {\n        const matches = []\n        const typeNames = this.allTypeNames()\n        for (let i = 0; i < typeNames.length; i++) {\n            const typeName = typeNames[i]\n            const methodName = \"is\" + typeName\n            if (this[methodName].apply(this, [value])) {\n                matches.push(typeName)\n            }\n        }\n        return matches\n    }\n\n    static assertValueTypeNames (v, validTypeNames) {\n        let doesMatch = true\n        const foundTypeNames = this.typeNamesForValue(v)\n        if (foundTypeNames.length === validTypeNames.length) {\n            for (let i = 0; i < foundTypeNames.length; i ++) {\n                const name = foundTypeNames[i]\n                if (!validTypeNames.includes(name)) {\n                    doesMatch = false;\n                    break;\n                }\n            }\n        } else {\n            doesMatch = false\n        }\n        if (!doesMatch) {\n            throw new Error(JSON.stringify(validTypeNames) + \" != \" + JSON.stringify(foundTypeNames) )\n        }\n    }\n\n    static test () { // private\n        this.assertValueTypeNames(null, [\"Null\", \"Object\"])\n        this.assertValueTypeNames(undefined, [\"Undefined\"])\n        this.assertValueTypeNames(\"foo\", [\"String\"])\n        this.assertValueTypeNames(1, [\"Number\"])\n        this.assertValueTypeNames([], [\"Array\", \"Object\"])\n        this.assertValueTypeNames({} [\"Object\"])\n        this.assertValueTypeNames(new Int8Array(), [\"Int8Array\", \"Object\"])\n\n        // extras\n        //assert(Type.isNullOrUndefined(undefined))\n        //assert(Type.isNullOrUndefined(null))\n    }\n\n});\n\n\n//Type.test()",
  "fwsDSCAjSkfE3aW6kpSG7iRIDmtkCtr81VHZb4ACh+0=": "\n\"use strict\"; \n\n/*\n    \n    Weird JS things:\n\n    Some of the primitives such as Array, Set, Map have constructors which \n    do not inherit from Object (they and the Object constructor all inherit \n    from constructor named \"\") but their constructor prototypes *do* inherit \n    from Object.prototype.\n\n    To make this consistent (so we can inherit class methods) we do\n    the following:\n\n*/\n\n{\n    const classesToFix = [\n        Array, \n        Boolean, \n        Date, \n        Error, \n        Image, \n        Set, \n        Map, \n        Number, \n        String,\n        ArrayBuffer\n    ]\n    classesToFix.forEach(aClass => aClass.__proto__ = Object)\n}\n\n/*\n\n    Object-helpers\n    \n    Some functions to help us implement categories.\n\n*/\n\nObject.defineSlot = function (obj, slotName, slotValue) {\n    if (Object.getOwnPropertyDescriptor(slotName)) {\n        // TODO: raise exception if it exists? Safer for categories?\n        this[slotName] = slotValue\n    } else {\n        const descriptor = {\n            configurable: true,\n            enumerable: false,\n            value: slotValue,\n            writable: true,\n        }\n\n        // this breaks on prototypes\n        /*\n        if (typeof (slotValue) === \"function\") {\n            let objType = null\n            try {\n                //if (obj.type) {\n                    objType = obj.type()\n                //}\n            } catch (e) {\n                //console.warn(\"can't get type on \", obj)\n            }\n\n            if (objType) {\n                //  debugger;\n                slotValue.displayName = objType + \".\" + slotName\n                //console.log(\"slotValue.displayName: \", slotValue.displayName)\n            } else {\n                slotValue.displayName = slotName\n            }\n        }\n        */\n\n        Object.defineProperty(obj, slotName, descriptor)\n    }\n}\n\n/*\nTest = class Test {\n    setup () {\n        this._foo = 123\n    }\n}\n \nObject.defineSlot(Test.prototype, \"_foo\", \"bar\")\n \nlet test = new Test()\ntest.setup()\n \nconsole.log(test)\nlet d = Reflect.getOwnPropertyDescriptor(test, \"_foo\")\nconsole.log(d)\n \nif (d.enumerable) {\n    console.log(\"is enumerable\")\n} else {\n    console.log(\"is not enumberable\")\n}\n*/\n\nObject.defineSlots = function (obj, dict) {\n    Object.keys(dict).forEach((slotName) => {\n        const slotValue = dict[slotName]\n        Object.defineSlot(obj, slotName, slotValue)\n    })\n};\n\n\nObject.defineSlotSafely = function(obj, slotName, slotValue) {\n    const nameForObj = function (obj) {\n        let name = \"?\" \n        try {\n            if (obj.hasOwnProperty(\"name\")) {\n                name = obj.name + \"\"\n            } else {\n                name = obj.constructor.name + \".prototype\"\n            }\n        } catch (e) {\n            name = \"[error getting name]\"\n        }\n        return name\n    }\n\n    if (obj.hasOwnProperty(slotName)) {\n        const msg = nameForObj(obj) + \".\" + slotName + \" slot already exists\"\n        console.log(msg)\n        throw new Error(msg)\n    } else {\n        //const msg = nameForObj(obj) + \".\" + slotName + \" DEFINED\"\n        //console.log(msg)\n        Object.defineSlot(obj, slotName, slotValue)\n    }\n};\n\nObject.defineSlotsSafely = function (obj, dict) {\n    Object.keys(dict).forEach((slotName) => {\n        const slotValue = dict[slotName]\n        Object.defineSlotSafely(obj, slotName, slotValue)\n\n    })\n};\n\n\nObject.defineSlot(Object, \"initThisCategory\", function () {\n    // define this first, so we can use it to more cleanly define our\n    // Object categories.\n    //\n    // This is a bit of a hack to implement class categories in Javascript\n    // sanity check: check name to ensure we're only using this on a category\n\n    const hasTwoPartName = this.name.split(\"_\").length === 2\n    if (!hasTwoPartName) {\n        const msg = \"category class name '\" + this.type() + \"' doesn't match expected pattern of ClassName-categoryName.\"\n        throw new Error(msg)\n    }\n\n    // copy category methods to parent class\n\n    const getSlotsDictOn = (obj) => {\n        const keys = Reflect.ownKeys(obj)\n        const dict = {}\n        keys.forEach(k => {\n            const v = obj[k]\n            dict[k] = v\n            /*\n            // this doesn't seem to get the correct .name(?)\n            if (typeof (v) === \"function\" && k !== \"constructor\") {\n                //v._categoryName = this.name // add a comment for category source \n            }\n            */\n        })\n        return dict\n    }\n\n\n\n    const parent = this.__proto__ //superClass()\n\n    // copy instance slots\n    const instanceSlotsDict = getSlotsDictOn(this.prototype)\n    delete instanceSlotsDict[\"constructor\"]\n    delete instanceSlotsDict[\"prototype\"]\n    Object.defineSlotsSafely(parent.prototype, instanceSlotsDict)\n\n    // copy class slots\n    const classSlotsDict = getSlotsDictOn(this)\n    delete classSlotsDict[\"length\"] // FIXME: hack for collection types\n    delete classSlotsDict[\"name\"]\n    delete classSlotsDict[\"prototype\"]\n    Object.defineSlotsSafely(parent, classSlotsDict)\n\n    /*\n    console.log(\"this.name = '\" + this.name + \"'\")\n    console.log(\"this.__proto__.name = '\" + this.__proto__.name + \"'\")\n    console.log(\"this.__proto__.__proto__.name = '\" + this.__proto__.__proto__.name + \"'\")\n    */\n    \n    if (this.__proto__ !== Object) { // don't need to call super on base class\n        // fix super in instance methods\n        Object.setPrototypeOf(this.prototype, this.__proto__.__proto__.prototype); \n\n        // fix super in static/class methods\n        // need to do this *after* instance methods super fix as it changes __proto__\n        Object.setPrototypeOf(this, parent.__proto__); \n\n        // related to super, see:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super\n    }\n\n    return this\n});\n\n\n",
  "ZSbRfeNpNLhUjwl/U1w3/vtkuTtX8O6SEOrFj5kP7uw=": "\"use strict\";\n\n/*\n\n    Object_copying\n    \n    copying related behavior \n\n*/\n\ngetGlobalThis().MissingSlotError = (class MissingSlotError extends Error {\n    constructor(message) {\n      super(message);\n      //debugger;\n      this.name = \"MissingSlotError\"; // not sure why this isn't already set...\n    }\n});\n  \n\n(class Object_copying extends Object {\n\n    // --- copying ---\n\n    shallowCopy () {\n        const copy = Object.assign({}, this);\n        return copy\n    }\n \n    duplicate () {\n        assert(this.isInstance())\n        const instance = this.thisClass().clone().copyFrom(this)\n        instance.duplicateSlotValuesFrom(this) // TODO: what about lazy slots?\n        return instance\n    }\n \n    copy () {\n        return this.duplicate()\n    }\n \n    copyFromAndIgnoreMissingSlots (anObject) { // prefer to use this externally so it's clear what it's doing\n        return this.copyFrom (anObject, true) \n    }\n    \n    copyFrom (anObject, ingoreMissingSlots = false) { \n        // externally, when you need:\n        //   copyFrom (anObject, true) \n        // please use: \n        //   copyFromAndIgnoreMissingSlots() e\n        // instead\n        //\n        // WARNING: subclasses will need to customize this\n        this.duplicateSlotValuesFrom(anObject, ingoreMissingSlots)\n        return this\n    }\n \n    duplicateSlotValuesFrom (otherObject, ingoreMissingSlots = false) {\n        // TODO: add a type check of some kind?\n \n        this.thisPrototype().allSlotsMap().forEachKV((slotName, mySlot) => {\n            const otherSlot = otherObject.thisPrototype().slotNamed(slotName)\n            const hasSlot = !Type.isNullOrUndefined(otherSlot)\n            if (hasSlot) {\n                const v = otherSlot.onInstanceGetValue(otherObject) // TODO: what about lazzy slots?\n                const dop = otherSlot.duplicateOp()\n    \n                if (dop === \"copyValue\") {\n                    mySlot.onInstanceSetValue(this, v)\n                } else if (dop === \"duplicate\" && v && v.duplicate) {\n                    const dup = v.duplicate()\n                    mySlot.onInstanceSetValue(this, dup)\n                } else if (dop === \"nop\") {\n                    // nop\n                } else {\n                    throw new Error(\"unsupported slot duplicate operation: '\" +  dop + \"'\")\n                }\n            } else if (!ingoreMissingSlots) {\n                throw new MissingSlotError()\n            }\n        })\n        return this\n    }\n \n    copySlotValuesFrom (otherObject) {\n        this.thisPrototype().allSlotsMap().forEachKV((slotName, mySlot) => {\n            const otherSlot = otherObject.thisPrototype().slotNamed(slotName)\n            const v = otherSlot.onInstanceGetValue(otherObject)\n            mySlot.onInstanceSetValue(this, v)\n        })\n        return this\n    }\n\n}).initThisCategory();\n\n",
  "0/X+WuMn8Wnk3QI21srDzZep3JW0RPhmUA7UTdWmIns=": "\"use strict\";\n\n/*\n\n    Object_class\n    \n    Some added state and behavior on Object class. \n\n*/\n\n\n(class Object_class extends Object {\n\n    static isClass () {\n        return true\n    }\n\n    static isInstance () {\n        return false\n    }\n\n    static isPrototype () {\n        return false\n    }\n\n    type () {\n        return this.constructor.name\n    }\n\n    superClass () {\n        return this.thisClass().superClass()\n    }\n\n    thisClass () {\n        if (this.isPrototype()) {\n            // it's an prototype\n            return this.constructor\n        }\n\n        // otherwise, it's an instance\n        return this.__proto__.constructor\n    }\n\n    isInstance () {\n        return !this.isPrototype() && !this.isClass()\n    }\n\n    isPrototype () {\n        return this.constructor.prototype === this\n    }\n \n    isInstance () {\n        return !this.isPrototype()\n    }\n \n    isClass () {\n        return false\n    }\n \n    thisClass () {\n        if (this.isPrototype()) {\n            return this.constructor\n        }\n        return this.__proto__.constructor\n    }\n \n    thisPrototype () {\n        assert(this.isInstance())\n        const prototype = this.__proto__\n        assert(prototype.isPrototype)\n        return prototype\n    }\n\n    // --- class methods ---\n\n    static clone () {\n        const obj = new this()\n        obj.init()\n        obj.afterInit()\n        return obj\n    }\n\n    static type () {\n        return this.name\n    }\n\n    static isClass () {\n        return true\n    }\n\n    static getClassNamed (aName) {\n        if (Type.isNullOrUndefined(aName)) {\n            return undefined\n        }\n        return getGlobalThis()[aName]\n    }\n\n    static parentClass () {\n        const p = this.__proto__\n\n        if (p && p.type) {\n            return p\n        }\n\n        return null\n    }\n\n    static addChildClass (aClass) {\n        this.childClasses().add(aClass)\n        return this\n    }\n\n    static globals () {\n        return getGlobalThis()\n    }\n\n    static initClass () {\n        this.newClassSlot(\"allClassesSet\", new Set())\n    }\n\n    static findAncestorClasses () {\n        const results = []\n        let aClass = this.parentClass()\n        while (aClass && aClass.parentClass) {\n            results.push(aClass)\n            aClass = aClass.parentClass()\n        }\n        return results\n    }\n\n\n    static newClassSlot (slotName, slotValue) {\n        const ivarName = \"_\" + slotName\n        const assert = function (aBool) {\n            if (!aBool) {\n                throw new Error(\"failed assert\")\n            }\n        }\n\n        // define ivar\n        {\n            const hasIvar = !Type.isUndefined(Object.getOwnPropertyDescriptor(this, ivarName))\n            assert(!hasIvar)\n            const descriptor = {\n                configurable: true,\n                enumerable: false,\n                value: slotValue,\n                writable: true,\n            }\n            Object.defineProperty(this, ivarName, descriptor)\n        }\n\n        // define getter\n        {\n            const hasGetter = !Type.isUndefined(Object.getOwnPropertyDescriptor(this, slotName))\n            assert(!hasGetter)\n            //const getterFunc = eval('function () { return this.' + ivarName + '; }');\n            const getterFunc = function () { return this[ivarName]; };\n            const descriptor = {\n                configurable: true,\n                enumerable: false,\n                value: getterFunc,\n                writable: true,\n            }\n            Object.defineProperty(this, slotName, descriptor)\n        }\n\n        // define setter\n        {\n\n            const setterName = \"set\" + slotName.capitalized()\n            const setterFunc = function (v) { this[ivarName] = v; return this };\n            const descriptor = {\n                configurable: true,\n                enumerable: false,\n                value: setterFunc,\n                writable: true,\n            }\n            Object.defineProperty(this, setterName, descriptor)\n        }\n\n        return this\n    }\n\n    static initThisClass () { // called on every class which we create\n        this.defineClassGlobally()\n\n        // setup ancestor list\n        // could become invalid if class structure dynamically changes\n        this.newClassSlot(\"ancestorClasses\", this.findAncestorClasses())\n        this.newClassSlot(\"childClasses\", new Set())\n\n        // add as class to parent\n        const p = this.parentClass()\n        if (p && p.addChildClass) {\n            p.addChildClass(this)\n        }\n\n        if (this.hasOwnProperty(\"initClass\")) {\n            // Only called if method defined on this class.\n            // This method should *not* call super.initClass().\n            this.initClass()\n        }\n\n        this.prototype.setupPrototype()\n\n        this.addToAllClasses()\n        return this\n    }\n\n    setupPrototype () {\n        if (!this.isPrototype()) {\n            throw new Error(\"setupPrototype called on non-prototype\")\n        }\n\n        /// each proto has it's own set of slots - use justNewSlot as newSlot needs to check the slots list\n        Object.defineSlot(this, \"_slotsMap\", new Map())\n        Object.defineSlot(this, \"_allSlotsMap\", new Map())\n        this.setupAllSlotsMap()\n\n        // We need to separate initPrototypeSlots, initSlots, initPrototype as\n        // initializing some slots may depend on others already existing.\n        \n        // Slot init ordering may be important as well and why slots should be stored in \n        // an array with a name->slot map used as an index.\n\n        if (this.hasOwnProperty(\"initPrototypeSlots\")) {\n            // Only called if method defined on this class.\n            this.initPrototypeSlots() // This method should NOT call super\n        }\n\n        this.initSlots()\n\n        if (this.hasOwnProperty(\"initPrototype\")) {\n            this.initPrototype() // This method should NOT call super\n        }\n\n        return this\n    }\n\n\n    allSlotsMap () {\n        return this._allSlotsMap\n    }\n\n    setupAllSlotsMap () {\n        //debugger;\n        if (!this.isPrototype()) {\n            throw new Error(\"setupAllSlotsMap called on non-prototype\")\n        }\n\n        const m = this.allSlotsMap()\n        //console.log(\"*** \" + this.type() + \" setupAllSlotsMap\")\n\n        //assert(this.isPrototype())\n        this.forEachSlot(slot => {\n            const k = slot.name()\n            if (!m.has(k)) { // to handle overrides\n                m.set(k, slot) \n            }\n        })\n    }\n\n    forEachSlotKV (fn) {\n        this.forEachSlot(slot => fn(slot.name(), slot))\n    }\n\n    forEachPrototype (fn) { // starts with this, and follows tree upwards\n        let proto = this\n        if(this.isInstance()) {\n            proto = this.__proto__\n        }\n\n        while (proto) {\n            fn(proto) \n            //console.log(\"proto is \", proto.type())\n            if (proto === proto.__proto__) {\n                throw new Error(\"__proto__ loop detected in \" + proto.type())\n                break;\n            } else {\n                proto = proto.__proto__\n            }\n        }\n    }\n\n    forEachSlot (fn) {\n        this.forEachPrototype(proto => {\n            if (Object.hasOwn(proto, \"_slotsMap\")) {\n                proto._slotsMap.forEach((slot, key, map) => {\n                    fn(slot)\n                })\n            }\n        })\n    }\n\n    initSlots () {\n        this.slotsMap().forEach(slot => slot.setupInOwner())\n    }\n\n    // ----------------------------------------\n\n\n    // ----------------------------------------\n\n\n    initPrototype () {\n        // called after setupInOwner is called on each slot\n        // so we have a chance to initialize things after all slots are set up \n    }\n\n    slotsMap () {\n        return this._slotsMap\n    }\n\n    static defineClassGlobally () {\n        const className = this.type()\n        if (Type.isUndefined(this.globals()[className])) {\n            this.globals()[className] = this\n            //console.log(this.type() + \".initThisClass()\")\n        } else if (this.type() !== \"Object\") {\n            const msg = \"WARNING: Attempt to redefine getGlobalThis()['\" + className + \"']\"\n            console.warn(msg)\n            throw new Error(msg)\n        }\n    }\n\n    static superClass () {\n        return this.__proto__\n    }\n\n    static addToAllClasses () {\n        //console.log(\"addToAllClasses '\" + this.type() + \"'\")\n        if (this.allClassesSet().has(this)) {\n            throw new Error(\"attempt to call initThisClass twice on class '\" + this.type() + \"'\")\n        }\n        this.allClassesSet().add(this)\n        return this\n    }\n\n    static allSubclasses () {\n        return this.allClassesSet().select(aClass => aClass.hasAncestorClass(this))\n    }\n\n    static subclasses () {\n        return this.allClassesSet().select(aClass => aClass.superClass() === this)\n    }\n\n    static hasAncestorClass (aClass) {\n        const sc = this.superClass()\n\n        if (sc === aClass) {\n            return true\n        }\n\n        if (sc === Object || !sc.hasAncestorClass) {\n            return false\n        }\n\n        return sc.hasAncestorClass(aClass)\n    }\n\n    static eachSlot (obj, fn) {\n        Object.keys(obj).forEach(k => fn(k, obj[k]))\n    }\n\n    static isKindOf (aClass) {\n        //assert(this.isClass())\n        //assert(aClass.isClass())\n\n        if (this.name === \"\") {\n            // anything touching the root \"\" class seems to crash Chrome,\n            // so let's be carefull to leave it alone\n            return false\n        }\n\n        if (this === aClass) {\n            return true\n        }\n\n        let proto = this.__proto__\n        if (proto && proto.name !== \"\") {\n            return proto.isKindOf.call(proto, aClass)\n        }\n\n        return false\n    }\n\n}).initThisCategory();\n\nObject.initThisClass();\n",
  "cqE0cye/0pihWCLR+8A9zDzXWFyt3URBRUwQ4DXQX7c=": "//\"use strict\";\n\n/*\n\n    Object_ideal\n    \n    Some added state and behavior on Object prototype. \n\n*/\n\n(class Object_ideal extends Object {\n\n    // ---- prototype ---\n \n    initPrototypeSlots () {\n        Object.defineSlot(this, \"_hasDoneInit\", false)\n        Object.defineSlot(this, \"_shouldScheduleDidInit\", false)\n        Object.defineSlot(this, \"_mutationObservers\", null)\n        Object.defineSlot(this, \"_shouldStore\", true)\n    }\n\n    isKindOf (aClass) {\n        return this.thisClass().isKindOf(aClass)\n    }\n\n    typeCategory () {\n        if (this.isInstance()) {\n            return \"instance\"\n        } else if (this.isPrototype()) {\n            return \"prototype\"\n        } else if (this.isClass()) {\n            return \"class\"\n        }\n        throw new Error(\"unable to identify\")\n    }\n \n    fullTypeName () {\n        return this.type() + \" \" + this.typeCategory()\n    }\n \n    // --- perform ---\n \n    perform (methodName, arg1, arg2, arg3) {\n        const f = this[methodName]\n        if (f) {\n            return f.call(this, arg1, arg2, arg3)\n        }\n        throw new Error(this.typeId() + \" does not respond to '\" + methodName + \"'\")\n    }\n \n    performIfResponding (methodName, arg1, arg2, arg3) {\n        const f = this[methodName]\n        if (f) {\n            return f.call(this, arg1, arg2, arg3)\n        }\n    }\n \n    // --- slots ---\n\n    // normal at() etc names would conflict with Array etc\n\n    atSlot (key) {\n        return this[key]\n    }\n \n    atSlotPut (key, value) {\n        this[key] = value\n        return this\n    }\n \n    removeSlotAt (key) {\n        delete this[key]\n        return this\n    }\n    \n    // --- enumeration ---\n \n    ownKVMap (fn) {\n        return Object.keys(this).map(k => fn(k, this[k]))\n    }\n \n    ownForEachValue (fn) {\n        Object.keys(this).forEach(k => fn(this[k]))\n        return this\n    }\n \n    ownForEachKey(fn) {\n        Object.keys(this).forEach(k => fn(k))\n        return this\n    }\n \n    ownForEachKV (fn) {\n        Object.keys(this).forEach(k => fn(k, this[k]))\n        return this\n    }\n \n    // --- equality ---\n    \n    isEqual (anObject) {\n        // compare like we would two dictionaries\n        // only checks enumerable properties\n        // for ProtoClass, we'll compare slot values instead\n        const keys = Object.keys(this)\n        const otherKeys = Object.keys(anObject)\n        if (keys.length !== otherKeys.length) {\n            return false\n        }\n \n        const firstKeyWithUnequalValue = keys.detect(k => this.getOwnProperty(k) !== anObject.getOwnProperty(k))\n        return !Type.isNullOrUndefined(firstKeyWithUnequalValue)\n    }\n \n    getOwnProperty (key) {\n        if (this.hasOwnProperty(key)) {\n            return this[key]\n        }\n        return undefined\n    }\n \n    // --- debugging helpers ---\n \n    slotValuePath (slotName, entries = []) { // for debugging serialization/deserialization\n        const entry = [this.fullTypeName(), this.getOwnProperty(slotName)]\n        entries.push(entry)\n \n        const proto = this.__proto__\n        if (proto) { // Object.prototype.__proto__ = null\n            //proto.constructor.name !== \"\") {\n            return proto.slotValuePath.apply(proto, [slotName, entries])\n        }\n \n        return entries\n    }\n\n    // --- scheduling ---\n\n    scheduleMethod (methodName, priority) {\n        // send at end of event loop\n        // methods with the same name and target will only be sent once\n        return SyncScheduler.shared().scheduleTargetAndMethod(this, methodName, priority)\n    }\n\n}).initThisCategory();\n\nObject.prototype.initPrototypeSlots()\n",
  "qRVaUN6jhzWm7rTB4p+J4RzXQBBCsFamW64uoql1zPs=": "\"use strict\";\n\n\n/* \n\n    Object_init\n\n    Initialization related behavior, and some important notes related to initialization.\n    \n    Some initialization may have to wait until other objects have initialized. \n    \n    These are some states the object may need to wait for, \n    and how to handle completing initialization at those points:\n\n    - initAfterEventLoop() (end of current event loop)\n\n        In your class's init() method, call this.setShouldScheduleDidInit(true) and implement didInit()\n        This will cause the didInit method called after Object.init() inside Object.clone() to \n        be scheduled for the end of the current event loop.\n\n    - initAfterDeserialization of the ObjectPool that created the object is complete (similar to awakeFromNib:)\n\n        Implement a didLoadFromStore(aStore) method. \n        This will be called (on the deserialized objects) after the ObjectPool has finished deserializing.\n        Deserialization currently takes place synchonously within a single event loop.\n\n    - appDidInit (when the Application posts an appDidInit notification)\n\n        Implement an appDidInit() method, and in init() call this.listenForAppdidInit().\n\n\n*/\n\n(class Object_init extends Object {\n\n    setShouldScheduleDidInit (aBool) {\n        this._shouldScheduleDidInit = aBool\n        return this\n    }\n\n    shouldScheduleDidInit () {\n        return this._shouldScheduleDidInit\n    }\n\n    init () { \n        // this is called by Object.clone()\n        // here to be overridden by subclasses\n        return this\n    }\n\n    afterInit () {\n        assert(!this.hasDoneInit()) // sanity check\n        if (this.shouldScheduleDidInit()) {\n            this.scheduleDidInit() // implemented in Object_init.js\n        } else {\n            this.didInit()\n        }\n    }\n\n    didInit () {\n        assert(!this.hasDoneInit())\n        this.setHasDoneInit(true)\n    }\n\n    hasDoneInit () {\n        return this._hasDoneInit === true\n    }\n    \n    setHasDoneInit (aBool) {\n        assert(this._hasDoneInit === false)\n        this._hasDoneInit = aBool\n        return this\n    }\n    \n    scheduleDidInit () {\n        //console.log(this.typeId() + \" \" + this.debugTypeId() + \" scheduleDidInit\")\n        assert(this.shouldScheduleDidInit())\n        assert(!this.hasDoneInit())\n        this.scheduleMethod(\"didInit\") \n    }\n\n    // -------------------------\n\n    /*\n    listenForAppDidInit () {\n        this.watchOnceForNote(\"appDidInit\")\n    }\n    */\n\n}).initThisCategory();\n",
  "/ux9/wmCEnQW7s+qKZhnSYIUQBdvcpg81RQAvqImNGk=": "\"use strict\";\n\n/*\n\n    Object_notification\n\n*/\n\n\n(class Object_notification extends Object {\n\n    prepareToRetire () { \n        // opportunity to remove notification observers, event listeners, etc\n        //this.assertNotRetired()\n        this.removeAllNotificationObservations()\n        this.removeScheduledActions()\n    }\n\n    // -------------------------------------------------\n \n    removeAllNotificationObservations () {\n        if (getGlobalThis()[\"BMNotificationCenter\"]) {\n            BMNotificationCenter.shared().removeObserver(this)\n        }\n    }\n \n    removeScheduledActions () {\n        if (getGlobalThis()[\"SyncScheduler\"]) {\n            SyncScheduler.shared().unscheduleTarget(this)\n        }\n    }\n\n    // --- notification helpers --- \n\n    watchOnceForNote (aNoteName) {\n        const obs = BMNotificationCenter.shared().newObservation()\n        obs.setName(aNoteName)\n        obs.setObserver(this)\n        obs.setIsOneShot(true)\n        obs.startWatching()\n        //this.debugLog(\".watchOnceForNote('\" + aNoteName + \"')\")\n        return obs\n    }\n\n    watchOnceForNoteFrom (aNoteName, sender) {\n        return this.watchOnceForNote(aNoteName).setSender(sender)\n    }\n\n    newNoteNamed (aNoteName) {\n        const note = BMNotificationCenter.shared().newNote()\n        note.setSender(this)\n        note.setName(aNoteName)\n        return note\n    }\n\n    postNoteNamed (aNoteName) {\n        const note = this.newNoteNamed(aNoteName)\n        note.post()\n        //this.debugLog(\".postNoteNamed('\" + aNoteName + \"')\")\n        return note\n    }\n\n    scheduleSelfFor (aMethodName, milliseconds) {\n        return SyncScheduler.shared().scheduleTargetAndMethod(this, aMethodName, milliseconds)\n    }\n\n}).initThisCategory();\n",
  "dBcfAPEnyRM9uGrWKFY1xwnIceF4nIRHIkDzeQAMrNc=": "\"use strict\";\n\n\n(class Object_puuid extends Object {\n\n    /*\n    static newUniqueInstanceId () {\n        const uuid_a = Math.floor(Math.random() * Math.pow(10, 17)).toBase64()\n        const uuid_b = Math.floor(Math.random() * Math.pow(10, 17)).toBase64()\n        return uuid_a + uuid_b\n    }\n\n    static newUuid () {\n        return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n            let r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    }\n    */\n\n    static newUuid () { \n        // TODO: move this JS UUID when it's added to JS standard lib\n        const uuidPart = () => { \n            const bigFloat = Math.random() * Math.pow(10, 17)\n            const bigInt = Math.floor(bigFloat)\n            const b64 = bigInt.toBase64()\n            return b64\n        }\n        return uuidPart() + uuidPart()\n    }\n\n   // _puuid: undefined,\n\n    puuid () {\n        if (!this.hasPuuid()) {\n            this.setPuuid(Object.newUuid())\n        }\n\n        return this[\"_puuid\"]\n    }\n\n    hasPuuid () {\n        return Object.prototype.hasOwnProperty.call(this, \"_puuid\")\n    }\n\n    setPuuid (puuid) {\n        assert(!Type.isNullOrUndefined(puuid))\n        if (this.hasPuuid()) {\n            const oldPid = this[\"_puuid\"]\n            this.defaultStore().onObjectUpdatePid(this, oldPid, puuid)\n        }\n        Object.defineSlot(this, \"_puuid\", puuid) // so _puuid isn't enumerable\n        return this\n    }\n\n    typePuuid () {\n        const puuid = this.puuid()\n        if (Type.isFunction(this.type)) {\n            return this.type() + \"_\" + puuid\n        }\n        return Type.typeName(this) + \"_\" + puuid\n    }\n\n    typeId () {\n        return this.typePuuid()\n    }\n\n    debugTypeId () {\n        const puuid = this.puuid().substr(0,3)\n\n        if (Type.isFunction(this.type)) {\n            return this.type() + \"_\" + puuid\n        }\n        return Type.typeName(this) + \"_\" + puuid\n    }\n\n    debugTypeIdSpacer () {\n        return \" -> \"\n    }\n\n}).initThisCategory();\n",
  "0mjLdAKyUkcG+FEFJ7jIrhhWn23YQd3V34YqKh0aXaA=": "\"use strict\";\n\n/*\n\n    Object_mutation \n\n    Object category to support observing slot value changes (i.e. \"mutations\").\n\n*/\n\n(class Object_mutation extends Object {\n\n    mutatorMethodNamesSet () {\n        throw new Error(\"undefined mutatorMethodNamesSet on '\" + this.type() + \"' class\")\n    }\n    \n    setupMutatorHooks () {\n        // this is to be called on a prototype\n        // it copies each slot whose name is in mutatorMethodNamesSet\n        // to unhooked_<slotName>, and implements a slot which calls the\n        // unhooked version after calling this.willMutate(slotName)\n        \n        this.mutatorMethodNamesSet().forEach((slotName) => {\n            const unhookedName = \"unhooked_\" + slotName\n            const unhookedFunction = this[slotName]\n    \n            Object.defineSlot(this, unhookedName, unhookedFunction)\n    \n            const hookedFunction = function () {\n                this.willMutate(slotName)\n                const result = this[unhookedName].apply(this, arguments)\n                this.didMutate(slotName)\n    \n                //let argsString = []\n                //for (let i=0; i < arguments.length; i++) {\n                //    if (i !== 0) { argsString += \", \" }\n                //    argsString += String(arguments[i])\n                //}\n                //console.log(\"hooked Array \" + slotName + \"(\" + argsString + \")\") \n                //console.log(\"result = \" + result)\n    \n                return result\n            }\n    \n            Object.defineSlot(this, slotName, hookedFunction)\n        })\n    }\n\n    // -----------------------------------------\n\n    setMutationObservers (aSet) {\n        this._mutationObservers = aSet\n        return this\n    }\n\n    mutationObservers () {\n        if (!this._mutationObservers) {\n            this.setMutationObservers(new Set())\n        }\n        return this._mutationObservers\n    }\n\n    addMutationObserver (anObserver) {\n        this.mutationObservers().add(anObserver)\n        return this\n    }\n\n    removeMutationObserver (anObserver) {\n        assert(anObserver)\n        this.mutationObservers().delete(anObserver)\n        return this\n    }\n\n    // ------\n\n    willMutate () {\n        /*\n        const mos = this._mutationObservers\n        if (mos) {\n            mos.forEach(v => { \n                v.onWillMutateObject(this)\n            })\n        }\n        */\n    }\n\n    didMutate () {\n        const mos = this._mutationObservers\n        if (mos) {\n            //console.log(\"\" + this.debugTypeId() + \".didMutate()\")\n            mos.forEach(obs => {\n                obs.onDidMutateObject(this)\n            })\n        }\n    }\n\n}).initThisCategory();\n",
  "Rx3i+H8QYIOBUBXfqu1kpTd+6Sw347dEUj7EdNlsVhg=": "\"use strict\";\n\n/*\n\n    Object_timeouts\n\n        Sometimes we can't use the SyncScheduler as we have to make sure \n        something happens *after* the current event loop ends (and control is returned to the browser),\n        but scheduler runs while still in (but at the end of) the current event.\n        Also, we sometimes need timeout delays.\n\n    Example use:\n\n        replace:\n\n            setTimeout(aFunc, ms) // returns timer id\n\n        with:\n\n            this.addTimeout(aFunc, ms, optionalName) // returns timer id\n\n    Note:\n\n        If the optionalName argument is used, any active timer with the same name on this object will\n        be cleared first, and a new timeout with the name will be added.\n\n    TODO: decide if exception should be raised when cancelling timeout not in _timeoutNameToIdMap\n        \n*/\n\n\n(class Object_timeouts extends Object {\n\n        timeoutNameToIdMap () { // the name will be the timeoutId if no name is provided\n            const slotName = \"_timeoutNameToIdMap\"\n            if (Type.isNullOrUndefined(this[slotName])) {\n                Object.defineSlot(this, slotName, new Map())\n            }\n            return this[slotName]\n        }\n    \n        addTimeout (aFunc, msDelay, optionalName) { \n            // if no optionalName given, use the timeoutId for the name,\n            // as timeout ids should be unique\n            const tids = this.timeoutNameToIdMap()\n\n            if (optionalName && tids.has(optionalName)) {\n                // clear existing timeout with this name, if there is one\n                this.clearTimeoutNamed(optionalName)\n            }\n\n            const tidInfo = new Array(2) // will store [timeoutName, timeoutId] so we can capture returned tid in timeout closure\n            const tid = setTimeout(() => { \n                this.removeTimeoutNamed(tidInfo[0])\n                EventManager.shared().safeWrapEvent(aFunc)\n            }, msDelay)\n            tidInfo[0] = optionalName ? optionalName : tid\n            tidInfo[1] = tid\n            this.timeoutNameToIdMap().set(optionalName, tid)\n            return tid\n        }\n\n        removeTimeoutNamed (name) {\n            const tids = this.timeoutNameToIdMap()\n            tids.delete(name)\n            return this\n        }\n\n        clearTimeout (tid) { \n            // IMPORTANT: (for now) we assume a given timeouts is either referred to by name or tid, but not both\n            // in which case, if the tid is called here, it was used at the key in the timeoutNameToIdMap\n            this.removeTimeoutNamed(tid)\n            clearTimeout(tid)\n            return this\n        }\n\n        clearTimeoutNamed (name) {\n            const tids = this.timeoutNameToIdMap()\n            if (tids.has(name)) {\n                const tid = tids.get(name)\n                this.clearTimeout(tid)\n            }\n            return this\n        }\n\n        hasTimeoutNamed (name) {\n            const tids = this.timeoutNameToIdMap()\n            return tids.has(name)\n        }\n    \n        cancelAllTimeouts () {\n            const tids = this.timeoutNameToIdMap()\n            tids.forEachKV((name, tid) => this.clearTimeout(tid))\n            return this\n        }\n\n        /*\n        timeoutForName (name) {\n            const tids = this.timeoutNameToIdMap()\n            return tids.get(name)\n        }\n        */\n\n}).initThisCategory();\n",
  "uBw7zzzhiYanUcd9YXTIyYQ9iaYlBROmJqSTx7+SSwU=": "\"use strict\";\n\n/*\n\n    Array_ideal\n\n    Some extra methods for the Javascript Array primitive.\n\n*/\n\n(class Array_ideal extends Array {\n\n    static withArray (anArray) {\n        return this.clone().copyFrom(anArray)\n    }\n\n    static fromIterator (iterator) {\n        const results = []\n        let entry = iterator.next()\n        while (!entry.done) {\n            results.push(entry.value)\n            entry = iterator.next()\n        }\n        return results\n    }\n\n    /*\n    init () {\n        Object.prototype.init.apply(this)\n     }\n    */\n\n    duplicate () {\n        return this.shallowCopy()\n    }\n\n    clear () {\n        while (this.length) {\n            this.pop()\n        }\n        return this\n    }\n\n    copyFrom (anArray) {\n        this.clear()\n        anArray.forEach(v => this.push(v))\n        return this\n    }\n\n    // --- read operations ---\n\n    // foreach key value (key being the index)\n\n    /*\n    strictForEach (func) {\n        addMutationObserver\n    }\n    */\n\n    safeForEach (func) {\n        this.shallowCopy().forEach(v => func(v))\n    }\n\n    forEachV (func) { // for compatibility\n        this.forEach(v => func(v))\n    }\n\n    forEachKV (func) {\n        let i = 0\n        this.forEach((v) => {\n            func(i, v)\n            i++\n        })\n    }\n\n    reverseForEachKV (func) {\n        let i = 0\n        this.forEach((v) => {\n            func(i, v)\n            i++\n        })\n    }\n\n    isEmpty () {\n        return this.length === 0;\n    }\n\n    isEqual (otherArray) {\n        if (this.length !== otherArray.length) {\n            return false;\n        }\n\n        for (let i = 0; i < this.length; i++) {\n            if (this[i] !== otherArray[i]) {\n                //if (this.at(i) !== otherArray.at(i)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    size () {\n        return this.length;\n    }\n\n    atWrap (index) {\n        if (index < 0) {\n            return this[this.length + index];\n        }\n\n        return this[index];\n    }\n\n    removeAt (index) {\n        // we need to hook this since delete can't be hooked\n        const v = this[index]\n        this.willMutate(\"removeAt\", v)\n        delete this[index]\n        this.didMutate(\"removeAt\", v)\n        return this\n    }\n\n    atPut (index, v) {\n        // we need to hook this since []= can't be hooked\n        this.willMutate(\"atPut\", v)\n        this[index] = v\n        this.didMutate(\"atPut\", v)\n        return this\n    }\n\n    first () {\n        return this.at(0)\n    }\n\n    second () {\n        return this.at(1)\n    }\n\n    rest () {\n        return this.slice(1);\n    }\n\n    last () {\n        return this.at(this.length - 1) // returns undefined for negative indexes\n    }\n\n    contains (element) {\n        return this.includes(element)\n        //return this.indexOf(element) !== -1;\n    }\n\n    containsAny (anArray) {\n        const match = anArray.detect(item => this.contains(item))\n        return !Type.isNullOrUndefined(match)\n    }\n\n    // --- duplicates ---\n\n    removeDuplicates () {\n        const u = this.unique()\n        if (this.length !== u.length) {\n            this.copyFrom(u)\n        }\n        return this\n    }\n\n    hasDuplicates () {\n        if (this.length > 100) {\n            return this.hasDuplicates_setImplementation()\n\n        } else {\n            return this.hasDuplicates_indexOfImplementation()\n        }\n    }\n\n    hasDuplicates_setImplementation() {\n        const set = new Set()\n        for (let i = 0; i < this.length - 1 /* skip last */; i++) {\n            const v = this[i]\n            if (set.has(v)) {\n                return true\n            } else {\n                set.add(v)\n            }\n        }\n        return false\n    }\n\n    hasDuplicates_indexOfImplementation () {\n        for (let i = 0; i < this.length - 1 /* skip last */; i++) {\n            if (this.indexOf(this[i], i + 1) !== -1) {\n                return true\n            }\n        }\n        return false\n    }\n\n    // ------------\n\n    hasPrefix (otherArray) {\n        if (this.length < otherArray.length) {\n            return false;\n        }\n\n        for (let i = 0; i < this.length; i++) {\n            if (this.at(i) !== otherArray.at(i)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    itemAfter (v) {\n        let i = this.indexOf(v);\n\n        if (i === -1) {\n            return null;\n        }\n\n        i = i + 1;\n\n        if (i > this.length - 1) {\n            return null;\n        }\n\n        if (this.at(i) !== undefined) {\n            return this.at(i);\n        }\n\n        return null;\n    }\n\n    itemBefore (v) {\n        let i = this.indexOf(v);\n\n        if (i === -1) {\n            return null;\n        }\n\n        i = i - 1;\n\n        if (i < 0) {\n            return null;\n        }\n\n        if (this.at(i)) {\n            return this.at(i)\n        }\n\n        return null;\n    }\n\n    shallowCopy () {\n        return this.slice()\n    }\n\n    copy (copyDict) {\n        // since not every object will implement copy:\n        // we need to have a check for it\n        return this.slice().map((v) => {\n            if (v.copy) {\n                return v.copy(copyDict)\n            } else {\n                return v\n            }\n        })\n    }\n\n    split (subArrayCount) {\n        const subArrays = [];\n        const subArraySize = Math.ceil(this.length / subArrayCount);\n\n        for (let i = 0; i < this.length; i += subArraySize) {\n            let subArray = this.slice(i, i + subArraySize);\n            if (subArray.length < subArraySize) {\n                let lastSubArray = subArrays.pop();\n                if (lastSubArray) {\n                    subArray = lastSubArray.concat(subArray);\n                }\n            }\n            subArrays.push(subArray);\n        }\n\n        return subArrays;\n    }\n\n    // --- write operations ---\n\n    atInsert (i, e) {\n        this.splice(i, 0, e);\n        return this\n    }\n\n    atInsertItems (i, items) {\n        let n = i\n        items.forEach(item => {\n            this.atInsert(n, item)\n            n++\n        })\n        return this\n    }\n\n    append () {\n        this.appendItems.call(this, arguments);\n        return this;\n    }\n\n    appendItems (elements) {\n        this.push.apply(this, elements);\n        return this;\n    }\n\n    appendItemsIfAbsent (elements) {\n        this.appendIfAbsent.apply(this, elements);\n        return this;\n    }\n\n    moveItemsToIndex (movedItems, anIndex) {\n        const newArray = this.shallowCopy()\n        let insertIndex = anIndex\n\n        movedItems.forEach(item => assert(this.contains(item))) // sanity check\n\n        //console.log(\"start: \" + this.map(s => s.title()).join(\"-\") + \".moveItemsToIndex(\"  + movedItems.map(s => s.title()).join(\"-\") + \", \" + anIndex + \")\")\n\n        movedItems.forEach(item => {\n            const i = this.indexOf(item)\n            if (i == -1) {\n                throw new Error(\"this isn't handled yet\")\n            }\n\n            if (i < insertIndex) {\n                insertIndex--\n            }\n            newArray.remove(item)\n        })\n\n        movedItems.reversed().forEach(item => {\n            newArray.atInsert(insertIndex, item)\n        })\n\n        this.copyFrom(newArray)\n        return this\n    }\n\n    prepend (e) {\n        this.unshift(e);\n        return this;\n    }\n\n    appendIfAbsent () {\n        this.slice.call(arguments).forEach((value) => {\n            if (!this.contains(value)) {\n                this.push(value);\n                return true;\n            }\n        })\n\n        return false;\n    }\n\n    removeAll () {\n        while (this.length) {\n            this.pop() // TODO: make more efficient?\n        }\n        return this\n    }\n\n    removeAt (i) {\n        this.willMutate(\"removeAt\")\n        this.splice(i, 1);\n        this.didMutate(\"removeAt\")\n        return this;\n    }\n\n    remove (e) {\n        const i = this.indexOf(e);\n        if (i !== -1) {\n            this.removeAt(i);\n        }\n        return this;\n    }\n\n    emptiesRemoved () {\n        return this.filter(v => !Type.isNullOrUndefined(v))\n    }\n\n    removeFirst () {\n        // isMutator\n        return this.shift();\n    }\n\n    removeLast () {\n        // isMutator\n        return this.pop();\n    }\n\n    removeItems (elements) {\n        // isMutator\n        elements.forEach(e => this.remove(e));\n        return this;\n    }\n\n    empty () {\n        this.splice(0, this.length);\n        return this;\n    }\n\n    shuffle () {\n        let i = this.length;\n\n        if (i === 0) {\n            return false;\n        }\n\n        while (--i) {\n            const j = Math.floor(Math.random() * (i + 1));\n            const tempi = this.at(i);\n            const tempj = this.at(j);\n            this.atPut(i, tempj)\n            this.atPut(j, tempi)\n        }\n\n        return this;\n    }\n\n    atRandom () {\n        const i = Math.floor(Math.random() * this.length)\n        return this.at(i);\n    }\n\n    // --- enumeration ---\n\n    /*\n    forEachCall (functionName) {\n        const args = this.slice.call(arguments).slice(1);\n        args.push(0);\n        this.forEach((e, i) => {\n            args[args.length - 1] = i;\n            if (e) {\n                const fn = e[functionName];\n                if (fn) {\n                    fn.apply(e, args);\n                } else {\n                    console.warn(\"Array.forEachCall: No method \" + functionName);\n                }\n            }\n        });\n        return this;\n     }\n    */\n\n    forEachPerformIfResponds (methodName, arg1, arg2, arg3) {\n        this.forEach((item) => {\n            if (item) {\n                const f = item[methodName]\n                if (f) {\n                    f.call(item, arg1, arg2, arg3)\n                }\n            }\n        })\n        return this\n    }\n\n    forEachPerform (methodName, arg1, arg2, arg3) {\n        this.forEach((item) => {\n            if (item) {\n                const f = item[methodName]\n                if (f) {\n                    f.call(item, arg1, arg2, arg3)\n                } else {\n                    throw new Error(Type.typeName(item) + \" does not respond to '\" + methodName + \"'\")\n                }\n            }\n        })\n        return this\n    }\n\n    sortPerform (functionName) { // WARNING: sorts IN-PLACE\n        const args = this.slice.call(arguments).slice(1);\n        return this.sort(function (x, y) {\n            const xRes = x[functionName].apply(x, args);\n            const yRes = y[functionName].apply(y, args);\n            if (xRes < yRes) {\n                return -1;\n            } else if (yRes < xRes) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n\n    mapProperty (propertyName) {\n        return this.map(e => e[propertyName]);\n    }\n\n    detect (func) {\n        for (let i = 0; i < this.length; i++) {\n            const v = this.at(i)\n            if (func(v, i)) {\n                return v;\n            }\n        }\n\n        return null; // or should this be undefined?\n    }\n\n    detectPerform (functionName) {\n        const args = this.slice.call(arguments).slice(1);\n        return this.detect((value, index) => {\n            return value[functionName].apply(value, args);\n        });\n    }\n\n    detectProperty (slotName, slotValue) {\n        for (let i = 0; i < this.length; i++) {\n            const v = this.at(i)\n            if (v[slotName] === slotValue) {\n                return v;\n            }\n        }\n\n        return null;\n    }\n\n    detectIndex (func) {\n        for (let i = 0; i < this.length; i++) {\n            if (func(this.at(i), i)) {\n                return i;\n            }\n        }\n\n        return null;\n    }\n\n    nullsRemoved () {\n        return this.filter(v => !Type.isNull(v));\n    }\n\n    reject (func) {\n        return this.filter(v => !func(v))\n    }\n\n    // max \n\n    maxEntry (optionalFunc) {\n        const length = this.length;\n        const mEntry = [undefined, undefined]\n\n        for (let i = 0; i < length; i++) {\n            let v = this.at(i);\n            if (optionalFunc) {\n                v = optionalFunc(v);\n            }\n\n            if (mEntry[1] === undefined || v > mEntry[1]) {\n                mEntry[0] = i\n                mEntry[1] = v\n            }\n        }\n\n        return mEntry;\n    }\n\n    maxIndex (optionalFunc) {\n        return this.maxEntry(optionalFunc)[0];\n    }\n\n    maxValue (optionalFunc, theDefault) {\n        return this.maxEntry(optionalFunc)[1];\n    }\n\n    maxItem (optionalFunc) {\n        return this.at(this.maxIndex(optionalFunc));\n    }\n\n\n    // min\n\n    minEntry (optionalFunc) {\n        const length = this.length;\n        const mEntry = [undefined, undefined]\n\n        for (let i = 0; i < length; i++) {\n            let v = this[i];\n            if (optionalFunc) {\n                v = optionalFunc(v);\n            }\n\n            if (mEntry[1] === undefined || v < mEntry[1]) {\n                mEntry[0] = i\n                mEntry[1] = v\n            }\n        }\n\n        return mEntry;\n    }\n\n    minIndex (optionalFunc) {\n        return this.maxEntry(optionalFunc)[0];\n    }\n\n    minValue (optionalFunc) {\n        return this.minEntry(optionalFunc)[1];\n    }\n\n    // sum\n\n    sum (optionalFunc) {\n        let sum = 0;\n        const length = this.length;\n\n        for (let i = 0; i < length; i++) {\n            let v = this.at(i);\n            if (optionalFunc) {\n                v = optionalFunc(v);\n            }\n\n            sum = sum + v;\n        }\n\n        return sum;\n    }\n\n    average () {\n        if (this.length === 0) {\n            return 0\n        }\n        return this.sum() / this.length;\n    }\n\n    /*\n    JS now has Array \"flat\" method\n    flatten (maxDepth = 1) {\n        const result = [];\n        let needsFlatten = true\n        let depth = 0\n        while (needsFlatten && depth < maxDepth) {\n            depth ++\n            needsFlatten = false\n            this.forEach((item) {\n                if (item === this) {\n                    throw new Error(\"attempt to flatten recursive array\")\n                }\n                if (Type.isArray(item)) { // TODO: generalize to enumerables?\n                    result.appendItems(array)\n                    needsFlatten = true\n                } else {\n                    result.append(item)\n                }\n            });\n        }\n        return result;\n     }\n    */\n\n\n    unique () {\n        return Array.from(new Set(this));\n    }\n\n    asSet () {\n        return new Set(this)\n    }\n\n    reversed () {\n        return this.shallowCopy().reverse();\n    }\n\n    asPath () {\n        if (this.length === 1 && this.first() === \"\") {\n            return \"/\";\n        }\n        else {\n            return this.join(\"/\");\n        }\n    }\n\n    isAbsolutePath () {\n        return this.first() === \"\";\n    }\n\n    isRelativePath () {\n        return this.first() !== \"\";\n    }\n\n    filterInPlace (func) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            const v = this.at(i);\n            if (!func(v)) {\n                this.removeAt(i)\n            }\n        }\n        return this\n    }\n\n    select (func) {\n        return this.filter(func)\n    }\n\n    after (v) {\n        const index = this.indexOf(v);\n\n        if (index === -1) {\n            return [];\n        }\n\n        return this.slice(index + 1);\n    }\n\n    before (v) {\n        const index = this.indexOf(v);\n\n        if (index === -1) {\n            return this.slice();\n        }\n\n        return this.slice(0, index);\n    }\n\n    replaceOccurancesOfWith (oldValue, newValue) {\n        // isMutator\n        for (let i = 0; i < this.length; i++) {\n            if (this.at(i) === oldValue) {\n                this.atPut(i, newValue);\n            }\n        }\n        return this\n    }\n\n    removeOccurancesOf (e) {\n        // isMutator\n        for (let i = this.length - 1; i >= 0; i--) {\n            const v = this.at(i);\n            if (v === e) {\n                this.removeAt(i)\n            }\n        }\n        return this;\n    }\n\n    joinWithFunc (aFunc) {\n        // not a mutator\n        // like join, but calls aFunc with the array and index as arguments\n        // to get each new item to insert between array items\n        const joined = []\n        for (let i = 0; i < this.length; i++) {\n            const v = this[i]\n            joined.push(v)\n            if (i < this.length - 1) {\n                const separator = aFunc(this, i)\n                joined.push(separator)\n            }\n        }\n        return joined\n    }\n\n    /*\n    wrap (obj) {\n        if (obj === null || obj === undefined) {\n            return [];\n        }\n        else if (obj.isArray) {\n            return obj;\n        }\n        else {\n            return [obj];\n        }\n     }\n    */\n\n    itemsBefore (item) {\n        const index = this.indexOf(item);\n        if (index !== -1) {\n            return this.slice(0, index);\n        }\n        return this\n    }\n\n    /*\n    const setDifference = (a, b) => new Set([...a].filter(x => !b.has(x)));\n    const setIntersection = (a, b) => new Set([...a].filter(x => b.has(x)));\n    const setUnion = (a, b) => new Set([...a, ...b]);\n    */\n\n    union (other) {\n        let r = this.concat(other).unique()\n        return r;\n    }\n\n    intersection (other) { // returns all items that are present in both\n        const thisSet = new Set(this)\n        return other.filter((v) => {\n            return thisSet.has(v);\n        });\n    }\n\n    difference (other) { // returns items in other that are not in self\n        const thisSet = new Set(this)\n        return other.filter(v => !thisSet.has(v));\n    }\n\n    symmetricDifference (other) { // returns items in either not present in the other\n        let all = this.concat(other)\n        const thisSet = new Set(this)\n        const otherSet = new Set(other)\n        return all.filter(v => !thisSet.has(v) || !otherSet.has(v));\n    }\n\n    /*\n    intersectionWithSelector (a, methodName) {\n        return this.select((e1) => { \n            return a.detect(e2 => e1[methodName].apply(e1) === e2[methodName].apply(e2)) !== null \n        })\n     }\n     \n    diffWithSelector (otherArray, methodName) {\n        let thisIdSet = new Set(this.map(v => v[methodName].apply(v)))\n        let otherIdSet = new Set(otherArray.map(v => v[methodName].apply(v)))\n    \n        return otherArray.select(v => !idSet.has(v.id()) )\n     }\n    */\n\n\n    // --- equality ---\n\n    equals (array /*, visited = new Set()*/) {\n        // we want this to work on any object that confroms to the array protocol, \n        // not just objects of the same JS type\n        // but how do we test for the [] accessor?\n        // also, how do we deal with circular structures?\n\n        /*\n        if (visited.has(this)) {\n            return true // ?\n        }\n        visited.add(this)\n        */\n\n        if (array.length === undefined) {\n            return false;\n        }\n\n        // compare lengths - can save a lot of time \n        if (this.length !== array.length) {\n            return false;\n        }\n\n        for (let i = 0, l = this.length; i < l; i++) {\n            const a = this.at(i)\n            const b = array.at(i)\n\n            // Check if we have nested arrays\n            /*\n                if (this.at(i) instanceof Array && array[i] instanceof Array) {\n                    // recurse into the nested arrays\n                    if (!this.at(i).equals(array[i]))\n                        return false;       \n                }     \n            */\n\n            if (a.equals && !a.equals(b, visited)) {\n                return false;\n            } else if (a !== b) {\n                // Warning - two different object instances will never be equal: {x:20} !== {x:20}\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n\n    containsEquals (b) {\n        for (let i = 0, l = this.length; i < l; i++) {\n            let a = this.at(i)\n\n            if (a.equals) {\n                if (!a.equals(b)) {\n                    return false;\n                }\n            } else if (a !== b) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /*\n    asImmutable () {\n        // doesn't raise exception on write - they just fail silently - too dangerous to use\n        //const obj = this.shallowCopy()\n        //Object.freeze(obj)\n        //return obj\n     }\n    */\n\n}).initThisCategory();\n\n",
  "E7Qozbhaj+rCrocJQUQoF0qps69IeyTI/YwFmAD+qik=": "\"use strict\";\n\n/*\n\n    Date-ideal\n\n    Some extra methods for the Javascript Date primitive.\n\n*/\n\n\n(class Date_ideal extends Date {\n\n    /*\n    static clone () {\n        return new Date(this.getTime())\n     }\n    */\n\n    copy () {\n        return this.shallowCopy()\n     }\n\n    shallowCopy () {\n        return new Date(this.getTime())\n     }\n\n    // ---\n   \n    monthNames () {\n        return [ \n            \"January\", \"February\", \"March\", \n            \"April\", \"May\", \"June\", \n            \"July\", \"August\", \"September\", \n            \"October\", \"November\", \"December\" \n        ];\n     }\n\n    monthName () {\n        const monthNumber = this.getMonth() - 1\n        return this.monthNames()[monthNumber];\n     }\n\n    dateNumberName () {\n        const dayNumber = this.getDate()\n        return dayNumber + dayNumber.ordinalSuffix()\n     }\n\n    paddedNumber (n) {\n        const s = \"\" + n\n        if (s.length === 1) { \n            return \"0\" + s\n        }\n        return s\n     }\n\n    zeroPaddedHours () {\n        return this.paddedNumber(this.getHours())\n     }\n\n    zeroPaddedMinutes () {\n        return this.paddedNumber(this.getMinutes())\n     }\n\n    zeroPaddedSeconds () {\n        return this.paddedNumber(this.getSeconds())\n     }\n\n    getTwelveHours () {\n        let h = this.getHours()\n        if (h > 12) { h -= 12 }\n        if (h === 0) { h = 12 }\n        return h\n     }\n\n    zeroPaddedUSDate () {\n        return this.paddedNumber(this.getTwelveHours()) + \":\" + this.paddedNumber(this.getMinutes())\n     }\n\n}).initThisCategory();\n\n\n\n\n\n\n",
  "iaK/LypHN7vXnuCRT5FcfqlF8ZaxgkOPskbaALcX9iM=": "\"use strict\";\n\n/*\n\n    String_ideal\n\n    Some extra methods for the Javascript String primitive.\n\n*/\n\nString.prototype._setterCacheMap = new Map();\n\n(class String_ideal extends String {\n    \n    shallowCopy () {\n        return this\n    }\n\n    duplicate () {\n        return this\n    }\n    \n    isEmpty () {\n        return this.length === 0;\n    }\n\n    size () {\n        return this.length;\n    }\n    \n    beginsWith (prefix) { // Javascript calls this \"startsWith\n        if (!prefix || this.length < prefix.length) {\n            return false;\n        }\n        for (let i = 0; i < prefix.length; i ++) {\n            if (this.charAt(i) !== prefix.charAt(i)) {\n                return false\n            }\n        } \n        return true\n        //return this.substr(0, prefix.length) === prefix // faster that indexOf as it \n        //return this.indexOf(prefix) === 0;\n    }\n\n    /*\n    Javascript supports this method now\n    endsWith (suffix) {\n        if (!suffix || this.length < suffix.length) {\n            return false;\n        }\n        for (let i = 0; i < suffix.length; i ++) {\n            if (this.charAt(this.length - suffix.length + i) !== suffix.charAt(i)) {\n                return false\n            }\n        } \n        return true\n        //const index = this.lastIndexOf(suffix);\n        //return (index !== -1) && (this.lastIndexOf(suffix) === this.length - suffix.length);\n    }\n    */\n\n    contains (aString) {\n        return this.indexOf(aString) !== -1;\n    }\n\n    before (aString) {\n        const index = this.indexOf(aString);\n        \n        if (index === -1) {\n            return this;\n        }\n\n        return this.slice(0, index);\n    }\n\n    after (aString) {\n        const index = this.indexOf(aString);\n\n        if (index === -1) {\n            return \"\";\n        }\n        \n        return this.slice(index + aString.length);\n    }\n\n    between (prefix, suffix) {\n        const after = this.after(prefix);\n        if (after != null) {\n            const before = after.before(suffix);\n            if (before != null) {\n                return before;\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return null;\n        }\n    }\n\n    /*\n    // JS implements this now\n    at (i) {\n        return this.slice(i, i + 1);\n    }\n    */\n\n    first () {\n        return this.slice(0, 1);\n    }\n\n    rest () {\n        return this.slice(1);\n    }\n\n    repeated (times) {\n        let result = \"\";\n        const aString = this;\n        times.repeat(function () { result += aString });\n        return result\n    }\n\n    sansPrefixes (aStringList) {\n        let result = this\n        aStringList.forEach((s) => { result = result.sansPrefix(s) })\n        return result\n    }\n\n    sansPrefix (prefix) {\n        return this.substring(this.startsWith(prefix) ? prefix.length : 0);\n    }\n\n    sansSuffixes (aStringList) {\n        let result = this\n        aStringList.forEach((s) => { result = result.sansSuffix(s) })\n        return result\n    }\n\n    sansSuffix (suffix) {\n        if (this.endsWith(suffix)) {\n            return this.substr(0, this.length - suffix.length);\n        }\n        else {\n            return this;\n        }\n    }\n\n    stripped () {\n        return this.replace(/^\\s\\s*/, \"\").replace(/\\s\\s*$/, \"\");\n    }\n\n    uncapitalized () {\n        return this.replace(/\\b[A-Z]/g, function (match) {\n            return match.toLowerCase();\n        });\n    }\n\n    asNumber () {\n        return Number(this);\n    }\n\n    //move to libraries?\n    humanized () //someMethodName -> Some Method Name\n    {\n        const words = [];\n        let start = -1;\n        const capitalized = this.capitalized();\n        for (let i = 0; i < capitalized.length; i++) {\n            if (capitalized.slice(i, i + 1).match(/[A-Z]/)) {\n                let word = capitalized.slice(start, i);\n                if (word) {\n                    words.append(word);\n                }\n                start = i;\n            }\n        }\n        words.append(capitalized.slice(start, i));\n        return words.join(\" \");\n    }\n\n    titleized () {\n        return this.split(/\\s+/).map(function (s) { return s.capitalized() }).join(\" \");\n    }\n\n    base64Encoded () {\n        //return new Buffer(String(this), \"utf8\").toString(\"base64\");\n        return window.btoa(this);\n    }\n\n    base64UrlEncoded () {\n        return this.base64Encoded().replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \",\");\n    }\n\n    base64Decoded () {\n        //return new Buffer(String(this), \"base64\").toString(\"utf8\");\n        return window.atob(this);\n    }\n\n    base64UrlDecoded () {\n        return this.replace(/-/g, \"+\").replace(/_/g, \"/\").replace(/,/g, \"=\").base64Decoded();\n    }\n\n    stringCount (str) {\n        return this.split(str).length - 1;\n    }\n\n    lineCount () {\n        let count = 0\n        for (let i = 0; i < this.length; i++) {\n            const c = this.charAt(i)\n            if (c === \"\\n\") {\n                count ++\n            }\n        }\n        return count\n    }\n\n    forEachCharacter (fn) {\n        for (let i = 0; i < this.length; i++) {\n            const c = this.charAt(i)\n            fn(c)\n        }\n    }\n\n    forEachKV (fn) {\n        for (let i = 0; i < this.length; i++) {\n            const c = this.charAt(i)\n            fn(i, c)\n        }\n    }\n\n    splitArray (splitters) {\n        let s = this\n        const results = []\n        splitters.forEach( (splitter) => {\n            if (s.contains(splitter)) {\n                const before = s.before(splitter)\n                s = s.after(splitter)\n                results.push(before)\n            } else {\n                results.push(null)\n            }\n        })\n        return results\n    }\n\n    // --- paths ---\n\n    pathComponents () {\n        if (this === \"/\") {\n            return [\"\"];\n        }\n        else if (this === \"\") {\n            return [];\n        }\n        else {\n            return this.split(\"/\");\n        }\n    }\n\n    sansLastPathComponent () {\n        const c = this.pathComponents()\n        c.removeLast();\n        return c.join(\"/\");\n    }\n\n    lastPathComponent () {\n        //return this.pathComponents().last()\n        const components = this.pathComponents()\n        if (components.length) {\n            return this.pathComponents().last();\n        }\n        return \"\"\n    }\n\n    fileName () {\n        return this.lastPathComponent().sansExtension()\n    }\n\n    sansExtension () {\n        const parts = this.split(\".\")\n        if (parts.length > 1) {\n            parts.pop()\n        }\n        return parts.join(\".\")\n    }\n\n    pathExtension () {\n        const extension = this.split(\".\").last();\n        return extension;\n    }\n\n    // --- pad / strip -------\n\n    padLeft (length, padding) {\n        let str = this;\n        while (str.length < length) {\n            str = padString + str;\n        }\n\n        return str.substring(0, length);\n    }\n\n    padRight (length, padding) {\n        let str = this;\n        while (str.length < length) {\n            str = str + padding;\n        }\n\n        return str.substring(0, length);\n    }\n\n    strip () {\n        return String(this).replace(/^\\s+|\\s+$/g, \"\");\n    }\n\n    asObject () {\n        return JSON.parse(this);\n    }\n\n    /* JS implements this now\n    capitalized () {\n        return this.replace(/\\b[a-z]/g, function (match) {\n            return match.toUpperCase();\n        });\n    }\n    */\n\n    /// String\n\n    asSetter () {\n        const cache = this.thisPrototype()._setterCacheMap \n        let result = cache[this]\n        if (!result) {\n             result = \"set\" + this.capitalized()\n             cache.set(this, result)\n             // test for highwater mark\n             if (cache.size > 50000) {\n                console.warn(\"setter cache is getting big! clearing...\")\n                cache.clear()\n             }\n        }\n        return result\n        //return \"set\" + this.capitalized();\n    }\n\n    firstCharacter () {\n        return this.slice(0);\n    }\n\n    lastCharacter () {\n        return this.slice(-1);\n    }\n\n    capitalizeWords () {\n        return this.replace(/(?:^|\\s)\\S/g, function (a) {\n            return a.toUpperCase();\n        });\n    }\n\n    loremIpsum (minWordCount, maxWordCount) {\n        if (!minWordCount) { minWordCount = 10; }\n        if (!maxWordCount) { maxWordCount = 40; }\n\n        const loremIpsumWordBank = new Array(\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet,\", \"consectetur\", \"adipisicing\", \"elit,\", \"sed\", \"do\", \"eiusmod\", \"tempor\", \"incididunt\", \"ut\", \"labore\", \"et\", \"dolore\", \"magna\", \"aliqua.\", \"enim\", \"ad\", \"minim\", \"veniam,\", \"quis\", \"nostrud\", \"exercitation\", \"ullamco\", \"laboris\", \"nisi\", \"ut\", \"aliquip\", \"ex\", \"ea\", \"commodo\", \"consequat.\", \"duis\", \"aute\", \"irure\", \"dolor\", \"in\", \"reprehenderit\", \"in\", \"voluptate\", \"velit\", \"esse\", \"cillum\", \"dolore\", \"eu\", \"fugiat\", \"nulla\", \"pariatur.\", \"excepteur\", \"sint\", \"occaecat\", \"cupidatat\", \"non\", \"proident,\", \"sunt\", \"in\", \"culpa\", \"qui\", \"officia\", \"deserunt\", \"mollit\", \"anim\", \"id\", \"est\", \"laborum.\", \"sed\", \"ut\", \"perspiciatis,\", \"unde\", \"omnis\", \"iste\", \"natus\", \"error\", \"sit\", \"voluptatem\", \"accusantium\", \"doloremque\", \"laudantium,\", \"totam\", \"rem\", \"aperiam\", \"eaque\", \"ipsa,\", \"quae\", \"ab\", \"illo\", \"inventore\", \"veritatis\", \"et\", \"quasi\", \"architecto\", \"beatae\", \"vitae\", \"dicta\", \"sunt,\", \"explicabo.\", \"nemo\", \"enim\", \"ipsam\", \"voluptatem,\", \"quia\", \"voluptas\", \"sit,\", \"aspernatur\", \"aut\", \"odit\", \"aut\", \"fugit,\", \"sed\", \"quia\", \"consequuntur\", \"magni\", \"dolores\", \"eos,\", \"qui\", \"ratione\", \"voluptatem\", \"sequi\", \"nesciunt,\", \"neque\", \"porro\", \"quisquam\", \"est,\", \"qui\", \"dolorem\", \"ipsum,\", \"quia\", \"dolor\", \"sit,\", \"amet,\", \"consectetur,\", \"adipisci\", \"velit,\", \"sed\", \"quia\", \"non\", \"numquam\", \"eius\", \"modi\", \"tempora\", \"incidunt,\", \"ut\", \"labore\", \"et\", \"dolore\", \"magnam\", \"aliquam\", \"quaerat\", \"voluptatem.\", \"ut\", \"enim\", \"ad\", \"minima\", \"veniam,\", \"quis\", \"nostrum\", \"exercitationem\", \"ullam\", \"corporis\", \"suscipit\", \"laboriosam,\", \"nisi\", \"ut\", \"aliquid\", \"ex\", \"ea\", \"commodi\", \"consequatur?\", \"quis\", \"autem\", \"vel\", \"eum\", \"iure\", \"reprehenderit,\", \"qui\", \"in\", \"ea\", \"voluptate\", \"velit\", \"esse,\", \"quam\", \"nihil\", \"molestiae\", \"consequatur,\", \"vel\", \"illum,\", \"qui\", \"dolorem\", \"eum\", \"fugiat,\", \"quo\", \"voluptas\", \"nulla\", \"pariatur?\", \"at\", \"vero\", \"eos\", \"et\", \"accusamus\", \"et\", \"iusto\", \"odio\", \"dignissimos\", \"ducimus,\", \"qui\", \"blanditiis\", \"praesentium\", \"voluptatum\", \"deleniti\", \"atque\", \"corrupti,\", \"quos\", \"dolores\", \"et\", \"quas\", \"molestias\", \"excepturi\", \"sint,\", \"obcaecati\", \"cupiditate\", \"non\", \"provident,\", \"similique\", \"sunt\", \"in\", \"culpa,\", \"qui\", \"officia\", \"deserunt\", \"mollitia\", \"animi,\", \"id\", \"est\", \"laborum\", \"et\", \"dolorum\", \"fuga.\", \"harum\", \"quidem\", \"rerum\", \"facilis\", \"est\", \"et\", \"expedita\", \"distinctio.\", \"Nam\", \"libero\", \"tempore,\", \"cum\", \"soluta\", \"nobis\", \"est\", \"eligendi\", \"optio,\", \"cumque\", \"nihil\", \"impedit,\", \"quo\", \"minus\", \"id,\", \"quod\", \"maxime\", \"placeat,\", \"facere\", \"possimus,\", \"omnis\", \"voluptas\", \"assumenda\", \"est,\", \"omnis\", \"dolor\", \"repellendus.\", \"temporibus\", \"autem\", \"quibusdam\", \"aut\", \"officiis\", \"debitis\", \"aut\", \"rerum\", \"necessitatibus\", \"saepe\", \"eveniet,\", \"ut\", \"et\", \"voluptates\", \"repudiandae\", \"sint\", \"molestiae\", \"non\", \"recusandae.\", \"itaque\", \"earum\", \"rerum\", \"hic\", \"tenetur\", \"a\", \"sapiente\", \"delectus,\", \"aut\", \"reiciendis\", \"voluptatibus\", \"maiores\", \"alias\", \"consequatur\", \"aut\", \"perferendis\", \"doloribus\", \"asperiores\", \"repellat\");\n\n        const randy = Math.floor(Math.random() * (maxWordCount - minWordCount)) + minWordCount;\n        let ret = \"\";\n        let needsCap = true\n        for (let i = 0; i < randy; i++) {\n            let newTxt = loremIpsumWordBank[Math.floor(Math.random() * (loremIpsumWordBank.length - 1))];\n\n            if (ret.substring(ret.length - 1, ret.length) === \".\" || ret.substring(ret.length - 1, ret.length) === \"?\") {\n                newTxt = newTxt.substring(0, 1).toUpperCase() + newTxt.substring(1, newTxt.length);\n            }\n\n            if (needsCap) {\n                newTxt = newTxt.capitalized()\n                needsCap = false\n            }\n\n            ret += \" \" + newTxt;\n        }\n\n        return ret + \".\"\n    }\n\n    escapeHtml () {\n        return this.replace(/[&<>\"'\\/]/g, function (s) {\n            const entityMap = {\n                \"&\": \"&amp;\",\n                \"<\": \"&lt;\",\n                \">\": \"&gt;\",\n                \"\\\"\": \"&quot;\",\n                \"'\": \"&#39;\",\n                \"/\": \"&#x2F;\"\n            };\n            return entityMap[s];\n        });\n    }\n\n    GUID () {\n        function s4() {\n            return Math.floor((1 + Math.random()) * 0x10000)\n                .toString(16)\n                .substring(1);\n        }\n        return s4() + s4() + \"-\" + s4() + \"-\" + s4() + \"-\" +\n            s4() + \"-\" + s4() + s4() + s4();\n    }\n\n    byteLength () {\n        // returns the byte length of an utf8 string\n        // from: https://stackoverflow.com/questions/5515869/string-length-in-bytes-in-javascript\n        let s = this.length;\n        for (let i = this.length - 1; i >= 0; i--) {\n            const code = this.charCodeAt(i);\n            if (code > 0x7f && code <= 0x7ff) {\n                s ++;\n            } else if (code > 0x7ff && code <= 0xffff) { \n                s += 2;\n            }\n            if (code >= 0xDC00 && code <= 0xDFFF) {\n                i--; //trail surrogate\n            }\n        }\n        return s;\n    }\n\n    byteSizeDescription () {\n        return this.byteLength().byteSizeDescription()\n        //return this.length.byteSizeDescription()\n    }\n\n    hashCode () {\n        let hash = 0;\n\n        for (let i = 0; i < this.length; i++) {\n          const chr = this.charCodeAt(i);\n          hash  = ((hash << 5) - hash) + chr;\n          hash |= 0; // Convert to 32bit integer\n        }\n        return hash;\n    }\n\n    promiseSha256Digest () {\n        // example use: \"hello\".promiseSha256Digest().then((hashBuffer) => {...})\n        const uint8Array = new TextEncoder(\"utf-8\").encode(this);    \n        return crypto.subtle.digest(\"SHA-256\", uint8Array.buffer)\n    }\n\n    stripHTML () {\n        const doc = new DOMParser().parseFromString(this, 'text/html');\n        return doc.body.textContent || \"\";\n    }\n\n}).initThisCategory();\n\n\n\n",
  "0knRWy9cihzoI7+nvSnekZnXaccRvs1XyuuH1Z4o9FM=": "\"use strict\";\n\n/*\n\n    Number-ideal\n\n    Some extra methods for the Javascript Number primitive.\n\n*/\n\n{\n\nconst Base64 = (function () { // FIXME: move this to a Number class method?\n    const digitsStr = \n    //   0       8       16      24      32      40      48      56     63\n    //   v       v       v       v       v       v       v       v      v\n        \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+-\";\n    let digits = digitsStr.split(\"\");\n    let digitsMap = {};\n    for (let i = 0; i < digits.length; i++) {\n        digitsMap[digits[i]] = i;\n    }\n    return {\n        fromInt (int32) {\n            let result = \"\";\n            while (true) {\n                result = digits[int32 & 0x3f] + result;\n                int32 >>>= 6;\n                if (int32 === 0) {\n                    break;\n                }\n            }\n            return result;\n        },\n        toInt (digitsStr) {\n            let result = 0;\n            const digits = digitsStr.split(\"\");\n            for (let i = 0; i < digits.length; i++) {\n                result = (result << 6) + digitsMap[digits[i]];\n            }\n            return result;\n        }\n    };\n})();\n\n(class Number_ideal extends Number {\n\n    duplicate () {\n        return this;\n    }\n    \n    copy () {\n        return this;\n    }\n\n    shallowCopy () {\n        return this;\n    }\n\n    repeat (func) {\n        for (let i = 0; i < this; i++) {\n            if (func(i) === false) {\n                return this;\n            }\n        }\n        return this;\n    }\n\n    forEach (func) {\n        assert(Number.isInteger(this))\n        for (let i = 0; i < this; i++) {\n            func(i);\n        }\n    }\n\n    reverseForEach (func) {\n        assert(Number.isInteger(this))\n        for (let i = this - 1; i >= 0; i++) {\n            func(i);\n        }\n    }\n\n    map () {\n        const a = [];\n        for (let i = 0; i < this; i++) {\n            a.push(i);\n        }\n        return Array.prototype.map.apply(a, arguments);\n    }\n\n    isEven () {\n        return this % 2 === 0;\n    }\n\n    isOdd () {\n        return this % 2 !== 0;\n    }\n\n    ordinalSuffix () {\n        const i = this;\n        let j = i % 10;\n        let k = i % 100;\n        \n        if (j === 1 && k !== 11) {\n            return \"st\";\n        }\n        if (j === 2 && k !== 12) {\n            return \"nd\";\n        }\n        if (j === 3 && k !== 13) {\n            return \"rd\";\n        }\n        return \"th\";\n    }\n\n    toBase64 () {\n        return Base64.fromInt(this);\n    }\n\n    fromBase64 (base64String) {\n        // need to call like: \n        // Number.prototype.fromBase64(\"...\")\n        return Base64.toInt(base64String);\n    }\n\n    byteSizeDescription () {\n        return ByteFormatter.clone().setValue(this).formattedValue();\n    }\n    \n}).initThisCategory();\n\n};\n",
  "GIzKt72k7sPdKKbxLEx5/tU9XAmNQ4TLTJ/80XFxZTc=": "\"use strict\";\n\n/*\n\n    Boolean-ideal\n\n*/\n\n(class Boolean_ideal extends Boolean {\n\n    duplicate () {\n        return this\n    }\n \n    // logic\n\n    negate () {\n        return !this\n    }\n\n    and (v) {\n        return this && v\n    }\n\n    or (v) {\n        return this || v\n    }\n\n    xor (v) {\n        return ( this && !v ) || ( !this && v )\n    }\n\n    // control flow\n\n    ifTrue (aClosure) { // just a test\n        if (this) {\n            return aClosure()\n        }\n        return undefined\n    }\n\n}).initThisCategory();\n",
  "zMFfpozriKe7Gp+vkyAc1d0v9G/YtcFc42Bf2fifbM4=": "\"use strict\";\n\n/*\n\n    Set_ideal\n    \n    Some extra methods for the Javascript Set primitive.\n\n*/\n\n(class Set_ideal extends Set {\n\n    static fromIterator (iterator) {\n        const results = new this()\n        let entry = iterator.next()\n        while (!entry.done) {\n            const v = entry.value\n            results.add(v)\n            entry = iterator.next()\n        }\n        return results\n    }\n\n    count () {\n        return this.size\n    }\n\n    shallowCopy () {\n        return new Set(this)\n    }\n\n    // --- keys and values ---\n\n    keysArray () {\n        return Array.fromIterator(this.values())\n    }\n\n    valuesArray () {\n        return this.keysArray()\n    }\n\n    // --- enumeration ---\n\n    forEachKV (fn) {\n        this.forEach((v, k, self) => fn(k, v, self))\n    }\n\n    forEachK (fn) {\n        this.forEach((v, k) => fn(k))\n    }\n\n    forEachV (fn) {\n        this.forEach(v => fn(v))\n    }\n\n    // --- detect, select, map ---\n\n    detect (fn) {\n        for (let v of this) {\n            const r = fn(v)\n            if (r === true) {\n                return v;\n            }\n        }\n        return undefined\n    }\n\n    filter (fn) {\n        return this.select(fn)\n    }\n    \n    select (fn) {\n        // should this return a Set?\n        return this.valuesArray().select(fn)\n    }\n\n    map (func) {\n        const result = new Set()\n        this.forEach((v) => result.add(func(v)))\n        return result\n    }\n\n    isSubsetOf (superSet) {\n        return superSet.isSupersetOf(this);\n    }\n\n    isSupersetOf (subset) {\n        if (this.size < subset.size) { // can't contain it with fewer keys\n            return false\n        }\n\n        for (let v of subset) {\n            if (!this.has(v)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    union (setB) {\n        let _union = new Set(this);\n        for (let v of setB) {\n            _union.add(v);\n        }\n        return _union;\n    }\n    \n    intersection (setB) {\n        let _intersection = new Set();\n        for (let elem of setB) {\n            if (this.has(elem)) {\n                _intersection.add(elem);\n            }\n        }\n        return _intersection;\n    }\n    \n    symmetricDifference (setB) { \n        // return values in self that are not in setB + values in setB not in self\n        let _difference = new Set(this);\n        for (let v of setB) {\n            if (_difference.has(v)) {\n                _difference.delete(v);\n            } else {\n                _difference.add(v);\n            }\n        }\n        return _difference;\n    }\n    \n    difference (setB) { // return values in self that are not in setB\n        let _difference = new Set(this);\n        for (let v of setB) {\n            _difference.delete(v);\n        }\n        return _difference;\n    }\n\n    isEmpty (func) {\n        return this.size == 0        \n    }\n\n    pop () {\n        const iter = this.values();\n        const value = iter.next().value;\n        return value\n    }\n\n}).initThisCategory();\n\n    \n/*\n    //Examples\n    let setA = new Set([1, 2, 3, 4])\n    let setB = new Set([2, 3])\n    let setC = new Set([3, 4, 5, 6])\n    \n    setA.isSupersetOf(setB); // => true\n    setA.union(setC); // => Set [1, 2, 3, 4, 5, 6]\n    setA.intersection(setC); // => Set [3, 4]\n    setA.symmetricDifference(setC); // => Set [1, 2, 5, 6]\n    setA.difference(setC); // => Set [1, 2]\n*/\n",
  "XVO22Qq5UOJ/o4Z5qWI6V4OrDDnKcfx6q21zIfsJwsI=": "\"use strict\";\n\n/*\n\n    Map_ideal\n\n    Some extra methods for the Javascript Set primitive.\n\n*/\n\n(class Map_ideal extends Map {\n    shallowCopy () {\n        return new Map(this)\n    }\n\n    count () {\n        return this.size\n    }\n\n    at (k) {\n        return this.get(k)\n    }\n\n    atIfAbsentPut (k, v) {\n        if (!this.has(k)) {\n            this.set(k, v)\n        }\n        return this\n    }\n\n    hasKey (k) {\n        return this.has(k)\n    }\n\n    atPut (k, v) {\n        this.set(k, v)\n        return this\n    }\n\n    removeKey (k) {\n        this.delete(k)\n        return this\n    }\n\n    // --- enumeration ---\n\n    forEachKV (fn) {\n        this.forEach((v, k, self) => fn(k, v, self))\n    }\n\n    forEachK (fn) {\n        this.forEach((v, k) => fn(k))\n    }\n\n    forEachV (fn) {\n        this.forEach(v => fn(v))\n    }\n\n    // --- keys ---\n\n    keysArray () {\n        return Array.fromIterator(this.keys())\n    }\n\n    keysSet () {\n        return Set.fromIterator(this.keys())\n    }\n\n    // --- values ---\n\n    valuesArray () {\n        return Array.fromIterator(this.values())\n    }\n\n    valuesSet () {\n        return Set.fromIterator(this.values())\n    }\n\n    // ---\n\n    mergeInto (aMap) {\n        this.forEachKV((k, v) => aMap.set(k, v))\n    }\n\n\n    merge (aMap) {\n        aMap.forEachKV((k, v) => this.set(k, v))\n    }\n\n    select (fn) {\n        const m = new this()\n        this.forEach((v, k) => {\n            if (fn(k, v)) {\n                m.set(k, v)\n            }\n        })\n        return m\n    }\n\n    isEqual (aMap) {\n        if (this.count() !== aMap.count()) {\n            return false\n        }\n\n        for (let k in this) {\n            const v1 = this.get(k)\n            const v2 = aMap.get(k)\n            if (v1 !== v2) {\n                return false\n            }\n        }\n        \n        return true\n    }\n\n    isEmpty () {\n        return this.size === 0        \n    }\n\n    asDict () {\n        const dict = {}\n        this.forEachKV((k, v) => dict[k] = v)\n        return dict\n    }\n    \n    fromDict (aDict) {\n        this.clear()\n        aDict.ownForEachKV((k, v) => this.set(k, v))\n        return this\n    }\n\n    description () {\n        return JSON.stringify(this.asDict(), null, 2) // may throw error if values aren't json compatible\n    }\n\n}).initThisCategory();\n\n    ",
  "Icrpta+6W0wKOpUGRqWgWUR7o1nDhCQBHNTBPM0gTKY=": "\"use strict\";\n\n/*\n\n    Error_ideal\n\n    Some extra methods for the Javascript Error primitive.\n\n*/\n\n(class Error_ideal extends Error {\n\n    /*\n    JS seems to have this slot\n    static stackTraceLimit () {\n        return 100 // looks like default on Chrome is 10?\n    }\n    */\n\n    static assert (v) {\n        if (!Boolean(v)) {\n            throw new Error(\"assert failed - false value\")\n        }\n        return v\n    }\n\n    static assertDefined (v) {\n        if (v === undefined) {\n            throw new Error(\"assert failed - undefined value\")\n        }\n        return v\n    }\n\n    static showCurrentStack () {\n        const e = new Error()\n        e.name = \"STACK TRACE\"\n        e.message = \"\"\n        console.log( e.stack );\n    }\n\n    static assertThrows (func) {\n        assert(Type.isFunction(func))\n\n        let didThrow = false\n        try {\n            func()\n        } catch(e) {\n            didThrow = true\n        }\n\n        if (!didThrow) {\n            console.log(\"assertThrows(\" + func.toString() + \") failed\")\n        } else {\n            //console.log(\"assertThrows(\" + func.toString() + \") passed\")\n        }\n\n        assert(didThrow)\n    }\n\n    static try (func) {\n        try {\n            func()\n        } catch (error) {\n            this.showError(error)\n        }\n    }\n\n    static callingScriptURL () {\n        const urls = new Error().stackURLs()\n        return urls[1]\n    }\n\n    \n    stackURLs (v) {\n        let urls = this.stack.split(\"at\")\n        urls.removeFirst()\n        urls = urls.map(url => {\n            \n            if (url.contains(\"(\")) {\n                url = url.after(\"(\")\n            }\n    \n            url = url.strip()\n    \n            const parts = url.split(\":\")\n            parts.removeLast()\n            parts.removeLast()\n            return parts.join(\":\")\n        })\n        return urls\n    }\n\n    // ------------------------\n\n    description () {\n        const error = this\n        const lines = error.stack.split(\"\\n\")\n        const firstLine = lines.removeFirst()\n        const out = []\n        const indent = \"    \"\n\t\t\n        lines.forEach(function (line) {\n            if (line.contains(\"at file\")) {\n                out.push([\"....\", line.after(\"at \").split(\"/\").pop()])\n            } else {\n                line = line.after(\"at \")\n                if (line === \"\") {\n                    return;\n                }\n                const obj = line.before(\".\")\n                const method = line.after(\".\").before(\" (\")\n                const path = line.after(\"(\").before(\")\")\n                const filePart = path.split(\"/\").pop()\n                let file = filePart.before(\":\")\n                if (file === \"\") { \n                    file = \"???.js:??:?\"\n                }\n                const className = file.before(\".js\")\n                const location = filePart.after(\":\")\n                out.push([className + \" \" + method + \"()      \", file + \":\" + location])\n            }\n        })\n\t\t\n        let s = firstLine + \"\\n\"\n        const m = out.maxValue(function (entry) { return entry[0].length })\n        out.forEach(function (entry) {\n            s += indent + entry[0] + \" \".repeat(m + 1 - entry[0].length) + entry[1] + \"\\n\"\n        })\n\t\t\n        //s = error.message + \"\\n\" + s\n        s = s.replaceAll(\"<br>\", \"\\n\")\n        return s\n    }\n\t\n    show () {\n        console.warn(this.description())\n    }\n\n}).initThisCategory();\n\n// --- helper functions ---\n\ngetGlobalThis().assert = function assert(v) {\n    return Error.assert(v)\n}\n\ngetGlobalThis().assertDefined = function assertDefined(v) {\n    return Error.assertDefined(v)\n}\n\ngetGlobalThis().assertThrows = function assertThrows(func) {\n    Error.assertThrows(func)\n}\n",
  "57PCjFxSdTWTKPIvrHNapK/Oy8ththLvf4ufmZmMtWo=": "\"use strict\";\n\n/*\n\n    Function_ideal\n\n    Some extra methods for the Javascript Function primitive.\n\n*/\n\n",
  "qAwXNUMJxnTb9fhPEceLLIJXMI/fmMwxCL4GOvBs1Ls=": "\"use strict\";\n\n/*\n\n    Image-ideal\n\n    Some extra methods for the Javascript Image primitive.\n\n    Delegate protocol:\n\n        didFetchDataUrl(data) // sent after load\n\n*/\n\nif (!getGlobalThis().Image) {\n    console.log(\"WARNING: no Image object found - maybe we are not in browser?\")\n} else {\n\n    (class Image_ideal extends Image {\n\n        setDelegate (anObject) {\n            Object.defineSlot(this, \"_delegate\", anObject)\n            return this\n        }\n\n        delegate () {\n            return this._delegate\n        }\n\n        loadUrl (url) {\n            this.crossOrigin = \"Anonymous\";\n            this.onload = () => { this.didLoad() }\n            this.src = url;\n            return this\n        }\n\n        didLoad () {\n            // create a canvas the size of the image\n            const canvas = document.createElement(\"CANVAS\");\n            canvas.height = this.height;\n            canvas.width = this.width;\n\n            // draw image to the canvas\n            const ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(img, 0, 0);\n\n            // get the image data from the canvas\n            const data = canvas.toDataURL(\"image/jpeg\");\n\n            // tell the delegate about the loaded data\n            if (this._delegate) {\n                this._delegate.didFetchDataUrl(data)\n            }\n\n            /*\n                // test data\n\n                if (img.complete || img.complete === undefined) {\n                    img.src = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==\";\n                    img.src = src;\n                }\n            */\n        \n            return this\n        }\n\n    }).initThisCategory();\n\n}\n",
  "t1mG9d9yDaS5ZjKwrRIIdBm6QQfFiwf6oChGMjQP214=": "\"use strict\";\n\n/*\n\n    Some code for adding categories to all the typed array types. \n\n*/\n\nType.typedArrayTypeNames().forEach((name) => {\n    const aClass = getGlobalThis()[name]\n\n    if (Type.isUndefined(aClass)) {\n        console.warn(\"TypeArray-store error: missing type \" + name)\n        return\n    }\n\n    /*\n    Object.defineSlots(aClass, { // class methods\n    })\n    */\n\n    Object.defineSlots(aClass.prototype, { // instance methods\n        base64Encoded: function(aRecord, aStore) {\n            return btoa(String.fromCharCode.apply(null, new Uint8Array(this)));\n        },\n    })\n\n})\n\nObject.defineSlots(ArrayBuffer.prototype, { // TODO: move to ArrayBuffer_ideal\n    base64Encoded: function (aRecord, aStore) {\n        return btoa(String.fromCharCode.apply(null, new Uint8Array(this)));\n    },\n\n    promiseSha256Digest: function () {\n        return crypto.subtle.digest(\"SHA-256\", this)\n     }\n});\n\n//console.log(\"base64Encoded test:\", new Uint32Array([1, 2, 3]).base64Encoded())",
  "0Lpc3fb2nKgFtThnT4IKX1tNIesQsYazOoq41y3gKhw=": "\"use strict\";\n\n/*\n\n    Slot\n\n    Abstraction for a slot on a prototype. \n    An array of these are stored in each prototype.\n    \n    - stores slot related data, such as:\n        - default value\n        - cloning policy \n        - persistent policy\n        - comment\n        - whether slot can be:\n            - edited\n            - inspected\n        - isPrivate\n        - slotType\n    - handles auto generating getter/setter\n\n    NOTE:\n\n        TODO: hooks code is a mess, need to cleanup and modularize\n*/\n\nif (!getGlobalThis().ideal) {\n    getGlobalThis().ideal = {} \n}\n\ngetGlobalThis().ideal.Slot = (class Slot extends Object { \n\n    setShouldStore (aBool) {\n        throw new Error(\"Slot.setShouldStore should not be called on Slot\")\n    }\n\n    shouldStore () {\n        throw new Error(\"Slot.shouldStore should not be called on Slot\")\n    }\n\n    simpleNewSlot (slotName, initialValue) { \n        // TODO: unify with Object.newSlot by separating out bit that creates a Slot instance\n        const privateName = \"_\" + slotName;\n        Object.defineSlot(this, privateName, initialValue)\n\n        if (!this[slotName]) {\n            const simpleGetter = function () {\n                return this[privateName];\n            }\n\n            Object.defineSlot(this, slotName, simpleGetter)\n        }\n\n        const setterName = \"set\" + slotName.capitalized()\n\n        if (!this[setterName]) {\n            const simpleSetter = function (newValue) {\n                this[privateName] = newValue;\n                return this;\n            }\n\n            Object.defineSlot(this, setterName, simpleSetter)\n        }\n\n        this._slotNames.add(slotName)\n        \n        return this;\n    }\n\n    initPrototypeSlots () {\n        Object.defineSlot(this, \"_slotNames\", new Set())\n        \n        this.simpleNewSlot(\"owner\", null) // typically a reference to a .prototype\n        this.simpleNewSlot(\"name\", false)\n        this.simpleNewSlot(\"setterName\", null)\n        this.simpleNewSlot(\"directSetterName\", null)\n        this.simpleNewSlot(\"initValue\", null) // needed?\n\n        // getter\n        this.simpleNewSlot(\"ownsGetter\", true)\n        this.simpleNewSlot(\"doesHookGetter\", false)\n        //this.simpleNewSlot(\"hookedGetterIsOneShot\", false) \n        //this.simpleNewSlot(\"isInGetterHook\", false)\n\n        // setter\n        this.simpleNewSlot(\"ownsSetter\", true) // if true, we'll create the setter\n        this.simpleNewSlot(\"doesHookSetter\", false) // if shouldStore, then auto post isDirty?\n        //this.simpleNewSlot(\"doesPostSetter\", false) // posts a didUpdateSlot<SlotName> notification\n\n        // storage related\n        this.simpleNewSlot(\"shouldStoreSlot\", false) // should hook setter\n        this.simpleNewSlot(\"initProto\", null) // clone this proto on init and set to initial value\n        this.simpleNewSlot(\"valueClass\", null) // declare the value should be a kind of valueClass\n        //this.simpleNewSlot(\"field\", null)\n        //this.simpleNewSlot(\"isLazy\", false) // should hook getter\n        this.simpleNewSlot(\"isWeak\", false) // should hook getter\n\n        // slot hook names\n        this.simpleNewSlot(\"methodForWillGet\", null)\n        this.simpleNewSlot(\"methodForWillUpdate\", null)\n        this.simpleNewSlot(\"methodForDidUpdate\", null)\n        this.simpleNewSlot(\"methodForUndefinedGet\", null)\n        this.simpleNewSlot(\"methodForOnFinalized\", null)\n        this.simpleNewSlot(\"privateName\", null)\n\n        // debugging \n        //this.simpleNewSlot(\"doesBreakInGetter\", false) // uses \"debugger;\"\n        //this.simpleNewSlot(\"doesBreakInSetter\", false) // uses \"debugger;\"\n\n        // copying behavior\n        //this.simpleNewSlot(\"initOp\", \"copyValue\")\n        //this.simpleNewSlot(\"validInitOps\", new Set([\"null\", \"lazy\", \"proto\", \"nop\", \"copyValue\", \"duplicate\"])) \n        this.simpleNewSlot(\"duplicateOp\", \"nop\")\n        this.simpleNewSlot(\"validDuplicateOps\", new Set([\"nop\", \"copyValue\", \"duplicate\"])) \n        this.simpleNewSlot(\"comment\", null)\n        this.simpleNewSlot(\"isPrivate\", false)\n\n        // inspector related\n        // slotType is a string value, eg: \"Boolean\", \"String\", \"Number\", Action - can be used to find a class \n        // to create an inspector node for the slotValue\n        this.simpleNewSlot(\"slotType\", null)\n        this.simpleNewSlot(\"canInspect\", false)\n        this.simpleNewSlot(\"canEditInspection\", true)\n        this.simpleNewSlot(\"label\", null) // visible label on inspector\n        this.simpleNewSlot(\"validValues\", null) // used for options field and validation\n        this.simpleNewSlot(\"validValuesClosure\", null) \n        this.simpleNewSlot(\"allowsMultiplePicks\", false)\n        this.simpleNewSlot(\"inspectorPath\", null) // if non-null, uses to create a path for the slot inspector\n\n        this.simpleNewSlot(\"syncsToView\", false) // if true, will hook slot setter to call this.scheduleSyncToView() on slotValue change\n    }\n\n    newInspectorField () {\n        const slotType = this.slotType() \n        if (slotType /*&& this.canInspect()*/) {\n            let fieldName = \"BM\" + slotType + \"Field\"\n            if (this.validValues() || this.validValuesClosure()) {\n                fieldName = \"BMOptionsNode\"\n            }\n            const proto = getGlobalThis()[fieldName]\n            if (proto) {\n                const field = proto.clone()\n\n                field.setKey(this.name())\n                field.setKeyIsEditable(false)\n                field.setValueMethod(this.name())\n                field.setValueIsEditable(this.canEditInspection())\n                field.setCanDelete(false)\n                //assert(!field.canSelfAddSubnode())\n\n                if (this.label()) {\n                    field.setKey(this.label())\n                }\n\n                if (this.validValues()) {\n                    field.setValidValues(this.validValues())\n                    field.setAllowsMultiplePicks(this.allowsMultiplePicks())\n                    field.setNodeSubtitleIsChildrenSummary(true)\n                } else if (this.validValuesClosure()) {\n                    const vv = this.validValuesClosure()()\n                    field.setValidValues(vv)\n                    field.setAllowsMultiplePicks(this.allowsMultiplePicks())\n                }\n                return field\n            }\n        }\n        return null\n    }\n\n    validDuplicateOps () {\n        return new Set([\"nop\", \"copyValue\", \"duplicate\"])\n    }\n    \n    setDuplicateOp (aString) {\n        assert(this.validDuplicateOps().has(aString))\n        this._duplicateOp = aString\n        return this\n    }\n\n    /*\n    onInstanceGetDuplicateValue (anInstance) {\n        const v = this.onInstanceGetValue(anInstance)\n        const dop = this.duplicateOp()\n\n        if (v === null) {\n            return null\n        } else if (dop === \"nop\") {\n            return v\n        } else if (dop === \"copyValue\") {\n            return v\n        } else if (dop === \"duplicate\" && v && v.duplicate) {\n            return v.duplicate()\n        }\n\n        throw new Error(\"unable to duplicate\")\n    }\n    */\n\n    setName (aName) {\n        assert(Type.isString(aName) && aName.trim().length > 0)\n        this._name = aName\n        const n = this.name().capitalized()\n        this.setPrivateName(\"_\" + aName)\n        this.setSetterName(\"set\" + aName.capitalized())\n        this.setDirectSetterName(\"directSet\" + aName.capitalized())\n        this.setMethodForWillGet(\"willGetSlot\" + n)\n        this.setMethodForDidUpdate(\"didUpdateSlot\" + n)\n        this.setMethodForWillUpdate(\"willUpdateSlot\" + n)\n        this.setMethodForUndefinedGet(\"onUndefinedGet\" + n) // for lazy slots\n        this.setMethodForOnFinalized(\"onFinalizedSlot\" + n) // for weak slots\n        return this \n    }\n\n    copyFrom (aSlot) {\n        this._slotNames.forEach(slotName => {\n            const privateName = \"_\" + slotName;\n            this[privateName] = aSlot[privateName]\n            /*\n            const setterName = \"set\" + slotName.capitalized()\n            const v = aSlot[slotName].apply(aSlot)\n            this[setterName].call(this, v)\n            */\n        })\n        return this\n    }\n\n    autoSetGetterSetterOwnership () {\n        this.setOwnsGetter(!this.alreadyHasGetter())\n        this.setOwnsSetter(!this.alreadyHasSetter())\n        return this\n    }\n\n    hookNames () {\n        const hookMethodNames = this._slotNames.filter(n => n.beginsWith(\"methodFor\"))\n        const hookNames = hookMethodNames.map(n => this[n].apply(this))\n        return hookNames\n    }\n\n    ownerImplemnentsdHooks () {\n        return true\n        /*\n        const slotsMap = this.owner().slotsMap() // TODO: this is slow\n        return this.hookNames().detect(hookName => slotsMap.has(hookName)) ? true : false\n        */\n    }\n\n    setDoesHookSetter (aBool) {\n        if (this._doesHookSetter !== aBool) {\n            this._doesHookSetter = aBool\n            if (aBool) {\n                if (this.alreadyHasSetter() && !this.ownsSetter()) {\n                    const msg = this.owner().type() + \".\" + this.setterName() + \"() exists, so we can't hook it - fix by calling slot.setOwnsSetter(true)\"\n                    console.log(msg)\n                    throw new Error(msg)\n                } \n                // this.setOwnsSetter(true)\n            }\n            //this.setupSetter()\n        }\n        return this \n    }\n\n    // setup\n\n    setupInOwner () {\n        this.autoSetGetterSetterOwnership()\n        this.setupValue()\n        this.setupGetter()\n        this.setupSetter()\n        return this\n    }\n\n    setupValue () {\n        Object.defineSlot(this.owner(), this.privateName(), this.initValue())\n        return this\n    }\n\n    // getter\n\n    alreadyHasGetter () {\n        return this.owner().hasOwnProperty(this.getterName()) // TODO: hasOwnProperty? \n    }\n\n    setupGetter () {\n        if (this.ownsGetter()) {\n            if (this.ownerImplemnentsdHooks()) {\n                Object.defineSlot(this.owner(), this.getterName(), this.autoGetter())\n            } else {\n                this.makeDirectGetter()\n            }\n        }\n        return this\n    }\n\n    alreadyHasSetter () {\n        return this.owner().hasOwnProperty(this.setterName())  // TODO: hasOwnProperty? \n    }\n\n    setupSetter () {\n        if (this.ownsSetter()) {\n            if (this.ownerImplemnentsdHooks()) {\n                Object.defineSlot(this.owner(), this.setterName(), this.autoSetter())\n            } else {\n                this.makeDirectSetter()\n            }\n            //Object.defineSlot(this.owner(), this.directSetterName(), this.directSetter())\n        }\n    }\n\n    // --- getter ---\n\n    getterName () {\n        return this.name()\n    }\n\n    // direct getter\n\n    makeDirectGetter () {\n        Object.defineSlot(this.owner(), this.getterName(), this.directGetter())\n        return this\n    }\n\n    directGetter () {\n        const privateName = this.privateName()\n        const func = function () {\n            return this[privateName]\n        }\n        return func\n    }\n\n    // hooked getter\n\n    makeDirectGetterOnInstance (anInstance) {\n        Object.defineSlot(anInstance, this.getterName(), this.directGetter())\n        return this   \n    }\n\n    // ----------------------------------------\n\n    autoGetter () {\n        const slot = this\n        return function () { \n            return this.getSlotValue(slot) \n        }\n    }\n\n    autoSetter () {\n        const slot = this\n        return function (newValue) { \n            return this.setSlotValue(slot, newValue) \n        }\n    }\n\n    // --- setter ---\n\n    makeDirectSetter () {\n        Object.defineSlot(this.owner(), this.setterName(), this.directSetter())\n        return this\n    }\n\n    directSetter () {\n        const privateName = this.privateName()\n        const func = function (newValue) {\n            this[privateName] = newValue\n            return this\n        }\n        return func\n    }\n\n    // call helpers\n\n    onInstanceRawGetValue (anInstance) {\n        return anInstance[this.privateName()]\n    }\n\n    onInstanceGetValue (anInstance) {\n        return anInstance[this.getterName()].apply(anInstance)\n    }\n\n    onInstanceSetValue (anInstance, aValue) {\n        const m = anInstance[this._setterName];\n        if (Type.isUndefined(m)) {\n            throw new Error(anInstance.type() + \" is missing setter '\" + this._setterName + \"'\")\n        }\n        return m.call(anInstance, aValue)\n    }\n\n    // --- StoreRefs for lazy slots ---\n\n    onInstanceSetValueRef (anInstance, aRef) {\n        anInstance.lazyRefsMap().set(this.name(), aRef) \n        return this\n    }\n\n    onInstanceGetValueRef (anInstance, aRef) {\n        return anInstance.lazyRefsMap().get(this.name()) \n    }\n\n    copyValueFromInstanceTo (anInstance, otherInstance) {\n        /*\n        if (this.isLazy()) {\n            const valueRef = this.onInstanceGetValueRef(anInstance)\n            if (valueRef) {\n                this.onInstanceSetValueRef(otherInstance, valueRef)\n                return this\n            }\n        }\n        */\n\n        const v = this.onInstanceGetValue(anInstance)\n        this.onInstanceSetValue(otherInstance, v)\n        return this\n    }\n\n    // -----------------------------------------------------\n\n    onInstanceInitSlot (anInstance) {\n        //assert(Reflect.has(anInstance, this.privateName())) // make sure slot is defined - this is true even if it's value is undefined\n        let defaultValue = anInstance[this._privateName]\n\n        /*\n        const op = this.initOp()\n        assert(this.validInitOps().contains(op)) // TODO: put on setter instead\n\n        const opMethods = {\n            \"null\" : () => { \n                this.onInstanceSetValue(anInstance, null)\n            },\n\n            \"lazy\" : () => { \n                const obj = this.initProto().clone()\n                anInstance[this.privateName()] = obj\n            },\n\n            \"proto\" : () => { \n                const obj = this.initProto().clone()\n                this.onInstanceSetValue(anInstance, obj)\n            },\n\n            \"nop\" : () => { \n            },\n\n            \"copyValue\" : () => { \n                this.onInstanceSetValue(anInstance, defaultValue)\n            },\n    \n            \"duplicate\" : () => { \n                if (defaultValue) {\n                    const obj = defaultValue.duplicate()\n                    this.onInstanceSetValue(anInstance, obj)\n                }\n            },\n        }\n\n        opMethods[op].apply(this)\n        */\n\n        const initProto = this._initProto\n        /*\n        if (this.isLazy()) {\n            const obj = initProto.clone()\n            anInstance[this._privateName] = obj\n        } else */ \n        if (initProto) {\n            const obj = initProto.clone()\n            this.onInstanceSetValue(anInstance, obj)\n        } else if (this._initValue) {\n            this.onInstanceSetValue(anInstance, this._initValue)\n        }\n\n        /*\n        if (this.field()) {\n            // duplicate the field instance owned by the slot,\n            // add it as a subnode to the instance,\n            // and sync it to the instance's slot value\n            const newField = this.field().duplicate()\n            anInstance.addSubnode(newField)\n            newField.getValueFromTarget()\n        }\n        */\n    }\n\n    onInstanceLoadRef (anInstance) {\n        const storeRef = this.onInstanceGetValueRef(anInstance)\n        if (storeRef) {\n            \n            //console.warn(anInstance.typeId() + \".\" + this.name() + \" [\" + anInstance.title() + \"] - loading storeRef\")\n            //console.warn(anInstance.title() + \" loading storeRef for \" + this.name())\n            const obj = storeRef.unref()\n            /*\n            //console.warn(\"   loaded: \" + obj.type())\n            anInstance[this.privateName()] = obj // is this safe? what about initialization?\n            //this.onInstanceSetValue(anInstance, obj)\n            this.onInstanceSetValueRef(anInstance, null)\n            */\n\n            const setter = anInstance[this.setterName()]\n            setter.apply(anInstance, [obj]) // WARNING: this may mark objects as dirty\n\n        } else {\n            //console.warn(anInstance.typeId() + \" unable to load storeRef - not found\")\n            //console.warn(anInstance.typeId() + \".shouldStoreSubnodes() = \" + anInstance.shouldStoreSubnodes())\n            //throw new Error(\"\")\n        }\n    }\n\n    hasSetterOnInstance (anInstance) {\n        return Type.isFunction(anInstance[this.setterName()])\n    }\n\n    // --- should store on instance ---\n\n    shouldStoreSlotOnInstancePrivateName () {\n        return \"_shouldStoreSlot\" + this.name().capitalized()\n    }\n\n    shouldStoreSlotOnInstance (anInstance) {\n        const k = this.shouldStoreSlotOnInstancePrivateName()\n        const v = anInstance[k]\n        if (Type.isUndefined(v)) {\n            return this.shouldStoreSlot()\n        }\n        return v === true\n    }\n\n    setShouldStoreSlotOnInstance (anInstance, aBool) {\n        const k = this.shouldStoreSlotOnInstancePrivateName()\n        Object.defineSlot(anInstance, k, aBool)\n        return aBool\n    }\n    \n}.initThisClass());\n\n\n// --- slot methods on Function -------------------------------------------------\n\n/*\nObject.defineSlots(Function.prototype, {\n    slot: function () {\n        return this._slot\n    },\n\n    setSlot: function (aSlot) {\n        this._slot = aSlot\n        return this\n    },\n\n})\n*/",
  "0rKRgnGOPAeXSj4vXMnRgLwKBCsg1bUku6hlcm5tZmU=": "\"use strict\";\n\n/*\n\n    ProtoClass\n    \n    A place for adding Smalltalk like features to the base object\n    that we don't want to add to all Object (and Object decendants) yet,\n    as I'm not sure how they might effect the rest of the system.\n\n*/\n\n\n\n\n(class ProtoClass extends Object {\n\n   // --- clone ---\n\n    static clone () {\n        if (this.isSingleton() && this.hasShared()) {\n         //   debugger;\n            // kinda weird dealing with shared in clone like this\n            // do we do this to deal with deserialization of singletons?\n            return this.shared() \n        }\n\n        const obj = new this() \n        obj.init()\n\n        if (this.isSingleton()) {\n            this.setShared(obj)\n        }\n        obj.afterInit()\n\n        //this.allInstancesWeakSet().add(obj)\n\n        return obj\n    }\n\n    // --- shared ---\n\n    static sharedContext () {\n        return this\n    }\n\n    static hasShared () {\n        return !Type.isNullOrUndefined(this.sharedContext()._shared)\n    }\n\n    static shared () {\n        if (!this.hasShared()) {\n            this.setShared(this.clone())\n        }\n        return this._shared\n    }\n\n    static setShared (v) {\n        this.sharedContext()._shared = v\n        return this\n    }\n\n    // --- init ---\n\n    static initClass () { // called only once when class is created\n\n        //console.log(this.type() + \" initThisClass\")\n        Object.defineSlot(this, \"_shared\", undefined)\n        //this.newClassSlot(\"shared\", undefined)\n        this.newClassSlot(\"isSingleton\", false)\n        this.newClassSlot(\"setterNameMap\", new Map()) // TODO: share this between all classes\n        this.newClassSlot(\"allProtoSlotsMap\", new Map())\n\n        //this.newClassSlot(\"allInstancesWeakSet\", new EnumerableWeakSet())\n        return this\n    }\n\n    // --- class slots and variables ---\n\n\n    static ancestorClassesTypesIncludingSelf () {\n        return this.ancestorClassesIncludingSelf().map(c => c.type())\n    }\n\n    static ancestorClassesTypes () {\n        return this.ancestorClasses().map(c => c.type())\n    }\n\n    /*\n    static ancestorClassesIncludingSelf (results = []) {\n        results.push(this)\n\n        const parent = this.parentClass()\n        if (parent && parent.ancestorClasses) {\n            //assert(!results.contains(parent))\n            parent.ancestorClassesIncludingSelf(results)\n        }\n        return results\n    }\n    */\n\n    static isSubclassOf (aClass) {\n        assert(aClass.isClass())\n        return this.ancestorClassesIncludingSelf().contains(aClass)\n    }\n\n    static ancestorClassesIncludingSelf () {\n        const results = this.ancestorClasses().shallowCopy()\n        results.atInsert(0, this)\n        return results\n    }\n\n    static descendantClasses (results = []) {\n        const children = this.childClasses()\n        children.forEach(child => {\n            results.push(child)\n            child.descendantClasses(results)\n        })\n        return results\n    }\n\n    static superClass () {\n        return Object.getPrototypeOf(this)\n    }\n\n    static subclassesDescription (level, traversed) {\n\n        if (Type.isUndefined(level)) {\n            level = 0\n        }\n\n        if (Type.isUndefined(traversed)) {\n            traversed = new Set()\n        }\n\n        /*\n        if (traversed.has(this)) {\n            throw new Error(\"already traversed \", this.type())\n        } else {\n            console.log(\"newly traversing \", this.type())\n        }\n        traversed.add(this)\n        */\n        //const prefix = \"<div class=level\" + level + \">\"\n        //const postfix = \"</div>\"\n\n        const prefix = \"\"\n        const postfix = \"\"\n\n        const spacer = \"  \".repeat(level)\n        const lines = []\n        if (level === 1) {\n            //lines.append(\"----\")\n        }\n        const path = \"\"\n        lines.append(prefix + spacer + this.type() + \" \" + path + postfix)\n        const sortedSubclasses = this.subclasses().sort((a, b) => a.type().localeCompare(b.type()))\n        const subclassLines = sortedSubclasses.map((subclass) => {\n            //return spacer + subclass.subclassesDescription(level + 1, traversed) \n            return subclass.subclassesDescription(level + 1, traversed) \n        })\n        lines.appendItems(subclassLines)\n        return lines.join(\"\\n\")\n    }\n\n    // --- instance ---\n\n\n    initPrototypeSlots () {\n        this.newSlot(\"isDebugging\", false)\n        this.newSlot(\"lazyRefsMap\", null)\n        Object.defineSlot(this, \"_timeoutNameToIdMap\", null)\n    }\n\n    lazyRefsMap () {\n        if (!this._lazyRefsMap) {\n            this._lazyRefsMap = new Map()\n        }\n        return this._lazyRefsMap\n    }\n\n\n\n    setType (aString) {\n        this.constructor.name = aString\n        return this\n    }\n\n    // --- slots ---\n\n    slotNamed (slotName) {\n        assert(this.isPrototype())\n\n        const slot = this.ownSlotNamed(slotName)\n        \n        if (slot) {\n            return slot\n        }\n\n        // look in parent\n        const p = this.__proto__ \n        if (p && p.ownSlotNamed) {\n            return p.slotNamed(slotName)\n        }\n\n        return null\n    }\n\n    ownSlotNamed (slotName) {\n        assert(this.isPrototype())\n\n        const slot = this.slotsMap().at(slotName)\n        if (slot) {\n            return slot\n        }\n        \n        return null\n    }\n\n    // slot objects\n\n\n    getSlot (slotName) {\n        return this.allSlotsMap().get(slotName)\n    }\n\n    hasSlot (slotName) {\n        return this.getSlot(slotName) !== undefined\n    }\n\n    detectSlot (fn) { // returns undefined if no match\n        // TODO: Optimize - this should stop search on match\n        let matchingSlot = undefined\n        this.forEachSlot(slot =>  {\n            if (matchingSlot === undefined && fn(slot)) {\n                matchingSlot = slot \n            }\n        })\n        return matchingSlot\n    }\n\n\n\n    /*\n    allSlotsRawValueMap () { // what about action slots?\n        const map = new Map()\n        this.forEachSlotKV((slotName, slot) => map.set(slot.name(), slot.onInstanceRawGetValue(this)))\n        return map\n    }\n\n    isEqual (anObject) {\n        // Should this test Type equality?\n        if (this.type() !== obj2.type()) {\n            return false\n        }\n        const sm1 = this.allSlotsRawValueMap()\n        const sm2 = anObject.allSlotsRawValueMap()\n        return sm1.isEqual(sm2)\n    }\n    */\n\n    // -------------------------------------\n\n    newSlotIfAbsent (slotName, initialValue) {\n        const slot = this.getSlot(slotName)\n        if (slot) {\n            return slot\n        }\n        return this.justNewSlot(slotName, initialValue)\n    }\n\n    newSlot (slotName, initialValue, allowOnInstance=false) {\n        /*\n        if (Reflect.ownKeys(this).contains(slotName)) {\n            const msg = \"WARNING: \" + this.type() + \".\" + slotName + \" slot already exists\"\n            throw new Error(msg)\n        }\n        */\n\n        if (this.hasSlot(slotName)) {\n            const msg = this.type() + \" newSlot('\" + slotName + \"') - slot already exists\"\n            console.log(msg)\n            throw new Error(msg)\n        }\n        return this.justNewSlot(slotName, initialValue, allowOnInstance)\n    }\n\n    overrideSlot (slotName, initialValue, allowOnInstance=false) {\n        const oldSlot = this.getSlot(slotName)\n        if (Type.isUndefined(oldSlot)) {\n            const msg = this.type() + \" newSlot('\" + slotName + \"') - no existing slot to override\"\n            console.log(msg)\n            throw new Error(msg)\n        }\n        const slot = this.justNewSlot(slotName, initialValue, allowOnInstance)\n        slot.copyFrom(oldSlot)\n        slot.setInitValue(initialValue)\n        slot.setOwner(this)\n        return slot\n    }\n\n    justNewSlot (slotName, initialValue, allowOnInstance=false) { // private\n        if (!allowOnInstance) {\n            assert(this.isPrototype())\n        }\n        assert(Type.isString(slotName))\n\n        /*\n        // TODO: we want to create the private slots and initial value on instances\n        // but ONLY create method slots on classes, not instances...\n        const privateName = \"_\" + slotName\n        this[privateName] = initialValue\n        */\n\n        const slot = ideal.Slot.clone().setName(slotName).setInitValue(initialValue)\n        slot.setOwner(this)\n        this.slotsMap().set(slotName, slot)\n        this.allSlotsMap().set(slotName, slot)\n        return slot\n    }\n\n    newWeakSlot (slotName, initialValue) {\n        const slot = this.newSlot(slotName, initialValue)\n        slot.setIsWeak(true)\n        return slot;\n    }\n\n    // --- weak slot ---\n\n    onFinalizedSlot (aSlot) {\n        this[aSlot.privateName()] = undefined\n\n        // only called on weak slot\n        const k = aSlot.methodForOnFinalized()\n        const m = this[k]\n        if (m) {\n            m.apply(this)\n        }\n    }\n\n    getWeakSlotValue (aSlot) {\n        const privateName = aSlot.privateName()  // fix this value\n        const weakRef = this[privateName]\n\n        if (weakRef === null) {\n            return null\n        }\n\n        if (weakRef === undefined) {\n            return undefined\n        }\n\n        // if we got here, it's a weakref\n        const v = weakRef.deref()\n        if (v === undefined) {\n            // it must have been collected\n            this.onFinalizedSlot(aSlot)\n        }\n        return v\n    }\n\n    setWeakSlotValue (aSlot, newValue) {\n        const privateName = aSlot.privateName()  // fix this value\n        const oldValue = this.getWeakSlotValue(aSlot) // doesn't trigger willGetSlot() but may call onFinalizedSlot()\n\n        if (newValue !== oldValue) {\n            if (newValue === null) {\n                this[privateName] = null\n            } else {\n                this[privateName] = new WeakRef(newValue)\n            }\n        }\n        return this\n    }\n\n    // --- base getter setter ---\n\n\n    baseGetSlotValue (aSlot) {\n        if (aSlot.isWeak()) {\n            return this.getWeakSlotValue(aSlot)\n        } else {\n            //const privateName = aSlot.privateName() \n            //return this[privateName]\n            return this[aSlot._privateName]\n        }\n    }\n\n    baseSetSlotValue (aSlot, newValue) {\n        const privateName = aSlot.privateName() \n        if (aSlot.isWeak()) {\n            this.setWeakSlotValue(aSlot, newValue)\n        } else {\n            this[privateName] = newValue\n        }\n        this[privateName]\n        return this\n    }\n\n    // --- auto getter setter ---\n\n    getSlotValue (aSlot) { //testing this\n        const v = this.baseGetSlotValue(aSlot)\n\n        /*\n        if (v === undefined) {\n            this.onUndefinedGetSlot(aSlot)\n        }\n        */\n\n        this.willGetSlot(aSlot)\n\n        return this.baseGetSlotValue(aSlot)\n    }\n\n    /*\n    onUndefinedGetSlot (aSlot) {\n        // get undefined hook\n        // e.g.: slot \"subnodes\" -> onUndefinedGetSubnodes()\n\n        if (aSlot.isLazy()) {\n            aSlot.onInstanceLoadRef(this)\n        }\n\n        const undefHook = aSlot.methodForUndefinedGet()\n        const m = this[undefHook]\n        if (m) {\n            m.apply(this)\n        }\n    }\n    */\n   \n    willGetSlot (aSlot) {\n        // e.g.: slot \"subnodes\" -> willGetSlotSubnodes()\n        const s = aSlot.methodForWillGet()\n        const f = this[s]\n        if (f) {\n            f.apply(this)\n        }\n    }\n\n    // --- setter ---\n\n    setSlotValue (aSlot, newValue) {\n        const oldValue = this.baseGetSlotValue(aSlot)\n        if (oldValue !== newValue) {\n            this.baseSetSlotValue(aSlot, newValue)\n            this.didUpdateSlot(aSlot, oldValue, newValue)\n        }\n        return this\n    }\n\n    // ----\n\n    didUpdateSlot (aSlot, oldValue, newValue) {\n        const m = this[aSlot.methodForDidUpdate()]\n        if (m) {\n            m.call(this, oldValue, newValue)\n        }\n        /*\n        if (aSlot.shouldStoreSlot()) {\n            this.didMutate(aSlot.name())\n        }\n        */\n    }\n\n    init () { \n        super.init()\n        // subclasses should override to do initialization\n        //assert(this.isInstance())\n        this.initializeSlots()\n    }\n\n    initializeSlots () {\n        this.thisPrototype().allSlotsMap().forEach(slot => slot.onInstanceInitSlot(this)) \n    }\n\n    toString () {\n        return this.type();\n    }\n\n    ownsSlot (name) {\n        return this.hasOwnProperty(name);\n    }\n\n    argsAsArray (args) {\n        return Array.prototype.slice.call(args);\n    }\n\n    respondsTo (methodName) {\n        const f = this[methodName] \n        return typeof(f) === \"function\";\n    }\n\n    performWithArgList (message, argList) {\n        return this[message].apply(this, argList);\n    }\n\n    perform (message) { // will apply any extra arguments to call\n        if (this[message] && this[message].apply) {\n            return this[message].apply(this, this.argsAsArray(arguments).slice(1));\n        }\n\n        throw new Error(this, \".perform(\" + message + \") missing method\")\n        return this;\n    }\n\n    setterNameForSlot (name) {\n        return \"set\" + name.capitalized()\n        /*\n        // cache these as there aren't too many and it will avoid extra string operations\n        if (!m.has(name)) {\n            m.set(name, \"set\" + name.capitalized())\n        }\n        return m.get(name)\n        */\n    }\n\n    toString () {\n        return this.typeId();\n    }\n\n    // --- ancestors ---\n\n    firstAncestorClassWithPostfix (aPostfix) {\n        // not a great name but this walks back the ancestors (including self) and tries to find an\n        // existing class with the same name as the ancestor + the given postfix\n        // useful for things like type + \"View\" or type + \"Tile\", etc\n        //this.debugLog(\" firstAncestorClassWithPostfix(\" + aPostfix + \")\")\n        const classes = this.thisClass().ancestorClassesIncludingSelf()\n        for (let i = 0; i < classes.length; i++) {\n            const aClass = classes[i]\n\n            const name = aClass.type() + aPostfix\n            const proto = Object.getClassNamed(name)\n            if (proto) {\n                return proto\n            }\n            const sansName = name.sansPrefix(\"BM\") // TODO: remove this hack\n            //console.log(\"sansName:\", sansName)\n            const sansProto = Object.getClassNamed(sansName) // hack to deal with nodeViewClass issues\n            if (sansProto) {\n              //  debugger;\n                return sansProto\n            }\n        }\n        return null\n    }\n\n    // debugging\n\n    debugLog (s) {\n        if (this.isDebugging()) {\n            if (Type.isFunction(s)) {\n                s = s()\n            }\n            if (arguments.length == 1) {\n                console.log(this.debugTypeId() + \" \" + s)\n            } else {\n                console.log(this.debugTypeId() + \" \", arguments[0], arguments[1])\n            }\n        }\n        return this\n    }\n\n    // --- other ---\n\n    freeze () {\n        Object.freeze(this)\n        return this\n    }\n\n}.initThisClass());\n\n\n\n",
  "o174avd7SI4sF3QSEATkPGfin4BKhhenuwXRSi1iHkY=": "\"use strict\";\n\n/*\n\n    ObservableProxy\n\n    A class for wrapping a reference in a proxy which can\n    send proxy trap notifications to observers.\n\n    WARNING:\n\n    Proxies are ~10x slower that direct getter/setters or wrappers around them,\n    so they may not be appropraite for high frequency use objects.\n\n    MOTIVATION:\n\n    The motivation for this class was originally as an access tripwire \n    for lazy loading of persistent objects.\n\n    POTENITAIL USES:\n\n    https://exploringjs.com/es6/ch_proxies.html\n\n    Example:\n\n        const myObject = [\"a\", \"b\", \"c\"]\n        const proxyRef = ObservableProxy.newProxyFor(myObject)\n        proxyRef.observable().addObserver(myObserver)\n\n        now if we call:\n\n            proxyRef.length\n\n        it will trigger the \"get\" trap and send an \"onGetObserved\" message to myObserver.\n        \n*/\n\n\n(class ObservableProxy extends ProtoClass {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"observers\", null)\n        this.newSlot(\"target\", null)\n        this.newSlot(\"revocable\", null)\n        this.newSlot(\"trapNames\", [\n            \"apply\",\n            \"construct\",\n            \"defineProperty\", // Object.defineProperty\n            \"deleteProperty\", // Object.deleteProperty\n            \"get\", // obj.x or obj[x]\n            \"getOwnPropertyDescriptor\", // Object.getOwnPropertyDescriptor\n            \"getPrototypeOf\", // Object.getPrototypeOf\n            \"has\", // x in obj\n            \"isExtensible\", // Reflect.isExtensible(target)\n            \"ownKeys\", // Reflect.ownKeys(target)\n            \"preventExtensions\", //  Reflect.preventExtensions(target);\n            \"set\", // obj.x = y or obj[x] = y\n            \"setPrototypeOf\", // Reflect.setPrototypeOf()\n        ])\n        this.newSlot(\"noteNamesDict\", null)\n    }\n\n    init () {\n        super.init()\n        this.setObservers([])\n        this.setupNoteNames()\n        this.setIsDebugging(false)\n        return this\n    }\n\n    newProxyFor (aTarget) {\n        const handler = this.thisClass().clone()\n        handler.setTarget(aTarget)\n        //const proxy = new Proxy(aTarget, handler)\n        this.setRevocable(Proxy.revocable(aTarget, handler))\n        return this.proxy()\n    }\n\n    proxy () {\n        return this.revocable().proxy\n    }\n\n    revoke () {\n        this.postForTrap(\"revoke\", null)\n        this._revocable.revoke()\n        return this\n    }\n\n    setupNoteNames () {\n        this._noteNamesDict = {}\n        this.trapNames().map((name) => {\n            // examples: \"onObservedGet\", \"onObservedSet\"\n            const noteName = \"onObserved\" + name.capitalized()\n            this._noteNamesDict[name] = noteName\n        })\n        return this\n    }\n\n    addObserver (obs) {\n        this.observers().appendIfAbsent(obs)\n        return obs\n    }\n\n    removeObserver (obs) {\n        this.observers().remove(obs)\n        return obs\n    }\n\n    postForTrap (trapName, propertyName) {\n        const noteName = this.noteNamesDict()[trapName]\n\n        this._observers.forEach((obs) => {\n            if (obs[noteName]) {\n                if (this.isDebugging()) {\n                    this.debugLog(\" posting \" + noteName)\n                }\n                obs[noteName].call(obs, this.target(), propertyName)\n            }\n        })\n        return true\n    }\n\n    // --- proxy trap methods ---\n    \n    /*\n\n    apply (target, thisArg, argumentsList) {\n        this.postForTrap(\"apply\", propertyName)\n        return target[propertyName].apply(target, argumentsList)\n    }\n\n    construct (target) {\n\n    }\n\n    */\n\n    defineProperty (target, propertyName, descriptor) {\n        this.postForTrap(\"defineProperty\", propertyName)\n        return Object.defineProperty(target, propertyName, descriptor)  \n    }\n\n    deleteProperty (target, propertyName) {\n        this.postForTrap(\"deleteProperty\", propertyName)\n        return delete target[propertyName];\n    }\n\n    get (target, propertyName) {\n        if (propertyName === \"observable\") {\n            const self = this\n            return () => { return self }\n        }\n\n        /*\n        const proxyMethods = { \"methodName\": true }\n        if (proxyMethods.hasOwnProperty(propertyName)) {\n            let self = this\n            return () => {\n                return self[propertyName].apply(self, arguments)\n            }\n        }\n        */\n\n        this.postForTrap(\"get\", propertyName)\n        return Reflect.get(target, propertyName, target);\n    }\n\n    getOwnPropertyDescriptor (target, propertyName) {\n        this.postForTrap(\"getOwnPropertyDescriptor\", propertyName)\n        return Object.getOwnPropertyDescriptor(target, propertyName)\n    }\n\n    getPrototypeOf (target) {\n        this.postForTrap(\"getPrototypeOf\", null)\n        return Object.getPrototypeOf(target)\n    }\n\n    isExtensible (target, propertyName) {\n        this.postForTrap(\"isExtensible\", propertyName)\n        return Reflect.isExtensible(target)\n    }\n\n    has (target, propertyName) {\n        this.postForTrap(\"has\", propertyName)\n        return Reflect.has( target, propertyName );\n    }\n\n    ownKeys (target, propertyName) {\n        this.postForTrap(\"ownKeys\", propertyName)\n        return Reflect.ownKeys(target)\n    }\n\n    preventExtensions (target, propertyName) {\n        this.postForTrap(\"preventExtensions\", propertyName)\n        return Reflect.preventExtensions(target);\n    }\n\n    set (target, propertyName, newValue) {\n        this.postForTrap(\"set\", propertyName)\n        return Reflect.set(target, propertyName, newValue);\n    }\n\n    setPrototypeOf (target, prototype) {\n        this.postForTrap(\"setPrototypeOf\", null)\n        return Object.setPrototypeOf(target, prototype)  \n    }\n\n    // ---------------\n\n    static selfTest () {\n        const resultsDict = {}\n\n        const noteNamesDict = ObservableProxy.clone().noteNamesDict()\n        \n        assert(\"need to fix this to assign to method name\")\n        const eventMethod = (target, propertyName) => { \n            resultsDict[propertyName] = true \n            console.log(\"got note \" + propertyName)\n        }\n\n        const testObserver = {}\n\n        Object.values(noteNamesDict).forEach((name) => { \n            testObserver[name] = eventMethod\n        })\n\n    \n        const testArray = [\"a\", \"b\", \"c\"]\n        const arrayProxy = ObservableProxy.newProxyFor(testArray)\n        arrayProxy.observable().addObserver(testObserver)\n    \n        const length = arrayProxy.length // get\n        arrayProxy[0] = 1 // set\n        const v = arrayProxy[0] // get\n        1 in arrayProxy // has\n    \n        Reflect.ownKeys(arrayProxy)\n        Object.getOwnPropertyDescriptor(arrayProxy, \"clone\")\n        delete arrayProxy[0]\n        //new arrayProxy\n        arrayProxy.observable().revoke()\n\n        try {\n            arrayProxy.length\n        } catch(e) {\n            console.log(\"proxy properly revoked\")\n        }\n\n        return true\n    }\n\n}.initThisClass());\n\n//ObservableProxy.selfTest()",
  "k7WiqSyeOlq94l9Jy5fUyaxEPLe5gywc/vBvwxP7+CE=": "\"use strict\";\n\n/*\n\n    FirewallProxy\n\n    Usefull for passing references to objects but limiting\n    how it can be accessed e.g. which methods can be called on it.\n\n    An example use case would be an immutable proxy for an array.\n    So an object that owns the array can share an immutable proxy for it\n    that doesn't allow other's to mutate it.\n        \n    Example:\n\n        const array = [\"a\", \"b\", \"c\"]\n        const proxyRef = FirewallProxy.newProxyFor(array)\n        proxyRef.observable().setProtectedMethodNames(new Set([...]))\n        proxyRef.observable().setProtectedTrapNames(new Set([...]))\n    \n*/\n\n(class FirewallProxy extends ObservableProxy {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"protectedTraps\", null).setComment(\"a Set\")\n        this.newSlot(\"protectedMethods\", null).setComment(\"a Set\")\n    }\n\n    init () {\n        super.init()\n        this.setProtectedTraps(this.defaultProtectedTraps().shallowCopy())\n        this.setProtectedMethods(this.defaultProtectedMethods().shallowCopy())\n        this.setIsDebugging(false)\n        return this\n    }\n\n    defaultProtectedTraps () {\n        return new Set([\n            \"defineProperty\", // Object.defineProperty\n            \"deleteProperty\", // Object.deleteProperty\n            \"preventExtensions\", //  Reflect.preventExtensions(target);\n            \"set\", // obj.x = y or obj[x] = y\n            \"setPrototypeOf\", // Reflect.setPrototypeOf()\n        ])\n    }\n\n    defaultProtectedMethods () {\n        return new Set([\n        ])\n    }\n\n    // need to hook GET so we return special functions to hook protected method calls\n\n    postForTrap (trapName, propertyName) {\n        // instead of posting to observers, \n        // just check if it's a protected trap and, if so, raise an exception\n        // TODO: abstract non posting behavior from ObservableProxy and \n        // use as parent class of both ObservableProxy and Firewall\n        if (this.protectedTraps().has(trapName)) {\n            const msg = \" blocked proxy trap '\" + trapName + \"' on property '\" + propertyName + \"'\"\n            this.debugLog(msg)\n            throw new Error(this.typeId() + msg)\n            return false\n        }\n\n        return true\n    }\n\n    onProtectedMethodCall (propertyName, argsList) {\n        const msg = \" blocked method call '\" + propertyName + \"' \"\n        this.debugLog(msg)\n        throw new Error(this.typeId() + msg)\n    }\n\n    get (target, propertyName) {\n        if (propertyName === \"observable\") {\n            const self = this\n            return () => { return self }\n        }\n\n        this.postForTrap(\"get\", propertyName)\n\n        // if it's a protected method, we'll return a special function\n        // that calls onProtectedMethodCall to raise an exception\n        const isProtected = this.protectedMethods().has(propertyName)\n        if (isProtected) {\n            const isFunction = Type.isFunction(target[propertyName])\n            if (isFunction) {\n                const self = this\n                return () => {\n                    return self.onProtectedMethodCall(propertyName, arguments)\n                }\n            }\n        }\n\n        return Reflect.get(target, propertyName, target);\n    }\n\n    static selfTest () {\n        // test array\n        const array = [\"a\", \"b\", \"c\"]\n        const ap = array.asReadOnly()\n        assertThrows(() => ap.atPut(0, \"foo\"))\n        assertThrows(() => ap[0] = \"bar\")\n        assertThrows(() => ap.pop())\n        assertThrows(() => ap.reverse())\n        assertThrows(() => ap.shift())\n        assertThrows(() => ap.sort())\n\n        // test set\n        const set = new Set([\"foo\", \"bar\"])\n        const sp = set.asReadOnly()\n        assertThrows(() => sp.add(1))\n        assertThrows(() => sp.clear())\n        assertThrows(() => sp.delete(\"foo\"))\n\n        // test map\n        const map = new Map([ [\"foo\", 1], [\"bar\", 2] ])\n        const mp = set.asReadOnly()\n        assertThrows(() => mp.clear())\n        assertThrows(() => mp.delete(\"foo\"))\n        assertThrows(() => mp.set(\"foo\", 2))\n\n        // test date\n        const date = new Date()\n        const dp = date.asReadOnly()\n        assertThrows(() => dp.setYear(1999))\n\n        console.log(this.type() + \" - self test passed\")\n    }\n}.initThisClass());\n\n\n// ------------------------------------------------------------------\n// Use FirewallProxy to implement asReadOnly methods on basic types\n// ------------------------------------------------------------------\n\nObject.defineSlots(Object.prototype, {\n    \n    mutatorMethodNamesSet () {\n        return new Set([\n            \"__defineGetter__\",  \n            \"__defineSetter__\",\n        ])\n    }\n\n})\n\nObject.defineSlots(Set.prototype, {\n    \n    mutatorMethodNamesSet () {\n        return new Set([\n            \"add\",\n            \"clear\",\n            \"delete\"\n        ])\n    }\n\n})\n\nObject.defineSlots(Map.prototype, {\n\n    mutatorMethodNamesSet () {\n        return new Set([\n            \"clear\",\n            \"delete\",\n            \"set\",\n        ])\n    }\n\n})\n\nObject.defineSlots(Array.prototype, {\n\n    mutatorMethodNamesSet () {\n        return new Set([\n            \"copyWithin\",\n            \"pop\",\n            \"push\",\n            \"reverse\",\n            \"shift\",\n            \"sort\",\n            \"splice\",\n            \"unshift\"\n        ])\n    }\n\n})\n\nObject.defineSlots(Date.prototype, {\n    \n    mutatorMethodNamesSet () {\n        return new Set([\n            \"setDate\",\n            \"setFullYear\",\n            \"setHours\",\n            \"setMilliseconds\",\n            \"setMinutes\",\n            \"setMonth\",\n            \"setSeconds\",\n            \"setTime\",\n            \"setUTCDate\",\n            \"setUTCFullYear\",\n            \"setUTCHours\",\n            \"setUTCMilliseconds\",\n            \"setUTCMinutes\",\n            \"setUTCMonth\",\n            \"setUTCSeconds\",\n            \"setYear\",\n        ])\n    }\n\n})\n\nObject.defineSlots(Object.prototype, {\n\n    asReadOnly () {\n        const obj = FirewallProxy.newProxyFor(this)\n        obj.observable().setProtectedMethods(this.mutatorMethodNamesSet())\n        return obj\n    }\n\n})\n\n\n//FirewallProxy.selfTest()\n",
  "noDKWt1MlgQBzDNInm9BYT7Iqsupq3hVnqsAvrOAY6U=": "\"use strict\";\n\n/*\n\n    HookedArray\n\n    A subclass of Array that maintains that hooks the base getters and setters.\nen\n    For this to work, you need to use method alternative to the non-method\n    array operations:\n    \n        a[i] -> instead use a.at(i) \n        a[i] = b -> instead use a.atPut(i, b)\n        delete a[i] -> instead use a.removeAt(i)\n    \n    \n    Example use:\n\n\n*/\n\n/*\n(class Array_mutator extends Array {\n    mutatorMethodNamesSet () {\n        // we can't hook []= or delete[] but we can hook these\n        // and use hooked methods instead of operators for those\n        return new Set([\n            \"pop\",\n            \"push\",\n            \"reverse\",\n            \"shift\",\n            \"sort\",\n            \"splice\",\n            \"unshift\"\n        ])\n    }\n}).initThisCategory();\n\nArray.prototype.setupMutatorHooks();\n*/\n\n(class HookedArray extends Array {\n\n    initPrototypeSlots () {\n        this.setupMutatorHooks()\n        //Array.prototype.setupMutatorHooks()\n    }\n\n    // ------------------------------\n\n    /*\n    nonMutatorMethodNames () {\n        // this doesn't cover operators, such as comparison\n        const allNames = Object.getOwnPropertyNames(Array.prototype)\n        const mutatorNames = mutatorMethodNames\n        const getterNames = allNames.filter(name => !mutatorNames.contains(name))\n        return getterNames\n    }\n    */\n\n    mutatorMethodNamesSet () {\n        // we can't hook []= or delete[] but we can hook these\n        // and use hooked methods instead of operators for those\n        return new Set([\n            \"copyWithin\",\n            \"pop\",\n            \"push\",\n            \"reverse\",\n            \"shift\",\n            \"sort\",\n            \"splice\",\n            \"unshift\"\n        ])\n    }\n\n\n    asReadOnlyShalowCopy () {\n        const obj = this.thisClass().withArray(this)\n        obj.willMutate = () => {\n            throw new Error(\"attempt to mutate a read only array\")\n        }\n        return obj\n    }\n\n    // ------------------------------\n\n    static selfTest () {\n        const a = this.clone()\n\n        let gotWillMutate = false\n        let gotDidMutate = false\n\n        a.willMutate = () => {\n            gotWillMutate = true\n        }\n        a.didMutate = () => {\n            gotDidMutate = true\n        }\n        a.push(\"b\")\n        assert(gotWillMutate)\n        assert(gotDidMutate)\n\n        const b = a.asReadOnlyShalowCopy()\n\n        let caughtReadOnlyMutate = false\n        try {\n            b.pop()\n        } catch (e) {\n            caughtReadOnlyMutate = true\n        }\n        assert(caughtReadOnlyMutate)\n\n        console.log(this.type() + \" - passed self test\")\n        return this\n    }\n\n}.initThisClass()); //.selfTest()\n\n",
  "34Q2BLdgUhRl23vNfVIOxDh8EU7ZoVIZ2fHT8AOuGt8=": "\"use strict\";\n\n/*\n\n    HookedSet\n\n    A subclass of Set that maintains that hooks the base mutation methods.\n\n    For this to work, you need to use method alternatives to the non-method\n    (operator) operation.\n\n*/\n\n(class HookedSet extends Set {\n\n    initPrototypeSlots () {\n        this.setupMutatorHooks()\n    }\n\n    // ------------------------------\n\n    mutatorMethodNamesSet () {\n        return new Set([\n            \"add\",\n            \"clear\",\n            \"delete\"\n        ])\n    }\n\n    static selfTest () {\n        const a = this.clone()\n        \n        let gotWillMutate = false\n        let gotDidMutate = false\n\n        a.willMutate = () => {\n            gotWillMutate = true\n        }\n        \n        a.didMutate = () => {\n            assert(gotWillMutate)\n            gotDidMutate = true\n        }\n\n        a.add(\"b\")\n        assert(gotWillMutate)\n        assert(gotDidMutate)\n\n        console.log(this.type() + \" - passed self test\")\n        return true\n    }\n\n}.initThisClass()); \n\n//HookedSet.selfTest()\n\n",
  "nijAfdEXvqWFYhP47h3wgPbrH52pMYiB1zOOkh1pRsM=": "\"use strict\";\n\n/*\n\n    HookedMap\n\n    A subclass of Map that maintains that hooks the base mutation methods.\n\n    (the JS Map object holds key-value pairs and remembers the original insertion order of the keys)\n\n    For this to work, you need to use method alternatives to the non-method\n    (operator) operations.\n\n*/\n\n(class HookedMap extends Map {\n\n    initPrototypeSlots () {\n        this.setupMutatorHooks()\n    }\n\n    mutatorMethodNamesSet () {\n        return new Set([\n            \"clear\",\n            \"delete\",\n            \"set\",\n        ])\n    }\n\n\n    static selfTest () {\n        const a = this.clone()\n        \n        let gotWillMutate = false\n        let gotDidMutate = false\n\n        a.willMutate = () => {\n            gotWillMutate = true\n        }\n        a.didMutate = () => {\n            gotDidMutate = true\n        }\n\n        a.clear()\n        assert(gotWillMutate)\n        assert(gotDidMutate)\n\n        console.log(this.type() + \" - passed self test\")\n        return this\n    }\n\n}.initThisClass()); //.selfTest()\n\n",
  "ol5j0GpF5Uot7ZZvM9aGN9okQ/9Q+CB8QbJg4GKCYts=": "\"use strict\";\n\n/*\n\n    IndexedArray\n\n    A subclass of Array that maintains an dictionary index of the \n    elements of the list via a index closure. The index closure should return \n    a string. For this to work, you need to avoid using the Array \n    operations which can't be overridden:\n    \n        a[i] -> instead use a.at(i) \n        a[i] = b -> instead use a.atPut(i, b)\n        delete a[i] -> instead use a.removeAt(i)\n    \n    Efficiency:\n\n        The index is produced lazily, so there's (practically) no cost if it isn't used.\n        TODO: This could be improved by removing didMutate method until needed? \n        Mutations to the array will set needsReindex property to true.\n        On accessing the index (e.g. calling itemForIndexKey(key)), the \n        index will be updated, if needed.\n\n        This could be optimized by overloading some of the mutation operations\n        and adding and removing the index as needed without setting the needsReindex to true.\n    \n    Example use:\n\n        const ia = IndexedArray.clone()\n        ia.setIndexClosure(item => item.hash())\n        ia.push(someItem) // this will trigger reindex\n        const hasItem = is.itemForIndexKey(someHash) // this is an O(1) operation\n\n*/\n\n(class IndexedArray extends HookedArray {\n\n    initPrototypeSlots () {\n        /*\n        this.newSlot(\"index\", null)\n        this.newSlot(\"indexClosure\", null)\n        this.newSlot(\"needsReindex\", false)\n        */\n\n        Object.defineSlot(this, \"_index\", null)\n        Object.defineSlot(this, \"_indexClosure\", null)\n        Object.defineSlot(this, \"_needsReindex\", false)\n    }\n\n    init () {\n        super.init()\n        this.setIndex(new Map())\n    }\n\n    // index\n\n    setIndex (aMap) {\n        this._index = aMap\n        return this\n    }\n\n    index () {\n        if (this._needsReindex) {\n            this.reindex()\n        }\n        return this._index\n    }\n\n    // index closure\n\n    setIndexClosure (aFunction) {\n        if (aFunction !== this._indexClosure) {\n            this._indexClosure = aFunction\n            this.setNeedsReindex(true)\n        }\n        return this\n    }\n\n    indexClosure () {\n        return this._indexClosure\n    }\n\n    isIndexed () {\n        return Type.isFunction(this._indexClosure)\n    }\n\n    // --- lazy reindexing ---\n\n    setNeedsReindex (aBool) {\n        this._needsReindex = aBool\n        return this\n    }\n\n    needsReindex () {\n        return this._needsReindex\n    }\n\n    reindex () {\n        this.setNeedsReindex(false) // do this first to avoid infinite loop\n        this._index.clear()\n        this.forEach( v => this.addItemToIndex(v) )\n        return this\n    }\n\n    hasIndexedItem (anObject) {\n        const key = this.indexKeyForItem(anObject)\n        return !Type.isUndefined(this.itemForIndexKey(key))\n    }\n\n    didMutate (slotName, optionalValue) {\n        super.didMutate(slotName, optionalValue)\n\n        if (this._indexClosure && !this._needsReindex && optionalValue) {\n            // If we don't already need to reindex, \n            // check if we can avoid it.\n            // These cover the common use cases.\n\n            /*\n            if (slotName === \"push\") {\n                // need to add a way to handle multiple arguments first\n                optionalArguments.forEach(v => this.addItemToIndex(v))\n                return\n            }\n            */\n\n            if (slotName === \"atPut\") {\n                // We can just add it, instead of doing a fill reindex.\n                this.addItemToIndex(optionalValue)\n                return\n            }\n\n            if (slotName === \"removeAt\") {\n                if (!this.contains(optionalValue)) {\n                    // No copies of this value in the array, \n                    // so we can just remove it from the index.\n                    this.removeItemFromIndex(optionalValue)\n                    return\n                }\n            }\n        }\n\n        this.setNeedsReindex(true)\n    }\n\n    // accessing index - public\n\n    itemForIndexKey (key) { // public\n        //if (this.hasIndexKey(key)) {\n        return this.index().get(key)\n        //}\n    }\n\n    indexHasItem (v) { // public\n        assert(this.isIndexed()) \n        const key = this.indexClosure()(v)\n        return this.hasIndexKey(key)\n    }\n\n    // indexing - private\n\n    hasIndexKey (key) { // private\n        return this._index.has(key)\n    }\n\n    indexKeyForItem (v) { // private\n        const key = this.indexClosure()(v)\n        return key\n    }\n\n    addItemToIndex (v) { // private\n        const key = this.indexKeyForItem(v)\n        assert(Type.isString(key))\n        this._index.set(key, v)\n        return this\n    }\n\n    removeItemFromIndex (v) { // private\n        const key = this.indexKeyForItem(v)\n        this._index.delete(key)\n        return this\n    }\n\n    // --------------------------------\n\n    static selfTest () {\n        let ia = IndexedArray.clone()\n        ia.setIndexClosure(v => v.toString())\n        ia.push(123)\n        let result = ia.itemForIndexKey(\"123\")\n        assert(result === 123)\n        return this\n    }\n\n}.initThisClass()); \n\n//IndexedArray.selfTest()\n",
  "2VzHmW/EdsRy1FF0J20Rc4vm8yg8Wx356zKhUtRwG+o=": "\"use strict\";\n\n/*\n\n    SortedArray\n\n    A subclass of IndexedArray that maintains it's items in sorted order. \n    The sort closure should return \n    \n    Efficiency:\n\n    Once sorted, a binary insert would be faster.\n    TODO: remove didMutate method when sortFunc is not defined?\n\n    \n    Example use:\n\n        const sa = SortedArray.clone()\n        sa.setSortFunc(function (a, b) { return a.compare(b) })\n        sa.push(someItem) // this will trigger resort\n\n*/\n\n(class SortedArray extends IndexedArray {\n\n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        Object.defineSlot(this, \"_isSorting\", false)\n        Object.defineSlot(this, \"_sortFunc\", null)\n    }\n\n    doesSort () {\n        return !Type.isNull(this._sortFunc)\n    }\n\n    setSortFunc (aFunc) {\n        if (this._sortFunc !== aFunc) {\n            this._sortFunc = aFunc\n            this.resort()\n        }\n        return this\n    }\n\n    sortFunc () {\n        return this._sortFunc\n    }\n\n    // sort\n\n    didChangeSlotSortFunc (oldValue, newValue) {\n        this.resort()\n    }\n\n    resort () {\n        if (this._sortFunc && this.length && !this._isSorting) {\n            this._isSorting = true\n            this.sort(this._sortFunc)\n            this._isSorting = false\n        }\n        return this\n    }\n\n    needsResortOnForSlot (slotName) {\n        const nonOrderChangingSlots = [\n            \"pop\", \n            \"shift\", \n            \"sort\", \n            \"removeAt\", \n            \"remove\", \n            \"removeAll\"\n        ]\n        return !nonOrderChangingSlots.contains(slotName)\n    }\n\n    didMutate (slotName, optionalValue) {\n        if (this._isSorting) {\n            return\n        }\n\n        super.didMutate(slotName, optionalValue)\n\n        if (this._sortFunc && this.needsResortOnForSlot(slotName)) {\n            this.resort()\n        }\n    }\n    \n    // --------------------------------\n\n    static selfTest () {\n        let sa = this.clone() \n        sa.setSortFunc((a, b) => { return a - b })\n        sa.push(3, 1, 2)\n        assert(sa.isEqual([1, 2, 3]))\n        return this\n    }\n\n}.initThisClass()); //.selfTest()\n",
  "fPXQT8NcV59AUtc4kOtehywCvw5qDaJV3sqi2rujHb8=": "\"use strict\";\n\n/*\n\n    AtomicMap\n \n*/\n\ngetGlobalThis().ideal.AtomicMap = class AtomicMap extends ProtoClass {\n\n    initPrototypeSlots () {\n        this.newSlot(\"isInTx\", false) // public read, private write - Bool, true during a tx\n        this.newSlot(\"map\", null) // public read, private write - Map, contains current state of map\n        this.newSlot(\"snapshot\", null) // private - Map, contains shallow copy of map before tx which we can revert to if tx is cancelled\n        this.newSlot(\"isOpen\", true) // public read, private write\n        this.newSlot(\"changedKeySet\", null) // private method\n        this.newSlot(\"keysAndValuesAreStrings\", true) // private method - Bool, if true, runs assertString on all input keys and values\n        this.newSlot(\"totalBytesCache\", null) // private\n    }\n\n    init () {\n        super.init()\n        this.setMap(new Map())\n        this.setSnapshot(null)\n        this.setChangedKeySet(new Set())\n        //this.setSnapshot(new Map())\n    }\n\n    open () {\n        this.setIsOpen(true)\n        return this\n    }\n\n    assertAccessible () {\n        this.assertOpen()\n    }\n\n    assertOpen () {\n        assert(this.isOpen())\n    }\n\n    promiseOpen () {\n        return new Promise((resolve, reject) => {\n            this.open()\n            resolve()\n        })\n    }\n\n    close () {\n        this.setIsOpen(false)\n        return this\n    }\n\n    begin () {\n        this.debugLog(() => \" begin ---\")\n        this.assertAccessible()\n        this.assertNotInTx()\n        this.setSnapshot(this.map().shallowCopy()) \n        this.changedKeySet().clear()\n        this.setIsInTx(true)\n        return this\n    }\n\n    revert () {\n        this.debugLog(() => \" revert ---\")\n        this.assertInTx()\n        this.setMap(this.snapshot())\n        this.setSnapshot(null)\n        this.changedKeySet().clear()\n        this.setIsInTx(false)\n        return this\n    }\n\n    promiseCommit () {\n        let promise = null;\n        this.debugLog(() => \" prepare commit ---\")\n        this.assertInTx()\n        if (this.hasChanges()) {\n            promise = this.promiseApplyChanges()\n        }\n        this.changedKeySet().clear()\n        this.setIsInTx(false)\n        this.clearTotalBytesCache()\n        return promise\n    }\n\n    // --- changes ---\n\n    hasChanges () {\n        return this.changedKeySet().size > 0\n        return this.map().isEqual(this.snapshot())\n    }\n\n    applyChanges () { // private - apply changes to snapshot\n        this.setSnapshot(null)\n        return this\n    }\n\n    // need to make sure writes happen within a transaction\n\n    assertInTx () { // private\n\t    assert(this.isInTx())\n    }\n\n    assertNotInTx () { // private\n\t    assert(!this.isInTx())\n    }\n\n    // reads\n\n \n    // --- keys ---\n\n    keysArray () {\n        return this.map().keysArray()\n    }\n\n    keysSet () {\n        return this.map().keysSet()\n    }\n\n    // --- values ---\n\n    valuesArray () {\n        return this.map().valuesArray()\n    }\n\n    valuesSet () {\n        return this.map().valuesSet()\n    }\n\n    // ---\n\n    has (k) {\n        return this.map().has(k)\n    }\n\n    hasKey (k) {\n        return this.map().hasKey(k)\n    }\n\n    at (k) {\n        return this.map().at(k)\n    }\n\n    // writes\n\n    clear () {\n        this.keysArray().forEach(k => this.removeKey(k))\n        return this\n    }\n\n    set (k, v) {\n        return this.atPut(k, v)\n    }\n\n    atPut (k, v) {\n        this.assertInTx()\n        if (this.keysAndValuesAreStrings()) {\n            assert(Type.isString(k))\n            assert(Type.isString(v))\n        }\n\n        //console.log(this.debugTypeId() + \" atPut('\" + k + \"', <\" + typeof(v) + \"> '\" + v + \"')\")\n        this.assertAccessible()\n        this.assertInTx()\n        this.changedKeySet().add(k)\n        this.map().set(k, v)\n        return this\n    }\n\n    removeKey (k) {\n        this.assertInTx()\n        this.changedKeySet().add(k)\n        if (this.keysAndValuesAreStrings()) {\n            assert(Type.isString(k))\n        }\n\n        this.assertAccessible()\n        this.assertInTx()\n        this.map().delete(k)\n        return this\n    }\n\n    // --- enumeration ---\n\n    forEachKV (fn) {\n        this.assertNotInTx() \n        this.assertAccessible()\n        this.map().forEach((v, k, self) => fn(k, v, self))\n    }\n\n    forEachK (fn) {\n        //this.assertNotInTx()  // why is this needed?\n        this.assertAccessible()\n        this.map().forEach((v, k) => fn(k))\n    }\n\n    forEachV (fn) {\n        this.assertNotInTx() \n        this.assertAccessible()\n        this.map().forEach(v => fn(v))\n    }\n\n    // read extras \n\n    keysArray () {\n        return this.map().keysArray();\n    }\n\t\n    valuesArray () {\n        return this.map().valuesArray();\n    }\n\n    count () { \n        return this.map().size;\n    }\t\n\n    clearTotalBytesCache () {\n        this.setTotalBytesCache(null)\n        return this\n    }\n\n    /*\n    String.prototype.lengthInBytes = function () {\n        return (new TextEncoder().encode(this)).length\n    }\n    */\n\n    totalBytes () {\n        const cachedResult = this.totalBytesCache()\n        if (!Type.isNull(cachedResult)) {\n            return cachedResult\n        }\n\n        this.assertNotInTx()\n        this.assertAccessible()\n        assert(this.keysAndValuesAreStrings())\n        let byteCount = 0\n        this.map().forEachKV((k, v) => {\n            byteCount += k.length + v.length // not correct for unicode, but fast and good enough for now\n            //byteCount += k.byteLength() + v.byteLength() // correct, but slow\n        })\n        this.setTotalBytesCache(byteCount)\n        return byteCount\n    }\n\n    asJson () {\n        return this.map().asDict()\n    }\n\n    fromJson (json) {\n        this.map().clear()\n        this.map().fromDict(json)\n        return this\n    }\n\n    // test\n\n    static selfTest () {\n        const m = this.clone()\n\n        m.begin()\n        m.atPut(\"foo\", \"bar\")\n        m.promiseCommit().then(() => {\n\n            assert(m.count() === 1)\n            assert(m.Array()[0] === \"foo\")\n\n        }).then(() => {\n\n            m.begin()\n            m.removeAt(\"foo\")\n            return m.promiseCommit()\n\n        }).then(() => {\n\n            assert(m.count() === 0)\n\n        })\n\n        return this\n    }\n}.initThisClass(); //.selfTest()\n\n",
  "kAaBI0jTfOHkdej80rzQAncUFatOJvDznrJ2ShpxehE=": "\"use strict\";\n\n/*\n\n    ByteFormatter\n    \n\tByteFormatter takes a number of bytes and returns a string with the order of magnitude in \n\tstandard SI decimal ditial information format.\n\n\texample use:\n\n\tconst stringVersion = ByteFormatter.clone().setValue(aNumberOfBytes).formattedValue()\n\n\texample output:\n\n\tif aNumberOfBytes was 300, stringVersion would be 300 bytes.\n\tif aNumberOfBytes was 3,000, stringVersion would be 3 kB.\n\tif aNumberOfBytes was 30,000, stringVersion would be 30 kB.\n\tif aNumberOfBytes was 300,000, stringVersion would be 300 kB.\n\tif aNumberOfBytes was 3,000,000, stringVersion would be 3 MB.\n\tetc.\n\n    TODO: move to power notation after max order name exceeded\n\n*/\n\n(class ByteFormatter extends ProtoClass {\n    initPrototypeSlots () {\n\n        {\n            const slot = this.newSlot(\"value\", 0)\n            slot.setShouldStoreSlot(false)\n            slot.setSlotType(\"Number\")\n            slot.setCanInspect(false)\n        }\n\n        {\n            const slot = this.newSlot(\"usePostfix\", true)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n\n        {\n            const slot = this.newSlot(\"useSpace\", false)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n\n        {\n            const slot = this.newSlot(\"useLongNames\", false)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n\n        {\n            const slot = this.newSlot(\"orderNamesShort\", [\n                \"bytes\", \n                \"k\", \n                \"M\", \n                \"G\", \n                \"T\", \n                \"P\", \n                \"E\", \n                \"Z\", \n                \"Y\"\n            ])\n        }\n        \n        {\n            const slot = this.newSlot(\"orderNamesLong\", [\n                \"bytes\", \n                \"kilobytes\", \n                \"megabytes\", \n                \"gigabytes\", \n                \"terabytes\", \n                \"petabytes\", \n                \"exabytes\", \n                \"zettabytes\", \n                \"yottabytes\"\n            ])\n        }\n    }\n\n    /*\n    init () {\n        super.init()\n    }\n    */\n\n    formattedValue () {\n        const b = Math.floor(this.value());\n        let postfix = this.usePostfix() ? \"B\" : \"\";\n        let space = this.useSpace() ? \" \" : \"\";\n\t\t\n        const orderNames = this.useLongNames() ? this.orderNamesLong() : this.orderNamesShort();\n        let order = b === 0 ? 0 : Math.floor(Math.log10(b)/3)\n        order = Math.min(order, orderNames.length - 1)\n        const orderName = orderNames[order]\n\n        if (order === 0 || this.useLongNames()) {\n            space = \" \"\n            postfix = \"\"\n        }\n\n        const v = Math.floor(b / Math.pow(10, order*3))\n\t\t\n        // remove plural if v === 1\n        if (orderName[orderName.length-1] === \"s\" && v === 1) {\n            orderName = orderName.substring(0, orderName - 2)\n        }\n\t\t\n        return v + space + orderName + postfix\n    }\n}.initThisClass());\n",
  "GegTvJA75Iz9i+A5Uohp9lKs2GM3IxSm84iVV1InIc8=": "\"use strict\";\n\n/*\n    \nTimePeriodFormatter \n\n    Takes a number of seconds and formats in a compact format.\n\n\tExample use:\n\n\tconst stringVersion = TimePeriodFormatter.clone().setValueInSeconds(seconds).formattedValue()\n\n\tExample output:\n\n\tif seconds was 10, stringVersion would be 10s.\n\tif seconds was 60, stringVersion would be 1m.\n\tif seconds was 3600, stringVersion would be 1h.\n\tif seconds was 172800, stringVersion would be 2d.\n\tetc.\n\n*/\n\n(class TimePeriodFormatter extends ProtoClass {\n    initPrototypeSlots () {\n        this.newSlot(\"valueInSeconds\", 0)\n\n        // TODO: move periods to a Map\n        this.newSlot(\"periods\", { \n            seconds: \"s\", \n            minutes: \"m\", \n            hours: \"h\", \n            days: \"d\", \n            months: \"months\", \n            years: \"years\"\n        })\n    }\n\n    /*\n    init () {\n        return super.init()\n    }\n    */\n\n    formattedValue () {\n        const periods = this.periods()\n\n        const seconds = this.valueInSeconds()\n        if (seconds === null) {\n            return \"?\"\n        }\n\n        if (seconds < 60) {\n            return Math.floor(seconds) + periods.seconds\n        }\n        \n        const minutes = Math.floor(seconds/60)\n        if (minutes < 60) {\n            return minutes + periods.hours\n        }\n\n        const hours = Math.floor(minutes/60)\n        if (hours < 24) {\n            return hours + periods.hours\n        }\n        \n        const days = Math.floor(hours/24)\n        return days + periods.days\n    }\n}.initThisClass());\n",
  "PdyE1OwIM3nf4rXmUAWcW+M3HyGc+jkjPwigOd5mEC4=": "\"use strict\";\n\n/*\n    \nTimeFormatter \n\n    Takes a javascript Date and can produces a formatted string description\n    following the object's format option properties. \n\n\tExample use:\n\n    const formatter = TimeFormatter.clone()\n    formatter.setIs24Hour(false)          // this is the default\n    formatter.setShowsMeridiem(true)      // this is the default\n    formatter.setUppercaseMeridiem(false) // this is the default\n    formatter.setAmString(\"am\")           // this is the default\n    formatter.setPmString(\"am\")           // this is the default\n    formatter.setShowsSeconds(false)      // this is the default\n    formatter.setShowsMilliseconds(false) // this is the default\n    formatter.setHourMinuteSpacer(\":\")    // this is the default\n    formatter.setDate(new Date())\n    const aDateString = formatter.formattedValue()\n\n    example output:\n\n        \"10:11am\"\n\n\n*/\n\n(class TimeFormatter extends ProtoClass {\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"date\", null) // temp value which will be formatted\n            slot.setShouldStoreSlot(false)\n            slot.setSlotType(\"Date\") // a javascript Date object\n            slot.setCanInspect(true)\n        }\n\n        {\n            const slot = this.newSlot(\"is24Hour\", false)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n\n        {\n            const slot = this.newSlot(\"showsMeridiem\", true)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n\n        {\n            const slot = this.newSlot(\"uppercaseMeridem\", false)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n            \n        {\n            const slot = this.newSlot(\"amString\", \"am\")\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"String\")\n            slot.setCanInspect(true)\n        }\n                \n        {\n            const slot = this.newSlot(\"pmString\", \"pm\")\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"String\")\n            slot.setCanInspect(true)\n        }\n                \n        {\n            const slot = this.newSlot(\"doesPadHours\", false)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n                \n        {\n            const slot = this.newSlot(\"showsHours\", true)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n                \n        {\n            const slot = this.newSlot(\"hourMinuteSpacer\", \":\")\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"String\")\n            slot.setCanInspect(true)\n        }\n                \n        {\n            const slot = this.newSlot(\"showsMinutes\", true)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n                \n        {\n            const slot = this.newSlot(\"showsSeconds\", false)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n                \n        {\n            const slot = this.newSlot(\"showsMilliseconds\", false)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n                \n    }\n\n    /*\n    init () {\n        return super.init()\n    }\n    */\n\n    paddedNumber (n, padLength) {\n        if (!padLength) {\n            padLength = 2\n        }\n        const s = \"\" + n\n        if (s.length < padLength) { \n            return \"0\".repeat(padLength - s.length) + s\n        }\n        return s\n    }\n\n    getTwelveHours () {\n        let h = this.date().getHours()\n        if (h > 12) { h -= 12 }\n        if (h === 0) { h = 12 }\n        return h\n    }\n\n    zeroPaddedUSDate () {\n        return this.paddedNumber(this.getTwelveHours()) + \":\" + this.paddedNumber(this.getMinutes())\n    }\n\n    hoursString () {\n        let h = this.date().getHours()\n\n        if (!this.is24Hour()) {\n            h = this.getTwelveHours()\n        }\n        \n        if (this.doesPadHours()) {\n            this.paddedNumber(h)\n        }\n\n        return \"\" + h\n    }\n\n    minutesString () {\n        return this.paddedNumber(this.date().getMinutes())\n\n    }\n\n    secondsString () {\n        return this.paddedNumber(this.date().getSeconds())\n    }\n\n    millisecondsString () {\n        return this.paddedNumber(this.date().getMilliseconds() % 1000)\n    }\n\n    meridiemString () {\n        let s = \"\"\n        \n        if (this.date().getHours() < 12) {\n            s = this.amString()\n        } else {\n            s = this.pmString()\n        }\n        \n        if (this.uppercaseMeridem()) {\n            s = s.toUpperCase()\n        }\n\n        return s\n    }\n\n    formattedValue () {\n        assert(this.date())\n        let s = \"\"\n\n        if (this.showsHours()) {\n            s += this.hoursString()\n        }\n\n        if (this.showsMinutes()) {\n            if (s.length) {\n                s += this.hourMinuteSpacer()\n            }\n            s += this.minutesString()\n        } \n\n        if (this.showsMeridiem()) { // correct location wrt seconds?\n            s += this.meridiemString()\n        } \n\n        if (this.showsSeconds()) {\n            if (s.length) {\n                s += this.hourMinuteSpacer()\n            }\n            s += this.secondsString()\n        } \n\n        if (this.showsMilliseconds()) {\n            if (s.length) {\n                s += this.hourMinuteSpacer()\n            }\n            s += this.millisecondsString() \n        } \n\n        if (true) {\n            const h = this.date().getHours()\n            const m = this.date().getMinutes()\n            if (h === 0 && m === 0) { \n                s = \"midnight\"\n            }\n\n            if (h === 12 && m === 0) { \n                s = \"noon\"\n            }\n        }\n\n        return s\n    }\n}.initThisClass());\n\n\n\n\n",
  "4tQI2MfhGgZpQdPbhttyY+HO4noBnsyimtpXx9EAmuo=": "\"use strict\";\n\n/*\n\n    Documentation\n\n    An simple in-memory documentation system.\n    \n    TODO: Rename to something more unique.\n\n*/\n\n(class Documentation extends ProtoClass {\n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n    }\n\n    classes () {\n        return ProtoClass.allClassesSet().asArray()\n    }\n\n    methodsDocsForClass (aClass) {\n        const methods = []\n        Object.getOwnPropertyNames(aClass).forEach((methodName) => {\n            const v = aClass[methodName]\n            //const docs = v._docs\n            if (Type.isFunction(v) && methodName !== \"constructor\") {\n                const source = v.toString()\n                let argNames = source.after(\"(\").before(\")\").split(\",\").map(s => s.trim())\n                if (argNames[0] === \"\") { \n                    argNames = [] \n                }\n                methods.push({ name: methodName, argNames: argNames, comments: v.extractComments() })\n            }\n        })\n        return methods\n    }\n\n    asJson () {\n        const classes = []\n        this.classes().forEach((aClass) => {\n            const classDict = {}\n            classDict.name = aClass.type()\n            const superclass = aClass.superClass()\n            if (superclass.type) {\n                classDict.superClass = superclass.type()\n            }\n            classes.push(classDict)\n            classDict.methods = this.methodsDocsForClass(aClass)\n            //classDict.comments = aClass.comments()\n        })\n        return classes\n    }\n\n    show () {\n        const classes = this.asJson()\n        const lines = []\n        classes.forEach((aClass) => {\n            lines.push(aClass.name + \" : \" + aClass.superClass)\n            /*\n            aClass.methods.forEach((aMethod) => {\n                let argsString = \"\"\n                if (aMethod.argNames.length > 0) {\n                    argsString = \"(\" + aMethod.argNames.join(\",\") + \")\"\n                }\n                lines.push(\"  - \" + aMethod.name + argsString + \" \" + aMethod.comments)\n            })\n            */\n        })\n        /*\n        const s = JSON.stringify(this.asJson(), 2, 2)\n        */\n        console.log(\"DOCUMENTATION:\\n\\n\", lines.join(\"\\n\"))\n    }\n}.initThisClass());\n\n\n/*\n// --- Object category -------------------------------------\n\nObject.defineSlots(Object.prototype, {\n\n    docs: function () {\n        if (!this._docs) {\n            this._docs = {}\n        }\n        return this._docs\n    },\n\n    setDocs: function (name, description) {\n        const docs = this.docs()\n        docs._name = methodName\n        docs._description = description\n        return this\n    },\n    \n})\n\n// --- Function category -------------------------------------\n\nObject.defineSlots(Function.prototype, {\n\n    docs: function () {\n        if (!this._docs) {\n            this._docs = {}\n        }\n        return this._docs\n    },\n\n    setDocs: function (name, description, returns) {\n        const docs = this.docs()\n        docs._name = name\n        docs._description = description\n        docs._returns = returns \n        return this\n    },\n\n    extractComments: function () {\n        const commentPattern = new RegExp(\"(\\\\/\\\\*([^*]|[\\\\r\\\\n]|(\\\\*+([^*\\/]|[\\\\r\\\\n])))*\\\\*+\\/)|(\\/\\/.*)\", \"g\");\n        return this.toString().match(commentPattern)\n    },\n})\n\n*/",
  "cwQLf53A5pusas+d8K5OjUtkaezAFLsxJK6goGgKGtU=": "\"use strict\";\n\n/*\n    \n    StackTrace\n    \n    Class that can parse a JS stack trace, into StackFrame objects.\n\n\n*/\n\n(class StackFrame extends ProtoClass {\n\n    initPrototypeSlots () {\n        this.newSlot(\"functionName\", null)\n        this.newSlot(\"url\", null)\n        this.newSlot(\"lineNumber\", null)\n        this.newSlot(\"characterNumber\", null)\n    }\n\n    /*\n    init () {\n        super.init()\n    }\n    */\n\n    fromLine (line) {\n        line = line.after(\"at \")\n\n        if (line.contains(\"(\")) {\n            const functionName = line.before(\"(\").strip()\n            this.setFunctionName(functionName)\n            line = line.between(\"(\", \")\").strip()\n        }\n        \n        const parts = line.split(\":\")\n        if (parts.length !== 4) {\n            console.log(\"unexpected stacktrace line format: '\" + line + \"'\")\n            return this\n        }\n        const lineNumber = parts.removeLast()\n        this.setLineNumber(Number(lineNumber))\n\n        const characterNumber = parts.removeLast()\n        this.setCharacterNumber(Number(characterNumber))\n\n        const url = parts.join(\":\")\n        this.setUrl(url)\n\n        return this\n    }\n\n    description () {\n        return \"  \" + this.functionName() + \"() line \" + this.lineNumber()\n    }\n\n    show () {\n        console.log(this.description())\n    }\n}.initThisClass());;\n\n\n// -----------------------------------------------------------------\n\n(class StackTrace extends ProtoClass {\n    initPrototypeSlots () {\n        this.newSlot(\"error\", null)\n        this.newSlot(\"stackFrames\", [])\n    }\n\n    init () {\n        super.init()\n    }\n\t\n    setError (error) {\n        this._error = error\n\n        const lines = error.stack.split(\"\\n\")\n        const firstLine = lines.removeFirst()\n\t\t\n        const frames = lines.map((line) => {\n            return StackFrame.clone().fromLine(line)\n        })\n        this.setStackFrames(frames)\n\n        return this\n    }\n\n    show () {\n        console.log(this.type() + \": '\" + this.error().message + \"'\")\n        this.stackFrames().forEach(frame => frame.show())\n    }\n\n    test () {\n        const f1 = function () {\n            try {\n                throw(new Error(\"test error\"))\n            } catch (e) {\n                StackTrace.clone().setError(e).show()\n            }\n        }\n        \n        const f2 = function () { f1() }\n        const f3 = function () { f2() }\n        f3()        \n    }\n\n}.initThisClass());\n\n//StackTrace.clone().test()\n//console.log(\"Currently running script:\", Error.callingScriptURL())\n",
  "wk6jGzNBXBNDW4NytOLQEKXJgKwvAxSDGPdVLFd6OqU=": "\"use strict\";\n\n/*\n\n    NamespaceSearch\n \n    A way to search the Javascript namespace.\n    All slots are enumerated and passed through a user defined closure to find matches.\n\n    Example use:\n\n        const search = new NamespaceSearch()\n        search.setSlotMatchClosure(function (slotOwner, slotName, slotValue, slotPath) {\n            return slotName === \"String\"\n        })\n        search.find()\n        assert(search.matchingPaths()[0] === \"globalThis/String\")\n\n*/\n\n(class NamespaceSearch extends ProtoClass {\n\n    initPrototypeSlots () {\n        this.newSlot(\"visited\", null)\n        this.newSlot(\"matchingPaths\", null)\n        this.newSlot(\"slotMatchClosure\", null)\n    }\n\n    init () {\n        super.init()\n        this.clear()\n    }\n\n    clear () {\n        this.setVisited(new Set([this])) // to avoid searching this object\n        this.setMatchingPaths([])\n    }\n\n    find (searchString) {\n        this.clear()\n\n        if (searchString) {\n            this.setSlotMatchClosure((slotOwner, slotName, slotValue, slotPath) => {\n                return slotName === s\n            })\n        }\n\n        //this.findOnObject(globalThis, [\"globalThis\"])\n        this.findOnObject(getGlobalThis(), [\"globalThis\"])\n        return this\n    }\n\n    findOnObject (v, path = []) {\n        if (Type.isNullOrUndefined(v)) {\n            return false\n        }\n\n        if (this.visited().has(v)) {\n            return false\n        } else {\n            this.visited().add(v)\n        }\n\n        //const joinedPath = path.join(\"/\")\n\n        Object.getOwnPropertyNames(v).forEach((k) => {\n            if (this.canAccessSlot(v, k)) {\n                this.findOnSlot(v, k, path)\n            }\n        })\n    }\n\n    canAccessSlot (v, k) {\n        // to avoid illegal operation errors\n        const descriptor = Object.getOwnPropertyDescriptor(v, k)\n        const hasCustomGetter = Type.isUndefined(descriptor.get)\n        return !hasCustomGetter\n    }\n\n    findOnSlot (slotOwner, slotName, path = []) {\n        const localPath = path.shallowCopy()\n        localPath.push(slotName)\n        \n        const slotValue = slotOwner[slotName]\n\n        if (this.doesMatchOnSlot(slotOwner, slotName, slotValue, localPath)) {\n            this.addMatchingPath(localPath)\n        }\n\n        this.findOnObject(slotValue, localPath)\n    }\n\n    doesMatchOnSlot (slotOwner, slotName, slotValue, slotPath) {\n        return this.slotMatchClosure()(slotOwner, slotName, slotValue, slotPath)\n    }\n\n    addMatchingPath (aPath) {\n        const stringPath = aPath.join(\"/\")\n        if (!this.matchingPaths().contains(stringPath)) {\n            this.matchingPaths().push(stringPath)\n        }\n        return this\n    }\n\n    showMatches () {\n        console.log(\"matchingPaths:\")\n        this.matchingPaths().forEach(p => console.log(\"  \" + p))\n    }\n\n    static selfTest () {\n        const ns = NamespaceSearch.clone()\n        ns.setSlotMatchClosure(function (slotOwner, slotName, slotValue, slotPath) {\n            return slotName === \"String\"\n        })\n        ns.find()\n        assert(ns.matchingPaths()[0] === \"globalThis/String\")\n    }\n\n}.initThisClass());\n\n//NamespaceSearch.selfTest()\n",
  "Gby43PQyVBY+vRmf70GvH+WBjNpb87djgEeV6rzpmjQ=": "\"use strict\";\n\n\n/*\n\n    SyncAction\n\n    An action managed by the SyncScheduler.\n\n*/\n\n(class SyncAction extends ProtoClass {\n\n    static ActionKeyForTargetAndMethod (target, method) {\n        return target.typeId() + \".\" + method\n    }\n\n    initPrototypeSlots () {\n        this.newSlot(\"target\", null)\n        this.newSlot(\"method\", null)\n        this.newSlot(\"order\", 0)\n        this.newSlot(\"args\", null)\n        this.newSlot(\"isUnscheduled\", false)\n    }\n\n    /*\n    init () {\n        super.init()\n        this.setIsDebugging(false)\n    }\n    */\n\t\n    tryToSend () {\n        try {\n            this.send()\n        } catch(error) {\n            console.warn(this.typeId() + \".tryToSend(\" + this.description() + \") caught exception: \")\n            error.show()\n            return error\n        }\n        return null\n    }\n\t\n    send () {\n        this.debugLog(() => \"   <- sending \" + this.description())\n        const t = this.target()\n        const m = this.method()\n        const a = this.args()\n        t[m].apply(t, a ? a : [])\n        return null\n    }\n\t\n    actionsKey () {\n        return SyncAction.ActionKeyForTargetAndMethod(this.target(), this.method())\n    }\n\t\n    equals (anAction) {\n        return anAction !== null && \n               (this.target() === anAction.target()) && \n               (this.method() === anAction.method())\n    }\n\t\n    description () {\n        const t = this.target() ? this.target().type() : \"null\"\n        const o = this.order() === 0 ? \"\" : \" order:\" + this.order()\n        return t + \" \" + this.method() + \"\" + o\n    }\n\n}.initThisClass());\n\n",
  "Rp0JuR1MISSdAIQA/36rmo59YoFh0yGksew+Zl7f6yM=": "\"use strict\";\n\n/*\n\n    SyncScheduler\n\n    Many state changes can cause the need to synchronize a given object \n    with others within a given event loop, but we only want synchronization to \n    happen at the end of an event loop, so a shared SyncScheduler instance is used to\n    track which sync actions should be sent at the end of the event loop and only sends each one once. \n\n    SyncScheduler should be used to replace most cases where this.addTimeout() would otherwise be used.\n\n       example use:\n    \n        SyncScheduler.shared().scheduleTargetAndMethod(this, \"syncToView\")\n\n    Automatic sync loop detection\n\n    It will throw an error if a sync action is scheduled while another is being performed,\n    which ensures sync loops are avoided.\n\n    Ordering\n\n    Scheduled actions can also be given a priority via an optional 3rd argument:\n\n        SyncScheduler.shared().scheduleTargetAndMethod(this, \"syncToView\", 1)\n\n    Higher priorities will be performed *later* than lower ones. \n\n    Some typical sync methods:\n\n        // node\n    \tsyncToStore\n    \tsyncToView\n\n        // view\n    \tsyncToNode\t\n        syncFromNode\n        \n    When to run\n\n        When a UI event is handled, SyncSchedule.fullSyncNow should be called just before\n        control is returned to the browser to ensure that another UI event won't occur\n        before syncing as that could leave the node and view out of sync.\n            For example:\n                - edit view #1\n                - sync to node\n                - node posts didUpdateNode\n                - edit view #2\n                - view get didUpdateNode and does syncFromNode which overwrites view state #2\n\n    \t\n*/\n\n(class SyncScheduler extends ProtoClass {\n\n    initPrototypeSlots () {\n        this.newSlot(\"actions\", new Map())\n        this.newSlot(\"hasTimeout\", false)\n        this.newSlot(\"isProcessing\", false)\n        this.newSlot(\"currentAction\", null)\n    }\n\n    /*\n    init () {\n        super.init()\n    }\n    */\n\n    newActionForTargetAndMethod (target, syncMethod, order) {\n        return SyncAction.clone().setTarget(target).setMethod(syncMethod).setOrder(order ? order : 0)\n    }\n\t\n    scheduleTargetAndMethod (target, syncMethod, optionalOrder) { // higher order performed last\n        if (!this.hasScheduledTargetAndMethod(target, syncMethod)) {\n            const newAction = this.newActionForTargetAndMethod(target, syncMethod, optionalOrder)\n\n            this.debugLog(() => \"    -> scheduling \" + newAction.description())\n\n            /*\n            if (this.isProcessing() && this.currentAction().method() !== \"processPostQueue\") {\n                this.debugLog(() => \"    - isProcessing \" + this.currentAction().description() +  \" while scheduling \" + newAction.description())\n            }\n            */\n            \n            if (syncMethod !== \"processPostQueue\") {\n                if (this.currentAction() && this.currentAction().equals(newAction)) {\n                    const error = [\n                        this.type() + \" LOOP DETECTED: \",\n                        \"  scheduleTargetAndMethod: (\" + newAction.description() + \")\",\n                        \"  while processing: (\" + this.currentAction().description() + \")\"\n                    ].join(\"\\n\")\n                    console.log(error)\n                    throw new Error(error)\n                }\n            }\n\n            this.actions().atIfAbsentPut(newAction.actionsKey(), newAction)\n\t    \tthis.setTimeoutIfNeeded()\n            return true\n        }\n\t\t\n        return false\n    }\n\n    isSyncingOrScheduledTargetAndMethod(target, syncMethod) {\n        const sc = this.hasScheduledTargetAndMethod(target, syncMethod) \n        const sy = this.isSyncingTargetAndMethod(target, syncMethod) \n        return sc || sy;\n    }\n\n    hasScheduledTargetAndMethod (target, syncMethod) {\n        const actionKey = SyncAction.ActionKeyForTargetAndMethod(target, syncMethod)\n    \treturn this.actions().hasKey(actionKey)\n    }\n\n    isSyncingTargetAndMethod (target, syncMethod) {\n        const ca = this.currentAction()\n        if (ca) {\n            const action = this.newActionForTargetAndMethod(target, syncMethod)\n    \t\treturn ca.equals(action)\n        }\n        return false\n    }\n    \n    actionsForTarget (target) {\n        return this.actions().valuesArray().select(action => action.target() === target)\n    }\n\n    hasActionsForTarget (target) {\n        const match = this.actions().valuesArray().detect(action => action.target() === target)\n        return !Type.isNullOrUndefined(match)\n    }\n\n    unscheduleTarget (target) {\n        if (this.hasActionsForTarget(target)) {\n            console.log(\"unscheduling target \" + target.debugTypeId())\n\n            if (this.isProcessing()) {\n                console.warn(\"WARNING: SynScheduler unscheduleTarget while processing actions set - will unschedule action\")\n                //debugger;\n                //return this\n            }\n\n            this.actionsForTarget(target).forEach(action => {\n                this.removeActionKey(action.actionsKey())\n            })\n        }\n\n        assert(!this.hasActionsForTarget()) // todo: remove this sanity check\n        return this\n    }\n\n    // return SyncScheduler.shared().isSyncingOrScheduledTargetAndMethod(this, \"syncFromNode\")\n\n\n    unscheduleTargetAndMethod (target, syncMethod) {\n        const k = this.newActionForTargetAndMethod(target, syncMethod).actionsKey()\n        this.removeActionKey(k)\n        return this\n    }\n\n    removeActionKey (k) {\n        const action = this.actions().at(k)\n        if (action) {\n            action.setIsUnscheduled(true)\n            this.actions().removeKey(k)\n        }\n        return this\n    }\n\t\n    setTimeoutIfNeeded () {\n\t    if (!this.hasTimeout()) {\n            this.setHasTimeout(true)\n\t        this.addTimeout(() => { \n\t            this.setHasTimeout(false)\n\t            this.processSets() \n\t        }, 1)\n\t    }\n\t    return this\n    }\n\t\n    orderedActions () {\n        const sorter = function (a1, a2) { return a1.order() - a2.order() }\n        return this.actions().valuesArray().sort(sorter)\n    }\n\t\n    processSets () {\n        if (this.isProcessing()) {\n            console.warn(\"WARNING: SynScheduler attempt to processSets before last set is completed\")\n            return this\n        }\n        assert(!this.isProcessing())\n\n        //console.log(\" --- SyncScheduler BEGIN ---\")\n        //this.show()\n\n        this.setIsProcessing(true)\n        let error = null\n\n        //this.debugLog(this.description())\n        this.debugLog(\"Sync\")\n        \n        const actions = this.orderedActions()\n        this.actions().clear()\n \n        actions.forEach((action) => {\n            if (action.isUnscheduled()) {\n               debugger;\n            } else {\n                this.setCurrentAction(action)\n                //const actionError = action.tryToSend()\n                const actionError = action.send()\n                if (actionError) {\n                    error = actionError\n                }\n                this.setCurrentAction(null)\n            }\n        })\n        \n        this.setCurrentAction(null)\n        this.setIsProcessing(false)\n        \n        if (error) {\n            throw error\n        }\n\n        //console.log(\" --- SyncScheduler END ---\")\n\n        return this\n    }\n\n    actionCount () {\n        return this.actions().size\n    }\n\n    fullSyncNow () {\n        if (this.isProcessing()) {\n            this.debugLog(() => \"fullSyncNow called while isProcessing so SKIPPING\")\n            return this\n        }\n\n        if (this.actionCount()) {\n            this.debugLog(\" --- fullSyncNow start --- \")\n            let count = 0\n            const maxCount = 10\n\n            while (this.actionCount()) {\n                /*\n                this.(() => \" --- processSets # \" + count + \" --- \")\n                this.debugLog(() => this.description())\n                this.debugLog(() => BMNotificationCenter.shared().notesDescription())\n                this.debugLog(\" --- \")\n                */\n                this.processSets()\n                count ++\n                if (count > 6) {\n                    this.debugLog(\"loop?\")\n                }\n                assert (count < maxCount)\n            }\n\n            this.debugLog(\" --- fullSyncNow end --- \")\n        }\n\n        return this\n    }\n\n    actionsDescription () {\n        return this.orderedActions().map(action => \"    \" + action.description() ).join(\"\\n\")\n    }\n\n    show () {\n        console.log(this.type() + \":\")\n        console.log(this.actionsDescription())\n    }\n\n}.initThisClass());\n\n",
  "KdQ5qP3jPyHyAkOfMsq/xJ3ASxTTCju7oITZ6yH1g9I=": "\"use strict\";\n\n/*\n\n    BMNotification\n\n*/\n\n(class BMNotification extends ProtoClass {\n\n    initPrototypeSlots () {\n        this.newSlot(\"name\", null)\n        this.newSlot(\"sender\", null)\n        this.newSlot(\"info\", null)\n        this.newSlot(\"center\", null) // NotificationCenter that owns this\n        this.newSlot(\"senderStack\", null)\n    }\n\n    /*\n    init () {\n        super.init()\n    }\n    */\n\n    senderId () {\n        return this.sender().typeId()\n    }\n\n    setSender (obj) {\n        assert(Type.isObject(obj))\n        this._sender = obj\n        //this._senderId = obj.typeId())\n        return this\n    }\n    \n    isEqual (obs) {\n        if (this === obs) { \n            return true \n        }\n\n        return (this.name() === obs.name()) && (this.sender() === obs.sender())\n    }\n\n    isPosted () {\n        return this.center().hasNotification(this)\n    }\n    \n    post () {\n        if (this.center().isDebugging()) {\n            //console.log(typeof(this.senderId()) + \".\" + this.senderId() + \" posting note \" + this.name() + \" and recording stack for debug\")\n            const e = new Error()\n            e.name = \"\" //\"Notification Post Stack\"\n            e.message = this.senderId() + \" posting note '\" + this.name() + \"'\" \n            this.setSenderStack(e.stack);\n        }\n\n        //console.log(\"   queuing post \" + this.senderId() + \" '\" + this.name() + \"'\" )\n       \n        this.center().addNotification(this)\n        return this\n    }\n    \n    /*\n    schedulePost () {\n\t     SyncScheduler.shared().scheduleTargetAndMethod(this, \"post\")\n    }\n    */\n\n    description () {\n        const s = this.senderId() ? this.senderId() : \"null\"\n        const n = this.name() ? this.name() : \"null\"\n        return s + \" \" + n\n    }\n\n    newObservation () {\n        /*\n            this avoids note name typos and helps runtime check/debug note name changes as note name isn't hardcoded as string in multiple places\n            example use:\n\n                aFileLoader.doneNote().newObservation().setObserver(this).setIsOneShot(true).startWatching()\n\n                how about:\n\n                (in Node)\n\n                this.observeNote(aFileLoader.doneNote())\n                this.observeNoteOnce(aFileLoader.doneNote())\n        */\n        return BMNotificationCenter.shared().newObservation().setName(this.name()).setSender(this.sender())\n    }\n}.initThisClass());\n\n",
  "pHMDWHML7chEEJxYkQ/M0YOwlCIGv/x70xRdBr9sTsw=": "\"use strict\";\n\n/* \n\n    BMNotificationCenter\n    \n    A notification system that queues notifications and waits for the \n    app to return to the event loop (using a timeout) to post them. \n    It filters out duplicate notifications (posted on the same event loop) \n    and duplicate observations (same object registering the same observation again).\n        \n    WeakRefs: \n\n        The Observation class holds sender and observer references as weakrefs,\n        and when either is collected, it will automatically call Observation.stopWatching()\n        and remove itself from the NotificationCenter.\n\n        It's still good policy from an observer to explicilty call stopWatching as\n        soon as it no longer needs to observe, unless it wants to observer for it's entire\n        lifetime.\n\n    Example use:\n \n    Observing notifications:\n\n        // start watching for \"changed\" message from sender object\n        this._obs = BMNotificationCenter.shared().newObservation().setName(\"changed\").setObserver(this).setSender(sender).startWatching()\n    \n        // start watching for \"changedStoredSlot\" message from any sender object\n        this._obs = BMNotificationCenter.shared().newObservation().setName(\"changedStoredSlot\").setObserver(this).startWatching()\n\n        // stop watching this observation\n        this._obs.stopWatching()\n        \n        // stop watching all\n        BMNotificationCenter.shared().removeObserver(this)\n\n        // watch only for first note named \"appDidInit\"\n        this.watchOnceForNote(\"appDidInit\")\n        // WARNING: in this case, if app has already done init, this will never be called!\n\n    If the source object has an accessor for a notification it uses, we can do:\n\n        sourceObject.didLoadNote().newObservation().setObserver(this).startWatching()\n        \n    Posting notifications:\n\n        // post a notification\n        const note = this.newNoteNamed(\"hello\").post()\n\n        // repost same notification\n        note.post()\n\n    Broadcasting notifications:\n\n        For use cases where the overhead of creating post objects would be costly, \n        it's possible to send a direct message to all name listeners without waiting\n        until the event loop to end. These will pass the sender itself instead of a Notification object.\n\n        See Broadcaster class.\n\n    Helper methods available to subclasses of BMNode:\n\n        this.postNoteNamed(\"hello\")\n        this.watchOnceForNote(\"hello\")\n        this.watchOnceForNoteFrom(\"hello\", sourceObject)\n\n        this.observeNote(aFileLoader.doneNote()) // still need to handle observation removal\n        this.observeNoteOnce(aFileLoader.doneNote()) \n\n        note: I think nodes try remove their observations when removed?\n\n*/\n\n(class BMNotificationCenter extends ProtoClass {\n    initPrototypeSlots () {\n        this.newSlot(\"observations\", null) // array \n        this.newSlot(\"notifications\", null) // array \n        this.newSlot(\"debugNoteName\", \"appDidInit\")\n        this.newSlot(\"currentNote\", null)\n        this.newSlot(\"isProcessing\", false)\n        this.newSlot(\"nameIndex\", null) // dict of dicts\n        this.newSlot(\"obsHighwaterCount\", 100) // used\n    }\n\n    init () {\n        super.init()\n        this.setObservations([]);\n        this.setNotifications([]);\n        this.setNameIndex({});\n    }\n\n    // --- observations ----\n\n    /*\n    cleanIfNeeded () {\n        if (this.observations().count() < this.obsHighwaterCount()) {\n            this.cleanObservations()\n            this.setObsHighwaterCount(this.observations().count() * 2)\n        }\n    }\n\n    cleanObservations () {\n        // remove observations whose senders or observers have been collected\n        this.observations().shallowCopy().forEach(obs => {\n            obs.clean()\n        })\n    }\n    */\n    \n    hasObservation (obs) {\n        return this.observations().detect(ob => ob.isEqual(obs))\n    }\n    \n    addObservation (obs) {\n        if (!this.hasObservation(obs)) {\n            this.observations().push(obs)\n        }\n        return this\n    }\n\n    newObservation () {\n        return BMObservation.clone().setCenter(this);\n    }\n\n    hasObservationsForSender (sender) {\n        const obs = this.observations().detect(obs => obs.sender() === sender)\n        return !Type.isNullOrUndefined(obs)\n    }\n\n    /*\n    observationsForSender (sender) {\n        const matches = this.observations().filter(obs => obs.sender() === sender)\n        return matches\n    }\n    */\n    \n    removeObservation (anObservation) {\n        const filtered = this.observations().filter(obs => !obs.isEqual(anObservation))\n        this.setObservations(filtered)\n        return this\n    }\n    \n    removeObserver (anObserver) {        \n        const filtered = this.observations().filter(obs => obs.observer() !== anObserver)\n        this.setObservations(filtered)\n        return this;\n    }\n\n    // --- helpers ---\n\n    observersForName (name) {\n        return this.nameToObservers()[name] // returns a set\n    }\n\n    // --- notifying ----\n    \n    hasNotification (note) {\n        return this.notifications().detect(n => n.isEqual(note))\n    }\n    \n    addNotification (note) {\n        if (!this.hasNotification(note)) {\n            /*\n            if (note.sender().title && note.sender().title === \"STRVCTapp\") {\n                console.log(\"NotificationCenter '\" + note.sender().title() + \"' \" + note.name())\n            }\n            */\n            this.notifications().push(note)\n\t\t    SyncScheduler.shared().scheduleTargetAndMethod(this, \"processPostQueue\", -1)\n        }\n        return this\n    }\n\n    newNote () {\n        return BMNotification.clone().setCenter(this)\n    }\n    \n    // --- timeout & posting ---\n    \n    processPostQueue () {\n        // TODO: for performance, we could make an observationName->observations dictionary\n        // but only worthwhile if observation list is sufficiently large\n\n        // keep local ref of notifications and set \n        // notifications to empty array in case any are\n        // added while we process them\n\n        /*\n        console.log(\" --- \" + this.type() + \" processPostQueue BEGIN ---\")\n        this.show()\n        console.log(\" \")\n        */\n        this.setCurrentNote(null)\n\n        if (!this.isProcessing()) {\n            this.setIsProcessing(true)\n            //console.log(\"processPostQueue \" + this.notifications().length)\n            const notes = this.notifications()\n            this.setNotifications([])\n            notes.forEach(note => this.postNotificationNow(note))\n            //notes.forEach(note => this.tryToPostNotificationNow(note))\n            this.setIsProcessing(false)\n        } else {\n            Error.showCurrentStack()\n            console.warn(\"WARNING: attempt to call processPostQueue recursively while on note: \", this._currentNote)\n        }\n\n        //console.log(\" --- \" + this.type() + \" processPostQueue END ---\")\n\n        return this\n    }\n\n    tryToPostNotificationNow (note) {\n        try { \n            this.postNotificationNow(note)\n            //this.debugLog(\"   <- posting \" + note.description() )\n        } catch (error) {\n            console.log(this.type() + \" caught exception while posting: \" + note.description())\n            return error\n        }\n        return null\n    }\n\n    shouldDebugNote (note) {\n        return this.isDebugging() === true && (this.debugNoteName() === null || this.debugNoteName() === note.name());\n    }\n    \n    postNotificationNow (note) {\n        // use a copy of the observations list in \n        // case any are added while we are posting \n        //\n        // TODO: add an dictionary index for efficiency\n\n        this.setCurrentNote(note)\n        \n        const showDebug = this.shouldDebugNote(note)\n\n        if (showDebug) {\n            this.debugLog(\" senderId \" + note.senderId() + \" posting \" + note.name())\n            //this.showObservers()\n        }\n        \n        const observations = this.observations().shallowCopy()  \n      \n        observations.forEach( (obs) => {\n            if (obs.matchesNotification(note)) {\n                if (showDebug) {\n                    this.debugLog(\" \" + note.name() + \" matches obs \", obs)\n                    this.debugLog(\" sending \", note.name() + \" to obs \" + obs.type())\n                }\n            \n                obs.sendNotification(note)    \n                //obs.tryToSendNotification(note)   \n            }\n        })        \n        \n        this.setCurrentNote(null)\n    }\n\n    show () {\n        console.log(this.type() + \":\")\n        console.log(\"  posting notes:\")\n        console.log(this.notesDescription())\n        console.log(\"  observations:\")\n        console.log(this.observersDescription())\n    }\n\n    notesDescription () {\n        return this.notifications().map(note => \"    \" + note.description()).join(\"\\n\")\n    }\n\n    observersDescription () {\n        return this.observations() .map(obs => \"    \" + obs.description()).join(\"\\n\") \n    }\n    \n    showCurrentNoteStack () {\n        if (this.currentNote() === null) {\n            //console.log(\"BMNotificationCenter.showCurrentNoteStack() warning - no current post\")\n        } else {\n            console.log(\"current post sender stack: \", this.currentNote().senderStack())\n        }\n    }\n}.initThisClass());\n",
  "GN6bgt5M8iqFJpPs/tFgPTCSCC2dFFwnf9eWW6DLrSs=": "\"use strict\";\n\n/*\n\n    BMObservation\n\n    An abstraction for a NotificationCenter observation. \n    Holds references to which notification message a given observer is wants\n    notifications for. \n\n*/\n\n(class BMObservation extends ProtoClass {\n    initPrototypeSlots () {\n        this.newSlot(\"center\", null) // NotificationCenter that owns this\n        this.newSlot(\"name\", null) // String \n        this.newSlot(\"isOneShot\", false) // Boolean\n        this.newWeakSlot(\"observer\", null) // WeakRef slot to observer\n        this.newWeakSlot(\"sender\", null) // WeakRef to sender\n    }\n\n    init () {\n        super.init()\n        this.setSender(null)\n        this.setObserver(null)\n        this.setIsDebugging(false)\n    }\n\n    onFinalizedSlotObserver () {\n        debugger;\n        this.scheduleMethod(\"stopWatching\")\n    }\n\n    onFinalizedSlotSender () {\n        debugger;\n        this.scheduleMethod(\"stopWatching\")\n    }\n\n    // --- private helpers ---\n\n    valueId (v) { // private\n        return v ? v.typeId() : \"undefined\"\n    }\n\n    // --- sender ---\n\n    senderId () { \n        return this.valueId(this.sender())\n    }\n\n    /*\n    senderOrObserverWasCollected () {\n        return this.observer() === undefined || this.sender() === undefined\n    }\n\n    clean () {\n        if (this.senderOrObserverWasCollected()) {\n            debugger\n            this.stopWatching()\n        }\n    }\n    */\n\n    // --- observer --- \n\n    observerId () { \n        return this.valueId(this.observer())\n    }\n\n    // ---\n\n    matchesNotification (note) {\n        const sender = this.sender()\n        const matchesSender = (sender === null) || (sender === note.sender()) \n        if (matchesSender) {\n            const name = this.name()\n            const matchesName = (name === null) || (note.name() === name) \n            return matchesName\n        }\n        return false\n    }\n\n    tryToSendNotification (note) {\n        try {\n            this.sendNotification(note)       \n        } catch(error) {\n            console.log(\"NOTIFICATION EXCEPTION: '\" + error.message + \"'\");\n            console.log(\"  OBSERVER (\" + this.observer() + \") STACK: \", error.stack)\n            if (note.senderStack()) {\n                console.log(\"  SENDER (\" + note.senderId() + \") STACK: \", note.senderStack())\n            }\n\n            // how to we propogate the exception so we can inspect it in the debugger\n            // without causing an inconsistent state by not completing the other notifications?\n            throw error\n        }\n        return null\n    }\n\n    sendNotification (note) {\n        if (this.center().isDebugging()) {\n            //console.log(this._observer + \" received note \" + note.name() + \" from \" + note.sender() )\n        }\n\n        const obs = this.observer()\n        if (obs === undefined) { // observer may have been collected\n            console.log(\"OBSERVER COLLECTED ON: \" + this.description())\n            this.stopWatching()\n            return\n        }\n        const method = obs[note.name()]\n        if (method) {\n            method.call(obs, note)\n        } else {\n            if (this.isDebugging()) {\n                this.debugLog(\" no method found for note name \" + note.name())\n            }\n        }\n\n        if (this.isOneShot()) {\n            this.stopWatching()\n        }\n    }\n\n    isEqual (obs) {\n        const sameName = this.name() === obs.name()\n        const sameObserver = this.observer() === obs.observer()\n        const sameSenderId = this.sender() === obs.sender()\n        return sameName && sameObserver && sameSenderId\n    }\n\n    startWatching () {\n        this.center().addObservation(this)\n        //this.sender().onStartObserving()\n        return this\n    }\n\n    isWatching () {\n        return this.center().hasObservation(this)\n    }\n\n    stopWatching () {\n        this.center().removeObservation(this)\n        //this.sender().onStopObserving()\n        return this\n    }\n\n    /*\n    stopWatchingIfSenderOrObserverCollected () {\n        if (this.sender() === undefined || this.observer() === undefined) {\n            this.stopWatching()\n        }\n    }\n    */\n\n    description () {\n        return this.observerId() + \" listening to \" + this.senderId() + \" \" + this.name()\n    }\n\n    static testWeakRefs () {\n        const observer = new Object()\n        const sender = new Object()\n        const observation = BMNotificationCenter.shared().newObservation().setName(\"weakRefTest\").setObserver(observer).setSender(sender).startWatching()\n        // let's see if this onFinalizedSlotObserver or onFinalizedSlotSender get called and it auto stops watching \n    }\n\n}.initThisClass());\n\n//BMObservation.testWeakRefs()\n",
  "hmq6CPirZ3mopNM6IcqMia49P4dESAy91XT5mSm1/yw=": "\"use strict\";\n\n/*\n\n    Broadcaster\n\n    Fast notifications that immediately message listeners \n    instead of using Observer and Notification objects.\n    As multiple notifications of the same name are not merged\n    within the same event loop, it's up to listeners to implement handlers efficiently.\n\n    Example use:\n\n        // inside a storable node\n        init () {\n            ...\n            Broadcaster.shared().addListenerForName(this, \"didChangeStoredSlot\")\n            ...\n        }\n\n        // inside a StoreableNode, on slot change\n        onSlotChange (...) {\n            ...\n            Broadcaster.shared().broadcastNameAndArgument(\"didChangeStoredSlot\", this)\n            ...\n        }\n\n        // inside a persistent store\n        didChangeStoredSlot (aSender) {\n            ... tell store to persist it ...\n        }\n\n    Example use:\n*/\n\n(class Broadcaster extends ProtoClass {\n    initPrototypeSlots () {\n        this.newSlot(\"nameToListenersMap\", null)  // dict to set\n    }\n\n    init () {\n        super.init()\n        this.setNameToListenersMap(new Map())\n    }\n\n    listenerSetForName (name) {\n        assert(!Type.isNullOrUndefined(name))\n\n        // probably not inneficient since \n        // 1. we don't remove listeners often\n        // 2. we don't have many names\n        const n2l = this.nameToListenersMap()\n\n        if (!n2l.has(name)) {\n            n2l.set(name, new Set())\n        }\n        return n2l.get(name)\n    }\n\t\n    addListenerForName (aListener, name) {\n        this.listenerSetForName(name).add(aListener)\n        return this\n    }\n    \n    removeListenerForName (aListener, name) {\n        this.listenerSetForName(name).delete(aListener)\n        return this\n    }\n\n    broadcastNameAndArgument (methodName, anArgument) {\n        this.listenerSetForName(methodName).forEach(v => {\n            v[methodName].call(v, anArgument)\n        })\n        return this\n    }\n\n    clean () {\n        const n2l = this.nameToListenersMap()\n        n2l.shallowCopy().forEachKV((name, listenerSet) => {\n            if (listenerSet.size === 0) {\n                n2l.delete(name)\n            }\n        })\n    }\n\n}.initThisClass());\n\nObject.defineSlots(ProtoClass.prototype, {\n\n    broadcastMessage: function(methodName) {\n        Broadcaster.shared().broadcastNameAndArgument(methodName, this)\n        return this\n    }\n    \n})\n",
  "nKGw9piP+WCN9XtqWtg/KNiC5SEjF1MP5vQkgYOLhu0=": "\"use strict\";\n\n/* \n\n    IndexedDBFolder\n\n*/\n\n(class IndexedDBFolder extends ProtoClass {\n    initPrototypeSlots () {\n        this.newSlot(\"path\", \"/\")\n        this.newSlot(\"pathSeparator\", \"/\") // path should end with pathSeparator\n        this.newSlot(\"db\", null)\n\n        // requesting persistence\n        this.newSlot(\"hasPermission\", false)\n        this.newSlot(\"promiseForPersistence\", null)\n\n        this.newSlot(\"promiseForOpen\", null) // has a value while opening. Returns this value while opening so multiple requests queue for open\n        this.newSlot(\"promiseForCommit\", null) \n    }\n\n    init () {\n        super.init()\n        this.setIsDebugging(false)\n    }\n\n    setPath (aString) {\n        assert(!this.isOpen())\n        this._path = aString\n        return this\n    }\n\n    hasIndexedDB () {\n        return \"indexedDB\" in window;\n    }\n\n    /*\n    promiseHasIndexedDB () {\n        if (this.hasIndexedDB()) {\n            return Promise.resolve()\n        } \n        return Promise.reject(new Error(\"IndexedDB unavailable on this client.\"))\n    }\n    */\n\n    hasStorageApi () {\n        return navigator.storage && navigator.storage.persist\n    }\n\n    promisePersistence () {\n        if (!this.promiseForPersistence()) {\n            this.setPromiseForPersistence(this.newPromisePersistence())\n        }\n        return this.promiseForPersistence()\n    }\n\n    newPromisePersistence () {\n        if (!this.hasStorageApi()) {\n            return Promise.reject(new Error(\"Missing navigator.storage API.\"))\n        }\n\n        return navigator.storage.persist().then((granted) => {\n            this.setHasPermission(granted)\n            if (granted) {\n                console.log(\"Storage will not be cleared except by explicit user action.\");\n                resolve(true)\n            } else {\n                console.warn(\"Storage may be cleared by the UA under storage pressure.\");\n                reject(false)\n            }\n        })\n    }\n\n    storeName () {\n        return this.path()\n    }\n\n    /*\n    root () {\n        if (!IndexedDBFolder._root) {\n            IndexedDBFolder._root = IndexedDBFolder.clone()\n            // IndexedDBFolder._root.rootShow()\n        }\n        return IndexedDBFolder._root\n    }\n    */\n\n    isOpen () {\n        return (this.db() !== null)\n    }\n\n    promiseOpen () {\n        if (!this.promiseForOpen()) {\n            this.setPromiseForOpen(this.newPromiseOpen())\n        }\n        return this.promiseForOpen()\n    }\n\n    newPromiseOpen () {\n        assert(this.hasIndexedDB())\n\n        return new Promise((resolve, reject) => {\n            if(this.isOpen()) {\n                resolve()\n                return\n            }\n\n            const version = 2 // can't be zero\n            //console.log(this.typeId() + \" promiseOpen '\" + this.path() + \"'\")\n            const request = window.indexedDB.open(this.path(), version);\n\n            request.onsuccess = (event) => {\n                //debugger;\n                this.setDb(event.target.result)\n                resolve()\n            }\n\n            request.onupgradeneeded = (event) => {\n                //debugger;\n                resolve(this.promiseOnOpenUpgradeNeeded(event))\n            }\n\n            request.onerror = (error) => {\n                debugger;\n                this.debugLog(\" open db error: \", event);\n                this.onOpenError(event)\n                reject(error)\n            }\n        })\n    }\n\n    onOpenError (event) {\n        let message = event.message\n        if (!message) {\n            message = \"Unable to open IndexedDB.<br>May not work on Brave Browser.\"\n            this.debugLog(\" open db error: \", event);\n        }\n    }\n\n    promiseOnOpenUpgradeNeeded (event) {\n        return new Promise((resolve, reject) => {\n            this.debugLog(\" onupgradeneeded - likely setting up local database for the first time\")\n\n            const db = event.target.result;\n\n            db.onerror = (event) => {\n                console.log(\"db error \", event)\n            };\n\n            this.setDb(db)\n\n            const objectStore = db.createObjectStore(this.storeName(), { keyPath: \"key\" }, false);\n            const idbIndex = objectStore.createIndex(\"key\", \"key\", { unique: true });\n            resolve()\n        })\n    }\n\n    close () {\n        if (this.isOpen()) {\n            this.db().close()\n            this.setIsOpen(false)\n            this.setDb(null)\n            this.setPromiseForOpen(null)\n        }\n        return this\n    }\n\n    // paths\n\n    folderAt (pathComponent) {\n        assert(!pathComponent.contains(this.pathSeparator()))\n        const db = IndexedDBFolder.clone().setPath(this.path() + pathComponent + this.pathSeparator())\n        return db\n    }\n\n    pathForKey (key) {\n        //assert(!key.contains(this.pathSeparator()))\n        return this.path() + key\n    }\n\n    // reading\n\n    promiseHasKey (key) {\n        return new Promise((resolve, reject) => {\n            const objectStore = this.db().transaction(this.storeName(), \"readonly\").objectStore(this.storeName())\n            //const keyRangeValue = IDBKeyRange.bound(key, key)\n            //const request = objectStore.openCursor(keyRangeValue)\n            const request = objectStore.openCursor(key)\n\n            request.onsuccess = (evente) => {\n                const cursor = event.target.result\n                if (cursor) { // key already exists\n                    resolve(true)\n                } else { // key does not exist\n                    resolve(false)\n                }\n            }\n\n            request.onerror = (event) => {\n                console.log(\"promiseAt('\" + key + \"') onerror\", event.target.error)\n                reject(event)\n            }\n        })\n    }\n    \n    promiseAt (key) {\n        return new Promise((resolve, reject) => {\n            //console.log(\"promiseAt \", key)\n            const objectStore = this.db().transaction(this.storeName(), \"readonly\").objectStore(this.storeName())\n            const request = objectStore.get(key);\n            const stack = \"(stack recording disabled)\" //new Error().stack\n\n            request.onsuccess = (event) => {\n                // request.result is undefined if value not in DB\n                try {\n                    if (!Type.isUndefined(request.result)) {\n                        const entry = request.result\n                        const value = entry.value\n                        resolve(value)\n                    } else {\n                        resolve(undefined)\n                    }\n                } catch (e) {\n                    this.debugLog(\" promiseAt('\" +  key + \"') caught stack \", stack)\n                }\n            }\n            \n            request.onerror = (event) => {\n                console.log(\"promiseAt('\" + key + \"') onerror\", event.target.error)\n                resolve(undefined)\n            }\n            \n        })\n    }\n\n    /*\n\n    promiseReadOnlyCursorRequest () {\n        return new Promise((resolve, reject) => {\n            const objectStore = this.db().transaction(this.storeName(), \"readonly\").objectStore(this.storeName())\n            const idbRequest = objectStore.openCursor()\n            idbRequest.onsuccess = (event) => {\n                resolve(event)\n            }\n            idbRequest.onerror = (event) => {\n                reject(event)\n            }\n        })\n    }\n\n\n    promiseForeachKey (aBlock) {\n        return this.promiseReadOnlyCursorRequest().then((event) => {\n            const cursor = event.target.result\n            if (cursor) {\n                aBlock(cursor.value.key)\n                cursor.continue() // this calls open resolve function again\n            } else {\n                resolve()\n            }\n        })\n    }\n    */\n\n\n    promiseAsMap () {\n        return new Promise((resolve, reject) => {\n            const objectStore = this.db().transaction(this.storeName(), \"readonly\").objectStore(this.storeName())\n            const idbRequest = objectStore.getAll()\n\n            idbRequest.onsuccess = (event) => {\n                const results = event.target.result\n                const map = new Map()\n                results.forEach(result => {\n                    map.set(result.key, result.value)\n                })\n                resolve(map)\n            }\n\n            idbRequest.onerror = (event) => {\n                reject(event)\n            }\n        })\n    }\n\n    show () {\n        this.promiseAsMap().then((map) => {\n            this.debugLog(\" \" + this.path() + \" = \" + map.description())\n        })\n    }\n\n    // removing\n\n    promiseClear () {\n        return new Promise((resolve, reject) => {\n\n            // setup transaction \n            const transaction = this.db().transaction([this.storeName()], \"readwrite\");\n\n            transaction.onerror = (event) => {\n                console.log(\"db clear tx error\")\n                reject(event)\n            };\n\n            transaction.oncomplete = (event) => {\n                console.log(\"db clear tx completed\")\n                resolve(event)\n            }\n\n            // setup clear request\n            const objectStore = transaction.objectStore(this.storeName());\n            const request = objectStore.clear();\n\n            request.onsuccess = (event) => {\n                console.log(\"db clear request success\")\n                //resolve(event) // we use tx oncomplete (see above code in this method) instead\n            };\n\n            request.onerror = (event) => {\n                console.log(\"db clear error\")\n                reject(event)\n            };\n\n        })\n    }\n\n    promiseDelete () {\n        assert(!this.isOpen())\n\n        return new Promise((resolve, reject) => {\n            const request = window.indexedDB.deleteDatabase(this.storeName())\n\n            request.onerror = (error) => {\n                this.debugLog(\"Error deleting '\" + this.storeName() + \"'\");\n                reject(error)\n            }\n\n            request.onsuccess = (event) => {\n                this.debugLog(\" deleted successfully '\" + this.storeName() + \"'\");\n                resolve(event)\n            }\n\n            this.setDb(null)\n        })\n    }\n\n    newTx () {\n        return IndexedDBTx.clone().setDbFolder(this)\n    }\n\n    debugTypeId () {\n        return super.debugTypeId() + \" '\" + this.path() + \"'\"\n    }\n\n    // test\n\n    static selfTest () {\n        const folder = IndexedDBFolder.clone()\n        folder.promiseOpen().then(() => {\n            return folder.promiseAtPut(\"test\", \"x\")\n        }).then(() => {\n            folder.promiseAsMap().then((map) => { console.log(\"db map = \", map) })\n        }).then(() => {\n            folder.promiseAt(\"test\", (v) => { console.log(\"read \", v) })\n        })\n    }\n\n}.initThisClass());\n",
  "59thqvLuVkt6fI83aUa498rE616O7X4kYclx2RBME4o=": "\"use strict\";\n\n/* \n\n    IndexedDBTx\n\n    Abstraction of a single IndexedDB transaction.\n\n*/\n\n(class IndexedDBTx extends ProtoClass {\n\n    initPrototypeSlots () {\n        this.newSlot(\"dbFolder\", null)\n        this.newSlot(\"objectStore\", null)\n        this.newSlot(\"tx\", null)\n        this.newSlot(\"requests\", [])\n        this.newSlot(\"isCommitted\", false)\n        this.newSlot(\"isAborted\", false)\n        this.newSlot(\"txRequestStack\", null)\n        this.newSlot(\"options\", { \"durability\": \"strict\" })\n        this.newSlot(\"txId\", null)\n    }\n\n    init () {\n        super.init()\n        this.setIsDebugging(true)\n    }\n\n    isDebugging () {\n        return true\n    }\n\n    db () {\n        return this.dbFolder().db()\n    }\n    \n    storeName () {\n        return this.dbFolder().storeName()\n    }\n\t\n    // --- being and commit ---\n\n    assertNotCommitted () {\n\t    assert(this.isCommitted() === false)\n    }\n\n    newTx () {\n        assert(Type.isNullOrUndefined(this.tx()))\n        const tx = this.db().transaction(this.storeName(), \"readwrite\", this.options())\n        tx.onerror    = (error) => { \n            debugger\n            throw new Error(error) \n        }\n        this.setTx(tx)\n        return tx\n    }\n\n    begin () {\n        this.debugLog(\"BEGIN \")\n        //this.debugLog(\"BEGIN \" + this.txId())\n\t    this.assertNotCommitted()\n        this.setTxRequestStack(this.isDebugging() ? new Error().stack : null)\n\t    const tx = this.newTx()\n        const objectStore = tx.objectStore(this.storeName());\n        this.setObjectStore(objectStore)\n        return this\n    }\n\n    showTxRequestStack () {\n        const rs = this.txRequestStack()\n        if (rs) { \n            console.log(\"error stack \", rs)\n        }\n    }\n\t\n    abort () {\n\t    this.assertNotCommitted()\n\t    this.tx().abort() // how does this get rejected?\n        this.setIsAborted(true)\n\t    return this\n    }\n\n    isFinished () {\n        return this.isAborted() || this.isCommitted()\n    }\n\n    promiseCommit () {\n        this.debugLog(\"promiseCommit \")\n\n        return new Promise((resolve, reject) => {\n            this.assertNotCommitted()\n            this.setIsCommitted(true)\n            const tx = this.tx()\n\n            if (Type.isUndefined(tx.commit)) {\n                reject(new Error(\"WARNING: no IDBTransation.commit method found for this browser\"))\n            } else {\n                tx.oncomplete = (event) => { \n                    this.debugLog(\" COMMIT COMPLETE\")\n                    //debugger\n                    resolve(event) \n                }\n                tx.onerror = (error) => { \n                    debugger; \n                    reject(error)\n                }\n                this.debugLog(\" COMMITTING\")\n                tx.commit()\n            }\n        })\n    }\n\t\n    // --- helpers ---\n\t\n    pushRequest (aRequest) {\n\t    this.assertNotCommitted()\n\n        const requestStack = this.isDebugging() ? new Error().stack : null;\n\n        aRequest.onerror = (event) => {\n\t\t    const fullDescription = \"objectStore:'\" + this.dbFolder().path() + \"' '\" + aRequest._action + \"' key:'\" + aRequest._key + \"' error: '\" + event.target.error + \"'\"\n\t\t    this.debugLog(fullDescription)\n\t\t    if (requestStack) { \n                console.log(\"error stack \", requestStack)\n            }\n\t\t  \tthrow new Error(fullDescription)\n        }\n\n        /*\n        aRequest.onsuccess = (event) => {\n            // report the success of the request (this does not mean the item\n            // has been stored successfully in the DB - for that you need transaction.onsuccess)\n        }\n        */\n\n        this.requests().push(aRequest)\n\t    return this\n    }\n\t\n    entryForKeyAndValue (key, value) {\n        assert(Type.isString(key))\n        assert(Type.isString(value) || Type.isArrayBuffer(value))\n        return { key: key, value: value }\n    }\n\t\n    // --- operations ----\n\t\n    atAdd (key, value) {\n        //debugger\n        //assert(!this.hasKey(key))\n\n        assert(Type.isString(key))\n        assert(Type.isString(value) || Type.isArrayBuffer(value))\n        this.assertNotCommitted()\n        \n        //this.debugLog(() => \" add \" + key + \" '\" + object + \"'\")\n        this.debugLog(() => \" ADD \" + key + \" '...'\")\n\n        const entry = this.entryForKeyAndValue(key, value)\n        const request = this.objectStore().add(entry);\n        request._action = \"add\"\n        request._key = key \n        this.pushRequest(request)\n        return this\n    }\n\n    atUpdate (key, value) {\n        //assert(!this.hasKey(key))\n\n        assert(Type.isString(key))\n        assert(Type.isString(value) || Type.isArrayBuffer(value))\n\t    this.assertNotCommitted()\n\n        this.debugLog(() => \" UPDATE \" + key)\n\n        const entry = this.entryForKeyAndValue(key, value)\n        const request = this.objectStore().put(entry);\n        request._action = \"put\"\n        request._key = key\n        this.pushRequest(request)\n        return this\n    }\n    \n    removeAt (key) {\n\t    this.assertNotCommitted()\n\n        this.debugLog(() => \" REMOVE \" + key)\n\n        const request = this.objectStore().delete(key);\n        request._action = \"remove\"\n        request._key = key\n        this.pushRequest(request)\n        return this\n    }\n\n    debugTypeId () {\n        return this.dbFolder().debugTypeId() + \" \" + this.txId() //super.debugTypeId()\n    }\n    \n}.initThisClass());\n\n\n\n\n",
  "5fs/iGd4XlxjNY37NiTnDX8bA6A+WjoMeR393BWgLOE=": "\"use strict\";\n\n/*\n\n    PersistentAtomicMap\n\n    An persistent atomic Map implemented as \n    a read & write cache on top of IndexedDB.\n    \n    On open, it reads the entire db into a dictionary\n    so we can do synchronous reads and writes (avoiding IndexedDB's async API),\n    and then call the async commit at the end of the event loop.\n\n    Notes:\n\n    - keys and values are assumed to be strings\n\t- any exception between begin and commit should halt the app and require a restart to ensure consistency\n\n    API:\n\n    - at(key) returns a value from the internal dict\n    - begin() shallow copies the current internal dict\n    - atPut(key, value) & removeAt(key)\n        applies normal op and adds key to changedKeySet\n    - revert() reverts changes since begin\n    - commit() constructs a transaction using changedKeySet \n\t- at(key) first checks the writeCache beforing checking the readCache\n\t\t\n    TODO: \n    \n    - auto sweep after a write if getting full? \n        \n*/\n\n(class PersistentAtomicMap extends ideal.AtomicMap {\n    initPrototypeSlots () {\n        this.newSlot(\"name\", null)\n        this.newSlot(\"idb\", null)\n        this.newSlot(\"txCount\", 0)\n    }\n\n    init () {\n        super.init()\n        this.setIsOpen(false)\n        this.setIdb(IndexedDBFolder.clone())\n        this.setIsDebugging(true)\n        this.setName(\"PersistentAtomicMap\")\n    }\n\n    setName (aString) {\n        this._name = aString\n        this.idb().setPath(this.name())\n        return this\n    }\n\n    // open\n\n    open () {\n        throw new Error(this.type() + \" synchronous open not supported\")\n        return this\n    }\n\n    setName (aString) {\n        this._name = aString\n        this.idb().setPath(this.name())\n        return this\n    }\n\n    promiseOpen () {\n        return this.idb().promiseOpen().then(() => { return this.promiseOnOpen()}) // it can deal with multiple calls while it's opening\n    }\n\t\n    promiseOnOpen () {\n        //debugger;\n        console.log(this.typeId() + \" promiseOnOpen '\" + this.name() + \"'\")\n        this.debugLog(\" onOpen() - loading cache\")\n        \n        if (false) {\n            debugger;\n            return this.promiseClear().then(() => this.promiseLoadMap())\n        } \n\n        return this.promiseLoadMap()\n    }\n\n    promiseLoadMap () {\n        return this.idb().promiseAsMap().then(map => {\n            assert(!Type.isNull(map))\n            //console.log(this.debugTypeId() + \" onOpen() --- loaded cache with \" + this.recordsMap().count() + \" keys\")\n            this.setMap(map)\n            console.log(\"map keys:\", map.keysArray())\n            this.setIsOpen(true)\n            //this.verifySync(callback, errorCallback)\n        })\n    }\n\n    // --- close ---\n\n    close () {\n        if (this.isOpen()) {\n            this.idb().close()\n        }\n        super.close()\n        return this\n    }\n\t\n    // ---- clear --- \n\t\t\n    promiseClear () {\n        return new Promise((resolve, reject) => {\n            this.idb().promiseClear().then(() => {\n                this.map().clear()            \n                resolve()\n            }, reject)\n        })\n    }\n\t\t\n    // --- transactions ---\n\n    newTxId () {\n        const count = this.txCount()\n        //const s = this.typeId() + \"_TX_\" + count\n        const s = \"TX_\" + count\n        this.setTxCount(count + 1)\n        return s\n    }\n\n    promiseApplyChanges () { // private -- apply changes to idb, super call will apply to map\n        const count = this.changedKeySet().size\n\t    const tx = this.idb().newTx().setTxId(this.newTxId())\n\t    tx.begin()\n        tx.setIsDebugging(this.isDebugging())\n        \n        //debugger\n        this.changedKeySet().forEachK((k) => {\n            const v = this.at(k)\n            //debugger;\n            if (!this.has(k)) {\n                tx.removeAt(k)\n            } else {\n                const isUpdate = this.snapshot().has(k)\n                if (isUpdate) {\n                    tx.atUpdate(k, v)\n                } else {\n                    tx.atAdd(k, v)\n                }                \n            }\n        })\n\t\t\n        //debugger\n\n        super.applyChanges() // do this last as it will clear the snapshot\n\t\t\n        this.debugLog(() => \"---- \" + this.type() + \" committed tx with \" + count + \" writes ----\")\n\n        // indexeddb commits on next event loop automatically\n        // tx is marked as committed and will throw exception on further writes\n        return tx.promiseCommit() //.then(() => this.verifySync())\n    }\n\t\n    // --- helpers ---\n\n    verifySync (resolve, reject) {\n        const currentMap = this.map().shallowCopy()\n\n        this.idb().promiseAsMap().then(map => {\t \n            const isSynced = map.isEqual(currentMap) // works if keys and values are strings\n            if (!isSynced) {\n                //this.idb().show()\n                //console.log(\"syncdb idb json: \", JSON.stringify(map.asDict(), null, 2))\n                throw new Error(his.debugTypeId() + \".verifySync() FAILED\")\n                reject()\n            }\n            console.log(this.debugTypeId() + \".verifySync() SUCCEEDED\")\n            if (resolve) {\n                resolve()\n            }\n        })\n    }\n}.initThisClass());\n\n",
  "OYBAnmeKaF3xIjwL7nzmxQl9UK/B58+H+4hljGumYXs=": "\"use strict\";\n\n/*\n\n    PersistentAsyncMap\n\n    An async Map wrapper for IndexedDB.\n\n    Public methods:\n\n        promiseOpen() \n        close()\n        promiseClear()\n        promiseAllKeys()\n        promiseHasKey(key)  // resolve passes true or false\n        promiseAt(key) // resolve passes value or undefined\n        promiseAtPut(key, value) \n        promiseRemoveKey(key)\n        \n*/\n\n(class PersistentAsyncMap extends ProtoClass {\n    initPrototypeSlots () {\n        this.newSlot(\"name\", \"PersistentAsyncDictionary\")\n        this.newSlot(\"idb\", null)\n    }\n\n    init () {\n        super.init()\n        this.setIdb(IndexedDBFolder.clone())\n        this.setIsDebugging(false)\n    }\n    \n    // open\n\n    assertAccessible () {\n        super.assertAccessible()\n        this.assertOpen()\n    }\n\n    isOpen () {\n        return this.idb().isOpen()\n    }\n\n    open () {\n        throw new Error(this.type() + \" synchronous open not supported\")\n        return this\n    }\n\n    close () {\n        if (this.isOpen()) {\n            this.idb().close()\n            this.setIsOpen(false)\n        }\n        return this\n    }\n\n    promiseOpen () {\n        if (!this.isOpen()) {\n            this.idb().setPath(this.name())\n        }\n        return this.idb().promiseOpen().then(() => {\n            return this.promiseOnOpen() \n        })\n    }\n\t\n    promiseOnOpen () {\n        return new Promise((resolve, reject) => {\n            if (false) {\n                return this.promiseClear()\n            } \n            resolve()\n        })\n    }\n\t\n    assertOpen () {\n        assert(this.isOpen())\n        return this\n    }\n\t\n    // ---- operations ---\n\n    promiseClear () {\n        return this.idb().promiseClear() \n    }\n\n    promiseAllKeys () {\n        return this.idb().promiseAllKeys()\n    }\n\n    promiseHasKey (key) { // resolve passes true or false\n        return this.idb().promiseHasKey(key) \n    }\n\n    promiseAt (key) { // resolve passes value or undefined\n        return this.idb().promiseAt(key)\n    }\n\n    promiseAtPut (key, value) {\n        if (Type.isArrayBuffer(value)) {\n            assert(value.byteLength)\n        }\n\n        this.assertOpen()\n\n        return this.promiseHasKey(key, (hasKey) => {\n            if (hasKey) {\n                return this.promiseUpdate(key, value, resolve, reject)\n            } else {\n                return this.promiseAdd(key, value, resolve, reject)\n            }\n        })\n    }\n\n    promiseUpdate (key, value) { // private\n\t    const tx = this.idb().newTx()\n\t    tx.begin()\n        tx.setIsDebugging(this.isDebugging())\n        tx.atUpdate(key, value)\n        return tx.promiseCommit() \n    }\n\n    promiseAdd (key, value) { // private\n\t    const tx = this.idb().newTx()\n\t    tx.begin()\n        tx.setIsDebugging(this.isDebugging())\n        tx.atAdd(key, value)\n        return tx.promiseCommit() \n    }\n\n    promiseRemoveKey (key) {\n\t    const tx = this.idb().newTx()\n\t    tx.begin()\n        tx.setIsDebugging(this.isDebugging())\n        tx.removeAt(key)\n        return tx.promiseCommit() \n    }\n\n}.initThisClass());\n",
  "bhHY8HteIAXXv2HTmqknPosOUmGIIsmcacnEtPV9C3A=": "\"use strict\";\n\n/*\n    Point\n\n    Class to represent a 2d or 3d point, optionally with a time.\n\n    TODO: \n        Move internal representation to array e.g.\n\n        this.newSlot(\"valueArray\", new Array(0, 0, 0, 0))\n\n        x () {\n            return this._valueArray[0]\n        }\n\n        isEqual (other) {\n            return this._valueArray == other.valueArray()\n        }\n\n*/\n\n\n(class Point extends ProtoClass {\n    initPrototypeSlots () {\n        this.newSlot(\"x\", 0)\n        this.newSlot(\"y\", 0)\n        this.newSlot(\"z\", 0)\n        this.newSlot(\"t\", 0)\n    }\n\n    /*\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n    valueArray () {\n        return [this._x, this._y, this._z]\n    }\n\n    setTimeToNow () {\n        const d = new Date();\n        this._t = d.getTime();\n        return this\n    }\n\n    copyFrom (p, copyDict) {\n        this._x = p._x\n        this._y = p._y\n        this._z = p._z\n        this._t = p._t\n        return this\n    }\n\n    setXY (x, y) {\n        this._x = x;\n        this._y = y;\n        return this\n    }\n    \n    set (x, y, z, t) {\n        this._x = x;\n        this._y = y;\n        if (Type.isNumber(z)) {\n            this._z = z\n        }\n        if (Type.isNumber(t)) {\n            this._t = t\n        }\n        return this\n    }\n\n    addInPlace (p) {\n        this._x += p._x\n        this._y += p._y\n        this._z += p._z\n        this._t += p._t\n        return this\n    }\n\n    subtractInPlace (p) {\n        this._x -= p._x\n        this._y -= p._y\n        this._z -= p._z\n        this._t -= p._t\n        return this\n    }\n\n    floorInPlace () {\n        this._x = Math.floor(this._x)\n        this._y = Math.floor(this._y)\n        this._z = Math.floor(this._z)\n        return this\n    }\n\n    copy () {\n        return this.thisClass().clone().copyFrom(this)\n    }\n\n    add (p) {\n        return this.copy().addInPlace(p)\n    }\n\n    subtract (p) {\n        return this.copy().subtractInPlace(p)\n    }\n\n    asString () {\n        let s = this.type() + \"(\" + this._x + \", \" + this._y \n\n        if (this._z) { \n            s += \", \" + this._z\n        }\n\n        /*\n        if (this._t) { \n            s += \", \" + this._t + \"t\" \n        }\n        */\n\n        return s + \")\"\n    }\n\n    distanceFromOrigin () {\n        const ds = Math.pow(this.x(), 2) + Math.pow(this.y(), 2) + Math.pow(this.z(), 2)\n        return Math.sqrt(ds)\n    }\n\n    // difference with another point\n\n    dxFrom (p) {\n        return this.x() - p.x()\n    }\n\n    dyFrom (p) {\n        return this.y() - p.y()\n    }\n\n    dzFrom (p) {\n        return this.z() - p.z()\n    }\n\n    dtFrom (p) {\n        return this.t() - p.t()\n    }\n\n    distanceFrom (p) {\n        const dx = this.dxFrom(p)\n        const dy = this.dyFrom(p)\n        const dz = this.dzFrom(p)\n        return Math.sqrt(dx*dx + dy*dy + dz*dz)\n    }\n\n    // eqaulity\n\n    isEqual (p) {\n        return (this.x() === p.x()) && (this.y() === p.y()) && (this.z() === p.z()) // && (this.t() === p.t())\n    }\n\n    isEqualWithTime (p) { // not ideal\n        return (this.x() === p.x()) && (this.y() === p.y()) && (this.z() === p.z()) && (this.t() === p.t())\n    }\n\n    // comparison \n\n    isGreaterThan (p) {\n        return this.x() > p.x() && this.y() > p.y()\n    }\n\n    isLessThan (p) {\n        return this.x() < p.x() && this.y() < p.y()\n    }\n\n    isGreaterThanOrEqualTo (p) {\n        return this.x() >= p.x() && this.y() >= p.y()\n    }\n\n    isLessThanOrEqualTo (p) {\n        return this.x() <= p.x() && this.y() <= p.y()\n    }\n\n    angleInRadians () {\n        return Math.atan2(y, x);\n    }\n\n    angleInDegrees () {\n        return this.angleInRadians() * 180 / Math.PI;\n    }\n\n    angleInRadiansTo (p) {\n        return p.subtract(this).angleInRadians()\n    }\n\n    angleInDegreesTo (p) {\n        return p.subtract(this).angleInDegrees()\n    }\n\n    midpointTo (p) {\n        return this.add(p).divideByScalar(2)\n    }\n\n    multiplyByScalar (v) {\n        const p = Point.clone()\n        p.set(this.x() * v, this.y() * v, this.z() * v)\n        return p\n    }\n\n    divideByScalar (v) {\n        return this.multiplyByScalar(1/v)\n    }\n\n    negated (p) {\n        return this.multiplyByScalar(-1)\n    }\n\n    // css\n\n    asCssStringWithUnitSuffix (name, unitSuffix) {\n        if (!unitSuffix) { \n            unitSuffix = \"\"\n        }\n\n        const us = unitSuffix;\n        return name + \"(\" + this._x + us + \",\" + this._y + us + \",\" + this._z + us + \")\"\n        //const s = this.valueArray().map(v => v + unitSuffix).join(\",\")\n        //return name + \"(\" + s + \")\"\n    }\n\n    asCssTranslate3dString () {\n        return this.asCssStringWithUnitSuffix(\"translate3d\", \"px\")\n    }\n\n    asCssRotate3dDegreesString () {\n        return this.asCssStringWithUnitSuffix(\"rotate3d\", \"deg\")\n    }\n\n    asCssScale3dString () {\n        return this.asCssStringWithUnitSuffix(\"scale3d\", \"\")\n    }\n\n    // size - TODO: move to Size type?\n\n    width () {\n        return this.x()\n    }\n\n    height () {\n        return this.y()\n    }\n    \n}.initThisClass());\n",
  "tW58Rk0VScLU1ZxuqhU0GAF4MC78EUkg0uuFmDNwwpc=": "\"use strict\";\n\n/*\n    Rectangle\n\n    Class to represent a rectangle.\n\n    NOTES\n\n    For top & bottom, we assume we are using screen coordinates so:\n\n        top = x\n    \n    and:\n\n        bottom = x + height\n\n*/\n\n(class Rectangle extends ProtoClass {\n    initPrototypeSlots () {\n        this.newSlot(\"origin\", null)\n        this.newSlot(\"size\", null)\n    }\n\n    init () {\n        super.init()\n        this.setOrigin(Point.clone())\n        this.setSize(Point.clone())\n        return this\n    }\n\n    duplicate () {\n        return this.thisClass().clone().copyFrom(this)\n    }\n\n    copyFrom (aRect) {\n        this.origin().copyFrom(aRect.origin())\n        this.size().copyFrom(aRect.size())\n        return this\n    }\n    \n    containsPoint (p) {\n        const a = p.isGreaterThanOrEqualTo(this.origin()) \n        const b = p.isLessThanOrEqualTo(this.maxPoint())\n        return a && b\n    }\n\n    containsRectangle (r) {\n        return r.origin().isGreaterThanOrEqualTo(this.origin()) && r.maxPoint().isLessThanOrEqualTo(this.maxPoint())\n    }\n\n    unionWith (r) {\n        const u = Rectangle.clone()\n        const o1 = this.origin()\n        const o2 = r.origin()\n        const m1 = this.maxPoint()\n        const m2 = r.maxPoint()\n        const minX = Math.min(o1.x(), o2.x())\n        const minY = Math.min(o1.y(), o2.y())\n        u.origin().setX(minX)\n        u.origin().setY(minY)\n        const maxX = Math.max(m1.x(), m2.x())\n        const maxY = Math.max(m1.y(), m2.y())\n        u.setWidth(maxX - minX)\n        u.setHeight(maxY - minY)\n        return u\n    }\n\n    maxPoint () {\n        return this.origin().add(this.size())\n    }\n\n    asString () {\n        return this.type() + \"(\" + this.origin().asString() + \", \" + this.size().asString() + \")\"\n    }\n\n    // x, y\n\n    x () {\n        return this.origin().x();\n    }\n\n    y () {\n        return this.origin().y();\n    }\n\n    minX () {\n        return this.x()\n    }\n\n    minY () {\n        return this.y()\n    }\n\n    maxX () {\n        return this.x() + this.width()\n    }\n\n    maxY () {\n        return this.y() + this.height()\n    }\n    \n    setMaxX (mx) {\n        const w = mx - this.x()\n        this.setWidth(w)\n        return this\n    }\n\n    setMaxY (my) {\n        const h = my - this.y()\n        this.setHeight(h)\n        return this\n    }\n\n    // width \n\n    setWidth (w) {\n        assert(w >= 0)\n        this.size().setX(w)\n        return this\n    }\n\n    width () {\n        return this.size().x();\n    }\n\n    // height\n\n    setHeight (h) {\n        assert(h >= 0)\n        this.size().setY(h)\n        return this\n    }\n\n    height () {\n        return this.size().y();\n    }\n\n    // top, bottom\n\n    top () {\n        return this.y() \n    }\n\n    bottom () {\n        return this.y() + this.height() \n    }\n\n    // left, right\n\n    left () {\n        return this.x() \n    }\n\n    right () {\n        return this.x() + this.width() \n    }\n\n    makeBoundsOfPoints (points) {\n        const firstPoint = points[0]\n        let minX = firstPoint.x()\n        let maxX = firstPoint.x()\n        let minY = firstPoint.y()\n        let maxY = firstPoint.y()\n        points.forEach(p => {\n            const x = p.x()\n            const y = p.y()\n\n            // faster than using Math.min/max\n            if (x < minX) {\n                minX = x\n            } else if (x > maxX) {\n                maxX = x \n            }\n\n            if (y < minY) {\n                minY = y \n            } else if (y > maxY) {\n                maxY = y\n            }\n        })\n        this.origin().setX(minX).setY(minY)\n        this.setMaxX(maxX)\n        this.setMaxY(maxY)\n        return this\n    }\n\n}.initThisClass());\n",
  "z9ztUqRJpFBDZ646C6lR6HamoANv02v98hwrsjAqAx0=": "\n\"use strict\";\n\n/*\n\n    DivTransform\n    \n*/\n\n(class Transform extends ProtoClass {\n    initPrototypeSlots () {\n        this.newSlot(\"position\", null).setComment(\"in px units\") \n        this.newSlot(\"rotation\", null).setComment(\"in degrees units\") \n        this.newSlot(\"scale\", null)\n    }\n\n    init () {\n        super.init()\n        this.setPosition(Point.clone())\n        this.setRotation(Point.clone())\n        this.setScale(Point.clone().setX(1).setY(1).setZ(1))\n        return this\n    }\n\n    // css\n\n    cssString () {\n        // NOTE: multiple transform one line directives are applied from right to left\n        const s = \n          this.scale().asCssScale3dString() + \" \" \n        + this.position().asCssTranslate3dString() + \" \" \n        + this.rotation().asCssRotate3dDegreesString(); // is this the expected order?\n        return s\n    }\n\n    // operations\n\n    copy () {\n        const t = Transform.clone()\n        t.position().copy(this.position())\n        t.rotation().copy(this.rotation())\n        t.scale().copy(this.scale())\n        return t\n    }\n\n\n    addInPlace (otherTransform) {\n        this.position().addInPlace(otherTransform.position())\n        this.rotation().addInPlace(otherTransform.rotation())\n        this.scale().addInPlace(otherTransform.scale())\n        return this\n    }\n\n    /*\n    add (aTransform) {\n        const t = this.copy()\n        t.position().addInPlace(aTransform.position())\n        t.rotation().addInPlace(aTransform.rotation())\n        t.scale().addInPlace(aTransform.scale())\n        return t\n    }\n\n\n    subtract (aTransform) {\n        const t = this.copy()\n        t.position().subtractInPlace(aTransform.position())\n        t.rotation().subtractInPlace(aTransform.rotation())\n        t.scale().subtractInPlace(aTransform.scale())\n        return t\n    }\n    */\n   \n}.initThisClass());",
  "5NKy2Va2fLxTQykOLBoBmzk9JUr/A4X4WTOHdInG6JI=": "\"use strict\";\n\n/*\n    \n    Event-cachedPoints\n\n*/\n\nif (!getGlobalThis().Event) {\n    console.log(\"WARNING: no Event object found - maybe we are not in browser?\")\n} else {\n    Object.defineSlots(Event.prototype, {\n        hasCachedPoints: function () {\n            return this._cachedPoints !== undefined\n        },\n\n        setCachedPoints: function (points) {\n            this._cachedPoints = points\n        },\n\n        cachedPoints: function () {\n            return this._cachedPoints\n        },\n        \n        pushCachedPoint: function (point) {\n            assert(this._cachedPoints)\n            this._cachedPoints.push(point)\n        }\n    })\n}\n\n",
  "Iu3Vfu+J0HCdGSjaHJEnZXkbfJOG3sptOfEwHKaukBU=": "\"use strict\";\n\n/*\n\n    EventPoint\n\n    Class to represent a 2d or 3d point, optionally with a time.\n\n    NOTES\n\n    Event's positions are set to the document (event.pageX, event.pageY) coordinates.\n    To get the viewport coordinates (event.clientX, event.clientY), \n    use the viewportPosition() method.\n\n*/\n\n(class EventPoint extends Point {\n    initPrototypeSlots () {\n        this.newSlot(\"id\", null)\n        this.newSlot(\"state\", null)\n        this.newSlot(\"target\", null)\n        this.newSlot(\"isDown\", false)\n        this.newSlot(\"overView\", null)\n        this.newSlot(\"event\", null)\n    }\n   \n    /*\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n    copyFrom (p, copyDict) {\n        super.copyFrom(p, copyDict)\n        this._id = p._id\n        this._state = p._state\n        this._target = p._target\n        return this\n    }\n\n    overView () {\n        if (this._overView === null) {\n            this._overView = this.findOverview()\n        }\n        return this._overView\n    }\n\n    findOverview () {\n        debugger;\n        // search up the dom elements until we find one \n        // associated with a DomView instance \n\n        let e = document.elementFromPoint(this.x(), this.y());\n\n\n        while (e) {\n            const view = e.domView()\n            if (view) {\n                return view\n            }\n            e = e.parentElement\n        }\n        return null\n    }\n\n    // viewport helpers\n\n    viewportPosition () {\n        const e = this.event()\n        const p = Point.clone().set(e.clientX, e.clientY)\n        return p\n    }\n\n    viewportHeight () {\n        return window.innerHeight\n    }\n\n    viewportWidth () {\n        return window.innerWidth\n    }\n\n    distFromTopOfViewport () {\n        return this.event().clientY\n    }\n\n    distFromBottomOfViewport () {\n        return this.viewportHeight() - this.distFromTopOfViewport()\n    }\n\n    distFromLeftOfViewport () {\n        return this.event().clientX\n    }\n\n    distFromRightOfViewport () {\n        return this.viewportWidth() - this.distFromLeftOfViewport()\n    }\n    \n}.initThisClass());\n",
  "lwOdzllL+jCVdc9pvCJ7aB/+Jp2GlD7i9CULbQPrMyU=": "\"use strict\";\n\n/*\n    Device\n\n*/\n\n(class Device extends ProtoClass {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n}.initThisClass());\n",
  "u6xWOdORC5y9oHSmwEwFhdd/YJtwneR+LRKLZeOrdqI=": "\"use strict\";\n\n/*\n    KeyboardKey\n\n\n*/\n\n(class KeyboardKey extends Device {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"isDown\", false)\n        this.newSlot(\"code\", null)\n        this.newSlot(\"name\", \"\")\n        this.newSlot(\"keyboard\", null)\n    }\n\n    init () {\n        super.init()\n        this.setIsDebugging(false)\n        return this\n    }\n\n    onKeyDown (event) {\n        //this.debugLog(() => this.name() + \" onKeyDown \" + event._id)\n        let shouldPropogate = true\n        this.setIsDown(true)\n        return shouldPropogate\n    }\n\n    onKeyUp (event) {\n        //this.debugLog(() => this.name() + \" onKeyUp \" + event._id)\n        let shouldPropogate = true\n        this.setIsDown(false)\n        return shouldPropogate\n    }\n\n    isUp () {\n        return !this.isDown()\n    }\n\n    isOnlyKeyDown () {\n        return this.isDown() && this.keyboard().currentlyDownKeys().length\n    }\n\n    isAlphabetical (event) {\n        const c = this.code()\n        return c >= 65 && c <= 90\n    }\n    \n}.initThisClass());",
  "7q8pgNyPXuLD4mmag6TvmTCjj+vBeE3Ev7TlUlZvo+o=": "\"use strict\";\n\n/*\n    Keyboard\n\n    Global shared instance that tracks current keyboard state.\n    Registers for capture key events on document.body.\n\n    MacOS/iOS note:\n\n        These Mac keys use different names in JS events:\n        CommandLeft -> MetaLeft\n        CommandRight -> MetaRight\n        Option/Alt -> Alternate\n        Control -> Control\n        Function -> [not seen by JS either as key event or modifier]\n\n    Browser Issues:\n\n        Key combinations intercepted by browser:\n\n            OSX:\n                meta-n (new window)\n                meta-m (minimize window)\n                meta-w (close window)\n                meta-t (new tab)\n\n                but we can intercept:\n                meta-o\n\n\n*/\n\n\n(class BMKeyboard extends Device {\n    initPrototypeSlots () {\n        this.newSlot(\"codeToKeys\", null).setComment(\"dictionary of KeyboardKey objects\")\n        this.newSlot(\"keyboardListener\", null)\n        this.newSlot(\"allModifierKeys\", null)\n    }\n\n    init () {\n        super.init()\n        this.setupCodeToKeys()\n        this.startListening()\n        this.setIsDebugging(false)\n        this.setAllModifierKeys(this.allModifierNames().map(kn => this.keyForName(kn)))\n        return this\n    }\n\n    startListening () {\n        const listener = KeyboardListener.clone().setUseCapture(true).setListenTarget(document.body).setDelegate(this)\n        this.setKeyboardListener(listener)\n        this.keyboardListener().setIsListening(true)\n        return this\n    }\n\n    setupCodeToKeys () {\n        const dict = {}\n        const c2k = this.keyCodesToNamesDict()\n        Object.keys(c2k).forEach((code) => {\n            const name = c2k[code]\n            dict[code] = KeyboardKey.clone().setName(name).setCode(code).setKeyboard(this)\n        })\n        this.setCodeToKeys(dict)\n        return this\n    }\n\n    keyForCode (aCode) {\n        return this.codeToKeys()[aCode]\n    }\n\n    keyForName (aName) {\n        const code = this.keyCodeForName(aName)\n        return this.keyForCode(code)\n    }\n\n    nameForKeyCode (aCode) {\n        const key = this.keyForCode(aCode)\n        if (key) {\n            return key.name()\n        }\n        return null\n    }\n\n    k2c () {\n        if (!this._k2c) {\n            this._k2c = {}\n            const c2k = this.keyCodesToNamesDict()\n            Object.keys(c2k).forEach((c) => {\n                const k = c2k[c]\n                this._k2c[k] = c\n            })\n        }\n        return this._k2c\n    }\n\n    keyCodeForName (aName) {\n        return this.k2c()[aName]\n    }\n\n    \n    eventIsJustModifierKey (event) {\n        const name = this.nameForKeyCode(event.keyCode)\n        return this.allModifierNames().contains(name)\n    }\n\n\n    keyCodesToNamesDict () {\n        return {\n            8: \"Backspace\",\n            9: \"Tab\",\n            13: \"Enter\",\n            16: \"Shift\",\n            17: \"Control\",\n            18: \"Alternate\",\n            19: \"PauseBreak\",\n            20: \"Capslock\",\n            27: \"Escape\",\n            32: \"Space\",\n            33: \"PageUp\",\n            34: \"PageDown\",\n            35: \"End\",\n            36: \"Home\",\n            37: \"LeftArrow\",\n            38: \"UpArrow\",\n            39: \"RightArrow\",\n            40: \"DownArrow\",\n            45: \"Insert\",\n            46: \"Delete\",\n            48: \"0\",\n            49: \"1\",\n            50: \"2\",\n            51: \"3\",\n            52: \"4\",\n            53: \"5\",\n            54: \"6\",\n            55: \"7\",\n            56: \"8\",\n            57: \"9\",\n            65: \"a\", // characters are the same code for upper and lower case in JS\n            66: \"b\",\n            67: \"c\",\n            68: \"d\",\n            69: \"e\",\n            70: \"f\",\n            71: \"g\",\n            72: \"h\",\n            73: \"i\",\n            74: \"j\",\n            75: \"k\",\n            76: \"l\",\n            77: \"m\",\n            78: \"n\",\n            79: \"o\",\n            80: \"p\",\n            81: \"q\",\n            82: \"r\",\n            83: \"s\",\n            84: \"t\",\n            85: \"u\",\n            86: \"v\",\n            87: \"w\",\n            88: \"x\",\n            89: \"y\",\n            90: \"z\",\n            91: \"MetaLeft\",\n            92: \"RightWindow\", // correct?\n            93: \"MetaRight\",\n            96: \"NumberPad0\",\n            97: \"NumberPad1\",\n            98: \"NumberPad2\",\n            99: \"NumberPad3\",\n            100: \"NumberPad4\",\n            101: \"NumberPad5\",\n            102: \"NumberPad6\",\n            103: \"NumberPad7\",\n            104: \"NumberPad8\",\n            105: \"NumberPad9\",\n            106: \"Multiply\",\n            107: \"Plus\",\n            109: \"Minus\",\n            110: \"DecimalPoint\",\n            111: \"Divide\",\n            112: \"Function1\",\n            113: \"Function2\",\n            114: \"Function3\",\n            115: \"Function4\",\n            116: \"Function5\",\n            117: \"Function6\",\n            118: \"Function7\",\n            119: \"Function8\",\n            120: \"Function9\",\n            121: \"Function10\",\n            122: \"Function11\",\n            123: \"Function12\",\n            144: \"NumberLock\",\n            145: \"ScrollLock\",\n            186: \"Semicolon\",\n            187: \"EqualsSign\",\n            188: \"Comma\",\n            189: \"Dash\",\n            190: \"Period\",\n            191: \"ForwardSlash\",\n            192: \"GraveAccent\",\n            219: \"OpenBracket\",\n            220: \"Backslash\",\n            221: \"CloseBracket\",\n            222: \"SingleQuote\",\n        }\n    }\n\n    /*\n    shiftChangingKeysDict () {\n        // Based on a Macbook Pro keyboard. \n        // Not sure if this is platform specific.\n\n        return {\n            \"\\`\": [\"Tilda\", \"~\"],\n            \"1\": [\"ExclaimationPoint\", \"!\"],\n            \"2\": [\"AtSymbol\", \"@\"],\n            \"3\": [\"Hash\", \"#\"],\n            \"4\": [\"DollarSign\", \"$\"],\n            \"5\": [\"Percent\", \"%\"],\n            \"6\": [\"Carot\"],\n            \"7\": [\"Ampersand\", \"&\"],\n            \"8\": [\"Asterisk\", \"*\"],\n            \"9\": [\"OpenParenthesis\", \"(\"],\n            \"0\": [\"CloseParenthesis\", \")\"],\n            \"-\": [\"Underscore\", \"_\"],\n            \"=\": [\"Plus\", \"+\"],\n            \"[\": [\"OpenCurlyBracket\", \"{\"],\n            \"]\": [\"CloseCurlyBracket\", \"}\"],\n            \"\\\\\": [\"Pipe\", \"|\"],\n            \";\": [\"Colon\", \":\"],\n            \"'\": [\"DoubleQuote\", \"\\\"\"],\n            \",\": [\"LessThan\", \"<\"],\n            \".\": [\"GreaterThan\", \">\"],\n            \"/\": [\"QuestionMark\", \"?\"],\n        }\n    }\n    */\n\n    shiftDict () {\n        // Based on a Macbook Pro keyboard. \n        // Not sure if this is platform specific.\n\n        return {\n            \"~\": \"Tilda\",\n            \"!\": \"ExclaimationPoint\",\n            \"@\": \"AtSymbol\",\n            \"#\": \"Hash\",\n            \"$\": \"DollarSign\",\n            \"%\": \"Percent\",\n            \"^\": \"Carot\",\n            \"&\": \"Ampersand\",\n            \"*\": \"Asterisk\",\n            \"(\": \"OpenParenthesis\",\n            \")\": \"CloseParenthesis\",\n            \"_\": \"Underscore\",\n            \"+\": \"Plus\",\n            \"{\": \"OpenCurlyBracket\",\n            \"}\": \"CloseCurlyBracket\",\n            \"|\": \"Pipe\",\n            \":\": \"Colon\",\n            \"\\\\\": \"DoubleQuote\",\n            \"<\": \"LessThan\",\n            \">\": \"GreaterThan\",\n            \"?\": \"QuestionMark\",\n        }\n    }\n\n    /*\n    specialKeyCodes () { \n        return {\n            8:  \"delete\", // \"delete\" on Apple keyboard\n            9:  \"tab\", \n            13: \"enter\", \n            16: \"shift\", \n            17: \"control\", \n            18: \"alt\", \n            20: \"capsLock\", \n            27: \"escape\", \n            33: \"pageUp\", \n            34: \"pageDown\", \n            37: \"leftArrow\",  \n            38: \"upArrow\",  \n            39: \"rightArrow\", \n            40: \"downArrow\",  \n            46: \"delete\", \n\n        }\n    }\n    */\n\n    keyForCode (aCode) {\n        return this.codeToKeys()[aCode]\n    }\n\n    // -- events ---\n\n    showCodeToKeys () {\n        const c2k = this.keyCodesToNamesDict()\n\n        //const s = JSON.stringify(c2k, null, 4)\n\n        const lines = Object.keys(c2k).map((code) => {\n            return \"    \" + code + \": \\\"\" + this.codeToKeys()[code].name() + \"\\\"\"\n        })\n        const s = \"{\\n\" + lines.join(\",\\n\") + \"}\\n\"\n        console.log(\"c2k:\", s)\n\n        /*\n        console.log(\"Keyboard:\")\n        Object.keys(this.codeToKeys()).forEach((code) => {\n            console.log(\"  code: \", code + \" key name: \", this.codeToKeys()[code].name())\n        })\n        */\n        return this\n    }\n\n    keyForEvent (event) {\n        const code = event.keyCode\n        const key = this.codeToKeys()[code]\n        return key\n    }\n\n    onKeyDownCapture (event) {\n        //console.log(\"event.metaKey = \", event.metaKey)\n        \n        const shouldPropogate = true\n        const key = this.keyForEvent(event)\n\n        if (key) {\n            key.onKeyDown(event)\n\n            if (this.isDebugging()) {\n                this.debugLog(\" \" + this.downMethodNameForEvent(event))\n            }\n        } else {\n            console.warn(\"BMKeyboard.shared() no key found for event \", event)\n        }\n            \n        return shouldPropogate\n    }\n\n    onKeyUpCapture (event) {\n        const shouldPropogate = true\n        const key = this.keyForEvent(event)\n        if (!key) {\n            console.log(\"]]]]]]]]]]] WARNING: missing key for event: \", event)\n            return\n        }\n        key.onKeyUp(event)\n\n        if (this.isDebugging()) {\n            this.debugLog(\" \" + this.upMethodNameForEvent(event))\n            //this.debugLog(\".onKeyUpCapture \" + key.name() + \" -> \" + this.modsAndKeyNameForEvent(event) + \"KeyUp\")\n        }\n\n        return shouldPropogate\n    }\n    \n    // --- event handling method names ---\n\n    downMethodNameForEvent (event) {\n        return \"on\" + this.modsAndKeyNameForEvent(event) + \"KeyDown\"\n    }\n\n    upMethodNameForEvent (event) {\n        return \"on\" + this.modsAndKeyNameForEvent(event) + \"KeyUp\"\n    }\n\n    eventIsAlphabetical (event) {\n        const c = event.keyCode\n        return c >= 65 && c <= 90\n    }\n\n    modsAndKeyNameForEvent (event) {\n        // examples: AltB AltShiftB\n        // Note that shift is explicit and the B key is always uppercase\n\n        if (Type.isUndefined(event.keyCode)) {\n            return \"\"\n        }\n        \n        const key = this.keyForCode(event.keyCode)\n        const isJustModifier = this.eventIsJustModifierKey(event)\n        const modifiers = this.modifierNamesForEvent(event)\n        const isAlpabetical = this.eventIsAlphabetical(event)\n        let keyName = key ? key.name() : event.code\n\n        \n        if (isJustModifier) {\n            return keyName\n        }\n\n        if (event.shiftKey) {\n            // Note: if another modifier besides the shift key is down, \n            // the non-shift version of event.key is use e.g.\n            // shift-equals is \"Plus\"\n            // control-shift-equals is \"ControlShiftEquals\"\n            // this follows the Javascript event.key convention\n\n            const shiftName = this.shiftDict()[event.key]\n            if (shiftName) {\n                keyName = shiftName\n            }\n        }\n\n        if (isAlpabetical) {\n            keyName = \"_\" + keyName + \"_\"\n            if (event.shiftKey) {\n                keyName = keyName.capitalized()\n                modifiers.remove(\"Shift\")\n            }\n        }\n\n        return modifiers.join(\"\") + keyName\n    }\n\n    // --- special ---\n\n    // get key helpers\n\n    shiftKey () {\n        return this.keyForName(\"Shift\")\n    }\n\n    controlKey () {\n        return this.keyForName(\"Control\")\n    }\n\n    alternateKey () {\n        return this.keyForName(\"Alternate\")\n    }\n\n    leftCommandKey () {\n        return this.keyForName(\"MetaLeft\")\n    }\n\n    rightCommandKey () {\n        return this.keyForName(\"MetaRight\")\n    }\n\n    // get key state helpers\n\n    shiftIsDown () {\n        return this.shiftKey().isDown()\n    }\n\n    commandIsDown () {\n        return this.leftCommandKey().isDown() || this.rightCommandKey().isDown()\n    }\n\n\n    equalsSignKey () {\n        return this.keyForName(\"EqualsSign\")\n    }\n\n    minusKey () {\n        return this.keyForName(\"Dash\")\n    }\n\n    plusKey () {\n        return this.keyForName(\"Plus\")\n    }\n\n    plusIsDown () {\n        return this.plusKey().isDown()\n    }\n\n    currentlyDownKeys () {\n        return Object.values(this.codeToKeys()).select(key => key.isDown())\n    }\n\n    currentlyUpKeys () {\n        return Object.values(this.codeToKeys()).select(key => !key.isDown())\n    }\n\n    hasKeysDown () {\n        return this.currentlyDownKeys().length !== 0\n    }\n\n    downKeyNames () {\n        return BMKeyboard.shared().currentlyDownKeys().map(k => k.name())\n    }\n\n    show () {\n        this.debugLog(\" downKeys: \", this.downKeyNames())\n    }\n\n    allModifierNames () {\n        return [\n            \"Alternate\", \n            \"Control\", \n            \"Meta\",\n            \"MetaLeft\", \n            \"MetaRight\", \n            \"Shift\", \n        ]\n    }\n\n    modifierNamesForEvent (event) {\n        let modifierNames = []\n\n        // event names are ordered alphabetically to avoid ambiguity\n\n        if (event.altKey) {\n            modifierNames.push(\"Alternate\")\n        } \n        \n        if (event.ctrlKey) {\n            modifierNames.push(\"Control\")\n        }\n        \n        if (event.metaKey) {\n            const n = event.location\n\n            //console.log(\"event.location = \", event.location)\n\n            if (n === 1) {\n                modifierNames.push(\"MetaLeft\")\n            } else if (n === 2) {\n                modifierNames.push(\"MetaRight\")\n            } else {\n                modifierNames.push(\"Meta\")\n            }\n        } \n        \n        if (event.shiftKey) {\n            modifierNames.push(\"Shift\")\n        }\n\n        return modifierNames\n    }\n\n    showEvent (event) {\n        const kb = BMKeyboard.shared()\n        console.log(\"---\")\n        console.log(\"BMKeyboard.showEvent():\")\n        console.log(\"  code: \", event.keyCode)\n        console.log(\"  name: \", kb.nameForKeyCode(event.keyCode))\n        console.log(\"  is modifier: \", kb.eventIsJustModifierKey(event))\n        console.log(\"  modifierNames: \", kb.modifierNamesForEvent(event))\n        console.log(\"  modsAndKeyName: \", kb.modsAndKeyNameForEvent(event))\n        console.log(\"---\")\n    }\n    \n}.initThisClass());\n",
  "5eEFUdOJfSL2Y8jIxX+WgG2vMoDz/7kxzgdBEmt3K3Y=": "\"use strict\";\n\n/*\n\n    Mouse\n\n    Global shared instance that tracks current mouse state in window coordinates.\n    Registers for capture mouse events on document.body.\n\n    NOTES\n\n    Doesn't deal with multi-button mouse input yet.\n    Not sure how multi-button mouse should be handled if we want code \n    to be Mac, touch pad, and touch screen compatible.\n\n*/\n\n(class Mouse extends Device {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"isDown\", false)\n        this.newSlot(\"downEvent\", null)\n        this.newSlot(\"currentEvent\", null)\n        this.newSlot(\"upEvent\", null)\n        this.newSlot(\"mouseListener\", null)\n        this.newSlot(\"mouseMoveListener\", null)\n    }\n\n    init () {\n        super.init()\n        this.startListening()\n        return this\n    }\n\n    /*\n    setCurrentEvent (event) {\n        this._currentEvent = event\n        //Devices.shared().setCurrentEvent(event)\n        return this\n    }\n    */\n\n    startListening () {\n        this.setMouseListener(MouseListener.clone().setUseCapture(true).setListenTarget(document.body).setDelegate(this))\n        this.mouseListener().setIsListening(true)\n\n        this.setMouseMoveListener(MouseMoveListener.clone().setUseCapture(true).setListenTarget(document.body).setDelegate(this))\n        this.mouseMoveListener().setIsListening(true)\n        return this\n    }\n\n    // positions\n\n    downPos () {\n        return this.pointForEvent(this.downEvent())\n    }\n\n    currentPos () {\n        return this.pointForEvent(this.currentEvent())\n    }\n\n    upPos () {\n        return this.pointForEvent(this.upEvent())\n    }\n\n    // --- events --- follow down, up, and move events\n\n    onMouseDownCapture (event) {\n        this.setDownEvent(event)\n        this.setCurrentEvent(event)\n        this.setIsDown(true);\n        return true\n    }\n\n    onMouseMoveCapture (event) {\n        this.setCurrentEvent(event)\n        return true\n    }\n\n    onMouseUpCapture (event) {\n        this.setCurrentEvent(event)\n        this.setUpEvent(event)\n        this.setIsDown(false);\n        return true\n    }  \n\n    // -- helpers ---\n\n    pointForEvent (event) {\n        assert(event.__proto__.constructor === MouseEvent)\n\n        const p = EventPoint.clone()\n        p.set(event.pageX, event.pageY) // document position\n        p.setTarget(event.target)\n        p.setTimeToNow()\n        p.setId(\"mouse\")\n        p.setState(event.buttons)\n        p.setIsDown(event.buttons !== 0)\n        p.setEvent(event)\n        //p.findOverview()\n\n        return p\n    }\n\n    dragVector (event) {   \n        if (this.downPos()) {\n            return this.currentPos().subtract(this.downPos())\n        }\n        /*  \n        if (this.isDown()) {\n            return this.currentPos().subtract(this.downPos())\n        }\n        */\n        return Point.clone()\n    }\n\n    pointsForEvent (event) {\n        if (!event.hasCachedPoints()) {\n            const points = [this.pointForEvent(event)]\n            event.setCachedPoints(points)\n        }\n\n        return event.cachedPoints()\n    }\n\n    currentPoints () {\n        if (this.currentEvent()) {\n            return this.pointsForEvent(this.currentEvent())\n        }\n        return []\n    }\n\n    // full event name\n\n    downMethodNameForEvent (event) {\n        const s = BMKeyboard.shared().modsAndKeyNameForEvent(event)\n        return \"on\" + s + \"MouseDown\"\n    }\n\n    upMethodNameForEvent (event) {\n        const s = BMKeyboard.shared().modsAndKeyNameForEvent(event)\n        return \"on\" + s + \"MouseUp\"\n    }\n    \n}.initThisClass());\n",
  "9a33fBBYsIgJnfNSIMhEPfhe4rAiXHzvcnX+6AY92z4=": "\"use strict\";\n\n/*\n\n    TouchScreen\n\n    Global shared instance that tracks current touch state in window coordinates.\n    Registers for capture events on document.body.\n\n    Example use:\n\n        const hasTouch = TouchScreen.shared().isSupported()\n\n*/\n\n(class TouchScreen extends Device {\n\n    initPrototypeSlots () {\n        this.newSlot(\"currentEvent\", null)\n        this.newSlot(\"lastEvent\", null)\n        this.newSlot(\"touchListener\", null)\n        this.newSlot(\"isSupported\", null)\n        //this.newSlot(\"isVisualDebugging\", false)\n    }\n\n    isSupported () {\n        if (this._isSupported === null) {\n            this._isSupported = this.calcIsSupported()\n        }\n        return this._isSupported\n    }\n\n    calcIsSupported () {\n        // return WebBrowserWindow.isTouchDevice()\n        let result = false \n        if (\"ontouchstart\" in window) { \n            result = true; \n        } // works on most browsers \n        if (navigator.maxTouchPoints) { r\n            esult = true; \n        } // works on IE10/11 and Surface\t\n        return result\n    }\n\n    init () {\n        super.init()\n        this.startListening()\n        this.setIsDebugging(false)\n        if (this.isDebugging()) {\n            this.debugLog(\".init()\")\n        }\n        return this\n    }\n\n    setCurrentEvent (event) {\n        if (this._currentEvent !== event) {\n            this.setLastEvent(this._currentEvent)\n            this._currentEvent = event\n            if (this.isDebugging()) {\n                console.log(this.type() + \" touch count: \" + this.currentPoints().length)\n            }\n            //Devices.shared().setCurrentEvent(event)\n        }\n        return this\n    }\n\n    startListening () {\n        this.setTouchListener(TouchListener.clone().setUseCapture(true).setListenTarget(document.body).setDelegate(this))\n        this.touchListener().setIsListening(true)\n        return this\n    }\n\n    // events\n\n    onTouchBeginCapture (event) {\n        if (this.isDebugging()) {\n            console.log(this.type() + \".onTouchBeginCapture()\")\n        }\n        this.setCurrentEvent(event)\n        //this.handleLeave(event)\n        return true\n    }\n\n    /*\n    elementsForEvent (event) {\n        const elements = [];\n        const points = this.pointsForEvent(event)\n        points.forEach((point) => {\n            const e = document.elementFromPoint(p.x(), p.y());\n            if (e) {\n                elements.push(e)\n            }\n        })\n        return elements\n    }\n    */\n\n    lastPointForId (id) {\n        const lastPoints = this.pointsForEvent(this.lastEvent())\n        return lastPoints.detect(p => p.id() === id)\n    }\n\n    currentPointForId (id) {\n        const currentPoints = this.pointsForEvent(this.currentEvent())\n        return currentPoints.detect(p => p.id() === id)\n    }\n\n    onTouchMoveCapture (event) {\n        this.setCurrentEvent(event)\n        //this.handleLeave(event)\n        return true\n    }\n\n    onTouchEndCapture (event) {\n        this.setCurrentEvent(event)\n        //this.handleLeave(event)\n        return true\n    }\n\n    pointForTouch (touch) {\n        assert(event.__proto__.constructor === TouchEvent)\n        const p = EventPoint.clone()\n        p.setId(touch.identifier)\n        p.setTarget(touch.target)\n        p.set(touch.pageX, touch.pageY)  // document position\n        p.setTimeToNow()\n        p.setIsDown(true)\n        p.setEvent(touch)\n        //p.findOverview()\n        return p\n    }\n\n    justPointsForEvent (event) {\n        //if (this.isDebugging()) {\n        //  console.log(\"touches.length = \", event.touches.length)\n        //}\n\n        const points = []\n        // event.touches isn't a proper array, so we can't enumerate it normally\n        const touches = event.touches // all current touches\n        for (let i = 0; i < touches.length; i++) {\n            const touch = touches[i]\n            const p = this.pointForTouch(touch)\n            points.append(p)\n        }\n\n        return points\n    }\n\n\n    pointsForEvent (event) {\n        if (!event.hasCachedPoints()) {\n            event.preventDefault() // needed to prevent browser from handling touches?\n\n            const points = this.justPointsForEvent(event)\n            event.setCachedPoints(points)\n        }\n\n        return event.cachedPoints(event)\n    }\n\n    currentPoints () {\n        if (this.currentEvent()) {\n            return this.pointsForEvent(this.currentEvent())\n        }\n        return []\n    }\n\n    // There are no standard onTouchLeave & onTouchOver events,\n    // so this is an attempt to add them. Only really need them\n    // for visual gesture debugging at the moment though.\n    \n    /*\n    sendEventToView (eventName, event, aView) {\n        // send to listeners instead?\n        aView.gestureRecognizers().forEach((gr) => {\n            gr[eventName].call(gr, event)\n        })\n        return this\n    }\n\n    handleLeave (event) {\n        // an attempt to add onTouchLeave and onTouchOver events\n        const currentPoints = this.pointsForEvent(this.currentEvent())\n\n        currentPoints.forEach((cp) => {\n            const lp = this.lastPointForId(cp.id())\n            if (lp) {\n                const lastView    = lp.overview()\n                const currentView = cp.overview()\n\n                // check if overView is the same\n                if (lastView !== currentView) {\n                    this.sendEventToView(\"onTouchLeave\", event, lastView)\n                    this.sendEventToView(\"onTouchOver\", event, currentView)\n                }\n            } else {\n                // this is a new finger\n            }\n        })\n\n        return this\n    }\n    */\n   \n}.initThisClass());\n",
  "7GvhmwbZJCwIEpXAirtGEup+NkfuZC+QfnPaFnVib34=": "\"use strict\";\n\n/*\n    GamePadManager\n\n    - checks if gamepad API is supported\n    - polls navigator gamepads state\n    - creates and removes GamePad instances to match current state\n    - can send notification of state changes for each GamePad\n\n    Since Chrome doesn't support gamePadListener, I'm just implementing\n    it to work without it, though this requires polling for game pad connected.\n\n    Example use:\n\n    // check for game pad support\n    const isSupported = GamePadManager.shared().isSupported()\n    \n    // start monitoring gamepads\n    GamePadManager.shared().startPolling()\n\n    // get array of connected game pads\n    const pads = GamePadManager.shared().connectedGamePads()\n\n    // each pad will have a unique id to identiy it\n    pads.forEach( (pad) => { \n        console.log(\"pad id:\", pad.id()) \n    })\n\n*/\n\n(class GamePadManager extends ProtoClass {\n    \n    initPrototypeSlots () {\n        //this.newSlot(\"gamePadListener\", null)\n        this.newSlot(\"gamePadsDict\", null)\n        this.newSlot(\"pollPeriod\", 1000).setComment(\"milliseconds\")\n    }\n\n    init () {\n        super.init()\n        this.setIsDebugging(false)\n        this.setGamePadsDict({})\n        //this.startListening()\n        this.startPollingIfSupported() // could delay this until connection if listen API is supported\n        return this\n    }\n\n    connectedGamePads () {\n        const dict = this.gamePadsDict()\n        return Object.keys(dict).map(k => dict[k])\n    }\n    \n    /*\n    canListenForConnect () {\n        return (\"ongamepadconnected\" in window); \n    }\n\n    startListening () {\n        if (this.canListenForConnect()) {\n            this.setGamePadListener(GamePadListener.clone().setUseCapture(true).setListenTarget(window).setDelegate(this))\n            this.gamePadListener().setIsListening(true)\n        }\n        return this\n    }\n    \n    // listener events\n\n    \n    onGamePadConnected (event) {\n        this.poll()\n        return true\n    }\n\n    onGamePadDisconnected (event) {\n        this.poll()\n        return true\n    }\n    */\n\n    startPollingIfSupported () {\n        if (this.isSupported()) {\n            this.startPolling()\n        }\n    }\n\n    isSupported () {\n        return this.navigatorGamepads() !== null\n    }\n\n    navigatorGamepads () {\n        if (navigator.getGamepads) {\n            return navigator.getGamepads()\n        } \n        \n        if (navigator.webkitGetGamepads) {\n            return navigator.webkitGetGamepads;\n        }\n\n        return null\n    }\n\n    startPolling () {\n        if (!this._intervalId) {\n            console.log(this.type() + \".startPolling()\")\n            this._intervalId = setInterval(() => { \n                this.poll() \n            }, this.pollPeriod());\n        }\n    }\n\n    stopPolling () {\n        if (this.intervalId()) {\n            clearInterval(this.intervalId());\n            this.setIntervalId(null)\n        }\n    }\n\n    newGamePad (index) {\n        return GamePad.clone().setGamePadManager(this)\n    }\n\n    poll () {\n        const gamepads = this.navigatorGamepads()\n        //console.log(this.type() + \".poll() gamepads.length = \", gamepads.length)\n        const padDict = this.gamePadsDict()\n\n        for (let i = 0; i < gamepads.length; i++) {\n            const gp = gamepads[i];\n            let gamePad = padDict[i]\n\n            if (gp) {\n                if (!gamePad) {\n                    gamePad = this.newGamePad().setIndex(i).setId(gp.id)\n                    gamePad.onConnected()\n                    this.gamePadsDict().atPut(i, gamePad)\n                }\n                gamePad.updateData(gp)\n\n                if (this.isDebugging()) {\n                    console.log(\"Gamepad index:\" + gp.index + \" id:\" + gp.id + \n                    \". buttonCount:\" + gp.buttons.length + \" axisCount:\" + gp.axes.length);\n                }\n            } else {\n                if (gamePad) {\n                    gamePad.onDisconnected()\n                    padDict.atPut(i, null)\n                }\n            }\n        }\n    }\n\n}.initThisClass());",
  "O7AGCSUop/XBCnRpsVUVspCz697iERI9iLlQBUgy9JI=": "\"use strict\";\n\n/*\n    GamePad\n\n    A single GamePad with a unique id.\n\n*/\n\n(class GamePad extends Device {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"gamePadManager\", null)\n        this.newSlot(\"index\", null)\n        this.newSlot(\"id\", null)\n        this.newSlot(\"timestamp\", null)\n        this.newSlot(\"buttons\", null)\n        this.newSlot(\"axes\", null)\n        this.newSlot(\"isConnected\", false)\n        this.newSlot(\"shouldSendNotes\", false)\n    }\n\n    init () {\n        super.init()\n        this.setButtons([])\n        this.setAxes([])\n        this.setIsDebugging(false)\n        return this\n    }\n\n    updateData (gp) {\n        assert(gp.id() === this.id()) // quick sanity check\n\n        if (gp.timestamp !== this.timestamp()) {\n            this.setTimestamp(gp.timestamp)\n            this.updateButtons(gp.buttons)\n            this.updateAxes(gp.axes)\n        }\n    }\n\n    // buttons\n\n    updateButtons (newButtons) {\n        // make sure number of buttons is correct\n        const currentButtons = this.buttons()\n        while (currentButtons.length < newButtons.length) {\n            currentButtons.push(0)\n        }\n\n        if (this.shouldSendNotes()) {\n            // check for differences\n            for (let i = 0; i < newButtons.length; i ++) {\n                if (currentButtons.at(i) !== newButtons.at(i)) {\n                    currentButtons.atPut(i, newButtons.at(i))\n                    this.changedButtonIndexTo(i, newButtons.at(i))\n                }\n            }\n        } else {\n            this.setButtons(newButtons.shallowCopy())\n        }\n\n        return this\n    }\n\n    changedButtonIndexTo (index, isDown) {\n        const note = BMNotificationCenter.shared().newNote().setSender(this)\n        note.setName(\"onGamePadButton\" + index + (isDown ? \"Down\" : \"Up\")) // TODO: optimize\n        note.setInfo(isDown)\n        note.post()\n        return this\n    }\n\n    // axes\n\n    updateAxes (newAxes) {\n        // make sure number of buttons is correct\n        const currentAxes = this.axes()\n        while (currentAxes.length < newAxes.length) {\n            currentAxes.push(0)\n        }\n\n        if (this.shouldSendNotes()) {\n            // check for differences\n            for (let i = 0; i < newAxes.length; i ++) {\n                if (currentAxes.at(i) !== newAxes.at(i)) {\n                    currentAxes.atPut(i, newAxes.at(i))\n                    this.changedAxesIndexTo(i, newAxes[i])\n                }\n            }\n        } else {\n            this.setAxes(newAxes.copy())\n        }\n\n        return this\n    }\n\n    changedAxesIndexTo (index, value) {\n        const note = BMNotificationCenter.shared().newNote().setSender(this)\n        note.setName(\"onGamePadAxis\" + index + \"Changed\") // TODO: optimize?\n        note.setInfo(value)\n        note.post()\n        return this\n    }\n\n    // connecting\n\n    onConnected () {\n        this.setIsConnected(true)\n        const note = BMNotificationCenter.shared().newNote().setSender(this)\n        note.setName(\"onGamePadConnected\")\n        note.post()\n        return this\n    }\n\n    onDisconnected () {\n        this.setIsConnected(false)\n        const note = BMNotificationCenter.shared().newNote().setSender(this)\n        note.setName(\"onGamePadDisconnected\")\n        note.post()\n        return this\n    }\n\n}.initThisClass());\n",
  "EKOaU/9AQp3PxyrmwF6xDNmUDPtl6HGDhEAhpeDsMZo=": "\"use strict\";\n\n/*\n    Devices\n\n    Right now, this just sets up the standard devices. \n    Later, we can using it for \n        - discovering\n        - organizing\n        - inspecting\n        - managing\n        - globally intercepting & recording input for debugging or playback\n        etc.\n\n*/\n\n(class Devices extends ProtoClass {\n    \n    initPrototypeSlots () {\n        //this.newSlot(\"gamePadListener\", null)\n        this.newSlot(\"keyboard\", null)\n        this.newSlot(\"mouse\", null)\n        this.newSlot(\"touchScreen\", null)\n        this.newSlot(\"gamePadManager\", null)\n        this.newSlot(\"isSetup\", false)\n    }\n\n    init () {\n        super.init()\n        this.setupIfNeeded() \n        return this\n    }\n\n    setupIfNeeded () {\n        if (!this.isSetup()) {\n            Mouse.shared()\n            BMKeyboard.shared()\n            TouchScreen.shared()\n            //GamePadManager.shared()\n            this.setIsSetup(true)\n        }\n        return this\n    }\n\n    currentTouchOrMouseEvent () {\n        // needed?\n        const me = Mouse.shared().currentEvent()\n        const te = TouchScreen.shared().currentEvent()\n        const es = [me, te]\n        es.filter(e => !TypeError.isNullOrUndefined(e))\n        return es.min(e => e.timeStamp)\n    }\n    \n}.initThisClass());\n",
  "I2ZcI0ePmbjkGsTZ0Yc7CdufCgeOP7+NKaoGP/Vvcbg=": "\"use strict\";\n\n/*\n    EventManager\n\n    A singleton to manager tracking all events including:\n    \n        - user events\n        - timers\n        - other events (indexed db, etc) - eventually\n\n    We need this in other to:\n    \n        - do sync operators at the end of an event callback.\n\n        - track the first user initiated event in order to wait \n          to request things like audio input or audio output access\n\n    Example use:\n\n            EventManager.shared().safeWrapEvent(() => { ... })\n\n*/\n\n(class EventManager extends ProtoClass {\n\n    initPrototypeSlots () {\n        this.newSlot(\"eventLevelCount\", 0)\n        this.newSlot(\"hasReceivedUserEvent\", false) // we only care about this for user events, but event manager handles timeouts too\n    }\n\n    onReceivedUserEvent () { // sent by event listeners if event is user interaction (like click) that browser waits for to enable things like audio/video use\n        if (!this.hasReceivedUserEvent()) {\n            // In normal web use, things like WebAudio context can't be created until \n            // we get first user interaction. So we send this event to let listeners know when\n            // those APIs can be used. Would help if JS sent a special event for this.\n            this.setHasReceivedUserEvent(true)\n            Broadcaster.shared().broadcastNameAndArgument(\"firstUserEvent\", this) // need this for some JS APIs which can only be used after first input event\n        }\n        \n        return this\n    }\n\n    setEventLevelCount (n) {\n        assert(n > -1)\n        this._eventLevelCount = n\n        return this\n    }\n\n    incrementEventLevelCount () {\n        const count = this.eventLevelCount()\n        this.setEventLevelCount(count + 1)\n        //console.warn(\"<\".repeat(count) + \" incremented event \" + count)\n        return this\n    }\n\n    decrementEventLevelCount () {\n        const count = this.eventLevelCount()\n        //let stack = new Error().stack\n        //console.warn(\"<\".repeat(count) + \" decrementing event \" + count)\n        this.setEventLevelCount(count - 1)\n        return this\n    }\n    \n    /*\n    safeWrapEvent (callback) {\n        let result = undefined\n        this.incrementEventLevelCount()\n        try {\n            result = callback()\n            this.decrementEventLevelCount()\n        } catch (anError) {\n            console.error(anError.stack);\n            this.decrementEventLevelCount()\n            throw anError\n        } //finally {\n        //    this.decrementEventLevelCount()\n        //}\n        this.syncIfAppropriate() \n        return result\n    }\n    */\n\n    safeWrapEvent (callback) {\n        //ThrashDetector.shared().beginFrame()\n        //Perf.shared().beginFrame()\n        let result = undefined\n        let eventCountBefore = this.eventLevelCount()\n        this.incrementEventLevelCount()\n        result = callback()\n        this.decrementEventLevelCount()\n        assert(this.eventLevelCount() === eventCountBefore)\n        this.syncIfAppropriate() // TODO: is this the best spot?\n        //Perf.shared().endFrame()\n        //ThrashDetector.shared().endFrame()\n        return result\n    }\n\n    syncIfAppropriate () {\n        if (getGlobalThis().SyncScheduler) {\n            /*\n                run scheduled events here to ensure that a UI event won't occur\n                before sync as that could leave the node and view out of sync\n                e.g. \n                - edit view #1\n                - sync to node\n                - node posts didUpdateNode\n                - edit view #2\n                - view get didUpdateNode and does syncFromNode which overwrites view state #2\n            */\n\n            /*\n            if (SyncScheduler.shared().actionCount()) {\n                this.debugLog(\" onAfterEvent \" + methodName)\n            }\n            */\n           //assert(EventManager.shared().eventLevelCount() > 0)\n           if (EventManager.shared().eventLevelCount() === 0) { \n                // we check event level count to ensure that we only \n                // sync when the stack fully unwinds back to the event loop.\n                // This is not the case for some events like onblur which can be triggered by\n                // removing a DOM element from a parent, and start an event callback before the\n                // current event stack has unwound.\n                //console.log(\"--->>> fullSyncNow <<<---\")\n                SyncScheduler.shared().fullSyncNow()\n           }\n        }\n        return this\n    }\n\n}.initThisClass());\n",
  "HpiwMmf4MrrXTaaRwEz3HlBNEHY3KQc3k81IBc+DzUI=": "\"use strict\";\n\n/*\n    EventListener\n\n    Listener for single event. Should only be used by EventSetListener class.\n\n    For full list of events, see:\n\n    https://developer.mozilla.org/en-US/docs/Web/Events\n\n*/\n\nlet listenCount = 0;\n\n(class EventListener extends ProtoClass {\n\n    static initClass () {\n        this.newClassSlot(\"activeListeners\", new Set()) // tmp debugging\n    }\n\n    static activeListenersForOwner (owner) { // tmp debugging\n        return this.activeListeners().filter(v => v.owner() === owner)\n    }\n\n    static activeOwners () { // tmp debugging\n        const owners = new Set()\n        this.activeListeners().forEach(v => owners.add(v.owner()))\n        return owners\n    }\n\n    static showActive () { // tmp debugging\n        const owners = this.activeOwners()\n        console.log(\"--- EventListener \" + owners.size + \" active owners ---\")\n        /*\n        owners.forEach((owner) => {\n            const listeners = this.activeListenersForOwner(owner)\n\n            console.log(\"  \" + owner.typeId() + \": \" + listeners.length)\n            //this.showActiveForOwner(owner)\n        })\n        */\n        console.log(\"-------------------------------------\")\n    }\n\n    static showActiveForOwner (owner) { // tmp debugging\n        const listeners = this.activeListenersForOwner(owner)\n        listeners.forEach(listener => {\n            console.log(\"    \" + listener.delegate().typeId() + \" \" + listener.fullMethodName())\n        })\n    }\n\n    initPrototypeSlots () {\n        //this.newSlot(\"listenerSet\", null) // possible owner\n\n        this.newSlot(\"listenTarget\", null)\n        this.newSlot(\"delegate\", null)\n        this.newSlot(\"isListening\", false)\n\n        this.newSlot(\"eventName\", null)\n        this.newSlot(\"methodName\", null)\n        this.newSlot(\"fullMethodName\", null) // calculated when methodName is set, and cached in ivar\n        this.newSlot(\"handlerFunc\", null)\n        this.newSlot(\"isUserInteraction\", null) // set to match eventName\n        this.newSlot(\"useCapture\", false).setComment(\"whether event will be dispatched to listener before EventTarget beneath it in DOM tree\")\n        this.newSlot(\"methodSuffix\", \"\")\n    }\n\n    init () {\n        super.init()\n        this.setHandlerFunc(event => this.safeHandleEvent(event))\n        //this.setHandlerFunc(event => this.handleEvent(event))\n        return this\n    }\n\n    // NOTE: atm, we leave restarting the event listeners up to the event set so we don't do extra restart\n\n    didUpdateSlotMethodName () {\n        this.clearFullMethodName()\n    }\n\n    didUpdateSlotMethodSuffix () {\n        this.clearFullMethodName()\n    }\n\n    didUpdateSlotUseCapture () {\n        this.clearFullMethodName()\n    }\n\n    setListenTarget (t) {\n        if (this.isListening()) {\n            assert(t)\n        }\n        this._listenTarget = t\n        return this\n    }\n\n    listenTargetDescription () {\n        return this.listenTarget().description()\n    }\n\n    // ---\n\n    clearFullMethodName () {\n        this.setFullMethodName(null)\n    }\n\n    calcFullMethodName () {\n        let suffix = \"\"\n\n        if (this.useCapture()) {\n            suffix = \"Capture\"\n        }\n\n        suffix += this.methodSuffix()\n        return this.methodName() + suffix\n    }\n\n    fullMethodName () {\n        if (!this._fullMethodName) {\n            this._fullMethodName = this.calcFullMethodName()\n        }\n        return this._fullMethodName\n    }\n\n    // ---------------------------------------------------------\n\n    setIsListening (aBool) {\n        if (aBool) {\n            this.start()\n        } else {\n            this.stop()\n        }\n        return this\n    }\n\n    assertHasListenTarget () {\n        assert(!Type.isNullOrUndefined(this.listenTarget()))\n    }\n\n    isValid () {\n        const hasListenTarget = !Type.isNullOrUndefined(this.listenTarget())\n        const hasEventName    = !Type.isNullOrUndefined(this.eventName())\n        const hasMethodName   = !Type.isNullOrUndefined(this.methodName())\n        return hasMethodName && hasEventName && hasListenTarget\n    }\n    \n    // listener key\n\n    listenerKey () {\n        let key = null\n        if (this.owner().node) {\n             key = this.owner().typeId() + \" \" + this.owner().node().title() + \" \" + this.delegate().typeId() + \" \" + this.fullMethodName()\n        } else {\n            key = this.owner().typeId() + \" \" + this.delegate().typeId() + \" \" + this.fullMethodName()\n        }\n        return key\n    }\n    \n    incrementListenCount () {\n        listenCount++\n        //EventListener.activeListeners().add(this)\n        //console.log(this.listenerKey() + \" START\")\n    }\n\n    decrementListenCount () {\n        listenCount--\n        //EventListener.activeListeners().delete(this)\n        //console.log(this.listenerKey() + \" STOP\")\n    }\n\n    // ---------------------------------------------------------\n\n    start () {\n        if (this.delegateCanRespond()) {\n            if (!this.isListening()) {\n                this.incrementListenCount()\n\n                this.debugLog(() => this.delegate().typeId() + \" will start listening for \" + this.eventName() + \" -> \" + this.methodName())\n                assert(this.isValid())\n                this._isListening = true; // can't use setter here as it would cause a loop\n                this.listenTarget().addEventListener(this.eventName(), this.handlerFunc(), this.useCapture());\n                /*\n                if (this.useCapture()) {\n                    debugger;\n                }\n                */\n            }\n        } else {\n            //console.log(this.delegate().debugTypeId() + \" doesn't respond to \" + this.fullMethodName() + \" so we won't listen for \" + this.eventName())\n            //debugger;\n        }\n        return this\n    }\n\n    owner () {\n        const d = this.delegate()\n        if (d.viewTarget) {\n            return d.viewTarget()\n        }\n        return d\n    }\n\n    ownerDescription () {\n        const d = this.delegate()\n        \n        if (d.viewTarget) {\n            //return d.viewTarget().debugTypeId() + \"->\" + d.type().before(\"GestureRecognizer\") \n            return d.viewTarget().typeId() + \" ->\" + d.type().before(\"GestureRecognizer\") \n        }\n\n        return d.typeId()\n    }\n\n    /*\n    descriptionForEvent (event) {\n        const e = event.currentTarget\n        let label = undefined\n        if (e.domView) {\n            label = e.domView().type()\n        } else {\n            label = e.constructor.name\n        }\n    }\n    */\n\n    safeHandleEvent (event) {\n        const result =  EventManager.shared().safeWrapEvent(() => {\n            //console.log(\"on event: \", this.listenerKey())\n\n            /*\n            //if (this.methodName() === \"onMouseDown\") {\n            if (this.fullMethodName() === \"onMouseDown\") {\n                console.log(\"on event: \", this.listenerKey())\n                //EventListener.showActive()\n                //MemoryUsage.shared().takeSnapshot()\n            }\n            */\n\n            this.handleEvent(event)\n        })\n        \n        return result\n    }\n\n    delegateCanRespond () {\n        if (Type.isNullOrUndefined(this.delegate())) {\n            return false\n        }\n        const method = this.delegate()[this.fullMethodName()]\n        const canRespond = Type.isFunction(method)\n        return canRespond\n    }\n\n    handleEvent (event) {\n        const fullMethodName = this.fullMethodName()\n        //event._isUserInteraction = this.isUserInteraction() // unused\n\n        const delegate = this.delegate()\n        const method = delegate[fullMethodName]\n\n\n        let result = true\n        if (method) {\n            this.onBeforeEvent(event)\n\n            result = method.call(delegate, event); \n\n            if (this.isDebugging()) {\n                console.log(\"sent: \" + delegate.type() + \".\" + fullMethodName, \"(\" + event.type + \") and returned \" + result)\n            }\n\n            if (result === false) {\n                event.stopPropagation()\n                if (event.cancelable) {\n                    event.preventDefault() // do we want this?\n                }\n            }\n\n            this.onAfterEvent(event)\n        } else {\n            if (this.isDebugging()) {\n                console.log(this.listenTargetDescription() + \" MISSING method: \" + delegate.type() + \".\" + fullMethodName, \"(\" + event.type + \")\" )\n            }\n        }\n\n        return result\n    }\n\n    onBeforeEvent (event) {\n        return this\n    }\n\n    onAfterEvent (event) {\n        if (this.isUserInteraction()) {\n            EventManager.shared().onReceivedUserEvent()\n        }\n        return this\n    }\n\n    stop () {\n        if (this.isListening()) {\n            this.assertHasListenTarget()\n\n            const t = this.listenTarget()\n\n            this.decrementListenCount()\n\n            //this.debugLog(() => this.delegate().typeId() + \" will stop listening for \" + this.methodName())\n            t.removeEventListener(this.eventName(), this.handlerFunc(), this.useCapture());\n            this._isListening = false; // can't use setter here as it would cause a loop\n        }\n\n        return this\n    }   \n\n}.initThisClass());\n\n",
  "RwmV6UTEBNZx/n2uOQraWuH/RMsyGKcCk7RKuYZ1vfM=": "\"use strict\";\n\n/*\n    EventSetListener\n\n    Manages registering a DOM element for a set of events which will be sent to a delegate\n    using a (potentially different) method name. Subclasses override init to define the\n    event set by calling this.addEventNameAndMethodName(...) for each event.\n\n    Example use of:\n\n        const mouseListener = MouseListener.clone().setListenTarget(element).setDelegate(anObject)\n\n    will send onMouseDown(event), onMouseOver(event) etc to anObject when those events occur on the element.\n    \n    TODO: abstraction for eventsDict\n*/\n\n(class EventSetListener extends ProtoClass {\n\n    initPrototypeSlots () {\n        this.newSlot(\"listenTarget\", null) // DOM Element (EventTarget)\n        this.newSlot(\"delegate\", null)\n        this.newSlot(\"isListening\", false)\n        this.newSlot(\"useCapture\", false).setComment(\"whether event will be dispatched to listener before EventTarget beneath it in DOM tree\")\n        this.newSlot(\"methodSuffix\", \"\")\n\n        this.newSlot(\"listenersMap\", null) // Map of eventName -> EventListener entries\n    }\n\n    init () {\n        super.init()\n        this.setListenersMap(new Map())\n        this.setupListeners()\n        return this\n    }\n\n    setupListeners () {\n        // subclasses override and set up event listeners by calling addEventNameAndMethodName()\n    }\n\n    /*\n    view () {\n        return this.listenTarget().domView()\n    }\n    */\n\n    allEventListeners () {\n        return this.listenersMap().valuesArray()\n    }\n\n    /* --- updates --- */\n\n    didUpdateSlotDelegate () {\n        this.resync()\n        return this\n    }\n\n    didUpdateSlotListenTarget () {\n        this.resync()\n        return this\n    }\n\n    didUpdateSlotUseCapture () {\n        this.resync()\n        return this\n    }\n\n    didUpdateSlotMethodSuffix () {\n        this.resync()\n        return this\n    }\n\n    resync () {\n        if (this.isListening()) {\n            console.warn(this.type() + \" resyncing while listening\")\n            debugger;\n            this.stop()\n            this.syncToListeners()\n            this.start()\n        } else {\n            this.syncToListeners()\n        }\n        return this\n    }\n\n    // --- listeners ---\n\n    newListener () {\n        const listener = EventListener.clone()\n        this.syncToListener(listener)\n        return listener\n    }\n\n    hasListenerForEventName (eventName) {\n        return this.listenersMap().has(eventName)\n    }\n\n    addEventNameAndMethodName (eventName, methodName, isUserInteraction) {\n        assert(!isUserInteraction)\n        assert(!this.isListening()) // TODO: handle this later\n        // TODO: make sure there's not already a listener for this eventName\n\n        assert(!this.hasListenerForEventName(eventName))\n\n        const listener = this.newListener()\n        listener.setEventName(eventName)\n        listener.setMethodName(methodName)\n        listener.setIsUserInteraction(isUserInteraction)\n        this.listenersMap().set(eventName, listener)\n        return listener\n    }\n\n    syncToListener (aListener) {\n        aListener.setListenTarget(this.listenTarget())\n        aListener.setDelegate(this.delegate())\n        aListener.setUseCapture(this.useCapture())\n        aListener.setIsDebugging(this.isDebugging())\n        return this\n    }\n\n    syncToListeners () {\n        this.forEachListener(listener => this.syncToListener(listener))\n        return this\n    }\n\n    forEachListener (fn) {\n        this.listenersMap().forEachV(listener => fn(listener))\n    }\n    // --- listening ---\n\n    setIsListening (aBool) {\n        if (aBool) {\n            this.start()\n        } else {\n            this.stop()\n        }\n        return this\n    }\n\n    start () {\n        if (!this.isListening()) {\n            this.syncToListeners()\n            this.forEachListener(listener => listener.start())\n            this._isListening = true; // can't use setter here as it would cause a loop\n        }\n        return this\n    }\n\n    stop () {\n        if (this.isListening()) {\n            this.forEachListener(listener => listener.stop())\n            this._isListening = false; // can't use setter here as it would cause a loop\n        }\n        return this\n    }   \n\n}.initThisClass());\n",
  "sC+EXCQcCQM16Lx97dQGINJSv9peIwpS5x3IKtUNU8E=": "\"use strict\";\n\n/*\n    AnimationListener\n\n    Listens to a set of animation events.\n\n    See: https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n\n    AnimationEvent contains \n    - animationName\n    - elapsedTime\n    - pseudoElement \n*/\n\n(class AnimationListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setIsDebugging(false)\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"animationend\", \"onAnimationEnd\");\n        this.addEventNameAndMethodName(\"animationiteration\", \"onAnimationIteration\");\n        this.addEventNameAndMethodName(\"animationstart\", \"onAnimationStart\");\n        this.addEventNameAndMethodName(\"animationcancel\", \"onAnimationCancel\");\n        return this\n    }\n\n}.initThisClass());\n",
  "lDxP+bQJHEtLtJ6wKa8QfmItto5tyBLnnMAQMIHjNsY=": "\"use strict\";\n\n/*\n    ClipboardListener\n\n    Listens to a set of clip board events.\n\n*/\n\n(class ClipboardListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"copy\", \"onCopy\");\n        this.addEventNameAndMethodName(\"cut\", \"onCut\");\n        this.addEventNameAndMethodName(\"paste\", \"onPaste\");\n        return this\n    }\n\n}.initThisClass());\n",
  "2pEA1RSdhyHObNd4XRRmS+X1X890u4DQZYjruvQ7BCg=": "\"use strict\";\n\n/*\n    DocumentListener\n\n    Listens to a set of document related events.\n\n*/\n\n(class DocumentListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        // See: https://developer.chrome.com/blog/page-lifecycle-api/\n\n        this.addEventNameAndMethodName(\"visibilitychange\", \"onDocumentVisibilityChange\");\n\n        this.addEventNameAndMethodName(\"freeze\", \"onDocumentFreeze\"); // Document specific\n        this.addEventNameAndMethodName(\"resume\", \"onDocumentResume\"); // Document specific\n        this.addEventNameAndMethodName(\"fullscreenerror\", \"onDocumentFullScreenError\"); // Document specific\n\n        // See: DOMElement requestFullscreen method\n        //this.addEventNameAndMethodName(\"fullscreenchange\", \"onBrowserFullScreenChange\"); // Document specific\n        //this.addEventNameAndMethodName(\"fullscreenerror\", \"onBrowserFullScreenError\"); // Document specific\n\n        return this\n    }\n\n    listenTarget () {\n        return document // is this the best way to handle this?\n    }\n    \n}.initThisClass());\n",
  "+vsfS6Yx1psJvHGOngGLp3Lnt0KEJpVzYiMrvShXx7E=": "\"use strict\";\n\n/*\n    DragListener\n\n    Listens to a set of drag event on element being dragged.\n\n*/\n\n(class DragListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        // fired on draggable element\n        this.addEventNameAndMethodName(\"dragstart\", \"onBrowserDragStart\");\n        this.addEventNameAndMethodName(\"drag\",      \"onBrowserDrag\");\n        this.addEventNameAndMethodName(\"dragend\",   \"onBrowserDragEnd\");\n        return this\n    }\n\n    start () {\n        super.start()\n        //this.listenTarget().ondragstart = (e) => { console.log(\"--- ondragstart ---\"); } // TODO: still needed?\n        return this\n    }\n    \n}.initThisClass());",
  "V05re0t2tOSwbq3W27Jb3GTHHs0yifX1xlgl32S40Ls=": "\"use strict\";\n\n/*\n    DropListener\n\n    Listens to a set of events on a drop target.\n\n*/\n\n(class DropListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        // fired on drop target\n        this.addEventNameAndMethodName(\"dragover\",  \"onBrowserDragOver\"); // must prevent default\n        this.addEventNameAndMethodName(\"dragenter\", \"onBrowserDragEnter\"); // must prevent default\n        this.addEventNameAndMethodName(\"drop\",      \"onBrowserDrop\");\n        this.addEventNameAndMethodName(\"dragleave\", \"onBrowserDragLeave\");\n        return this\n    }\n\n    start () {\n        super.start()\n        //this.listenTarget().__isListeningForDrop___ = true\n        return this\n    }\n\n    stop () {\n        super.stop()\n        //this.listenTarget().__isListeningForDrop___ = false // breaks if multiple drop listeners on same element\n        return this\n    }\n\n    /*\n    onBeforeEvent (methodName, event) {\n        this.debugLog(() => { return \" onBeforeEvent \" + methodName })\n        return this\n    }\n    */\n    \n}.initThisClass());\n",
  "J5TSf3zQSNPJFigMlnUdvpUOmnNrPs7ncIUzypM+2Mg=": "\"use strict\";\n\n/*\n    FocusListener\n\n    Listens to a set of focus events.\n\n*/\n\n(class FocusListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"blur\", \"onBlur\");\n        this.addEventNameAndMethodName(\"focus\", \"onFocus\");\n        this.addEventNameAndMethodName(\"focusin\", \"onFocusIn\");\n        this.addEventNameAndMethodName(\"focusout\", \"onFocusOut\"); \n        return this\n    }\n\n}.initThisClass());\n",
  "P/XWJKPc76yipCpzW12lPYjuvmmJW2xdWheGVEe/rc0=": "\"use strict\";\n\n/*\n    KeyboardListener\n\n    Listens to a set of keyboard events.\n\n*/\n\n(class KeyboardListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        this.setIsDebugging(false)\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"keyup\", \"onKeyUp\").setIsUserInteraction(true)\n        this.addEventNameAndMethodName(\"keydown\", \"onKeyDown\").setIsUserInteraction(true)\n        //this.addEventNameAndMethodName(\"keypress\", \"onKeyPress\");\n        //this.addEventNameAndMethodName(\"change\", \"onChange\");\n        //this.addEventNameAndMethodName(\"select\", \"onSelect\");\n        return this\n    }\n    \n}.initThisClass());\n",
  "nCiRl/WpJkhz+ezBS8JH22JmVQznzSh/lfqcSgFvtiA=": "\"use strict\";\n\n/*\n    MouseListener\n\n    Listens to a set of mouse events.\n\n*/\n\n\n(class MouseListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"mousedown\", \"onMouseDown\").setIsUserInteraction(true)\n        this.addEventNameAndMethodName(\"mouseup\",   \"onMouseUp\").setIsUserInteraction(true)\n\n        this.addEventNameAndMethodName(\"mouseover\",  \"onMouseOver\");  // triggered only when mouse enters element\n        this.addEventNameAndMethodName(\"mouseleave\", \"onMouseLeave\"); // triggered only when mouse exits element\n\n        //this.addEventNameAndMethodName(\"mousemove\", \"onMouseMove\");\n\n        // NOTE: don't see a good use case for these, so commenting out for now\n        //this.addEventNameAndMethodName(\"mouseout\",   \"onMouseOut\");   // triggered when mouse exits any child element        \n        //this.addEventNameAndMethodName(\"mouseenter\", \"onMouseEnter\"); // triggered when mouse enters any child element\n\n        this.addEventNameAndMethodName(\"click\",    \"onClick\").setIsUserInteraction(true)\n        this.addEventNameAndMethodName(\"dblclick\", \"onDoubleClick\").setIsUserInteraction(true) // is this valid?\n\n        this.addEventNameAndMethodName(\"contextmenu\", \"onContextMenu\"); // occurs on right mouse click on element\n        return this\n    }\n\n}.initThisClass());\n",
  "4oFKmNeurkdujMaid3f3wFeFrKelsyShold2eBh75Vw=": "\"use strict\";\n\n/*\n    MouseMoveListener\n\n    Listens to a set of mouse move events.\n    This is separated from MouseListener because move events happen at such a high rate,\n    that it's important for performance reasons to only listen for them when needed.\n\n*/\n\n\n(class MouseMoveListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n    }\n\n    /*\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"mousemove\", \"onMouseMove\");\n        return this\n    }\n\n}.initThisClass());\n",
  "VN0URFwom7fe1kvORMqdJ9wpM/xlbweyook/+QscObY=": "\"use strict\";\n\n/*\n    SelectListener\n\n    Listens to a set of select events on element.\n\n*/\n\n(class SelectListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setListenTarget (anElement) {\n        // is event only works on document or window?\n        assert(anElement === document || anElement === window)\n        super.setListenTarget(anElement)\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"selectstart\", \"onSelectStart\");\n        this.addEventNameAndMethodName(\"selectionchange\", \"onSelectionChange\");\n        return this\n    }\n    \n}.initThisClass());",
  "QkMl5UHtrH67ljvJNrpBO9YFKMyHK3jRBBbzid5qeBw=": "\"use strict\";\n\n/*\n    TouchListener\n\n    Listens to a set of touch events.\n\n*/\n \n(class TouchListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        return this\n    } \n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"touchstart\",  \"onTouchStart\").setIsUserInteraction(true)\n        this.addEventNameAndMethodName(\"touchmove\",   \"onTouchMove\");\n        this.addEventNameAndMethodName(\"touchcancel\", \"onTouchCancel\");\n        this.addEventNameAndMethodName(\"touchend\",    \"onTouchEnd\");\n        return this\n    }\n\n}.initThisClass());\n",
  "1lacFMDblj5gYmswU8JSpama8sZ8y65faFmzn+DpNl8=": "\"use strict\";\n\n/*\n    TouchMoveListener\n\n    Listens to touch move events.\n    Seperated from TouchListeners for performance reasons.\n\n*/\n \n(class TouchMoveListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        return this\n    } \n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"touchmove\",   \"onTouchMove\");\n        return this\n    }\n\n}.initThisClass());\n",
  "tther27vU5F/ty/cnQvTnVugMAp+FBxA6ZuKm+vG6JE=": "\"use strict\";\n\n/*\n    TransitionListener\n\n    Listens to a set of animation transition events.\n\n*/\n\n(class TransitionListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"transitionrun\", \"onTransitionRun\");\n        this.addEventNameAndMethodName(\"transitionstart\", \"onTransitionStart\");\n        this.addEventNameAndMethodName(\"transitioncancel\", \"onTransitionCancel\");\n        this.addEventNameAndMethodName(\"transitionend\", \"onTransitionEnd\");\n        return this\n    }\n    \n}.initThisClass());\n",
  "8sOb0G6/ElhKNXz95Aa5NVuLg7oAwzkQBhUnQaXYL8k=": "\"use strict\";\n\n/*\n    GamePadListener\n\n    Listens to a set of mouse events.\n\n*/\n\n(class GamePadListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"gamepadconnected\",   \"onGamePadConnected\");\n        this.addEventNameAndMethodName(\"gamepaddisconnected\", \"onGamePadDisconnected\");\n        return this\n    }\n\n}.initThisClass());\n\n",
  "TP/WPmAaK7I8RgyLI0p4DwSyzHYB3ltHkoWOJmT2v6Q=": "\"use strict\";\n\n/*\n    WebSocketListener\n\n    Listens to a set of web socket events.\n\n    NOTES:\n    \n    MessageEvent contains:\n    - data\n    - origin\n    - lastEventId \n    - source \n    - ports\n*/\n\n(class WebSocketListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"open\", \"onOpen\");\n        this.addEventNameAndMethodName(\"close\", \"onClose\");\n        this.addEventNameAndMethodName(\"error\", \"onError\");\n        this.addEventNameAndMethodName(\"message\", \"onMessage\");\n        return this\n    }\n\n}.initThisClass());\n",
  "aC1GashxiJd1idAK9PoalDAbKkouIqa8B5tZyedi5Mk=": "\"use strict\";\n\n/*\n    WheelListener\n\n    Listens to a set of wheel (mouse or other wheel) events.\n\n*/\n\n(class WheelListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"wheel\",   \"onWheel\");\n        return this\n    }\n\n}.initThisClass());\n",
  "XIsS0F4YQHqOwLN5cDkcw8qJpWeZCf5307R5mnToSH4=": "\"use strict\";\n\n/*\n    WindowListener\n\n    Listens to a set of Window related events.\n\n*/\n\n(class WindowListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        // See: https://developer.chrome.com/blog/page-lifecycle-api/\n\n        // window events\n        this.addEventNameAndMethodName(\"resize\", \"onWindowResize\"); // Document specific\n\n        this.addEventNameAndMethodName(\"pageshow\", \"onPageShow\"); // Window specific\n        this.addEventNameAndMethodName(\"pagehide\", \"onPageHide\"); // Window specific\n\n        this.addEventNameAndMethodName(\"beforeunload\", \"onDocumentBeforeUnload\"); // Window specific?\n        this.addEventNameAndMethodName(\"unload\", \"onDocumentUnload\"); // Window specific?\n\n        this.addEventNameAndMethodName(\"submit\", \"onSubmit\"); // FormElement specific\n\n        this.addEventNameAndMethodName(\"online\", \"onBrowserOnline\"); // Window specific\n        this.addEventNameAndMethodName(\"offline\", \"onBrowserOffline\"); // Window specific\n\n        //this.addEventNameAndMethodName(\"error\", \"onBrowserResourceLoadError\");\n\n        return this\n    }\n\n    listenTarget () {\n        // \n        return window // is this the best way to handle this?\n    }\n    \n}.initThisClass());\n",
  "0D/YlTm9Bv2NJShpi0tHjr8hS/Rgnpx+819jA3eakWY=": "\"use strict\";\n\n/*\n    SpeechListener\n\n    Listens to events on a SpeechSynthesisUtterance instance.\n\n*/\n\n(class SpeechListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        this.setIsDebugging(false)\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"boundary\", \"onBoundary\");\n        this.addEventNameAndMethodName(\"end\", \"onEnd\");\n        this.addEventNameAndMethodName(\"error\", \"onError\");\n        this.addEventNameAndMethodName(\"mark\", \"onMark\");\n        this.addEventNameAndMethodName(\"pause\", \"onPause\");\n        this.addEventNameAndMethodName(\"resume\", \"onResume\");\n        this.addEventNameAndMethodName(\"start\", \"onStart\");\n        return this\n    }\n\n}.initThisClass());\n",
  "4jKAFef8ADAMxfIFlmXS7zxTWLgGiWoYPWIRiset92U=": "\"use strict\";\n\n/*\n    GestureManager\n\n    We typically only want one gesture to be active globally.\n    GestureManager helps to coordinate which gesture has control.\n\n    To pause all gestures:\n    \n        GestureManager.shared().pause()\n        GestureManager.shared().unpause()\n    \n    or:\n\n        GestureManager.shared().setIsPaused(aBool)\n\n    NOTES:\n\n    If a decendant view requests control, it can steal it.\n\n*/\n\n(class GestureManager extends ProtoClass {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"activeGesture\", null) // aGesture\n        this.newSlot(\"begunGestures\", null) // dict\n        this.newSlot(\"isPaused\", false) // used to pause gestures while editing text fields\n    }\n\n    init () {\n        super.init()\n        this.setBegunGestures({})\n        return this\n    }\n\n    hasActiveGesture () {\n        return this.activeGesture() && this.activeGesture().isActive()\n    }\n\n    pause () {\n        this.setIsPaused(true)\n        return this\n    }\n\n    unpause () {\n        this.setIsPaused(false)\n        return this\n    }\n\n    setIsPaused (aBool) {\n        if (this._isPaused !== aBool) {\n            this._isPaused = aBool\n\n            this.debugLog(this.type() + \".setIsPaused(\" + aBool + \")\")\n\n            if (aBool) {\n                this.cancelAllGestures()\n            }\n        }\n        return this\n    }\n\n    cancelAllGestures () {\n        this.cancelAllBegunGestures()\n        const ag = this.activeGesture()\n        if (ag) {\n            ag.cancel()\n        }\n    }\n\n    requestActiveGesture (aGesture) { // sent by gestures themselves\n        this.debugLog(\"requestActiveGesture(\" + aGesture.description() + \")\")\n\n        if (this.isPaused()) {\n            return false\n        }\n\n        assert(aGesture)\n        const ag = this.activeGesture()\n\n        if (!ag) {\n            this.acceptGesture(aGesture)\n            return true\n        }\n\n        //this.releaseActiveGestureIfInactive()\n        if (aGesture === ag) { // error\n            console.warn(\"request to activate an already active gesture \", aGesture.description())\n            return false\n        }\n\n        // see if active gesture has lower priority\n        if (ag) {\n            // allow child views to steal the active gesture\n            const childViewIsRequesting = ag.viewTarget().hasSubviewDescendant(aGesture.viewTarget())\n            if (childViewIsRequesting) {\n                this.acceptGesture(aGesture)\n                return true\n            }\n        }\n\n\n        // already have active gesture, so reject this request\n        this.rejectGesture(aGesture)\n        return false\n    }\n\n    acceptGesture (aGesture) { // private method\n        aGesture.viewTarget().cancelAllGesturesExcept(aGesture)\n        this.cancelBegunGesturesExcept(aGesture)\n        this.setActiveGesture(aGesture)\n        this.debugLog(\"acceptGesture(\" + aGesture.description() + \")\")\n        return this\n    }\n\n    rejectGesture (aGesture) { // private method\n        this.debugLog(\"rejectGesture(\" + aGesture.description() + \")\")\n        this.debugLog(\"already active \" + this.activeGesture().description())\n        return this\n    }\n\n    deactivateGesture (aGesture) {\n        if (this.activeGesture() === aGesture) {\n            this.setActiveGesture(null)\n        }\n        return this\n    }\n\n    addBegunGesture (aGesture) {\n        this.begunGestures().atSlotPut(aGesture.typeId(), aGesture)\n        return this\n    }\n\n    removeBegunGesture (aGesture) {\n        this.begunGestures().removeSlotAt(aGesture.typeId())\n        return this\n    }\n\n    cancelAllBegunGestures () {\n        Object.values(this.begunGestures()).forEach(g => g.requestCancel() );\n        return this\n    }\n\n    cancelBegunGesturesExcept (aGesture) {\n        Object.values(this.begunGestures()).forEach((g) => {\n            if (g !== aGesture) {\n                g.requestCancel()\n            }\n        });\n        return this\n    }\n\n    debugTypeId () {\n        const s = this.isPaused() ? \"(paused)\" : \"(not paused)\"\n        return super.debugTypeId() + s\n    }\n    \n}.initThisClass());\n",
  "xlVnWgXDWF0fa8TvDMTX9K4XtrUu8eaxJEgvBcn0CkA=": "\"use strict\";\n\n/*\n    GestureRecognizer\n\n    This class:\n     - listens for events \n     - uses logic to detect gestures\n     - coordinates which gestures are active with a GestureManager\n     - sends delegate messages for gesture state changes\n    \n    This class supports general gesture logic & helper methods\n    and is intended to be sublclassed to implement particular gesture types. \n    See SlideGestureRecognizer, for an example subclass.\n\n    Event Listeners\n\n    Listeners are typically on a particular view's element. \n    document.body listeners are usually added once the gesture has begun, \n    in order to track events outside the element. \n    The document listeners are then removed once the gesture has ended or cancelled.\n\n    Delegate Messages\n\n    State change delegate messages are sent to the viewTarget. These are typically:\n    \n        accepts<GestureType>(aGesture)\n        on<GestureType>Begin(aGesture)\n        on<GestureType>Move(aGesture)\n        on<GestureType>End(aGesture)\n        on<GestureType>Cancel(aGesture)\n\n    Simulating Touches with the Mouse\n\n    Holding the SHIFT key and click-dragging the mouse can be used to simulate 2 finger \n    gestures on non-touch devices.\n\n    State to track event semantics:\n\n        downEvent - set onDownEvent *if* number of touchs is in correct range\n        beginEvent - set when sending begin message - typically in onMove: \n        activePoints() - returns downEvent points for fingers contained in currentEvent\n        upEvent - usually set on complete, not used much yet\n\n    NOTES\n\n    Browsers may implement their own touch gestures. To prevent these from \n    interfering with our own, be sure to call:\n\n        aView.setTouchAction(\"none\")\n\n    On related views (or probably all views, to be safe) or set these in the CSS e.g.\n\n        html * { touch-action: none; }\n\n    TODO: \n    \n    - rename methods to clearly identify Doc and View related methods\n    - move visualizer to separate class?\n\n    QUESTIONS:\n    If a view has the active gesture control, and a decendent view requests becoming the active\n    gesture, the GestureManager will detect this and let the child steal control.\n    \n*/\n\n(class GestureRecognizer extends ProtoClass {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"viewTarget\", null)\n        this.newSlot(\"shouldRemoveOnComplete\", false)\n\n        // listener classes\n\n        this.newSlot(\"listenerClasses\", null)\n        this.newSlot(\"moveListenerClasses\", [\"MouseMoveListener\", \"TouchMoveListener\"])\n        this.newSlot(\"defaultListenerClasses\", [\"MouseListener\", \"TouchListener\"])\n\n        // listeners\n\n        this.newSlot(\"viewListeners\", null)\n        this.newSlot(\"docListeners\", null)\n\n        // move listeners\n\n        this.newSlot(\"viewMoveListeners\", null)\n        this.newSlot(\"docMoveListeners\", null)\n\n        // events\n\n        this.newSlot(\"overEvent\", null)\n        this.newSlot(\"leaveEvent\", null)\n        this.newSlot(\"didBegin\", false)\n        this.newSlot(\"downEvent\", null)\n        this.newSlot(\"beginEvent\", null)\n        this.newSlot(\"currentEvent\", null)\n        this.newSlot(\"lastEvent\", null)\n        this.newSlot(\"upEvent\", null)\n\n        // standard messages\n\n        this.newSlot(\"gestureName\", null) // sets <GestureType> name used for messages\n        this.newSlot(\"acceptMessage\", null)  //\"accepts<GestureType>\"\n        this.newSlot(\"beginMessage\", null) //\"on<GestureType>Begin\",\n        this.newSlot(\"moveMessage\", null) //\"on<GestureType>Move\",\n        this.newSlot(\"requestCancelMessage\", null) // \"on<GestureType>RequestCancel\"\n        this.newSlot(\"cancelledMessage\", null) // \"on<GestureType>Cancelled\",\n        this.newSlot(\"completeMessage\", null) // \"on<GestureType>Complete\",\n        \n        // debugging\n\n        this.newSlot(\"isEmulatingTouch\", false) // assumes touch and mouse events aren't mixed\n        this.newSlot(\"isVisualDebugging\", false)\n        this.newSlot(\"fingerViewDict\", null)\n\n        // begin pressing \n\n        this.newSlot(\"isPressing\", false).setDoesHookSetter(true)\n        this.newSlot(\"minFingersRequired\", 2)\n        this.newSlot(\"maxFingersAllowed\", 4)\n        this.newSlot(\"minDistToBegin\", 10)\n        this.newSlot(\"allowsKeyboardKeys\", false)\n        this.newSlot(\"requiresKeyboardKeys\", null)\n        this.newSlot(\"shouldRequestActivation\", true)\n        this.newSlot(\"shouldAcceptCancelRequest\", true)\n        this.newSlot(\"isActive\", false) // only used if shouldRequestActivation === false\n    }\n\n    init () {\n        super.init()\n        this.setListenerClasses([]) // subclasses override this in their\n\n        this.setViewListeners([])\n        this.setDocListeners([])\n\n        this.setViewMoveListeners([])\n        this.setDocMoveListeners([])\n\n        //this.setGestureName(this.type().before(\"GestureRecognizer\"))\n        this.autoSetMessageNames()\n        this.setIsEmulatingTouch(true)\n        this.setFingerViewDict({})\n\n        this.setIsDebugging(false)\n        //this.setIsVisualDebugging(true)\n        return this\n    }\n\n \n    // -- event helpers --\n\n    clearEvents () {\n        this.setDownEvent(null)\n        this.setBeginEvent(null)\n        this.setCurrentEvent(null)\n        return this\n    }\n    \n    setCurrentEvent (event) {\n        if (this._currentEvent !== event) {\n            this.setLastEvent(this._currentEvent)\n            this._currentEvent = event\n        }\n        return this\n    }\n\n    currentPosition () {\n        return this.pointsForEvent(this.currentEvent()).first()\n    }\n\n    downPosition () {\n        return this.pointsForEvent(this.downEvent()).first()\n    }\n\n    beginPosition () {\n        return this.pointsForEvent(this.beginEvent()).first()\n    }\n\n    upPosition () {\n        return this.pointsForEvent(this.upEvent()).first()\n    }\n\n    numberOfFingersDown () {\n        const points = this.pointsForEvent(this.currentEvent())\n        return points.length\n    }\n\n    currentEventIsOnTargetView () {\n        const points = this.pointsForEvent(this.currentEvent())\n        const p = points.first()\n        const view = this.viewTarget()\n        return view.containsPoint(p)\n        //return points.detect(p1 => !view.containsPoint(p1)) === null\n    }\n\n    // --- listener classes ---\n\n    setListenerClasses (classNames) {\n        this._listenerClasses = classNames\n        this.filterListenerClassesForTouch()\n        return this\n    }\n\n    filterListenerClassesForTouch () {\n        // if we don't have a touch screen, avoid registering for touch events\n        if (!TouchScreen.shared().isSupported()) {\n            const results = this.listenerClasses().filter(name => !name.beginsWith(\"Touch\"))\n            this._listenerClasses = results\n        }\n    }\n\n    // --- new listeners ---\n\n    newListenersForClasses (classesArray) {\n        return classesArray.map((className) => {\n            const proto = Object.getClassNamed(className);\n            const listener = proto.clone();\n            listener.setDelegate(this);\n            return listener\n        })\n    }\n\n    startNewViewListenersForClasses (classesArray) {\n        const listeners = this.newListenersForClasses(classesArray)\n        listeners.forEach(listener => {\n            listener.setListenTarget(this.viewTarget().element())\n            listener.setIsDebugging(this.isDebugging())\n            listener.start()\n        })\n        return listeners\n    }\n    \n    startNewDocListenersForClasses (classesArray) {\n        const listeners = this.newListenersForClasses(classesArray)\n        listeners.forEach(listener => {\n            listener.setUseCapture(true)\n            listener.setListenTarget(window)\n            listener.setIsDebugging(this.isDebugging())\n            listener.start()\n        })\n        return listeners\n    }\n\n    // --- view listeners ---\n\n    startViewListeners () {\n        //debugger;\n        this.stopViewListeners()\n        this.setViewListeners(this.startNewViewListenersForClasses(this.listenerClasses()))\n        return this\n    }\n\n    stopViewListeners () {\n        this.viewListeners().forEach(listener => listener.stop())\n        this.viewListeners().clear()\n        return this\n    }\n\n    // --- doc listeners ---\n\n    startDocListeners () {\n        this.stopDocListeners()\n        this.setDocListeners(this.startNewDocListenersForClasses(this.listenerClasses()))\n        return this\n    }\n\n    stopDocListeners () {\n        this.docListeners().forEach(listener => listener.stop())\n        this.docListeners().clear()\n        return this\n    }\n\n    // -- special case for mouse and touch move events ---\n\n    didUpdateSlotIsPressing (oldValue, newValue) {\n        if (newValue === true) {\n            this.startViewMoveListeners()\n            this.startDocMoveListeners() // is this correct?\n        } else {\n            this.stopViewMoveListeners()\n            this.stopDocMoveListeners() // is this correct?\n        }\n    }\n\n    // --- view move listeners ---\n\n    newMoveListeners () {\n        return this.listenersForClasses(this.moveListenerClasses())\n    }\n\n    stopViewMoveListeners () {\n        this.viewMoveListeners().forEach(listener => listener.stop())\n        this.viewMoveListeners().clear()\n        return this\n    }\n\n    startViewMoveListeners () {\n        //debugger;\n        this.stopViewMoveListeners()\n        this.setViewMoveListeners(this.startNewViewListenersForClasses(this.moveListenerClasses()))\n        return this\n    }\n\n    // --- doc move listeners ---\n\n    stopDocMoveListeners () {\n        this.docMoveListeners().forEach(listener => listener.stop())\n        this.docMoveListeners().clear()\n        return this\n    }\n\n    startDocMoveListeners () {\n        this.stopDocMoveListeners()\n        this.setDocMoveListeners(this.startNewDocListenersForClasses(this.moveListenerClasses()))\n        return this\n    }\n\n    // ---------------------\n\n    // condition helpers\n\n    hasMovedEnough () {\n        // intended to be overridden by subclasses\n        // e.g. a rotation recognizer might look at how much first two fingers have rotated\n        const m = this.minDistToBegin()\n        const d = this.currentPosition().distanceFrom(this.downPosition())\n        return d >= m\n    }\n\n    hasAcceptableFingerCount () {\n        const n = this.numberOfFingersDown()\n        return  n >= this.minFingersRequired() &&\n                n <= this.maxFingersAllowed();\n    }\n\n    hasAcceptableKeyboardState () {\n        if (!this.allowsKeyboardKeys()) {\n            if (BMKeyboard.shared().hasKeysDown()) {\n                // make exception for shift key since we use it to emulate multi-touch\n                if (BMKeyboard.shared().shiftKey().isOnlyKeyDown()) {\n                    return true\n                }\n                return false\n            }\n        }\n        return true\n    }\n\n    canBegin () {\n        return !this.isActive() && \n                this.hasMovedEnough() && \n                this.hasAcceptableFingerCount() &&\n                this.hasAcceptableKeyboardState();\n    }\n\n    // --- start / stop ---\n\n    start () {\n        this.startViewListeners()\n        // We typically don't want to listen to document level events all the time.\n        // Instead, some view events will start and stop the doc listeners.\n        //this.startViewMoveListeners() \n        return this\n    }\n\n    stop () {\n        this.stopViewListeners()\n        this.stopDocListeners()\n        this.stopViewMoveListeners() // is this correct?\n        this.stopDocMoveListeners() // is this correct?\n        return this\n    }\n\n    allEventListeners () {\n        const sets = [this.viewListeners(), this.docListeners(), this.viewMoveListeners(), this.docMoveListeners()].flat()\n        return sets.map(eventListenerSet => eventListenerSet.allEventListeners()).flat()\n    }\n\n    // active\n\n    requestActivationIfNeeded () {\n        if (this.shouldRequestActivation()) {\n            return GestureManager.shared().requestActiveGesture(this);\n        }\n        this.setIsActive(true)\n        return true\n    }\n\n    isActive () {\n        if (this.shouldRequestActivation()) {\n            return GestureManager.shared().activeGesture() === this\n        }\n        return this._isActive\n    }\n\n    deactivate () {\n        if (this.shouldRequestActivation()) {\n            GestureManager.shared().deactivateGesture(this);\n        }\n        this.setIsActive(false)\n        return this\n    }\n\n    // finish\n\n    didFinish () {\n        this.setDidBegin(false)\n        GestureManager.shared().removeBegunGesture(this)\n\n        // why do we do this with a delay?\n        // is it needed now to prevent a move\n        this.addTimeout(() => { \n            GestureManager.shared().removeBegunGesture(this)\n            this.deactivate();\n        }, 0)\n\n        if (this.shouldRemoveOnComplete() && this.viewTarget()) {\n            this.stop()\n            this.viewTarget().removeGestureRecognizer(this)\n        }\n\n        this.removeFingerViews()\n        return this\n    }\n\n    // subclass helpers\n\n    sendDelegateMessage (methodName, argument) {\n        let result = undefined\n        assert(methodName !== null)\n        const vt = this.viewTarget()\n\n        if (this.isDebugging()) {\n            console.log(this.shortTypeId() + \" sending \" + methodName + \" to \" + vt.typeId())\n        }\n\n        //try {\n        if (vt) {\n            if (vt[methodName]) {\n                result = vt[methodName].call(vt, this, argument)\n            } else {\n                if (this.isDebugging()) {\n                    console.log(\"gesture delegate missing method \" + methodName)\n                }\n                result = false\n            }\n        }\n        /*\n        } catch(e) {\n            console.error(this.typeId() + \".sendDelegateMessage(\" + methodName + \") caught exception \", e.stack)\n            result = false\n            //this.cancel() // how to do this without potentially cause a loop?\n            throw e\n        }\n        */\n\n        return result\n    }\n\n    // points helper\n    // maps mouse and touch events to a common list of points (with times and ids) format\n    // so we can share the event handling code for both devices \n\n    pointsForEvent (event) {\n        if (Type.isNullOrUndefined(event)) {\n            throw new Error(this.type() + \".pointsForEvent(event) event is missing\")\n        }\n\n        const eventClass = event.__proto__.constructor;\n\n        if (eventClass === MouseEvent) {\n            //this.debugLog(\" got mouse\")\n            return Mouse.shared().pointsForEvent(event)\n        } else if (eventClass === TouchEvent) {   \n            //this.debugLog(\" got touch\")\n            return TouchScreen.shared().pointsForEvent(event)\n        }\n        \n        console.warn(this.type() + \" can't handle this event type yet: \", event)\n\n        return []\n    }\n\n    // all events hook\n\n    onEvent (event) {\n        if (this.isVisualDebugging()) {\n            this.updateOutlineView()\n            this.updateFingerViews()\n            //this.updateDebugTimer()\n        }\n    }\n\n    // --- events ---\n\n    onOver (event) {\n        this.setOverEvent(event)\n        this.setCurrentEvent(event)\n        this.onEvent(event)\n    }\n\n    onDown (event) {\n        this.setDownEvent(event)\n        this.setCurrentEvent(event)\n        this.onEvent(event)\n    }\n\n    onMove (event) {\n        this.setCurrentEvent(event)\n        this.onEvent(event)\n    }\n\n    onUp (event) {\n        this.setUpEvent(event)\n        //this.setCurrentEvent(event) // on Windows, the up event may not have any positions\n        this.onEvent(event)\n    }\n\n    onLeave (event) {\n        this.setLeaveEvent(event)\n        this.setCurrentEvent(event)\n        this.onEvent(event)\n    }\n\n    // --- mouse events ---\n\n    shouldEmulateEvent (event) {\n        return this.isEmulatingTouch() && \n                event.shiftKey && \n                event.__proto__.constructor === MouseEvent &&\n                this.pointsForEvent(event).length === 1;\n    }\n\n    emulateDownIfNeeded (event) {\n        const p1 = this.pointsForEvent(event).first()\n\n        if (this.shouldEmulateEvent(event)) {\n            // make a duplicate of the down event point with a different id\n            const p2 = p1.copy().setId(\"emulatedTouch\")\n            p2.setX(p2.x() + 10)\n            p2.setY(p2.y() + 10)\n            event.pushCachedPoint(p2)\n        }\n        return this\n    }\n\n    onMouseDown (event) {      \n        //debugger;  \n        this.emulateDownIfNeeded(event)\n        this.setDownEvent(event)\n        this.onDown(event)\n    }\n\n    emulateMoveIfNeeded (event) {\n        const p2 = this.pointsForEvent(event).first()\n\n        if (this.shouldEmulateEvent(event) && this.downEvent()) {      \n            // get down point and current point and add an emulated point on the other side\n            const p1 = this.pointsForEvent(this.downEvent()).first()\n            const v = p2.subtract(p1).negated()\n            const emulatedPoint = p1.add(v).setId(\"emulatedTouch\")\n            event.pushCachedPoint(emulatedPoint)\n        }\n\n        return this\n    }\n\n    onMouseMove (event) {\n        this.emulateMoveIfNeeded(event)\n        this.onMove(event)\n    }\n\n    onMouseUp (event) {\n        this.onUp(event)\n    }\n\n    onMouseLeave (event) {\n        this.onLeave(event)\n    }\n\n    // mouse capture events\n\n    onMouseOverCapture (event) {\n        this.onOver(event)\n    }\n\n    onMouseDownCapture (event) {\n        this.emulateDownIfNeeded(event)\n        this.onDown(event)\n    }\n\n    onMouseMoveCapture (event) {\n        this.emulateMoveIfNeeded(event)\n        this.onMove(event)\n    }\n\n    onMouseUpCapture (event) {\n        this.onUp(event)\n    }\n\n    onMouseLeaveCapture (event) {\n        this.onLeave(event)\n    }\n\n    // touch events\n\n    onTouchStart (event) {\n        this.onDown(event)\n    }\n\n    onTouchMove (event) {\n        this.onMove(event)\n    }\n\n    onTouchEnd (event) {\n        this.onUp(event)\n    }\n\n    onTouchCancel (event) { \n        //this.onUp(event)\n        this.cancel()\n    }\n    \n    // touch capture events\n\n    onTouchStartCapture (event) {\n        this.onDown(event)\n    }\n\n    onTouchMoveCapture (event) {\n        this.onMove(event)\n    }\n\n    onTouchEndCapture (event) {\n        this.onUp(event)\n    }\n\n    onTouchCancelCapture (event) {\n        //this.onUp(event)\n        this.cancel()\n    }\n\n    // diff position helper\n\n    diffPos () {\n        return this.currentPosition().subtract(this.beginPosition()).floorInPlace() // floor here?\n    }\n\n    distance () {\n        const dp = this.diffPos()\n        const dx = Math.abs(dp.x())\n        const dy = Math.abs(dp.y())\n        const funcs = {\n            left: (dx, dy) => dx,\n            right: (dx, dy) => dx,\n            up: (dx, dy) => dy,\n            down: (dx, dy) => dy,\n            x: (dx, dy) => dx,\n            y: (dx, dy) => dy\n        }\n        return funcs[this.direction()](dx, dy)\n    }\n\n    setGestureName (aName) {\n        this._gestureName = aName\n        this.autoSetMessageNames()\n        return this\n    }\n\n    gestureName () {\n        if (this._gestureName) {\n            return this._gestureName\n        }\n        return this.type().before(\"GestureRecognizer\")\n    }\n\n    defaultMessageForState (state) {\n        return \"on\" + this.gestureName() + state.capitalized()\n    }\n\n    autoSetMessageNames () {\n        this.setAcceptMessage(\"accepts\" + this.gestureName())\n        this.setBeginMessage(this.defaultMessageForState(\"Begin\"))\n        this.setMoveMessage(this.defaultMessageForState(\"Move\"))\n        this.setRequestCancelMessage(\"on\" + this.gestureName() + \"RequestCancel\")\n        this.setCancelledMessage(this.defaultMessageForState(\"Cancelled\"))\n        this.setCompleteMessage(this.defaultMessageForState(\"Complete\"))\n        return this\n    }\n\n    // sending delegate messages\n\n    doesTargetAccept () {\n\n        // see if view accepts the gesture before we begin\n        // for now, assume it accepts if it doesn't implement the accept<GestureType> method\n        const vt = this.viewTarget()\n        if (vt[this.acceptMessage()]) {\n            if (!this.sendDelegateMessage(this.acceptMessage())) {\n                this.cancel()\n                return false\n            }\n        }\n\n        return true\n    }\n\n    sendBeginMessage () {\n        if (!this.doesTargetAccept()) {\n            return this\n        }\n        \n        this.setDidBegin(true)\n        this.setBeginEvent(this.currentEvent())\n        this.sendDelegateMessage(this.beginMessage())\n        GestureManager.shared().addBegunGesture(this)\n        return this\n    }\n\n    sendMoveMessage () {\n        this.sendDelegateMessage(this.moveMessage())\n        //this.didMove()\n        return this\n    }\n\n    sendCompleteMessage () {\n        this.sendDelegateMessage(this.completeMessage())\n        this.didFinish()\n        return this\n    }\n\n    sendCancelledMessage () {\n        this.sendDelegateMessage(this.cancelledMessage())\n        this.didFinish()\n        return this\n    }\n\n    requestCancel (byGesture) {\n        if (this.shouldAcceptCancelRequest()) {\n            this.cancel()\n        }\n        /*\n        const shouldCancel = this.sendDelegateMessage(this.requestCancelMessage(), byGesture)\n        //console.log(\"this.requestCancelMessage() =================== \", this.requestCancelMessage(), \" -> \", shouldCancel)\n        if (shouldCancel || Type.isUndefined(shouldCancel)) { \n            this.cancel()\n        }\n        */\n    }\n\n    cancel () {\n        this.debugLog(\" cancel\")\n        //this.willCancel()\n        this.sendCancelledMessage()\n        //this.didCancel()\n    }\n\n    /*\\\n    willCancel () {\n\n    }\n\n    didCancel () {\n        //this.didFinish()\n    }\n    */\n\n    // ---\n\n    cleanup () {\n        this.setDownEvent(null)\n        this.setCurrentEvent(null)\n        this.setUpEvent(null)\n        return this\n    }\n\n    shouldShowVisualDebugger () {\n        return this.hasDownPointsInView() || this.isActive() // || this.isPressing());\n    }\n\n    // ---  outline view for debugging ---\n\n    newOutlineView () {\n        const v = DomView.clone()\n        v.setPointerEvents(\"none\")\n        v.setBorder(\"1px dashed white\")\n        v.setBackgroundColor(\"transparent\")\n        v.setPosition(\"absolute\")\n        v.setZIndex(10000)\n        return v\n    }\n\n    outlineView () {\n        if (!this._outlineView) {\n            const v = this.newOutlineView()\n            this._outlineView = v\n        }\n        return this._outlineView\n    }\n\n    updateOutlineView () {\n        /*\n        if (this.shouldShowVisualDebugger()) {\n            this.showOutlineView()\n        } else {\n            const v = this.outlineView()\n            if (v.parentView()) {\n                v.removeFromParentView()\n            }\n        }\n        */\n    }\n\n    showOutlineView () {\n        const v = this.outlineView()\n        if (!v.parentView()) {\n            DocumentBody.shared().addSubview(v)\n        }\n        const vt = this.viewTarget()\n        const bounds = vt.frameInDocument()\n\n        v.setMinAndMaxHeight(bounds.height())\n        v.setMinAndMaxWidth(bounds.width())\n        v.setLeftPx(bounds.x())\n        v.setTopPx(bounds.y())\n    }\n\n\n\n    // --- finger views for debugging ---\n\n    newFingerView () {\n        const v = DomView.clone()\n        v.setPointerEvents(\"none\")\n\n        const size = 50\n        v.setMinAndMaxHeight(size)\n        v.setMinAndMaxWidth(size)\n        v.setBorderRadiusPx(Math.round(size/2) + \"px\")\n        v.setBorder(\"1px dashed white\")\n        //v.setBackgroundColor(\"rgba(255, 255, 255, 0.5)\")\n        v.setPosition(\"absolute\")\n        v.setTextAlign(\"center\")\n        v.setZIndex(10000)\n        v.setInnerHtml(this.type())\n        v.setPxFontSize(10)\n        v.setColor(\"white\")\n        return v\n    }\n\n    viewForFingerId (id) {\n        const fvs = this.fingerViewDict()\n        let v = fvs.at(id)\n        if (!v) {\n            v = this.newFingerView()\n            DocumentBody.shared().addSubview(v)\n            fvs.atPut(id, v)\n        }\n        return v\n    }\n\n    removeFingerViews () {\n        const dict = this.fingerViewDict()\n        Object.keys(dict).forEach((id) => {\n            const fingerView = dict[id]\n            fingerView.removeFromParentView()\n        })\n        this.setFingerViewDict({})\n        return this\n    }\n\n    titleForFingerNumber (n) {\n        return \"&nbsp;\".repeat(26) + this.type() + \"&nbsp;\" + n + \"&nbsp;of&nbsp;\" + this.numberOfFingersDown() \n    }\n\n    showFingers () {\n        const points = this.pointsForEvent(this.currentEvent());\n        const idsToRemove = Object.keys(this.fingerViewDict()) // TODO: move to dict\n        let count = 1\n\n        points.forEach((point) => {\n            const id = point.id()\n            const v = this.viewForFingerId(id);\n            idsToRemove.remove(id) \n            const nx = point.x() - v.clientWidth()/2;\n            const ny = point.y() - v.clientHeight()/2;\n            v.setLeftPx(nx);\n            v.setTopPx(ny);\n            v.setInnerHtml(this.titleForFingerNumber(count))\n            v.setBorder(\"1px dashed white\")\n            if (this.isPressing()) {\n                v.setBorder(\"1px solid white\")\n                v.setColor(\"white\")\n            } else {\n                v.setBorder(\"1px dashed #888\")\n                v.setColor(\"#888\")\n            }\n            count ++\n        })\n\n        const fvd = this.fingerViewDict()\n        idsToRemove.forEach((id) => {\n            const fingerView = fvd[id]\n            assert(fingerView)\n            fingerView.removeFromParentView()\n            delete fvd[id]\n        })\n\n        return this\n    }\n\n    updateFingerViews () {\n        if (this.shouldShowVisualDebugger()) {\n            this.showFingers()\n        } else {            \n            this.removeFingerViews()\n        }\n\n        return this\n    }\n\n    updateDebugger () {\n        this.updateOutlineView() \n        this.updateFingerViews()\n        if (this.viewTarget()) {\n            console.log(this.viewTarget().typeId() + \".updateDebugger\")\n        }\n    }\n\n    updateDebuggerTimeoutName () {\n        return \"updateDebugger\"\n    }\n\n    updateDebuggerTimeoutSeconds () {\n        return 0.1\n    }\n\n    updateDebugTimer () {\n        const ms = this.updateDebuggerTimeoutSeconds() * 1000\n        this.addTimeout(() => this.updateDebugger(), ms, this.updateDebuggerTimeoutName())\n        return this\n    }\n\n    // down points\n\n    hasDownPointsInView () {\n        if (!this.viewTarget()) {\n            return false\n        }\n\n        const view = this.viewTarget();\n        const points = this.allDownPoints();\n        const match = points.detect(p => view.containsPoint(p)) \n        //console.log(\"all points.length:\", points.length, \" has match:\", match != null)\n        return match !== null\n    }\n\n    allPoints () { // TODO: some better abstraction for Touch+Mouse?\n        const points = []\n        points.appendItems(TouchScreen.shared().currentPoints())\n        points.appendItems(Mouse.shared().currentPoints())\n        return points\n    }\n\n    allDownPoints () { // TODO: some better abstraction for Touch+Mouse?\n        return this.allPoints().select(p => p.isDown())\n    }\n\n    shortTypeId () {\n        return this.typeId().replaceAll(\"GestureRecognizer\", \"\")\n    }\n\n    description () {\n        return this.shortTypeId() + \" on \" + (this.viewTarget() ? this.viewTarget().typeId() : \"null view target\")\n    }\n    \n}.initThisClass());\n\n",
  "DGaCh9E+v+/PNoI1Uf2XJEyiZ4ddlT+JpbmEwih8Deg=": "\"use strict\";\n\n/*\n\n    LongPressGestureRecognizer\n\n    Recognize a long press and hold in (roughly) one location.\n\n    Notes:\n\n        Should gesture cancel if press moves?:\n        \n            1. outside of a distance from start point or\n            2. outside of the view\n\n\n    Delegate messages:\n\n        onLongPressBegin\n        onLongPressComplete\n        onLongPressCancelled\n\n*/\n\n(class LongPressGestureRecognizer extends GestureRecognizer {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"timePeriod\", 500).setComment(\"milliseconds\")\n        this.newSlot(\"timeoutId\", null).setIsPrivate(true)\n    }\n\n    init () {\n        super.init()\n        this.setListenerClasses(this.defaultListenerClasses())\n        this.setIsDebugging(false) \n\n        this.setMinFingersRequired(1)\n        this.setMaxFingersAllowed(1)\n        this.setMinDistToBegin(null)\n        return this\n    }\n\n    // --- timer ---\n\n    startTimer () {\n        if (this.hasTimer()) {\n            this.stopTimer()\n        }\n\n        const tid = this.addTimeout(() => { this.onLongPress() }, this.timePeriod());\n        this.setTimeoutId(tid)\n        this.startDocListeners() // didFinish will stop listening\n        return this\n    }\n\n    stopTimer () {\n        if (this.hasTimer()) {\n            this.clearTimeout(this.timeoutId());\n            this.setTimeoutId(null)\n        }\n        return this\n    }\n\n    hasTimer () {\n        return this.timeoutId() !== null\n    }\n\n    // -- the completed gesture ---\n    \n    onLongPress () {\n        this.setTimeoutId(null)\n\n        if (this.currentEventIsOnTargetView()) {\n            if (this.requestActivationIfNeeded()) {\n                this.sendCompleteMessage()\n                this.didFinish()\n            }\n        } else {\n            this.cancel()\n        }\n    }\n\n    // -- single action for mouse and touch up/down ---\n\n    onDown (event) {\n        super.onDown(event)\n        \n        const isWithin = this.currentEventIsOnTargetView();\n\n        if (isWithin && \n            this.hasAcceptableFingerCount() && \n            !GestureManager.shared().hasActiveGesture()) {\n            this.startTimer()\n            this.sendBeginMessage()\n        }\n    }\n\n    onMove (event) {\n        super.onMove(event)\n    \n        if (this.hasTimer()) { // TODO: also check move distance?\n            if (this.currentEventIsOnTargetView()) {\n                this.setCurrentEvent(event)\n            } else {\n                this.cancel()\n            }\n        }\n\n    }\n\n    onUp (event) {\n        super.onUp(event)\n\n        if (this.hasTimer()) {\n            this.cancel()\n        }\n    }\n\n    cancel () {\n        if (this.hasTimer()) {\n            this.stopTimer()\n            this.sendCancelledMessage()\n            this.didFinish()\n        }\n        return this\n    }\n\n    /*\n\n    shouldCancel () {\n        return this.hasTimer()\n    }\n\n    willCancel () {\n        this.stopTimer()\n    }\n\n    didCancel () {\n        this.didFinish()\n    }\n    */\n    \n}.initThisClass());\n",
  "ozQ1a2Rz1jSpl88TyKufDp2Z6pe5nPqvFlRCeTmfjmM=": "\"use strict\";\n\n/*\n\n    SlideGestureRecognizer\n\n    This gets tricky as we need to follow movement outside the view.\n    To do this, we add special event move and up handlers to the document after getting\n    a down event and then remove them after the up event. \n    \n    We ignore the view's own move and up events.\n\n    Delegate messages :\n\n        onSlideBegin\n        onSlideMove\n        onSlideComplete\n        onSlideCancelled\n    \n    Gesture state info methods:\n\n        direction()\n        distance() \n        downPosInView()\n\n    TODO\n\n        make multitouch\n\n        optimization: floor the move event points and only send delegate messages if\n        new position is different from last?\n\n*/\n\n\n(class SlideGestureRecognizer extends GestureRecognizer {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"direction\", \"left\")\n        this.newSlot(\"validDirectionsDict\", { left: 1, right: 2, up: 3, down: 4 })\n        this.newSlot(\"maxPerpendicularDistToBegin\", 10) // will not begin if this is exceeded\n        //downPositionInTarget: null,\n    }\n\n    init () {\n        super.init()\n        this.setListenerClasses(this.defaultListenerClasses())     \n        this.setMinFingersRequired(1)\n        this.setMaxFingersAllowed(1)\n        this.setMinDistToBegin(10)\n        //this.setIsDebugging(false)\n        return this\n    }\n\n    setDirection (directionName) {\n        assert(this.validDirectionsDict().hasOwnProperty(directionName));\n        this._direction = directionName\n        return this\n    }\n\n    setNumberOfTouchesRequired (n) {\n        assert(n === 1) // need to add multi-touch support\n        this._numberOfTouchesRequired = n\n        return this\n    }\n\n    // --- events --------------------------------------------------------------------\n\n    onDown (event) {\n        super.onDown(event)\n\n        if (!this.isPressing()) {\n            if (this.hasAcceptableFingerCount()) {\n                this.setIsPressing(true)\n                this.setBeginEvent(event)\n                this.startDocListeners()\n            }\n        }\n    }\n\n    onMove (event) {\n        super.onMove(event)\n\n        if (this.isPressing()) {\n            if (!this.isActive() && this.hasMovedTooMuchPerpendicular()) {\n                this.cancel()\n                return this\n            }\n\n            if (!this.isActive() && this.hasMovedEnough()) {\n                if (this.requestActivationIfNeeded()) {\n                    //this.setIsActive(true)\n                    this.sendBeginMessage() // being\n                }\n            }\n        \n            if (this.isActive()) {\n                this.sendMoveMessage() // move\n            }\n        }\n    }\n\n    // -----------\n\n    onUp (event) {\n        super.onUp(event)\n\n        if (this.isPressing()) {\n            this.setIsPressing(false)\n            if (this.isActive()) {\n                this.sendCompleteMessage() // complete\n            }\n            this.finish()\n        }\n\n        return true\n    }\n\n    cancel () {\n        if (this.isActive()) {\n            this.sendCancelledMessage()\n        }\n        this.finish()\n        return this\n    }\n\n    finish () {\n        //this.debugLog(\".finish()\")\n        this.setIsPressing(false)\n        this.deactivate()\n        this.stopDocListeners()\n        this.didFinish()\n        return this\n    }\n\n    // ----------------------------------\n\n    hasMovedTooMuchPerpendicular () {\n        let m = this.maxPerpendicularDistToBegin()\n        let dp = this.diffPos()\n\n        let funcs = {\n            left: (dx, dy) => dy,\n            right: (dx, dy) => dy,\n            up: (dx, dy) => dx,\n            down: (dx, dy) => dx\n        }\n\n        let r = Math.abs(funcs[this.direction()](dp.x(), dp.y())) > m\n        return r\n    }\n\n    hasMovedEnough () {\n        let m = this.minDistToBegin()\n        let dp = this.diffPos()\n\n        let funcs = {\n            left: (dx, dy) => -dx,\n            right: (dx, dy) =>  dx,\n            up: (dx, dy) =>  dy,\n            down: (dx, dy) => -dy\n        }\n\n        let r = funcs[this.direction()](dp.x(), dp.y()) > m\n        return r\n    }\n\n    // --- helpers ----\n\n    diffPos () {\n        let cp = this.currentPosition()\n        let bp = this.beginPosition()\n\n        assert(cp)\n        assert(bp)\n        \n        let p = cp.subtract(bp).floorInPlace() // floor here?\n        let dx = p.x()\n        let dy = p.y()\n        let funcs = {\n            left: (p) => p.setX(Math.min(dx, 0)),\n            right: (p) => p.setX(Math.max(dx, 0)),\n            up: (p) => p.setY(Math.max(dy, 0)),\n            down: (p) => p.setY(Math.min(dy, 0))\n        }\n\n        funcs[this.direction()](p)\n        return p\n    }\n\n    distance () {\n        let p = this.diffPos()\n        let dx = p.x()\n        let dy = p.y()\n        let funcs = {\n            left: (dx, dy) => dx,\n            right: (dx, dy) => dx,\n            up: (dx, dy) => dy,\n            down: (dx, dy) => dy\n        }\n        return Math.abs(funcs[this.direction()](dx, dy))\n    }\n\n}.initThisClass());\n",
  "RrFcLmQqDRL6SgagveKJD4V/psUIOcBOTi29fWPsLyU=": "\"use strict\";\n\n/*\n\n    TapGestureRecognizer\n\n    Recognize a number of taps inside a viewTarget and within a maxHoldPeriod.\n        \n    On first tap for finger count, start timer. \n    If second tap for finger count occurs before it's expired, it's recognized. \n    Otherwise, restart timer.\n\n    Delegate messages:\n\n        onTapBegin\n        onTapComplete\n        onTapCancelled\n\n        Typically, delegate will ignore onTapBegin & onTapCancelled.\n\n    The names of the delegate messages can be specified. Example:\n\n        const tg = TapGestureRecognizer.clone()\n        tg.setNumberOfTapsRequired(2)\n        tg.setNumberOfFingersRequired(2)\n        tg.setGestureName(\"DoubleFingerDoubleTap\") // on recognize, will send a onDoubleFingerDoubleTapComplete() message\n        this.addGestureRecognizer(tg)\n\n*/\n\n(class TapGestureRecognizer extends GestureRecognizer {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"maxHoldPeriod\", 1000).setComment(\"milliseconds per tap down hold\")\n        this.newSlot(\"timeoutId\", null) // private\n        this.newSlot(\"numberOfTapsRequired\", 1)\n        this.newSlot(\"numberOfFingersRequired\", 1)\n        this.newSlot(\"tapCount\", 0)\n    }\n\n    init () {\n        super.init()\n        this.setListenerClasses(this.defaultListenerClasses())\n        this.setIsDebugging(false) \n        this.resetTapCount()\n        this.setShouldRequestActivation(false) // allow multiple tap targets?\n        this.setIsDebugging(false)\n        return this\n    }\n\n    resetTapCount () {\n        this.setTapCount(0)\n        return this\n    }\n\n    // --- timer ---\n\n    startTimer (event) {\n        if (this.timeoutId()) {\n            this.stopTimer()\n        }\n\n        const tid = this.addTimeout(() => this.cancel(), this.maxHoldPeriod());\n        this.setTimeoutId(tid)\n        return this\n    }\n\n    stopTimer () {\n        if (this.hasTimer()) {\n            this.clearTimeout(this.timeoutId());\n            this.setTimeoutId(null)\n            this.resetTapCount()\n        }\n        return this\n    }\n\n    hasTimer () {\n        return this.timeoutId() !== null\n    }\n\n    // -- single action for mouse and touch up/down ---\n\n    onDown (event) {\n        super.onDown(event)\n        \n        if (this.numberOfFingersDown() < this.numberOfFingersRequired()) {\n            return this\n        }\n\n        if (!this.hasTimer()) {\n            this.setTapCount(1)\n            this.startTimer()\n            this.sendBeginMessage() // begin\n        } else {\n            this.setTapCount(this.tapCount() + 1)\n        }\n\n        return true\n    }\n\n    onUp (event) {\n        super.onUp(event)\n \n        if (true || this.isDebugging()) {\n            this.debugLog(\".onUp()  tapCount:\" + this.tapCount() + \" viewTarget:\" + this.viewTarget().typeId())\n        }\n\n        if (this.hasTimer()) {\n            if (this.tapCount() === this.numberOfTapsRequired()) {\n                this.stopTimer()\n                this.complete()\n            }\n        } else {\n            //this.cancel()\n        }\n    }\n\n    // end states\n\n    complete () {\n        this.stopTimer()\n        if (this.requestActivationIfNeeded()) {\n            this.sendCompleteMessage() // complete\n        }\n    }\n\n    cancel () {\n        /*\n        if (this.isDebugging() && this.numberOfTapsRequired() === 2) {\n            debugger;\n        }\n        */\n\n        if (this.hasTimer()) {\n            this.stopTimer()\n            this.sendCancelledMessage() // cancelled\n        }\n        return this\n    }\n\n    /*\n    // was going to do some auto-naming but decided against it for now\n    // too many names for point tap count and number of fingers?\n    // 3 taps * 10 fingers?\n\n    incrementTapCountForFingerCount (n) {\n        const d = this.tapCountDict()\n        if (d.hasOwnProperty(n)) { \n            d.atPut(n, d.at(n)+1)\n        } else {\n            d.atPut(n, 1)\n        }\n        return this\n    }\n\n    nameForCount (n) {\n        if (n === 1) { return \"Single\" }\n        if (n === 2) { return \"Double\" }\n        if (n === 3) { return \"Triple\"; }\n        return n + \"x\"\n    }\n    beginMessageForCount (n) {\n        return \"on\" + this.nameForCount(n) + \"TapBegin\"\n    }\n\n    completeMessageForCount (n) {\n        return \"on\" + this.nameForCount(n) + \"TapComplete\"\n    }\n\n    cancelledMessageForCount (n) {\n        return \"on\" + this.nameForCount(n) + \"TapCancelled\"\n    }\n    */\n\n}.initThisClass());\n",
  "NGeQVI0XRvphCE6Wo0O/+GDN8DinY8wClgu/AaiVDCg=": "\"use strict\";\n\n/*\n\n    OrientGestureRecognizer\n\n    - on down, note 1st and 2nd fingers\n    - on move, use noted 1st and 2nd finger for pinch info\n        if either disappear, gesture ends\n\n    - track center point of 1st & 2nd finger for translation info\n\n    Delegate messages:\n\n        onOrientBegin\n        onOrientMove\n        onOrientComplete\n        onOrientCancelled\n\n    Helper methods:\n\n        points:\n            downPoints // initial 1st two fingers down\n            beginPoints // location (of 1st two fingers down) when gesture began\n            activePoints // current locations of the 1st two fingers down\n\n        position:\n            beginCenterPosition //  initial midpoint between 1st two fingers down\n            currentCenterPosition // current midpoint between 1st two fingers down\n            diffPosition // currentCenterPosition - beginCenterPosition\n\n        rotation:\n            activeAngleInDegress // current angle between 1st two fingers down\n            rotationInDegrees // difference between initial angle between 1st two fingers down and their current angle\n\n        scale:\n            scale // current distance between 1st to fingers down divided by their intitial distance  \n\n*/\n\n\n(class OrientGestureRecognizer extends GestureRecognizer {\n\n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setListenerClasses(this.defaultListenerClasses())\n\n        this.setMinFingersRequired(2)\n        this.setMaxFingersAllowed(4)\n        this.setMinDistToBegin(10)\n\n        this.setIsDebugging(false)\n        return this\n    }\n\n    // events\n\n    onDown (event) {\n        super.onDown(event)\n        //console.log(this.shortTypeId() + \".onDown() this.isPressing() = \", this.isPressing())\n\n        if (!this.isPressing()) {\n            const downCount = this.numberOfFingersDown()\n            if (downCount >= this.minFingersRequired() &&\n                downCount <= this.maxFingersAllowed()\n            ) {\n                this.setIsPressing(true)\n                //this.setBeginEvent(event)\n                this.startDocListeners()\n            }\n        }\n    }\n\n    /*\n    hasMovedEnough () {\n        // intended to be overridden by subclasses\n        // e.g. a rotation recognizer might look at how much first two fingers have rotated\n        const m = this.minDistToBegin()\n        const d = this.currentPosition().distanceFrom(this.downPosition())\n        return d >= m\n    }\n\n    hasAcceptableFingerCount () {\n        const n = this.numberOfFingersDown()\n        return  n >= this.minFingersRequired() &&\n                n <= this.maxFingersAllowed();\n    }\n\n    canBegin () {\n        return !this.isActive() && \n                this.hasMovedEnough() && \n                this.hasAcceptableFingerCount();\n    }\n    */\n\n    onMove (event) {\n        super.onMove(event)\n\n        if (this.isPressing()) {\n            if (this.canBegin()) {\n                if (this.requestActivationIfNeeded()) {\n                    this.sendBeginMessage()\n                }\n            }\n\n            if (this.activePoints().length < this.minFingersRequired()) {\n                this.onUp(event)\n                return\n            }\n\n            if (this.isActive()) {\n                if (this.activePoints().length >= this.minFingersRequired()) {\n                    this.sendMoveMessage()\n                } else {\n                    this.onUp(event)\n                }\n            }\n        }\n    }\n\n    // -----------\n\n    onUp (event) {\n        super.onUp(event)\n\n        if (this.isPressing()) {\n            this.setIsPressing(false)\n            if (this.isActive()) {\n                this.sendCompleteMessage()\n            }\n            this.didFinish()\n        }\n    }\n\n    cancel () {\n        if (this.isActive()) {\n            this.sendCancelledMessage()\n        }\n        this.didFinish()\n        return this\n    }\n\n    didFinish () {\n        super.didFinish()\n        this.setIsPressing(false)\n        this.deactivate()\n        this.stopDocListeners()\n        return this\n    }\n\n    // points - move to GestureRecognizer?\n\n    downPoints () {\n        const p = this.pointsForEvent(this.downEvent())\n        return [p[0], p[1]]\n    }\n\n    activeForEvent (event) {\n        // looks for two points whose id matchs those of the two down points\n        const points = this.pointsForEvent(event)\n        const ids = this.downPoints().map(p => p.id())\n        return points.select(p => ids.contains(p.id()))\n    }\n\n    beginPoints () {\n        return this.activeForEvent(this.beginEvent())\n    }\n\n    lastPoints () {\n        return this.activeForEvent(this.lastEvent())\n    }\n\n    activePoints () { // current points that were in down points\n        return this.activeForEvent(this.currentEvent())\n    }\n\n    // position\n\n    centerForPoints (p) {\n        return p[0].midpointTo(p[1])\n    }\n\n    downCenterPosition () {\n        return this.centerForPoints(this.downPoints())\n    }\n\n    beginCenterPosition () {\n        return this.centerForPoints(this.beginPoints())\n    }\n\n    currentCenterPosition () {\n        return this.centerForPoints(this.activePoints())\n    }\n\n    diffPosition () {\n        return this.currentCenterPosition().subtract(this.beginCenterPosition())\n    }\n\n    // rotation\n\n    angleInDegreesForPoints (p) {\n        return p[0].angleInDegreesTo(p[1])\n    }\n\n    downAngleInDegress () {\n        return this.angleInDegreesForPoints(this.downPoints())\n    }\n\n    beginAngleInDegress () {\n        return this.angleInDegreesForPoints(this.beginPoints())\n    }\n\n    activeAngleInDegress () {\n        return this.angleInDegreesForPoints(this.activePoints())\n    }\n\n    rotationInDegrees () {\n        // difference between initial angle between 1st two fingers down and their current angle\n        const a1 = this.beginAngleInDegress();\n        const a2 = this.activeAngleInDegress();\n        return a2 - a2;\n    }\n\n    // scale\n\n    spreadForPoints (p) {\n        return p[0].distanceFrom(p[1])\n    }\n\n    downSpread () {\n        // initial distance between first two fingers down\n        return this.spreadForPoints(this.downPoints())\n    }\n\n    beginSpread () {\n        // initial distance between first two fingers down\n        return this.spreadForPoints(this.beginPoints())\n    }\n\n    currentSpread () {\n        // current distance between first two fingers down\n        return this.spreadForPoints(this.activePoints())\n    }\n\n    spread () {\n        const s = this.currentSpread() - this.beginSpread();\n        //console.log(\"spread = \" + s + \" = \" + this.currentSpread() + \" - \" + this.beginSpread() )\n        return s\n    }\n\n    downSpreadX () {\n        const p = this.downPoints()\n        return Math.abs(p[0].x() - p[1].x())\n    }\n\n    downSpreadY () {\n        const p = this.downPoints()\n        return Math.abs(p[0].y() - p[1].y())\n    }\n\n    currentSpreadX () {\n        const p = this.activePoints()\n        return Math.abs(p[0].x() - p[1].x())\n    }\n\n    currentSpreadY () {\n        const p = this.activePoints()\n        return Math.abs(p[0].y() - p[1].y())\n    }\n\n    spreadX () {\n        return this.currentSpreadX() - this.downSpreadX()\n    }\n\n    spreadY () {\n        return this.currentSpreadY() - this.downSpreadY()\n    }\n\n    scale () {\n        const s = this.currentSpread() / this.beginSpread();\n        //console.log(\"scale = \" + s + \" = \" + this.currentSpread() + \"/\" + this.beginSpread() )\n        return s\n    }\n\n    // show\n\n    debugJson () {\n        const dp = this.diffPosition()\n        return {\n            id: this.typeId(),\n            dx: dp.x(),\n            dy: dp.y(),\n            scale: this.scale(),\n            rotation: this.rotationInDegrees()\n        }\n    }\n\n    show () {\n        console.log(this.debugJson())\n    }\n\n}.initThisClass());\n",
  "umzAleefIg7sRWwUPbwPRtqJxJubj0oYVcBE1eS90O4=": "\"use strict\";\n\n/*\n\n    PanGestureRecognizer\n\n    Gesture begins when the minimal number of fingers have moved the minimal distance.\n    Will requestActive before beginning.\n\n    Delegate messages:\n\n        onPanBegin\n        onPanMove\n        onPanComplete\n        onPanCancelled\n\n*/\n\n(class PanGestureRecognizer extends GestureRecognizer {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"minNumberOfFingersRequired\", 1)\n        this.newSlot(\"maxNumberOfFingersAllowed\", 1)\n        //downPositionInTarget: null,\n    }\n\n    init () {\n        super.init()\n        this.setListenerClasses(this.defaultListenerClasses()) \n        //this.setIsDebugging(false)\n        return this\n    }\n\n    // --- events --------------------------------------------------------------------\n\n    // tap events\n\n    hasOkFingerCount () {\n        const n = this.numberOfFingersDown()\n        const min = this.minNumberOfFingersRequired()\n        const max = this.maxNumberOfFingersAllowed()\n        return (n >= min && n <= max)\n    }\n\n    isReadyToBegin () {\n        return this.hasOkFingerCount();\n    }\n\n    doPress (event) { \n        this.debugLog(\"doPress\")\n        this.setIsPressing(true)\n        this.setDownEvent(event)\n        this.startDocListeners()\n        return this\n    }\n\n    onDown (event) {\n        super.onDown(event)\n\n        if (!this.isPressing()) {\n            if (this.isReadyToBegin()) {\n                this.doPress(event)\n            }\n        }\n        \n        return this\n    }\n\n    attemptBegin () {\n        this.debugLog(\"attemptBegin\")\n\n        if (!this.doesTargetAccept()) {\n            return;\n        }\n\n        if (this.requestActivationIfNeeded()) {\n            this.sendBeginMessage() // begin\n        } else {\n            if (this.isDebugging()) {\n                console.log(this.shortTypeId() + \".attemptBegin() FAILED\")\n            }\n        }\n    }\n\n    onMouseMoveCapture (event) { // tmp for debugging dragview\n        this.debugLog(\"onMouseMoveCapture\")\n        super.onMouseMoveCapture(event)\n    }\n\n    onMove (event) {\n        super.onMove(event)\n\n        if (this.isPressing()) {\n            if (this.isActive()) {\n                this.sendMoveMessage() // move\n            } else {\n                if (this.hasMovedEnough()) {\n                    this.attemptBegin()\n                }\n            }\n        }\n        return this\n    }\n\n    onUp (event) {\n        super.onUp(event)\n\n        if (this.isPressing()) {\n            if (this.isActive()) {\n                this.sendCompleteMessage() // complete\n            }\n            this.didFinish() // will set isPressing to false\n        }\n        return this\n    }\n\n    // ----------------------------------\n\n    cancel () {\n        if (this.isActive()) {\n            this.sendCancelledMessage()\n        }\n        this.didFinish()\n        return this\n    }\n\n    didFinish () {\n        super.didFinish()\n        this.setIsPressing(false)\n        this.stopDocListeners()\n        return this\n    }\n\n    // ----------------------------------\n\n    hasMovedEnough () {\n        const m = this.minDistToBegin()\n        const d = this.currentPosition().distanceFrom(this.downPosition())\n        return d >= m\n    }\n\n    distance () {\n        return this.currentPosition().distanceFrom(this.beginPosition())\n    }\n\n}.initThisClass());\n",
  "S0jthWAFfu4k7kyMMcfbNsnwysrehhGFvDJqUw8FwyE=": "\"use strict\";\n\n/*\n\n    PinchGestureRecognizer\n\n    Subclass of OrientGestureRecognizer that overrides hasMovedEnough() to \n    check for minDistToBegin.\n\n    Delegate messages:\n\n        onPinchBegin\n        onPinchMove\n        onPinchComplete\n        onPinchCancelled\n\n    Helper methods:\n\n        scale:\n            scale // current distance between 1st to fingers down divided by their intitial distance  \n\n*/\n\n\n(class PinchGestureRecognizer extends GestureRecognizer {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setListenerClasses(this.defaultListenerClasses()) \n        //this.setIsDebugging(false)\n        //this.setIsVisualDebugging(true)\n        this.setMinFingersRequired(2)\n        this.setMaxFingersAllowed(2)\n        return this\n    }\n\n    hasMovedEnough () {\n        const m = this.minDistToBegin()\n        const d = this.currentPosition().distanceFrom(this.downPosition())\n        //console.log(this.shortTypeId() + \".hasMovedEnough() \" + d + \">= min \" + m)\n        return d >= m\n    }\n    \n}.initThisClass());\n",
  "6FEkfVWeG/zJiHi1NhImO7Xmt1/0f8ICmKKHJOP/klY=": "\"use strict\";\n\n/*\n\n    RotationGestureRecognizer\n\n    Overrides OrientGestureRecognizer's hasMovedEnough() method to \n    check for minRotationInDegreesToBegin.\n    \n    Delegate messages:\n\n        onRotationBegin\n        onRotationMove\n        onRotationComplete\n        onRotationCancelled\n\n    Helper methods:\n    \n        rotation:\n            activeAngleInDegress // current angle between 1st two fingers down\n            rotationInDegrees // difference between initial angle between 1st two fingers down and their current angle\n\n*/\n\n(class RotationGestureRecognizer extends GestureRecognizer {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setListenerClasses(this.defaultListenerClasses()) \n        this.setIsDebugging(false)\n        return this\n    }\n\n    hasMovedEnough () {\n        const ma = this.minRotatationInDegreesToBegin()\n        const a = this.activeAngleInDegress()\n        return a >= ma\n    }\n    \n}.initThisClass());\n",
  "s6k8LgEAcG4cut1oKb4vBPsrUnRA4W4GZBPD4axXTM8=": "\"use strict\";\n\n/*\n\n    EdgePanGestureRecognizer\n\n    Subclass of PanGestureRecognizer that limits pan detection to gestures starting at the edge fo the view. \n    Don't use this class directed - instead use it's subclass for the edge you're interested in.\n\n    Delegate messages:\n\n        onEdgePanBegin\n        onEdgePanMove\n        onEdgePanComplete\n        onEdgePanCancelled\n        \n*/\n\n(class EdgePanGestureRecognizer extends PanGestureRecognizer {\n\n    initPrototypeSlots () {\n        this.newSlot(\"edgeName\", null)\n        this.newSlot(\"maxStartDistance\", 15)\n    }\n\n    init () {\n        super.init()\n        this.setListenerClasses(this.defaultListenerClasses())\n        this.setMinDistToBegin(5)\n        this.setIsDebugging(false)\n        return this\n    }\n\n    start () {\n        return super.start()\n    }\n\n    /*\n    start () {\n        this.startDocListeners() // only want to listen to the document\n        // TODO: do we always want to listen outside the view? \n        // is listening only inside both more efficient and good enough?\n        return this\n    }\n    */\n\n    // --- events --------------------------------------------------------------------\n\n    /*\n    didFinish () {\n        super.didFinish()\n        this.setIsPressing(false)\n        this.stopDocListeners()\n        return this\n    }\n    */\n\n    /*\n    onDown (event) {\n        super.onDown(event)\n\n        if (this.isReadyToBegin()) {\n            this.doPress(event)\n        }\n\n        return this\n    }\n    */\n\n\n    isReadyToBegin () {\n        return this.hasOkFingerCount() &&\n            this.distanceFromEdge() <= this.maxStartDistance();\n    }\n\n    distanceFromEdge () {\n        const name = this.edgeName()\n        //assert(name)\n        const d = this.currentEdgeDistances()[name]\n        //assertDefined(d)\n        //console.log(\"distanceFromEdge \", d)\n        return d\n    }\n\n    // -------------\n\n    maxEdgeDistance () {\n        return 100000\n    }\n\n    currentEdgeDistances () {\n        const max = this.maxEdgeDistance()\n        const points = this.allPoints() // event points are in document coordinates\n        const vt = this.viewTarget()\n\n        if (!vt) {\n            this.debugLog(\" missing viewTarget\")\n            return max\n        }\n\n        const f = vt.frameInDocument()\n\n        // use maxValue to make sure all fingers are close to the edge\n\n        return {\n            top: points.maxValue(p => Math.abs(f.top() - p.y()), max),\n            bottom: points.maxValue(p => Math.abs(f.bottom() - p.y()), max),\n            left: points.maxValue(p => Math.abs(f.left() - p.x()), max),\n            right: points.maxValue(p => Math.abs(f.right() - p.x()), max)\n        }\n    }\n\n}.initThisClass());\n",
  "QfJFJotghltLKd/EYTBf1797XFiYhGBqo09jdyORh8U=": "\"use strict\";\n\n/*\n\n    TopEdgePanGestureRecognizer\n\n    Delegate messages:\n\n        onTopEdgePanBegin\n        onTopEdgePanMove\n        onTopEdgePanComplete\n        onTopEdgePanCancelled\n\n*/\n\n(class TopEdgePanGestureRecognizer extends EdgePanGestureRecognizer {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setEdgeName(\"top\")\n        return this\n    }\n\n}.initThisClass());\n",
  "WK4fW8n6Oqe01fZkLDSIStAQTvZbU1Zkmo3DRKphhpU=": "\"use strict\";\n\n/*\n\n    BottomEdgePanGestureRecognizer\n\n    Delegate messages:\n\n        onBottomEdgePanBegin\n        onBottomEdgePanMove\n        onBottomEdgePanComplete\n        onBottomEdgePanCancelled\n\n*/\n\n(class BottomEdgePanGestureRecognizer extends EdgePanGestureRecognizer {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setEdgeName(\"bottom\")\n        this.setIsDebugging(false)\n        return this\n    }\n    \n    \n}.initThisClass());\n",
  "oyrM9tiQ1+JeMaPQN0cvRShW0wlwgzoimu/YKUqLrhA=": "\"use strict\";\n\n/*\n\n    LeftEdgePanGestureRecognizer\n\n    Delegate messages:\n\n        onLeftEdgePanBegin\n        onLeftEdgePanMove\n        onLeftEdgePanComplete\n        onLeftEdgePanCancelled\n\n*/\n\n(class LeftEdgePanGestureRecognizer extends EdgePanGestureRecognizer {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setEdgeName(\"left\")\n        return this\n    }\n\n}.initThisClass());\n",
  "bPllA5BIds/fgVy4zVyPnvefQx3B34nGKro4j6S7gfY=": "\"use strict\";\n\n/*\n\n    RightEdgePanGestureRecognizer\n\n    Delegate messages:\n\n        onRightEdgePanBegin\n        onRightEdgePanMove\n        onRightEdgePanComplete\n        onRightEdgePanCancelled\n\n*/\n\n(class RightEdgePanGestureRecognizer extends EdgePanGestureRecognizer {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setEdgeName(\"right\")\n        return this\n    }\n\n}.initThisClass());\n",
  "K8Qbgw+Yt8HTomgWjOxNDtS02wbdH/DqTwHTY/R/BnI=": "\"use strict\";\n\n/*\n\n    ScreenEdgePanGestureRecognizer\n\n    Subclass of PanGestureRecognizer that limits pan detection to gestures starting at the edge. \n    Don't use this class directly - instead use it's subclass for the edge you're interested in.\n\n    Delegate messages:\n\n        onScreenEdgePanBegin\n        onScreenEdgePanMove\n        onScreenEdgePanComplete\n        onScreenEdgePanCancelled\n\n\n    for distance, ask the target for it's frameInViewport and compare with\n    event's posInWindow:\n\n        const frame = target.frameInDocument()\n        frame.top()\n        frame.bottom()\n        frame.left()\n        frame.right()\n        \n*/\n\n(class ScreenEdgePanGestureRecognizer extends PanGestureRecognizer {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"edgeName\", null)\n        this.newSlot(\"maxStartDistance\", 15)\n    }\n\n    init () {\n        super.init()\n        this.setListenerClasses(this.defaultListenerClasses()) \n        this.setMinDistToBegin(5)\n        this.setIsDebugging(false)\n        return this\n    }\n\n    start () {\n        this.startDocListeners() // only want to listen to the document\n        return this\n    }\n\n    // --- events --------------------------------------------------------------------\n\n    didFinish () {\n        super.didFinish()\n        this.setIsPressing(false)\n        //this.stopDocListeners()\n        return this\n    }\n\n    isReadyToBegin () {\n        return this.hasOkFingerCount() &&\n                this.distanceFromEdge() <= this.maxStartDistance();\n    }\n\n    distanceFromEdge () {\n        const name = this.edgeName()\n        assert(name)\n        const d = this.currentEdgeDistances()[name]\n        assertDefined(d)\n        return d\n    }\n\n    // -------------\n\n    maxEdgeDistance () {\n        return 100000\n    }\n\n    currentEdgeDistances () {\n        const max = this.maxEdgeDistance()\n        const points = this.allPoints()\n        return {\n            top:    points.minValue(p => p.distFromTopOfViewport(),    max),\n            bottom: points.minValue(p => p.distFromBottomOfViewport(), max),\n            left:   points.minValue(p => p.distFromLeftOfViewport(),   max),\n            right:  points.minValue(p => p.distFromRightOfViewport(),  max)\n        }\n    }\n    \n}.initThisClass());\n",
  "DALpc8UEiMkQr6+Hax9dYaummT+O3UeZj4N3SdUmPIw=": "\"use strict\";\n\n/*\n\n    ScreenTopEdgePanGestureRecognizer\n\n    Delegate messages:\n\n        onScreenTopEdgePanBegin\n        onScreenTopEdgePanMove\n        onScreenTopEdgePanComplete\n        onScreenTopEdgePanCancelled\n\n*/\n\n(class ScreenTopEdgePanGestureRecognizer extends ScreenEdgePanGestureRecognizer {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        this.setEdgeName(\"top\")\n        return this\n    }\n\n}.initThisClass());\n",
  "dyqDMtv3bsuatvZWNaseAJ9mzw+MGUPTGeQhDLJp3AE=": "\"use strict\";\n\n/*\n\n    ScreenBottomEdgePanGestureRecognizer\n\n    Delegate messages:\n\n        onScreenBottomEdgePanBegin\n        onScreenBottomEdgePanMove\n        onScreenBottomEdgePanComplete\n        onScreenBottomEdgePanCancelled\n\n*/\n\n(class ScreenBottomEdgePanGestureRecognizer extends ScreenEdgePanGestureRecognizer {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setEdgeName(\"bottom\")\n        return this\n    }\n\n}.initThisClass());\n",
  "abwOwpklY3t1zh03lBf6cIxfJ6hwkTRK3J7HowHYxIU=": "\"use strict\";\n\n/*\n\n    ScreenLeftEdgePanGestureRecognizer\n\n    Delegate messages:\n\n        onScreenLeftEdgePanBegin\n        onScreenLeftEdgePanMove\n        onScreenLeftEdgePanComplete\n        onScreenLeftEdgePanCancelled\n\n*/\n\n(class ScreenLeftEdgePanGestureRecognizer extends ScreenEdgePanGestureRecognizer {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setEdgeName(\"left\")\n        return this\n    }\n\n}.initThisClass());\n",
  "h3JqGOsu93iJzNlAuX/gdPpLkMCi50pxizbGKeHjUsA=": "\"use strict\";\n\n/*\n\n    ScreenRightEdgePanGestureRecognizer\n\n    Delegate messages:\n\n        onScreenRightEdgePanBegin\n        onScreenRightEdgePanMove\n        onScreenRightEdgePanComplete\n        onScreenRightEdgePanCancelled\n\n*/\n\n(class ScreenRightEdgePanGestureRecognizer extends ScreenEdgePanGestureRecognizer {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setEdgeName(\"right\")\n        return this\n    }\n\n}.initThisClass());\n",
  "/l5Kzz3RJpCNA5loeswbk8w5ejdCxv8Q6Kw2j1a8Ygo=": "\"use strict\";\n\n/*\n\n    WebBrowserScreen\n\n*/\n\n(class WebBrowserScreen extends ProtoClass {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        assert(!this.thisClass().hasShared()) // enforce singleton\n        super.init()\n    }\n\n    width () {\n        return screen.width\n    }\n\n    height () {\n        return screen.height\n    }\n    \n    aspectRatio () {\n        return this.width() / this.height()\n    }\n    \n    isRotated () { // screen aspect doesn't match window (only works on mobile)\n        const a = this.aspectRatio() > 1 \n        const b = WebBrowserWindow.shared().aspectRatio() > 1\n        return a !== b && WebBrowserWindow.shared().isOnMobile()\n    }\n    \n    orientedWidth () {\n        return this.isRotated() ? this.height() : this.width()\n    }\n    \n    orientedHeight () {\n        return this.isRotated() ? this.width() : this.height()\n    }\n        \n    show () {\n        this.debugLog(\" size \" + this.width() + \"x\" + this.height())\n    }\n\n    lesserOrientedSize () {\n        // lesser of window and oriented screen size\n        const w = Math.min(this.orientedWidth(), WebBrowserWindow.shared().width())\n        const h = Math.min(this.orientedHeight(), WebBrowserWindow.shared().height())\n        return { width: w, height: h }\n    }\n\n    userPrefersDarkMode () {\n        // should we add a timer to monitor this value and post notifications on changes?\n        // how about an NoteMonitor object that does this? example:\n        // const m = NoteMonitor.clone().setTarget(this).setMethod(\"userPrefersDarkMode\")\n        // m.setName(\"didChangeDarkMode\").setPeriodInSeconds(1).start()\n        const prefersDark = window.matchMedia && window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n        return prefersDark\n    }\n\n}.initThisClass());\n\n",
  "ozrNG1/a35jDmUk8fHTcMoLmvK6pGGOUAKuG0pjq5Nc=": "\"use strict\";\n\n/*\n\n    WebBrowserWindow\n\n    Abstraction for the main web browser window. \n    Owns a DocumentBody view.\n\n*/\n\n(class WebBrowserWindow extends ProtoClass {\n    \n    initPrototypeSlots () {\n    }\n    \n    init () {\n        //throw new Error(\"this class is meant to be used as singleton, for now\")\n        super.init()\n        //this.showAgent()\n        return this\n    }\n\n    documentBody () {\n        return DocumentBody.shared()\n    }\n    \n    /*  \n    electronWindow () {\n        if (!this._electronWindow) {\n            const remote = require(\"electron\").remote;\n            this._electronWindow = remote.getCurrentWindow()\n        }\n        return this._electronWindow\n    }\n    */\n\t\n    // attributes\n    \n    width () {\n        return window.innerWidth\n    }\n\n    height () {\n        return window.innerHeight\n    }\n    \n    aspectRatio () {\n        return this.width() / this.height()\n    }\n    \n    setWidth (w) {\n        console.warn(\"warning: WebBrowserWindow.setWidth() unavailable in browser\")\n        return this\n    }\n    \n    setHeight (h) {\n        console.warn(\"warning: WebBrowserWindow.setHeight() unavailable in browser\")\n        return this\n    }\n    \n    show () {\n        console.log(\"Window size \" + this.width() + \"x\" + this.height())\n    }\n\n    showAgent () {\n        console.log(\"navigator.userAgent = \", navigator.userAgent);\n        console.log(\"   agentIsSafari: \", this.agentIsSafari())\n        console.log(\"   agentIsChrome: \", this.agentIsChrome())\n        console.log(\"  agentIsFirefox: \", this.agentIsFirefox())\n        console.log(\"      isOnMobile: \", this.isOnMobile())\n        console.log(\"   isTouchDevice: \", this.isTouchDevice())\n    }\n    \n    mobileNames () {\n        return [\"android\", \"webos\", \"iphone\", \"ipad\", \"ipod\", \"blackBerry\", \"windows phone\"]  \n    }\n\n    agent () {\n        return navigator.userAgent.toLowerCase()\n    }\n\n    vendor () {\n        return navigator.vendor.toLowerCase()\n    }\n\n    agentIsFirefox () {\n        const agent = navigator.userAgent;\n        return agent.contains(\"Firefox\")\n    }\n\n    agentIsSafari () {\n        const vendor = navigator.vendor;\n        const agent = navigator.userAgent;\n        \n        const isSafari = !Type.isNullOrUndefined(vendor) && \n                vendor.contains(\"Apple\") &&\n                !Type.isNullOrUndefined(agent) &&\n                !agent.contains(\"CriOS\") &&\n                !agent.contains(\"FxiOS\");\n        return isSafari\n    }\n\n    agentIsChrome () {\n        const isChrome = Boolean(window.chrome) //&& \n        //!navigator.userAgent.contains('Brave');\n        //console.log(\"window.chrome = \", window.chrome);\n        return isChrome\n    }\n    \n    isOnMobile () { \n        const agent = this.agent();\n        const match = this.mobileNames().detect((name) => { return agent.contains(name); })\n        return match !== null\n    }\n\n    isTouchDevice () {\n        //return TouchScreen.shared().isSupported()\n\n        // via https://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript\n        let result = false \n        if (\"ontouchstart\" in window) { result = true; }        // works on most browsers \n        if (navigator.maxTouchPoints) { result = true; }       // works on IE10/11 and Surface\t\n        //console.log(\"WebBrowserWindow.isTouchDevice() = \", result)\n        return result\n    }\n\n    urlHash () {\n        return decodeURI(window.location.hash.substr(1)) // return string after # character\n    }\n    \n    setUrlHash (aString) {\n        if (this.urlHash() !== aString) {\n            window.location.hash = encodeURI(aString)\n            //console.log(\"window.location.hash = [\" + window.location.hash + \"]\")\n        }\n        return this\n    }\n    \n    descriptionDict () {\n        const dict = {\n            agent: this.agent(),\n            size: this.width() + \"x\" + this.height(),\n            isOnMobile: this.isOnMobile()\n        }\n        return dict\n    }\n\n    urlHostname () {\n        const parser = document.createElement(\"a\")\n        parser.href = window.location.href\n        let name = parser.hostname\n        if (!name) {\n\t\t    name = \"\"\n        }\n        return name\n    }\n\t\n    setTitle (aName) {\n        document.title = aName\n        return this\n    }\n\n    title () {\n        return document.title\n    }\n    \n    activeDomView () {\n        const e = document.activeElement\n        if (e && e.domView()) {\n            return e.domView()\n        }\n        return null\n    }\n\n}.initThisClass());\n\n\n",
  "74pVbQpWt+LUZ0xHWuefWDqEAV11P1rLjIXH6WDU5wc=": "\"use strict\";\n\n/*\n\n    WebBrowserNotifications\n\n    Simple interface to browser notifications. Takes care of:\n    - only checking for permissions once\n    - sending any waiting notifications after permission is gained\n    - notification timeouts\n\n    Todo: \n    - support for multiple waiting notes? waiting note limit\n    - add any abstractions specific to special Chrome/Android notifications\n\n    example use:\n\n    WebBrowserNotifications.shared().newNote().setTitle(\"hello\").setBody(\"...\").tryToPost()\n\n*/\n\n\n(class WebBrowserNotifications extends ProtoClass {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"permissionRequestResult\", null)\n        this.newSlot(\"waitingNote\", null)\n    }\n\n    /*\n    init () {\n        super.init()\n        //throw new Error(\"this class is meant to be used as singleton, for now\")\n        return this\n    }\n    */\n\n    hasPermission () {\n        return this.permissionRequestResult() === \"granted\"\n    }\n\n    wasDenied () {\n        return this.permissionRequestResult() === \"denied\"\n    }\n\n    hasAskedForPermission () {\n        return this.permissionRequestResult() !== null\n    }\n\n    requestPermissionIfNeeded () {\n        if (!this.hasAskedForPermission()) {\n            this.requestPermission()\n        }\n        return this\n    }\n\n    requestPermission () {\n        Notification.requestPermission().then((result) => {\n            this.setPermissionRequestResult(result)\n            console.log(\"requestPermission:\", result);\n            this.postWaitingNotes()\n        });\n        Notification.requestPermission();\n    }\n\n    isSupported () {\n        return window.hasOwnProperty(\"Notification\")\n    }\n\n    postNote (aNote) {\n        this.setWaitingNote(aNote)\n\n        if (!this.isSupported()) {\n            return this\n        }\n\n        this.requestPermissionIfNeeded() // will call this.postWaitingNotes()\n\n        if (this.hasPermission()) {\n            this.postWaitingNotes()\n        }\n\n        return this\n    }\n\n    postWaitingNotes () {\n        if (this.waitingNote()) {\n            this.waitingNote().tryToPost()\n            this.setWaitingNote(null)\n        }\n        return this\n    }\n\n    newNote () {\n        return WebBrowserNotification.clone()\n    }\n    \n}.initThisClass());\n\n",
  "gb57Mrawo0rE0hoRCTAzYpkfZICHS4hQuisw1GJ5hlw=": "\"use strict\";\n\n/*\n\n    WebBrowserNotification\n\n\n*/\n\n(class WebBrowserNotification extends ProtoClass {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"title\", \"\")\n        this.newSlot(\"body\", null)\n        this.newSlot(\"icon\", null).setComment(\"a url to an image\")\n        this.newSlot(\"notificationRef\", null)\n        this.newSlot(\"timeoutMs\", 4000)\n    }\n\n    /*\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n    tryToPost () {\n        WebBrowserNotifications.postNote(this)\n        return this\n    }\n\n    justPost () {\n        const note = new Notification(this.title(), { body: this.body(), icon: this.icon() });\n        this.setNotificationRef(note)\n        this.startTimeout()\n        return this\n    }\n\n    startTimeout () {\n        this.addTimeout(notification.close.bind(this.notificationRef()), this.timeoutMs());\n    }\n\n}.initThisClass());\n\n\n\n",
  "HvDi1jhO0zGdTSyHg6htCfpDyvc8vGQdXlrrH5DZQlw=": "\"use strict\";\n\n/*\n\n    WebDocument\n\n    Abstraction for web document object.\n\n*/\n\n(class WebDocument extends ProtoClass {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    body () {\n        return DocumentBody.shared()\n    }\n\n    styleSheets () {\n        const elements = document.styleSheets;\n        const sheets = []\n\n        for (let i = 0; i < elements.length; i ++) {\n            const sheetElement = elements[i];\n            sheets.push(StyleSheet.clone().setSheetElement(sheetElement))\n        }\n\n        return sheets\n    }\n\n    show () {\n        this.debugLog(\":\")\n        this.styleSheets().forEach(sheet => sheet.show())\n    }\n\n}.initThisClass());",
  "GqEFpSR84NxgLaXhKlZzTK79FTjFIulARBC3FtI169c=": "\"use strict\";\n\n/*\n\n    BMStyleSheet\n\n    const sheet = DocumentBody.shared().styleSheets().first()\n    sheet.setSelectorProperty(\"body\", \"color\", \"red\")\n*/\n\n(class BMStyleSheet extends ProtoClass {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"sheetElement\", null)\n    }\n\n    /*\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n    href () {\n        return this.sheetElement().href\n    }\n\n    changeStylesheetRule (selector, property, value) {\n        const sheet = this.sheetElement()\n\n        selector = selector.toLowerCase();\n        property = property.toLowerCase();\n        value = value.toLowerCase(); // assumed to be a string?\n\n        // Change it if it exists\n        for(let i = 0; i < sheet.cssRules.length; i++) {\n            const rule = sheet.cssRules[i];\n            if (rule.selectorText === selector) {\n                rule.style[property] = value;\n                return this;\n            }\n        }\n\n        // Add it if it does not\n        sheet.insertRule(selector + \" { \" + property + \": \" + value + \"; }\", 0);\n        return this;\n    }\n\n    show () {\n        console.log(\"sheetElement:\", this.sheetElement())\n    }\n\n}.initThisClass());\n\n",
  "3a6PpzEQOtQc8GhMzxsBxbRd2RWdd0ctJOlNugejzwM=": "\"use strict\";\n\n/*\n\n    ThrashDetector\n\n    The DOM can be slow if (layout dependent) read and (layout modifying) write operations are interleaved,\n    as the read will require a re-layout or \"reflow\" of the DOM rendering engine.\n\n    This detector helps minimize this issue by warning when interleaving is detected.\n\n    When possible, it's best to do all read operations first, then do any write operations\n    as this allows for a single reflow of the DOM at the end of the frame.\n\n    USE:\n\n    When doing DOM Node reads, call:\n\n        ThrashDetector.shared().didRead(\"opName\")\n\n    and on DOM Node writes, call:\n\n        ThrashDetector.shared().didWrite(\"opName\")\n\n    NOTES:\n\n    See:\n    What forces layout / reflow\n    https://gist.github.com/paulirish/5d52fb081b3570c81e3a\n\n    All style properties:\n    this.newSlot(\"styleProperties\", new Set(\n                \"color\",\n                \"border\",\n                \"margin\",\n                \"font-style\",\n                \"transform\",\n                \"background-color\",\n                \"align-content\",\n                \"align-items\",\n                \"align-self\",\n                \"all\",\n                \"animation\",\n                \"animation-delay\",\n                \"animation-direction\",\n                \"animation-duration\",\n                \"animation-fill-mode\",\n                \"animation-iteration-count\",\n                \"animation-name\",\n                \"animation-play-state\",\n                \"animation-timing-function\",\n                \"backface-visibility\",\n                \"background\",\n                \"background-attachment\",\n                \"background-blend-mode\",\n                \"background-clip\",\n                \"background-color\",\n                \"background-image\",\n                \"background-origin\",\n                \"background-position\",\n                \"background-repeat\",\n                \"background-size\",\n                \"border\",\n                \"border-bottom\",\n                \"border-bottom-color\",\n                \"border-bottom-left-radius\",\n                \"border-bottom-right-radius\",\n                \"border-bottom-style\",\n                \"border-bottom-width\",\n                \"border-collapse\",\n                \"border-color\",\n                \"border-image\",\n                \"border-image-outset\",\n                \"border-image-repeat\",\n                \"border-image-slice\",\n                \"border-image-source\",\n                \"border-image-width\",\n                \"border-left\",\n                \"border-left-color\",\n                \"border-left-style\",\n                \"border-left-width\",\n                \"border-radius\",\n                \"border-right\",\n                \"border-right-color\",\n                \"border-right-style\",\n                \"border-right-width\",\n                \"border-spacing\",\n                \"border-style\",\n                \"border-top\",\n                \"border-top-color\",\n                \"border-top-left-radius\",\n                \"border-top-right-radius\",\n                \"border-top-style\",\n                \"border-top-width\",\n                \"border-width\",\n                \"bottom\",\n                \"box-shadow\",\n                \"box-sizing\",\n                \"caption-side\",\n                \"caret-color\",\n                \"@charset\",\n                \"clear\",\n                \"clip\",\n                \"clip-path\",\n                \"color\",\n                \"column-count\",\n                \"column-fill\",\n                \"column-gap\",\n                \"column-rule\",\n                \"column-rule-color\",\n                \"column-rule-style\",\n                \"column-rule-width\",\n                \"column-span\",\n                \"column-width\",\n                \"columns\",\n                \"content\",\n                \"counter-increment\",\n                \"counter-reset\",\n                \"cursor\",\n                \"direction\",\n                \"display\",\n                \"empty-cells\",\n                \"filter\",\n                \"flex\",\n                \"flex-basis\",\n                \"flex-direction\",\n                \"flex-flow\",\n                \"flex-grow\",\n                \"flex-shrink\",\n                \"flex-wrap\",\n                \"float\",\n                \"font\",\n                \"@font-face\",\n                \"font-family\",\n                \"font-kerning\",\n                \"font-size\",\n                \"font-size-adjust\",\n                \"font-stretch\",\n                \"font-style\",\n                \"font-variant\",\n                \"font-weight\",\n                \"grid\",\n                \"grid-area\",\n                \"grid-auto-columns\",\n                \"grid-auto-flow\",\n                \"grid-auto-rows\",\n                \"grid-column\",\n                \"grid-column-end\",\n                \"grid-column-gap\",\n                \"grid-column-start\",\n                \"grid-gap\",\n                \"grid-row\",\n                \"grid-row-end\",\n                \"grid-row-gap\",\n                \"grid-row-start\",\n                \"grid-template\",\n                \"grid-template-areas\",\n                \"grid-template-columns\",\n                \"grid-template-rows\",\n                \"height\",\n                \"hyphens\",\n                \"@import\",\n                \"justify-content\",\n                \"@keyframes\",\n                \"left\",\n                \"letter-spacing\",\n                \"line-height\",\n                \"list-style\",\n                \"list-style-image\",\n                \"list-style-position\",\n                \"list-style-type\",\n                \"margin\",\n                \"margin-bottom\",\n                \"margin-left\",\n                \"margin-right\",\n                \"margin-top\",\n                \"max-height\",\n                \"max-width\",\n                \"@media\",\n                \"min-height\",\n                \"min-width\",\n                \"object-fit\",\n                \"object-position\",\n                \"opacity\",\n                \"order\",\n                \"outline\",\n                \"outline-color\",\n                \"outline-offset\",\n                \"outline-style\",\n                \"outline-width\",\n                \"overflow\",\n                \"overflow-x\",\n                \"overflow-y\",\n                \"padding\",\n                \"padding-bottom\",\n                \"padding-left\",\n                \"padding-right\",\n                \"padding-top\",\n                \"page-break-after\",\n                \"page-break-before\",\n                \"page-break-inside\",\n                \"perspective\",\n                \"perspective-origin\",\n                \"pointer-events\",\n                \"position\",\n                \"quotes\",\n                \"right\",\n                \"scroll-behavior\",\n                \"table-layout\",\n                \"text-align\",\n                \"text-align-last\",\n                \"text-decoration\",\n                \"text-decoration-color\",\n                \"text-decoration-line\",\n                \"text-decoration-style\",\n                \"text-indent\",\n                \"text-justify\",\n                \"text-overflow\",\n                \"text-shadow\",\n                \"text-transform\",\n                \"top\",\n                \"transform\",\n                \"transform-origin\",\n                \"transform-style\",\n                \"transition\",\n                \"transition-delay\",\n                \"transition-duration\",\n                \"transition-property\",\n                \"transition-timing-function\",\n                \"user-select\",\n                \"vertical-align\",\n                \"visibility\",\n                \"white-space\",\n                \"width\",\n                \"word-break\",\n                \"word-spacing\",\n                \"word-wrap\",\n                \"writing-mode\",\n                \"z-index\"\n        ))\n        \n*/\n\n(class ThrashDetector extends ProtoClass {\n        \n    static initClass () {\n        this.setIsSingleton(true)\n\t\treturn this\n    }\n\n    initPrototypeSlots () {\n\n        /*\n        this.newSlot(\"writeStyleProperties\", new Set([\n                \"border\",\n                \"margin\",\n                \"font-style\",\n                \"transform\",\n                \"align-content\",\n                \"align-items\",\n                \"align-self\",\n                \"all\",\n                \"border\",\n                \"border-bottom\",\n                \"border-bottom-color\",\n                \"border-bottom-left-radius\",\n                \"border-bottom-right-radius\",\n                \"border-bottom-style\",\n                \"border-bottom-width\",\n                \"border-collapse\",\n                \"border-color\",\n                \"border-image\",\n                \"border-image-outset\",\n                \"border-image-repeat\",\n                \"border-image-slice\",\n                \"border-image-source\",\n                \"border-image-width\",\n                \"border-left\",\n                \"border-left-color\",\n                \"border-left-style\",\n                \"border-left-width\",\n                \"border-radius\",\n                \"border-right\",\n                \"border-right-color\",\n                \"border-right-style\",\n                \"border-right-width\",\n                \"border-spacing\",\n                \"border-style\",\n                \"border-top\",\n                \"border-top-color\",\n                \"border-top-left-radius\",\n                \"border-top-right-radius\",\n                \"border-top-style\",\n                \"border-top-width\",\n                \"border-width\",\n                \"bottom\",\n                \"box-shadow\",\n                \"box-sizing\",\n                \"caption-side\",\n                \"@charset\",\n                \"clear\",\n                \"clip\",\n                \"clip-path\",\n                \"column-count\",\n                \"column-fill\",\n                \"column-gap\",\n                \"column-rule\",\n                \"column-rule-color\",\n                \"column-rule-style\",\n                \"column-rule-width\",\n                \"column-span\",\n                \"column-width\",\n                \"columns\",\n                \"content\",\n                \"counter-increment\",\n                \"counter-reset\",\n                \"direction\",\n                \"display\",\n                \"empty-cells\",\n                \"flex\",\n                \"flex-basis\",\n                \"flex-direction\",\n                \"flex-flow\",\n                \"flex-grow\",\n                \"flex-shrink\",\n                \"flex-wrap\",\n                \"float\",\n                \"font\",\n                \"@font-face\",\n                \"font-family\",\n                \"font-kerning\",\n                \"font-size\",\n                \"font-size-adjust\",\n                \"font-stretch\",\n                \"font-style\",\n                \"font-variant\",\n                \"font-weight\",\n                \"grid\",\n                \"grid-area\",\n                \"grid-auto-columns\",\n                \"grid-auto-flow\",\n                \"grid-auto-rows\",\n                \"grid-column\",\n                \"grid-column-end\",\n                \"grid-column-gap\",\n                \"grid-column-start\",\n                \"grid-gap\",\n                \"grid-row\",\n                \"grid-row-end\",\n                \"grid-row-gap\",\n                \"grid-row-start\",\n                \"grid-template\",\n                \"grid-template-areas\",\n                \"grid-template-columns\",\n                \"grid-template-rows\",\n                \"height\",\n                \"hyphens\",\n                \"@import\",\n                \"justify-content\",\n                \"@keyframes\",\n                \"left\",\n                \"letter-spacing\",\n                \"line-height\",\n                \"list-style\",\n                \"list-style-image\",\n                \"list-style-position\",\n                \"list-style-type\",\n                \"margin\",\n                \"margin-bottom\",\n                \"margin-left\",\n                \"margin-right\",\n                \"margin-top\",\n                \"max-height\",\n                \"max-width\",\n                \"@media\",\n                \"min-height\",\n                \"min-width\",\n                \"object-fit\",\n                \"object-position\",\n                \"opacity\",\n                \"order\",\n                \"outline\",\n                \"outline-color\",\n                \"outline-offset\",\n                \"outline-style\",\n                \"outline-width\",\n                \"overflow\",\n                \"overflow-x\",\n                \"overflow-y\",\n                \"padding\",\n                \"padding-bottom\",\n                \"padding-left\",\n                \"padding-right\",\n                \"padding-top\",\n                \"page-break-after\",\n                \"page-break-before\",\n                \"page-break-inside\",\n                \"perspective\",\n                \"perspective-origin\",\n                \"pointer-events\",\n                \"position\",\n                \"quotes\",\n                \"right\",\n                \"scroll-behavior\",\n                \"table-layout\",\n                \"text-align\",\n                \"text-align-last\",\n                \"text-decoration\",\n                \"text-decoration-color\",\n                \"text-decoration-line\",\n                \"text-decoration-style\",\n                \"text-indent\",\n                \"text-justify\",\n                \"text-overflow\",\n                \"text-shadow\",\n                \"text-transform\",\n                \"top\",\n                \"transform\",\n                \"transform-origin\",\n                \"transform-style\",\n                \"transition\",\n                \"transition-delay\",\n                \"transition-duration\",\n                \"transition-property\",\n                \"transition-timing-function\",\n                \"user-select\",\n                \"vertical-align\",\n                \"visibility\",\n                \"white-space\",\n                \"width\",\n                \"word-break\",\n                \"word-spacing\",\n                \"word-wrap\",\n                \"writing-mode\",\n                \"z-index\"\n        ]))\n        */\n        \n        this.newSlot(\"readOpSet\", new Set([\n            // on Elements\n            \"offsetTop\", \"offsetLeft\", \"offsetWidth\", \"offsetHeight\", \"offsetParent\", // offset\n            \"scrollTop\", \"scrollLeft\", \"scrollWidth\", \"scrollHeight\", // scroll\n            \"scrollBy\", \"scrollTo\", \"scrollIntoView\", \"scrollIntoViewIfNeeded\", // scroll animations\n            \"clientTop\", \"clientLeft\", \"clientWidth\", \"clientHeight\", // client\n            \"getComputedStyle\", \n            \"getClientRects\", \"getBoundingClientRect\", // rects\n            \"computeRole\", \"computedName\", \"innerText\",\n\n            // on Window\n            \"scrollX\", \"scrollY\", \"innerHeight\", \"innerWidth\", \"visualViewPort\", // window\n            //\"getComputedStyle\", \n\n            // on Document\n            \"scrollingElement\", \"elementFromPoint\", // document\n\n            /*\n            // on Forms\n            \"focus\", \"select\", // on inputElement\n            \"select\" // on textAreaElement\n            */\n\n            // on Mouse Event\n            \"layerX\", \"layerY\", \"offsetX\", \"offsetY\",\n\n            // on Range\n            //\"getClientRects\", \"getBoundingClientRect\", // rects\n\n            // on SVG\n\n            \"computeCTM\", \"getBBox\", \"getCharNumAtPosition\", \"getComputedTextLength\", \n            \"getEndPositionOfChar\", \"getExtentOfChar\", \"getNumberOfChars\", \"getRotationOfChar\", \n            \"getStartPositionOfChar\", \"getSubStringLength\", \"selectSubString\", \"instanceRoot\"\n        ]))\n\n        this.newSlot(\"writeOpSet\", new Set([\n            \"focus\",\n            \"appendChild\",\n            \"atInsertElement\",\n            \"removeChild\",\n            \"className\",\n            \"display\",\n            \"position\",\n            \"width\",\n            \"height\",\n            \"min-width\",\n            \"min-height\",\n            \"max-width\",\n            \"max-height\"\n        ]))\n\n        this.newSlot(\"noReflowWriteOpSet\", new Set(\n            \"color\",\n            \"backface-visibility\",\n            \"background\",\n            \"background-attachment\",\n            \"background-blend-mode\",\n            \"background-clip\",\n            \"background-color\",\n            \"background-image\",\n            \"background-origin\",\n            \"background-position\",\n            \"background-repeat\",\n            \"background-size\",\n            \"border-left-color\",\n            \"border-left-style\",\n            \"border-radius\",\n            \"border-right\",\n            \"border-right-color\",\n            \"border-right-style\",\n            \"border-style\",\n            \"border-top-color\",\n            \"border-top-left-radius\",\n            \"border-top-right-radius\",\n            \"border-top-style\",\n            \"caret-color\",               \n            \"color\",\n            \"filter\",\n            \"outline-color\",\n            \"scroll-behavior\",\n            \"user-select\"\n        ))\n\n        this.newSlot(\"needsReflow\", false)\n        this.newSlot(\"reflowCount\", false)\n        this.newSlot(\"triggers\", null)\n        this.newSlot(\"lastWrite\", null)\n        this.newSlot(\"enabled\", false)\n    }\n\n    /*\n    init () {\n        super.init() \n        return this\n    }\n    */\n\n    beginFrame () {\n        //console.log(\"--- new frame ---\")\n        this.setNeedsReflow(false)\n        this.setReflowCount(0)\n        this.setTriggers([])\n        this.setLastWrite(null)\n    }\n\n    didRead (opName, optionalView) {\n        if (this.readOpSet().has(opName)) {\n            //console.log(this.type() + \".didRead('\" + opName + \"')\")\n            if (this.needsReflow()) {\n                this.setReflowCount(this.reflowCount() + 1)\n                this.setNeedsReflow(false)\n                let m = opName \n                if (optionalView) {\n                    m = optionalView.debugTypeId() + \" get \" + opName\n                }\n                const s = this.lastWrite() + \" -> \" + m\n                //console.log(s)\n                this.triggers().push(s)\n                this.onThrash()\n            }\n        } \n        return this\n    }\n\n    didWrite (opName, optionalView) {\n        if (!this.noReflowWriteOpSet().has(opName)) {\n            this.setNeedsReflow(true)\n            let m = opName \n            if (optionalView) {\n                m = optionalView.debugTypeId() + \" set \" + opName\n            }\n            //console.log(m)\n            this.setLastWrite(m)\n        }\n        return this\n    }\n\n    onThrash () {\n        //console.log(this.type() + \" reflowCount: \", this.reflowCount())\n    }\n\n    endFrame () {\n        if (this.enabled() && this.reflowCount()) {\n            console.log(\">>> \" +  this.type() + \" reflowCount: \", this.reflowCount() + \" triggers: \", JSON.stringify(this.triggers(), 2, 2))\n        }\n    }\n\n }.initThisClass());\n",
  "Y3lRrwMYHmBh9jH/ougEi9gYfbKqa6On/Giobl0qrjY=": "\n\"use strict\";\n\n/*\n\n    DomTransition\n         \n\n*/\n\n(class DomTransition extends ProtoClass {\n    \n    static initClass () {\n        const globalValues = [\"inherit\", \"initial\", \"revert\", \"revert-layer\", \"unset\"].asSet();\n        this.newClassSlot(\"globalValues\", globalValues)\n    }\n\n    static validPropertyValues () {\n        return [  \"background-color\",  \"background-position\",  \"border-color\",  \"border-width\",  \"border-spacing\",  \n        \"bottom\",  \"color\",  \"font-size\",  \"font-weight\",  \"height\",  \"left\",  \"letter-spacing\",  \"line-height\",  \n        \"margin\",  \"margin-bottom\",  \"margin-left\",  \"margin-right\",  \"margin-top\",  \"max-height\",  \"max-width\",  \n        \"min-height\",  \"min-width\",  \"opacity\",  \"outline-color\",  \"outline-offset\",  \"outline-width\",  \"padding\",  \n        \"padding-bottom\",  \"padding-left\",  \"padding-right\",  \"padding-top\",  \"right\",  \"text-indent\",  \"text-shadow\",  \n        \"top\",  \"vertical-align\",  \"visibility\",  \"width\",  \"word-spacing\",  \"z-index\"]\n    }\n\n    initPrototypeSlots () {\n        this.newSlot(\"global\", null)\n        this.newSlot(\"property\", \"\")\n        this.newSlot(\"duration\", 0)\n        this.newSlot(\"timingFunction\", \"ease-in-out\") // \"linear\", \"ease\", \"ease-in\", cubic-bezier(n, n, n, n)\n        this.newSlot(\"delay\", 0) // set to number type (unit = seconds)\n        this.newSlot(\"transitions\", null)\n    }\n\n    /*\n    init () {\n        super.init()\n    }\n    */\n\n    clear () {\n        this.setGlobal(null)\n        this.setProperty(null)\n        this.setDuration(0)\n        this.setTimingFunction(\"\")\n        this.setDelay(0)\n        return this\n    }\n\n    updateDuration (s) {\n        if (Type.isNumber(s)) {\n            s = s + \"s\"\n        }\n        this.setDuration(s)\n        this.syncToDomView()\n        return this\n    }\n\n    updateDelay (s) {\n        this.setDelay(s)\n        this.syncToDomView()\n        return this\n    }\n\n    updateTimingFunction (s) {\n        this.setTimingFunction(s)\n        this.syncToDomView()\n        return this\n    }\n\n    durationString () {\n        const v = this.duration()\n        if (Type.isNumber(v)) {\n            return v + \"s\"\n        }\n        return v\n    }\n\n    delayString () {\n        const v = this.delay()\n        if (Type.isNumber(v)) {\n            return v + \"s\"\n        }\n        return v\n    }\n\n    asString () {\n        if (this.global()) {\n            return this.global()\n        }\n\n        const parts = [\n            this.property(),\n            this.durationString(),\n            this.timingFunction()\n            //this.delayString(),\n        ]\n\n        const s = parts.join(\" \")\n        console.log(this.type() + \" asString() = '\" + s + \"'\")\n        return s\n    }\n\n    setFromString (aString) {\n        // ordering of parts: \n        //   transition-property, \n        //   transition-duration, \n        //   transition-timing-function, \n        //   transition-delay.\n        //\n\n        const startsWithNumber = function (s) {\n            if (s.length) {\n                const c = s[0]\n                return (c >= '0' && c <= '9');\n            }\n            return false\n        }\n\n        const parts = aString.split(\" \").select(part => part !== \"\")\n\n        this.clear()\n\n        if (parts.length === 1 && this.thisClass().validGlobalValues().has(parts[0])) {\n            this.setGlobal(parts[0])\n            return this\n        }\n\n        debugger;\n        let v = parts.removeFirst()\n        assert(!Type.isNull(v))\n        this.setProperty(v)\n\n        v = parts.removeFirst()\n        if (!Type.isNull(v)) {\n            assert(startsWithNumber(v))\n            this.setDuration(v)\n        }\n\n        v = parts.removeFirst()\n        if (!Type.isNull(v)) {\n            this.setTimingFunction(v)\n        }\n\n        v = parts.removeFirst()\n        if (!Type.isNull(v)) {\n            assert(startsWithNumber(v))\n            this.setDelay(v)\n        }\n\n        return this\n    }\n\n    syncToDomView () {\n        this.transitions().syncToDomView()\n        return this\n    }\n\n}.initThisClass());\n\n\n",
  "wDNBu8vK/fM8Y+SBzXpRN0PscXiXSh+By9XAJlM2qE8=": "\"use strict\";\n\n/*\n\n    DomTransition\n         \n    Example use in a DomView:\n\n            aDomView.transitions().at(\"opacity\").updateDuration(\"0.3s\")\n\n        updates the opacity time without changing other transition settings\n        \n\n    NOTES:\n\n        CSS transition value example:\n        \n            transition: width 2s linear 1s, height 2s ease 1s; \n        \n        1st time value is the duration, \n        2nd time value is the delay\n\n\n*/\n\n\n(class DomTransitions extends ProtoClass {\n    initPrototypeSlots () {\n        this.newSlot(\"properties\", null)\n        this.newSlot(\"domView\", null)\n    }\n\n    init () {\n        super.init()\n        this.setProperties({})\n    }\n\n    at (aName) {\n        const d = this.properties()\n        if (!d.hasOwnProperty(name)) {\n            d[name] = DomTransition.clone().setProperty(aName).setTransitions(this)\n        }\n        return d[name]\n    }\n\n    propertiesAsList () {\n        return Object.values(this.properties())\n    }\n\n    asString () {\n        return this.propertiesAsList().map(t => t.asString()).join(\", \")\n    }\n\n    syncToDomView () {\n        //console.log(\".setTransition('\" + this.asString() + \"')\")\n        this.domView().justSetTransition(this.asString())\n        return this\n    }\n\n    syncFromDomView () {\n        this.setProperties({})\n\n        const s = this.domView().transition()\n\n        if (s !== \"\") {\n            const transitionStrings = s.split(\",\")\n\n            transitionStrings.forEach((tString) => {\n                const t = DomTransition.clone().setFromString(tString)\n                this.properties()[t.property()] = t\n            })\n        }\n\n        return this\n    }\n}.initThisClass());\n\n\n",
  "hip+tSCNUrol8+Z5I1ivLDXcV4zvPbe8Yg2g9iz37Ro=": "\n\"use strict\";\n\n/*\n\n    DomBorderRadius\n         \n\n    // this.titleView().setBorderRadius(\"8px 8px 0px 8px\") // top-left, top-right,  bottom-right, bottom-left\n    // TODO: em vs px support?\n\n*/\n\n\n(class DomBorderRadius extends ProtoClass {\n    initPrototypeSlots () {\n        this.newSlot(\"divView\", null)\n        this.newSlot(\"topLeft\", 0)\n        this.newSlot(\"topRight\", 0)\n        this.newSlot(\"bottomRight\", 0)\n        this.newSlot(\"bottomLeft\", 0)\n        this.newSlot(\"partNames\", [\"topLeft\", \"topRight\", \"bottomRight\", \"bottomLeft\"])\n    }\n\n    /*\n    init () {\n        super.init()\n    }\n    */\n\n    clear () {\n        this.setAll(0)\n        return this\n    }\n\n    setAll (v) {\n        if (!v) {\n            v = 0\n        }\n\n        this.partSetters().forEach((setter) => {\n            this[setter].apply(this, [v])\n        })\n        return this\n    }\n\n    partSetters () {\n        return this.partNames().map(k => k.asSetter())\n    }\n\n    partValues () {\n        return this.partNames().map(k => this[k].apply(this))\n    }\n\n    asString (aString) {\n        return this.partValues().map(v => v + \"px\").join(\" \")\n    }\n\n    setFromString (aString) {\n        const parts = aString.split(\" \").select(part => part !== \"\")\n\n        this.clear()\n\n        if (parts.length === 1) {\n            this.setAll(Number(parts[0]))\n        }\n\n        let v;\n\n        v = parts.removeFirst()\n        if (Type.isString(v)) {\n            this.setTopLeft(Number(v))\n        }\n\n        v = parts.removeFirst()\n        if (Type.isString(v)) {\n            this.setTopRight(Number(v))\n        }\n\n        v = parts.removeFirst()\n        if (Type.isString(v)) {\n            this.setBottomRight(Number(v))\n        }\n\n        v = parts.removeFirst()\n        if (Type.isString(v)) {\n            this.setBottomLeft(Number(v))\n        }\n\n        return this\n    }\n\n    syncToDomView () {\n        this.divView().setBorderRadius(this.asString())\n        return this\n    }\n\n    syncFromDomView () {\n        const s = this.divView().borderRadius()\n\n        if (s) {\n            this.setFromString(s)\n        } else {\n            this.clear()\n        }\n\n        return this\n    }\n}.initThisClass());\n\n",
  "CGICpF1qDlyZP46kKmLnm+HybBwrQTVCB6xE1w/qxmw=": "\n\"use strict\";\n\n/*\n\n    ViewAnimator\n         \n\n*/\n\n(class ViewAnimator extends ProtoClass {\n    initPrototypeSlots () {\n        this.newSlot(\"startValue\", 0)\n        this.newSlot(\"targetValue\", 0)\n        this.newSlot(\"viewProperty\", \"\")\n        this.newSlot(\"duration\", 200).setComment(\"milliseconds\")\n        this.newSlot(\"easing\", \"linear\")\n        this.newSlot(\"view\", null)\n    }\n\n    /*\n    init () {\n        super.init()\n    }\n    */\n\n    currentValue () {\n        const view = this.view()\n        return view[this.viewProperty()].apply(view)\n    }\n\n    start () {\n        this.setStartValue(this.currentValue())\n        this.setStartTime(new Date().getTime())\n        this.nextFrame()\n        return this\n    }\n\n    timeRatioDone () {\n        const now = new Date().getTime();\n        return Math.min(1, ((now - this.startTime()) / this.duration()));\n    }\n\n    setterName () {\n        if (!this._setterName) {\n            this._setterName = this.viewProperty().asSetter()\n        }\n        return this._setterName\n    }\n\n    setValue (v) {\n        view[this.setterName()].call(view, v)\n        return this\n    }\n\n    nextFrame () {\n        const tr = this.timeRatioDone()\n        const newValue = Math.ceil((this.timeRatioDone() * (this.currentValue() - this.startValue())) + this.startValue());\n        this.setValue(newValue)\n\n        if (tr !== 1) {\n            requestAnimationFrame(() => { this.nextFrame() })\n        } else {\n            this.didComplete()\n        }\n        return this\n    }\n\n    didComplete () {\n\n    }\n\n    /*\n    EasingsFunctions () {\n        linear(t) {\n            return t;\n        }\n        easeInQuad(t) {\n            return t * t;\n        }\n        easeOutQuad(t) {\n            return t * (2 - t);\n        }\n        easeInOutQuad(t) {\n            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n        }\n        easeInCubic(t) {\n            return t * t * t;\n        }\n        easeOutCubic(t) {\n            return (--t) * t * t + 1;\n        }\n        easeInOutCubic(t) {\n            return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n        }\n        easeInQuart(t) {\n            return t * t * t * t;\n        }\n        easeOutQuart(t) {\n            return 1 - (--t) * t * t * t;\n        }\n        easeInOutQuart(t) {\n            return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t;\n        }\n        easeInQuint(t) {\n            return t * t * t * t * t;\n        }\n        easeOutQuint(t) {\n            return 1 + (--t) * t * t * t * t;\n        }\n        easeInOutQuint(t) {\n            return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t;\n        }\n    }\n    */\n}.initThisClass());\n\n\n",
  "IG7iSoCGOvxTiJp6PYKAE3wInSpYZ89N21oJ6ubea4c=": "\n\"use strict\";\n\n/*\n\n    CssAnimation\n\n    Encapsulation of CSS animation rule and animation control properties on a view.\n    It will also start an animationListener on the target view, \n    which will send a onAnimationStart, and onAnimationEnd messages to the view.\n\n    It works by composing a CSS animation rule and inserting it into the document's first style sheet.\n    The rule name is a hash of the rule content, and the CssAnimation class keeps a set of names\n    it's already registered, so it doesn't register them again.\n\n    Example use:\n         \n        CssAnimation.clone().setPropertyName(\"right\").setTargetValue(\"10px\").setView(aView).start()\n\n    */\n\n(class CssAnimation extends ProtoClass {\n\n\n    static insertRuleForAnimation (cssAnimation) {\n        const name = cssAnimation.ruleName()\n        const rules = this.insertedRuleNamesSet()\n        if (!rules.has(name)) { // name is a hash of rule, so this should be safe\n            const css = window.document.styleSheets[0];\n            css.insertRule(cssAnimation.composedRule(), css.cssRules.length); // is this allowed or will some security nonsense block it?\n            rules.add(name)\n        }\n        return this\n    }\n\n    static initClass () {\n        this.newClassSlot(\"insertedRuleNamesSet\", new Set())\n    }\n\n    initPrototypeSlots () {\n        this.newSlot(\"view\", null)\n        this.newSlot(\"propertyName\", \"\")\n        this.newSlot(\"startValue\", null)\n        this.newSlot(\"targetValue\", 0)\n\n        // animation name is computed from hash of animation css rule string\n        this.newSlot(\"duration\", 1).setComment(\"seconds\")\n        this.newSlot(\"timingFunction\", \"ease\")\n        this.newSlot(\"iterationCount\", 1) // animation-iteration-count\n        this.newSlot(\"delay\", 0) // animation-delay\n        this.newSlot(\"direction\", \"normal\") // animation-direction (normal or alternate)\n        this.newSlot(\"fillMode\", \"forwards\")  // animation-fill-mode (none|forwards|backwards|both|initial|inherit)\n        this.newSlot(\"playState\", \"running\")  // animation-play-state (paused|running|initial|inherit)\n        this.newSlot(\"animationPropertyNames\", [\n            \"animation-name\",\n            \"animation-duration\",\n            \"animation-timing-function\",\n            \"animation-delay\",\n            \"animation-iteration-count\",\n            \"animation-direction\",\n            \"animation-fill-mode\",\n            \"animation-play-state\"\n        ])\n        this.newSlot(\"propertySlotsDict\", null) \n    }\n\n    initPrototype () {\n        this.propertySlotsDict() // cache it on the prototype\n    }\n\n    init () {\n        super.init()\n    }\n\n    insertRule () {\n        assert(this.isValidRule())\n        this.thisClass().insertRuleForAnimation(this)\n    }\n\n    composedRule () {\n        return \"@keyframes \" + this.name() + \" { \" + this.ruleContent() + \"}\"\n    }\n\n    name () {\n        return \"animation\" + this.ruleContent().hashCode()\n    }\n\n    ruleContent () {\n        const k = this.propertyName()\n        let s = \"\" \n        if (!Type.isNullOrUndefined(this.startValue())) {\n            s += \" from {\" + k + \": \" + this.startValue() + \"; }\\n\"\n        }\n        s += \"to {\" + k + \": \" + this.targetValue() + \"; }\"\n        s += \"\"\n        return s\n    }\n\n    isValidRule () {\n        return !Type.isNullOrUndefined(this.startValue()) && Type.isNullOrUndefined(this.targetValue())\n    }\n\n    propertySlotsDict () {\n        if (!this._propertySlotsDict) {\n            const dict = {}\n            this.animationPropertyNames().forEach(k => dict[k] = this.slotNameForPropertyName(k))\n            this._propertySlotsDict = dict\n        }\n        return this._propertySlotsDict\n    }\n\n    slotNameForPropertyName (k) {\n        const parts = k.split(\"-\")\n        parts.removeFirst() \n        const result = parts.map(p => p.capitalized()).join(\"\").uncapitalized()\n        //console.log(\"slotNameForPropertyName('\" + k + \"') -> '\" + result + \"'\") \n        return result\n    }\n\n    applyToView (aView) { \n        const dict = this.propertySlotsDict()\n        const e = this.view().element()\n        Reflect.ownKeys(dict).forEach(attributeName => {\n            const slotName = dict[attributeName]\n            const value = this[slotName].apply(this)\n            e.setAttribute(attributeName, value);\n        })\n    }\n\n    start () {\n        this.insertRule()\n        const v = this.view()\n        v.animationListener().setIsListening(true)\n        this.applyToView(v)\n        return this\n    }\n\n    didComplete () {\n\n    }\n\n}.initThisClass());\n\n\n",
  "/yKYicBQD65+rVELnBFG92HOpfm+MEv7MMkJByAhuXs=": "\"use strict\";\n\n/*\n    DomCssInspector\n    Used to inspect class styles since css hides stylesheet.cssRules.\n    \n    example use:\n    const value = DomCssInspector.shared().setElementClassName(\"..\").cssStyle.fontFamily\n\n*/\n\n(class DomCssInspector extends ProtoClass {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"idName\", \"DomCssInspector\")\n    }\n\n    testElement () {\n        if (!this._testElement) {\n            this._testElement = this.createTestElement()\n            document.body.appendChild(this._testElement);\n            if (!document.getElementById(this.idName())) {\n                throw new Error(\"missing element '\" + this.idName() + \"'\")\n            }\n        }\n        return this._testElement\n    }\n\t\n    createTestElement () {\n        const e = document.createElement(\"div\");\n\t    e.setAttribute(\"id\", this.idName());\n        e.style.display = \"none\";\n        e.style.visibility = \"hidden\";\n        return e\n    }\n\n    setElementClassName (aName) {\n        this.testElement().setAttribute(\"class\", aName);\n        return this\n    }\n\n    cssStyle (key) {\n        return this.testElement().style\n    }\n    \n}.initThisClass());\n",
  "Hvk8+m/bo2ujZ2XAzfNHEbNLEEgv0aDt1NK5CPk3PH0=": "\"use strict\";\n\n/*\n    \n    CssColor\n    \n    Helpful for manipulating css colors.\n\t\n*/\n\n// RGB2HSV and HSV2RGB are based on Color Match Remix see: http://color.twysted.net/\n// which is based on or copied from ColorMatch 5K see: http://colormatch.dk/\n\nconst RGB2HSV = function (rgb) { \n    // rgb is a dict in form { r: 0-255, g: 0-255, b: 0-255 }\n    const hsv = new Object();\n    const max = max3(rgb.r, rgb.g, rgb.b);\n    const dif = max - min3(rgb.r, rgb.g, rgb.b);\n    hsv.saturation = (max == 0.0) ? 0 : (100 * dif / max);\n    if (hsv.saturation == 0) hsv.hue = 0;\n    else if (rgb.r == max) hsv.hue = 60.0 * (rgb.g - rgb.b) / dif;\n    else if (rgb.g == max) hsv.hue = 120.0 + 60.0 * (rgb.b - rgb.r) / dif;\n    else if (rgb.b == max) hsv.hue = 240.0 + 60.0 * (rgb.r - rgb.g) / dif;\n    if (hsv.hue < 0.0) hsv.hue += 360.0;\n    hsv.value = Math.round(max * 100 / 255);\n    hsv.hue = Math.round(hsv.hue);\n    hsv.saturation = Math.round(hsv.saturation);\n    return hsv;\n}\n\n\nconst HSV2RGB = function (hsv) {\n    const rgb = new Object();\n    if (hsv.saturation == 0) {\n        rgb.r = rgb.g = rgb.b = Math.round(hsv.value * 2.55);\n    } else {\n        hsv.hue /= 60;\n        hsv.saturation /= 100;\n        hsv.value /= 100;\n        let i = Math.floor(hsv.hue);\n        let f = hsv.hue - i;\n        let p = hsv.value * (1 - hsv.saturation);\n        let q = hsv.value * (1 - hsv.saturation * f);\n        let t = hsv.value * (1 - hsv.saturation * (1 - f));\n        switch (i) {\n        case 0: rgb.r = hsv.value; rgb.g = t; rgb.b = p; break;\n        case 1: rgb.r = q; rgb.g = hsv.value; rgb.b = p; break;\n        case 2: rgb.r = p; rgb.g = hsv.value; rgb.b = t; break;\n        case 3: rgb.r = p; rgb.g = q; rgb.b = hsv.value; break;\n        case 4: rgb.r = t; rgb.g = p; rgb.b = hsv.value; break;\n        default: rgb.r = hsv.value; rgb.g = p; rgb.b = q;\n        }\n        rgb.r = Math.round(rgb.r * 255);\n        rgb.g = Math.round(rgb.g * 255);\n        rgb.b = Math.round(rgb.b * 255);\n    }\n    return rgb;\n}\n\n//Adding HueShift via Jacob (see comments)\nconst HueShift = function (h, s) {\n    h += s; \n    while (h >= 360.0) { \n        h -= 360.0; \n    }\n    while (h < 0.0) { \n        h += 360.0; \n    }\n    return h;\n}\n\n//min max via Hairgami_Master (see comments)\nconst min3 = function(a, b, c) {\n    return (a < b) ? ((a < c) ? a : c) : ((b < c) ? b : c);\n}\nconst max3 = function(a, b, c) {\n    return (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c);\n}\n\n// ----------------------------------------------------------------------------------\n\n(class CssColor extends ProtoClass {\n    \n    initPrototypeSlots () {\n        // values between 0.0 and 1.0\n        this.newSlot(\"red\", 0)\n        this.newSlot(\"green\", 0)\n        this.newSlot(\"blue\", 0)\n        this.newSlot(\"opacity\", 1)\n        this.newSlot(\"colorCacheMap\", 1)\n        //isMutable: true,\n    }\n    \n    init () {\n        super.init()\n        this.setColorCacheMap(new Map())\n        return this\n    }\n\n    randomize () {\n        this.setRed(Math.random())\n        this.setGreen(Math.random())\n        this.setBlue(Math.random())\n        return this\n    }\n\n    copyFrom (aColor, copyDict) {\n        return CssColor.clone().set(aColor.red(), aColor.green(), aColor.blue(), aColor.opacity())\n    }\n\n    justParseColorString (aColorString) { // private\n        // TODO: test if this is expensive\n        // also, check for any risk of causing an event?\n        const div = document.createElement(\"div\");\n        document.body.appendChild(div);\n        div.style.color = aColorString;\n        const style = window.getComputedStyle(div); debugger;\n        const color = style.color;\n        document.body.removeChild(div);\n\n        assert(color.startsWith(\"rgb\"))\n        const inner = color.between(\"(\", \")\");\n        const parts = inner.split(\",\");\n        const numbers = parts.map((v) => parseInt(v));\n\n        // add an alpha of 1 if no alpha is specified\n        // in order to make returned array format consistent\n\n        if (numbers.length === 3) {\n            numbers.push(1)\n        }\n\n        assert(numbers.length === 4)\n\n        numbers[0] /= 255\n        numbers[1] /= 255\n        numbers[2] /= 255\n        return numbers\n    }\n\n    parseColorString (string) {\n        const cache = CssColor.colorCacheMap()\n        const cachedResult = cache.at(string)\n        if (!Type.isUndefined(cachedResult)) {\n            return cachedResult\n        }\n\n        if (Type.isNull(cachedResult)) {\n            throw new Error(\"invalid color string '\" + string + \"'\")\n        }\n\n        const result = this.justParseColorString(string)\n\n        cache.atPut(string, result)\n        return result\n    }\n\n    setCssColorString (aString) {\n        const array = this.parseColorString(aString)\n        this.set(array.at(0), array.at(1), array.at(2), array.at(3))\n        return this\n    }\n\n    setHex (hex) {\n        return this.setCssColorString(hex)\n    }\n\n    set (r, g, b, opacity) {\n        this.setRed(r)\n        this.setGreen(g)\n        this.setBlue(b)\n\n        if (!opacity) {\n            this.setOpacity(0)\n        } else {\n            this.setOpacity(opacity)\n        }\n\n        return this\n    }\n\n    // conversion helpers\n\n    v255toUnit (v) {\n        return v / 255;\n    }\n\n    unitTo255 (v) {\n        return Math.round(v * 255)\n    }\n\n    red255 () {\n        return this.unitTo255(this.red());\n    }\n\n    green255 () {\n        return this.unitTo255(this.green());\n    }\n\n    blue255 () {\n        return this.unitTo255(this.blue());\n    }\n\n    /*\n    setCssColorString (s) {\n\n    }\n    */\n\n    cssColorString () {\n        return \"rgba(\" + this.red255() + \", \" + this.green255() + \", \" + this.blue255() + \", \" + this.opacity()  + \")\"\n    }\n\n    // operations\n\n    interpV1V2Ratio(v1, v2, r) {\n        const diff = v2 - v1;\n        if (v1 > v2) {\n            return v1 - (v1 - v2)*r\n        }\n        return v2 - (v2 - v1)*r\n    }\n\n    interpolateWithColorTo (other, v) {\n        const r1 = this.red()\n        const g1 = this.green()\n        const b1 = this.blue()\n        const o1 = this.opacity()\n\n        const r2 = other.red()\n        const g2 = other.green()\n        const b2 = other.blue()\n        const o2 = other.opacity()\n\n        const r = this.interpV1V2Ratio(r1, r2, v)\n        const g = this.interpV1V2Ratio(g1, g2, v)\n        const b = this.interpV1V2Ratio(b1, b2, v)\n        const o = this.interpV1V2Ratio(o1, o2, v)\n\n        const result = CssColor.clone().set(r, g, b, o)\n        return result\n    }\n\n    darken (v) {\n        assertDefined(v)\n        assert(v <= 1)\n        const r = this.red()\n        const g = this.green()\n        const b = this.blue()\n        this.setRed(r * v)\n        this.setGreen(g * v)\n        this.setBlue(b * v)\n        return this\n    }\n\n    lighten (v) {\n        assertDefined(v)\n        const r = this.red()\n        const g = this.green()\n        const b = this.blue()\n        this.setRed(r + (1 - r) * v)\n        this.setGreen(g + (1 - g) * v)\n        this.setBlue(b + (1 - b) * v)\n        return this\n    }\n\n    brightness () {  \n        // return value between 0.0 and 1.0\n        return (this.red() + this.green() + this.blue() ) / 3.0;\n    }\n\n    whiteColor () {\n        return CssColor.clone().set(1, 1, 1, 1)\n    }\n\n    blackColor () {\n        return CssColor.clone().set(0, 0, 0, 1)\n    }\n\n    lightGrayColor () {\n        return CssColor.clone().set(0.75, 0.75, 0.55, 1)\n    }\n\n    grayColor () {\n        return CssColor.clone().set(0.5, 0.5, 0.5, 1)\n    }\n\n    darkGrayColor () {\n        return CssColor.clone().set(0.25, 0.25, 0.25, 1)\n    }\n\n    redColor () {\n        return CssColor.clone().set(1, 0, 0, 1)\n    }\n\n    greenColor () {\n        return CssColor.clone().set(0, 1, 0, 1)\n    }\n\n    blueColor () {\n        return CssColor.clone().set(0, 0, 1, 1)\n    }\n\n    yellowColor () {\n        return CssColor.clone().set(1, 1, 0, 1)\n    }\n\n    randomColor () {\n        return CssColor.clone().randomize()\n    }\n\n    asDict255 () {\n        return { r:this.red255(), g:this.green255(), b:this.blue255() }\n    }\n\n    fromDict255 (d) {\n        this.setRed(  d.r / 255)\n        this.setGreen(d.g / 255)\n        this.setBlue( d.b / 255)\n        return this\n    }\n\n    complement () {\n        const temprgb = this.asDict255();\n        const temphsv = RGB2HSV(temprgb);\n        temphsv.hue = HueShift(temphsv.hue, 180.0);\n        temprgb = HSV2RGB(temphsv);\n        return CssColor.clone().fromDict255(temprgb)\n    }\n\n    contrastComplement (v) { // v should be a value in the range of 0.0 to 1.0\n        // returns another CssColor object which is the same as the receiver but darkened\n        //\n\n        const b = this.brightness() \n\n        if (b < 0.55) {\n            const lightened = this.copy().lighten(v)\n            return lightened\n        } else {\n            const darkened = this.copy().darken(v)\n            return darkened\n        }\n    }\n\n}.initThisClass());\n\n",
  "oyPT2fMe2CfYoT6nK5t2TPnIMGFn6xcZvhhX1xnCF1I=": "\"use strict\";\n\n/*\n`\n    Helper methods DOM nodes.\n    Mostly for use inside DomView.\n    Not for general consumption as elements typically shouldn't be interacted with directly. \n\n*/\n\nif (getGlobalThis()[\"Node\"]) { // DOM Node\n\n    Object.defineSlots(Node.prototype, {\n\n        // --- weakref to domView ---\n\n        _domViewWeakRef: null,\n\n        setDomView: function (aView) {\n            this._domViewWeakRef = aView ? new WeakRef(aView) : null;\n            return this\n        },\n\n        domView: function () { \n            const ref = this._domViewWeakRef;\n            const v = ref ? ref.deref() : undefined;\n            return v\n        },\n\n        // --- children ---\n\n        removeAllChildren: function () {\n            while (this.firstChild) {\n                this.removeChild(this.lastChild);\n            }\n            return this\n        },\n\n        moveChildrenTo: function (e) {\n            while (this.firstChild) {\n                e.appendChild(this.firstChild);\n            }\n        },\n\n        atInsertElement: function (index, child) {\n            const children = this.children\n            \n            if (index < children.length) {\n                this.insertBefore(child, children[index])\n                return\n            }\n            \n            if (index === children.length) {\n                this.appendChild(child)\n                return\n            }\n            \n            throw new Error(\"invalid dom child index\")\n        },\n\n        // --- description ---\n\n        description: function () {\n            let s = false\n        \n            if (this === window) {\n                s = \"window\"\n            }\n        \n            if (!s) {\n                s = this.getAttribute(\"id\")\n            }\n        \n            if (!s) {\n                s = this.getAttribute(\"class\")\n            }\n        \n            if (!s) {\n                s = this.tagName\n            }\n        \n            return s\n        },\n\n        // --- forEach ---\n\n        forEachChild (fn) {\n            for(let i = 0; i < this.childNodes.length; i ++) {\n                const child = this.childNodes[i]\n                fn(child)\n            }\n        },\n        \n        forEachDecendant: function (fn) {\n            this.forEachChild(child => {\n                fn(child)\n                child.forEachDecendant(fn)\n            })\n        },\n\n        forEachAncestor: function (fn) {\n            const pn = this.parentNode()\n            if (pn) {\n                fn(pn)\n                pn.forEachAncestor(fn)\n            }\n        },\n\n        hasAncestor: function (anElement) {\n            const pn = this.parentNode()\n            if (pn) {\n                if (pn === anElement) {\n                    return true\n                }\n\n                return pn.hasAncestor(anElement)\n            }\n\n            return false\n        }, \n\n        // --- style ---\n\n        copyComputedStyleFrom: function (e) {\n            debugger; // getComputedStyle can force a reflow\n            const style = window.getComputedStyle(e, null).cssText;\n            this.style.cssText = style;\n            return this\n        },\n\n        copyStyleFrom: function (e) {\n            const style = e.style.cssText;\n            this.style.cssText = style;\n            return this\n        },\n\n        // --- set / remove attributes ---\n\n        copyAttributesFrom: function (e) {\n            for (const attr of e.attributes) {\n                if (attr.namespace) {\n                    this.setAttributeNS(attr.namespace, attr.name, attr.value)\n                } else {\n                    this.setAttribute(attr.name, attr.value)\n                }\n            }\n\n            return this\n        },\n\n        attributesMap: function () {\n            const map = new Map()\n            for (const attr of this.attributes) {\n                map.set(attr.name, attr.value)\n            }\n            return map\n        },\n\n        setAttributesMap: function (map) {\n            if (this.setAttribute) {\n                map.forEachKV((k, v) => {\n                    this.setAttribute(k, v)\n                })\n            }\n        },\n\n        removeAttributes: function (names) {\n            if (this.removeAttribute) {\n                names.forEach(k => this.removeAttribute(k))\n            }\n        },\n        \n        setAttributesAndRemoveFromDecendants: function (attributeMap) {\n            this.setAttributesMap(attributeMap)\n            const names = attributeMap.keysArray()\n            this.forEachDecendant(e => {\n                e.removeAttributes(names)\n            })\n        },\n\n        // --- layers ---\n\n        addSvgGroupLayer: function () {\n            const xmlns = \"http://www.w3.org/2000/svg\";\n            const symbol = document.createElementNS(xmlns, \"g\");\n            //const symbol = document.createElement(\"g\");\n            this.moveChildrenTo(symbol)\n            this.appendChild(symbol)\n            return symbol\n        },\n\n        containsPointXY: function (x, y) {\n            // this assumes ancestors geographically contain descendant elements\n            // which isn't always the case, but document.elementFromPoint might typically clip \n            // subviews such that this is usually true\n            const topElement = document.elementFromPoint(x, y)\n            if (topElement === this) {\n                return true\n            }\n            return topElement.hasAncestor(this)\n        }\n\n    })\n\n}",
  "0Za2g+Z5RG+OSsaGyQDxCwJFqCuYENstQKdapP0YI5A=": "\"use strict\";\n\n/*\n\n    CanvasTextTapeMeasure\n\n    Used to measure rendered text dimensions given a string and a style.\n    \n    Example uses:\n\n            const width = CanvasTextTapeMeasure.shared().getTextWidth(text, fontString);\n\n*/\n\n(class CanvasTextTapeMeasure extends ProtoClass {\n    \n    initPrototypeSlots () {\n        //this.newSlot(\"cache\", new Map())\n        this.newSlot(\"canvas\", null)\n        this.newSlot(\"context\", null)\n    }\n\t\n    init () {\n        super.init()\n        this.setCanvas(document.createElement(\"canvas\"))\n        this.setContext(this.canvas().getContext(\"2d\"))\n        return this\n    }\n\n    getTextWidth (text, fontString) {\n        //font The css font descriptor that text is to be rendered with (e.g. \"14px verdana\").\n        const context = this.context()\n        context.font = fontString;\n        const metrics = context.measureText(text)\n        return metrics.width\n    }       \n\n    static selfTest () {\n        const tape = CanvasTextTapeMeasure.clone()\n        const w = tape.getTextWidth(\"hello there!\", \"bold 12pt arial\");\n        assert(Math.round(w) === 86)\n        //console.log(getTextWidth(\"hello there!\", \"bold 12pt arial\"));  // close to 86\n        return this\t\n    }\n\t\n}.initThisClass());\n\n//CanvasTextTapeMeasure.selfTest()\n\n",
  "RuSO+o2KLr67wqJC4M1irsAYQHziwRikfZgFfqLF8mo=": "\"use strict\";\n\n/*\n\n    DomTextTapeMeasure\n\n    Used to measure rendered text dimensions given a string and a style.\n    \n    Example uses:\n\n            const size1 = DomTextTapeMeasure.shared().sizeOfCssClassWithHtmlString(this.elementClassName(), text);\n            const h = size1.height;\n\n            const size2 = DomTextTapeMeasure.shared().sizeOfElementWithHtmlString(domElement, text);\n            const w = size2.width;\n    \n    TODO: move to using separate document\n\n*/\n\n(class DomTextTapeMeasure extends ProtoClass {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"document\", null)\n        this.newSlot(\"testElement\", null)\n\n        this.newSlot(\"stylesToCopy\", [\n            \"fontSize\",\n            \"fontStyle\", \n            \"fontWeight\", \n            \"fontFamily\",\n            \"lineHeight\", \n            \"textTransform\", \n            \"letterSpacing\"\n        ])\n        \n        this.newSlot(\"cache\", new Map())\n        this.newSlot(\"cacheKeys\", new Array())\n        this.newSlot(\"maxCacheKeys\", 100)\n    }\n\n    document () {\n        // return document\n        if (!this._document) {\n            this.setDocument(new Document())\n        }\n        return this._document\n    }\n\t\n    testElement () {\n        if (!this._testElement) {\n            this._testElement = this.createTestElement()\n        }\n        return this._testElement\n    }\n\t\n    createTestElement () {\n        const e = document.createElement(\"div\");\n\t    e.setAttribute(\"id\", this.typeId());\n        e.style.display = \"block\";\n        e.style.position = \"absolute\";\n        e.style.width = \"auto\";\n        e.style.left = -1000;\n        e.style.top  = -1000;\n        e.style.visibility = \"hidden\";\n        this.document().body.appendChild(e);\n        return e\t\t\n    }\n\n    addToCache (k, v) {\n        const keys = this.cacheKeys()\n        \n        if (keys.length > this.maxCacheKeys()) {\n            const oldKey = keys.shift() // first in, first out\n            this.cache().delete(oldKey)\n        }\n\n        this.cache().set(k, v)\n        keys.push(k)\n        console.log(this.type() + \" caching: \" + keys.length)\n    }\n\n    sizeOfElementWithHtmlString (element, text) {\n        if (this.cache().has(text)) {\n            return this.cache().get(text)\n        }\n\n        const e = this.testElement()\n        //e.cssText = element.cssText // this would force reflow?\n\t\t\n        this.stylesToCopy().forEach(function (styleName) {\n            const v = element.style[styleName]\n            if (v) {\n                e.style[styleName] = v\n            } else {\n                delete e.style[styleName]\n            }\n        })\n\t\t\n        e.innerHTML = element.innerHTML\n\t\t\n        const width = (e.clientWidth + 1) \n        const height = (e.clientHeight + 1) \n        this.clean()\n\n        const result = { width: width, height: height }\n        this.addToCache(text, result)\n        return result\n    }\n\t\n    clean () {\n        const e = this.testElement()\n        e.innerHTML = \"\"\n        e.className = \"\"\n        this.stylesToCopy().forEach(styleName => delete e.style[styleName] )\n        return this\t\n    }\n\t\n}.initThisClass());\n",
  "A/3nyd8hE/TBO3ElGgAlSRDC5DQPsEWvLlGh/fiFGpU=": "\"use strict\";\n\n/*\n    DomView\n\n    Base view class. Wraps a dom element. \n    This is wrapped instead of a category or subclass of Element/etc because:\n      - The DOM doesn't play nicely with such extensions.\n      - Keep open possibility of being ability swap out DOM as a render/event layer \n    \n    TODO: add class variable validPropertyValues[propertyName] -> validValueSet and check css values if available?\n\n*/\n\n(class ElementDomView extends ProtoClass {\n\n    /*\n    static initClass () {\n        this.newClassSlot(\"viewsWithoutParents\", new Set()) // track these so we can retire them, but not during drag & drop \n        this.newClassSlot(\"isPausingRetires\", false) // when true, retireQueue is paused\n    }\n\n    static pauseRetires () {\n        this.setIsPausingRetires(true)\n    }\n\n    static unpauseRetires () {\n        this.setIsPausingRetires(false)\n    }\n\n    static retireParentlessViews () {\n        debugger;\n        const parentless = this.viewsWithoutParents()\n\n        while (parentless.size) { // do this effective \"pop\" loop, so it's ok to delete items inside a prepareToRetire\n            if (this.isPausingRetires()) {\n                console.log(\"retireParentlessViews  isPausingRetires\")\n                return\n            }\n\n            const view = parentless.pop();\n            view.prepareToRetire()\n            parentless.delete(view)\n        }\n    }\n    */\n\n    static documentBodyView () {\n        return DocumentBody.shared()\n    }\n    \n    initPrototypeSlots () {\n        this.newSlot(\"elementClassName\", \"\")\n        this.newSlot(\"elementType\", \"div\")\n        this.newSlot(\"element\", null)\n    }\n\n    init () {\n        super.init()\n        this.setupElement()\n        return this\n    }\n\n    // retiring\n\n    gestureRecognizerListeners () {\n        const results = this.gestureRecognizers().map(gr => gr.allEventListeners()).flat()\n        results.forEach(result => {\n            assert(result.thisClass().isKindOf(EventListener))\n        })\n        return results\n    }\n\n    allEventListeners () {\n        const results = [this.eventListeners(), this.gestureRecognizerListeners()].flat()\n        /*\n        results.forEach(result => {\n            assert(result.thisClass().isKindOf(EventListener))\n        })\n        */\n        return results\n    }\n\n    fullActiveEventListenerCount () {\n        return this.allEventListeners().filter(v => v.isListening()).length\n    }\n\n    externalFullActiveEventListenerCount () {\n        return EventListener.activeListenersForOwner(this).length;\n    }\n\n    /*\n    assertEventListenerCountsMatch () {\n        let internal = this.fullActiveEventListenerCount()\n        if (isNaN(internal)) {\n            debugger;\n            this.fullActiveEventListenerCount()\n        }\n        let external = this.externalFullActiveEventListenerCount()\n        if (internal !== external) {\n            console.log(this.typeId() + \" internal: \" + internal + \" \", this.allEventListeners().filter(v => v.isListening()).map(v => v.fullMethodName()) )\n            console.log(this.typeId() + \" external: \" + external + \" \", EventListener.activeListenersForOwner(this).map(v => v.fullMethodName()))\n            this.fullActiveEventListenerCount();\n            EventListener.activeListenersForOwner(this);\n            debugger;\n        }\n        //assert(internal === external)\n    }\n    */\n\n    prepareToRetire () {\n        //debugger;\n        console.log(this.typeId() + \" prepareToRetire\")\n        assert(!this.hasParentView())\n\n        // if view has no parent at the end of event loop, \n        // our policy is to retire the view\n\n        this.setIsRegisteredForVisibility(false) // this one isn't a listener\n        \n        this.retireSubviewTree()\n\n        // do this after removing subviews, just in case events where added by those changes\n        this.removeAllGestureRecognizers()\n        this.removeAllListeners()\n        this.cancelAllTimeouts()\n\n        //this.assertEventListenerCountsMatch()\n\n        /*\n        if (this.externalFullActiveEventListenerCount()) {\n            console.warn(this.typeId() + \" was unable to remove the following event listeners:\")\n            EventListener.showActiveForOwner(this)\n            debugger\n        }\n        */\n\n        //assert(!EventListener.activeOwners().has(this))\n\n        SyncScheduler.shared().unscheduleTarget(this)\n\n        //if (this.isFirstResponder()) {\n        //    this.blur() / is this needed?\n        //}\n\n        this.detachFromElement()\n\n        super.prepareToRetire() // call on super\n        return this\n    }\n\n    detachFromElement () {\n        const e = this.element()\n        //e.style.transition = \"all 0s\" // probably not needed\n        if (e) {\n            e.setDomView(null)\n            this._element = null\n        }\n        e.removeAllChildren()\n    }\n\n    retireSubviewTree () {\n        // this should be called by:\n        //   scheduleRetireIfReady() -> prepareToRetire()\n        // will this cause a SyncAction loop issue as this will result in adding:\n        //   scheduleMethod(\"retireIfReady\")\n        // on subviews, so we do it in a way that avoids this.\n\n        this.subviews().forEach(sv => {\n            sv.setParentView(null)\n            sv.prepareToRetire()\n        })\n    }\n\n    // --- element ---\n\n    setElementId (aString) {\n        this.setAttribute(\"id\", aString)\n        return this\n    }\n\n    elementId () {\n        return this.getAttribute(\"id\")\n    }\n\n    setElement (e) {\n        if (e === this._element) {\n            console.warn(\"attempt to set to same element\")\n        } else {\n            if (Type.isNullOrUndefined(e)) {\n                console.warn(this.debugTypeId() + \" setElement null\")\n                debugger;\n            }\n            \n            //assert(!this._element) // element shouldn't change, if only to avoid dealing with listener issues\n            \n            if (this._element) {\n                this.removeAllListeners()\n            }\n            \n\n            this._element = e\n            e.setDomView(this)\n            /*\n            if (e) {\n                // use timer as focus listener can't be set up yet - why not?\n                this.addTimeout(() => { this.setIsRegisteredForFocus(true); }, 0) \n            }\n            */\n        }\n        return this\n    }\n\n    hasElement () {\n        return !Type.isNullOrUndefined(this.element())\n    }\n\n    createElement () {\n        const e = document.createElement(this.elementType())\n        return e\n    }\n\n    setupElement () {\n        const e = this.createElement()\n        this.setElement(e)\n        this.setElementId(this.debugTypeId())\n        //this.setupElementClassName()\n        return this\n    }\n\n    escapedElementId () {\n        const id = this.elementId()\n        const escapedId = id.replace(/[^a-z|\\d]/gi, '\\\\$&');\n        return escapedId\n    }\n\n    setupElementClassName () {\n        const e = this.element()\n        const ancestorNames = this.thisClass().ancestorClassesIncludingSelf().map(obj => obj.type())\n        ancestorNames.forEach(name => e.classList.add(name))\n        return this\n    }\n\n    insertElementClassName (aName) {\n        const e = this.element()\n        e.classList.add(aName)\n        return this\n    }\n\n    removeElementClassName (aName) {\n        const e = this.element()\n        e.classList.remove(aName)\n        return this\n    }\n\n    setElementClassNames (names) {\n        this.setElementClassName(names.join(\" \"))\n        return this\n    }\n  \n    // --- element class name ---\n\n    setElementClassName (aName) {\n        if (this._elementClassName !== aName) {\n            this._elementClassName = aName\n            if (this.element()) {\n                this.setAttribute(\"class\", aName);\n            }\n        }\n        return this\n    }\n\n    elementClassName () {\n        if (this.element()) {\n            const className = this.getAttribute(\"class\");\n            this._elementClassName = className\n            return className\n        }\n        return this._elementClassName\n    }\n\n    loremIpsum (maxWordCount) {\n        this.setInnerHtml(\"\".loremIpsum(10, 40))\n        return this\n    }\n\n    // --- editing - abstracted from content editable for use in non text views ---\n\n    setIsEditable (aBool) {\n        // subclasses can override for non text editing behaviors e.g. a checkbox, toggle switch, etc\n        this.setContentEditable(aBool)\n        return this\n    }\n\n    isEditable () {\n        return this.isContentEditable()\n    }\n\n    // --- content editing ---\n\n    setContentEditable (aBool) {\n        //console.log(this.elementClassName() + \" setContentEditable(\" + aBool + \")\")\n        if (aBool) {\n            this.makeCursorText()\n        } else {\n            this.makeCursorDefault() // is this correct?\n        }\n\n        this.setAttribute(\"contentEditable\", aBool ? \"true\" : \"false\")\n\n        /*\n        if (this.showsHaloWhenEditable()) {\n            this.setBoxShadow(aBool ? \"0px 0px 5px #ddd\" : \"none\")\n        }\n        */\n\n        this.setCssProperty(\"outline\", \"none\")\n\n        this.setIsRegisteredForKeyboard(aBool)\n\n        if (aBool) {\n            this.turnOnUserSelect()\n        } else {\n            this.setUserSelect(\"auto\")\n        }\n\n        this.setIsRegisteredForClipboard(aBool) // so we receive onPaste events from clipboard\n\n        return this\n    }\n\n    isContentEditable () { \n        // there's a separate method for contentEditable() that just accesses element attribute\n        //const v = window.getComputedStyle(this.element(), null).getPropertyValue(\"contentEditable\");\n        const s = this.getAttribute(\"contentEditable\")\n        if (s === \"inherit\" && this.parentView()) {\n            return this.parentView().isContentEditable()\n        }\n        const aBool = (s === \"true\" || s === true)\n        return aBool\n    }\n\n    contentEditable () {\n        return this.getAttribute(\"contentEditable\") === \"true\"\n    }\n\n}.initThisClass());\n",
  "2AgQnP/tRONhGigM9wnB3TssFhJp5QydeUo4dVfvoY8=": "\"use strict\";\n\n/*\n    CssDomView\n\n    CSS related state and behavior.\n\n*/\n\n(class CssDomView extends ElementDomView {\n    \n    initPrototypeSlots () {\n        // css hidden values\n        this.newSlot(\"hiddenDisplayValue\", undefined)\n        /*\n        this.newSlot(\"hiddenMinHeight\", undefined)\n        this.newSlot(\"hiddenMaxHeight\", undefined)\n        */\n        this.newSlot(\"hiddenTransitionValue\", undefined)\n        //this.newSlot(\"pushedAttributes\", undefined)\n        this.newSlot(\"pushedSlotValues\", undefined)\n        this.newSlot(\"cachedSize\", null)\n    }\n\n    \n    init () {\n        super.init()\n        //this.setDisplay(\"block\")\n        return this\n    }\n\n    // --- push/pop slot values ---\n    // useful for pushing a css attribute using it's normal getter/setter methods\n\n    pushedSlotValues () {\n        if (Type.isUndefined(this._pushedSlotValues)) {\n            this._pushedSlotValues = new Map()\n        }\n        return this._pushedSlotValues\n    }\n\n    pushedSlotValuesAt (slotName) {\n        const p = this.pushedSlotValues()\n        if (!p.has(slotName)) {\n            p.set(slotName, [])\n        }\n        return p.get(slotName)\n    }\n\n    pushSlotValue (slotName, newValue) {\n        const stack = this.pushedSlotValuesAt(slotName)\n        const oldValue = this[slotName].apply(this)\n        stack.push(oldValue)\n        const setterName = \"set\" + slotName.capitalized()\n        this[setterName].call(this, newValue)\n        return this\n    }\n\n    popSlotValue (slotName) {\n        const a = this.pushedSlotValuesAt(slotName)\n        if (a.length === 0) {\n            throw new Error(\"attempt to pop empty slot value stack\")\n        }\n        const oldValue = a.pop()\n        const setterName = \"set\" + slotName.capitalized()\n        this[setterName].call(this, oldValue)\n        return this\n    }\n\n    /*\n    // --- push and pop attribute stacks ---\n\n    pushedAttributes () {\n        if (Type.isUndefined(this._pushedAttributes)) {\n            this._pushedAttributes = new Map()\n        }\n        return this._pushedAttributes\n    }\n\n    pushedAttributesAt (name) {\n        const p = this.pushedAttributes()\n        if (!p.has(name)) {\n            p.set(name, [])\n        }\n        return p.get(name)\n    }\n\n    pushAttribute (name, newValue) {\n        const stack = this.pushedAttributesAt(name)\n        const oldValue = this.getCssProperty(name)\n        stack.push(oldValue)\n        this.setCssProperty(name, newValue) // NOTE: bypasses css change callbacks\n        return this\n    }\n\n    popAttribute (name) {\n        const a = this.pushedAttributesAt(name)\n        if (a.length === 0) {\n            throw new Error(\"attempt to pop empty css attribute stack\")\n        }\n        const oldValue = a.pop()\n        this.setCssProperty(name, oldValue) // NOTE: bypasses css change callbacks\n        return this\n    }\n    */\n\n    // ------------------------------\n    \n    /*    \n    applyCSS (ruleName) {\n        if (ruleName == null) { \n            ruleName = this.elementClassName()\n        }\n        CSS.ruleAt(ruleName).applyToElement(this.element())\n        return this\n    }\n    */\n\n    stylesheetWithClassName (className) {\n        for (let i = 0; i < document.styleSheets.length; i++) {\n            const stylesheet = document.styleSheets[i]\n\n            if (\"cssRules\" in stylesheet) {\n                try {\n                    const rules = stylesheet.cssRules\n                    for (let j = 0; j < rules.length; j++) {\n                        const rule = rules[j]\n                        const ruleClassName = rule.selectorText.split(\" \")[0]\n                        console.log(\"rule.selectorText: \", rule.selectorText)\n                        if (ruleClassName === className) {\n                            return stylesheet\n                        }\n                    }\n                } catch (e) {\n                    //console.log(\"couldn't add CSS rule: \" + rule + \"\")\n                }\n            }\n        }\n        return null\n    }\n\n    setCssDict (aDict) {\n        Reflect.ownKeys(aDict).forEach((k) => {\n            const v = aDict[k]\n            this.setCssProperty(k, v)\n        })\n        return this\n    }\n\n    // --- attributes ---\n\n    setAttribute (k, v) {\n        //ThrashDetector.shared().didWrite(k, this)\n        this.element().setAttribute(k, v)\n        return this\n    }\n\n    getAttribute (k) {\n        this.didDomRead(k, this)\n        const v = this.element().getAttribute(k)\n        if (v === null) {\n            let result = this.element()[k]\n            assert(result !== null)\n            //console.log(\"getAttribute('\" + k + \"') = \", v)\n            //console.log(\"element['\" + k + \"'] = \", result)\n            //console.log(\"-----------------------> getAttribute '\" + k + \"' \", result) \n            //throw new Error(\"move this to another method\")\n            return result\n        }\n        return v\n    }\n\n    removeAttribute (k) {\n        if (this.element().hasAttribute(k)) {\n            //ThrashDetector.shared().didWrite(k, this)\n            this.element().removeAttribute(k)\n        }\n        return this\n    }\n\n    // --- css properties ---\n\n    setSpecialCssProperty (k, newValue) {\n        //ThrashDetector.shared().didWrite(k, this)\n\n        assert(k[0] === \"-\" && !k.beginsWith(\"--\")) // sanity check\n\n        this.cssStyle()[k] = newValue\n        return this\n    }\n\n    getSpecialCssProperty (k) {\n        this.didDomRead(k)\n\n        assert(k[0] === \"-\" && !k.beginsWith(\"--\")) // sanity check\n\n        return this.cssStyle()[k]\n    }\n\n    removeCssProperty (k) {\n        //ThrashDetector.shared().didWrite(k, this)\n        this.element().style.removeProperty(k)\n        return this\n    }\n\n    setCssProperty (key, newValue, didChangeCallbackFunc) {\n\n        // sanity checks\n        assert(Type.isString(key))\n\n        if (key[0] === \"-\" && key[1] !== \"-\") { // no dash, and double dash are ok\n            throw new Error(\"use setSpecialCssProperty for single dash options\")\n            //this.setSpecialCssProperty(key, newValue)\n            //return this\n        }\n\n        const style = this.cssStyle()\n        const doesSanityCheck = false\n        //const oldValue = style.getPropertyValue(key)\n\n        //if (String(oldValue) !== String(newValue)) {\n        if (true) {\n                if (newValue == null) {\n                this.removeCssProperty(key)\n            } else {\n                //style[key] = newValue\n                style.setProperty(key, newValue)\n                //ThrashDetector.shared().didWrite(key, this)\n\n                /*\n                if (doesSanityCheck) {\n                    // sanity check the result\n                    // but ignore these keys as they have equivalent functional values \n                    // that can have different string values\n                    const ignoredKeys = { \n                        \"background-position\": true,  \n                        \"transition\": true, \n                        \"color\": true , \n                        \"background-color\": true,\n                        \"box-shadow\": true,\n                        \"border-bottom\": true,\n                        \"transform-origin\": true,\n                        \"outline\": true,\n                        \"border\": true,\n                        \"border-color\": true\n                    }\n\n                    if (!(key in ignoredKeys)) {\n                        //const resultValue = style[key]\n                        const resultValue = style.getPropertyValue(key)\n                        if (resultValue != newValue) {\n                            let msg = \"DomView: style['\" + key + \"'] not set to expected value\\n\";\n                            msg += \"     set: <\" + typeof(newValue) + \"> '\" + newValue + \"'\\n\";\n                            msg += \"     got: <\" + typeof(resultValue) + \"> '\" + resultValue + \"'\\n\";\n                            console.warn(msg)\n                            //throw new Error(msg) \n                        }\n                    }\n                }\n                */\n            }\n\n            if (didChangeCallbackFunc) {\n                didChangeCallbackFunc()\n            }\n        }\n\n        return this\n    }\n\n    getCssProperty (key, errorCheck) {\n        /*\n        if (errorCheck) {\n            throw new Error(\"getCssProperty called with 2 arguments\")\n        }\n        */\n\n        /*\n        if (key[0] === \"-\") {\n            throw new Error(\"use getSpecialCssProperty instead\")\n            return this.getSpecialCssProperty(key)\n        }\n        */\n\n        this.didDomRead(key)\n\n        //return this.cssStyle()[key]\n        return this.cssStyle().getPropertyValue(key)\n    }\n\n    // css px attributes\n\n    setPxCssProperty (name, value, didChangeCallbackFunc) {\n        this.setCssProperty(name, this.pxNumberToString(value), didChangeCallbackFunc)\n        return this\n    }\n\n    getPxCssProperty (name, errorCheck) {\n        const s = this.getCssProperty(name, errorCheck)\n        if (s.length) {\n            return this.pxStringToNumber(s)\n        }\n        return 0\n    }\n\n    // computed style\n\n    getComputedCssProperty (name, errorCheck) {\n        //debugger; // getComputedStyle forces a layout - make sure it's needed \n        return window.getComputedStyle(this.element()).getPropertyValue(name)\n    }\n\n    getComputedPxCssProperty (name, errorCheck) {\n     //   debugger; // getComputedCssProperty forces a reflow? - make sure it's needed \n        const s = this.getComputedCssProperty(name, errorCheck)\n        if (s.length) {\n            return this.pxStringToNumber(s)\n        }\n        return 0\n    }\n\n    // --- css properties ---\n\n    setPosition (s) {\n        this.setCssProperty(\"position\", s)\n        return this\n    }\n\n    position () {\n        return this.getCssProperty(\"position\")\n    }\n\n    // pointer events\n\n    pointerEventsValidValues () {\n        return [null, \n            \"auto\", \n            \"none\", \n            \"visiblePainted\", \n            \"visibleFill\", \n            \"visibleStroke\", \n            \"visible\", \n            \"painted\", \n            \"fill\", \n            \"stroke\", \n            \"all\", \n            \"inherit\", \n            \"initial\", \n            \"unset\"]\n    }\n\n    setPointerEvents (s) {\n        assert(this.pointerEventsValidValues().contains(s))\n        return this.setCssProperty(\"pointer-events\", s)\n    }\n\n    pointerEvents () {\n        return this.getCssProperty(\"pointer-events\")\n    }\n\n    // transform\n\n    textTransformValidValues () {\n        return [null, \"none\", \"capitalize\", \"uppercase\", \"lowercase\", \"initial\", \"inherit\"]\n    }\n\n    setTextTransform (v) {\n        assert(this.textTransformValidValues().contains(v))\n        this.setCssProperty(\"text-transform\", v)\n        return this\n    }\n\n    textTransform () {\n        return this.getCssProperty(\"text-transform\")\n    }\n\n    // word wrap\n\n    wordWrapValidValues () {\n        return [null, \"normal\", \"break-word\", \"initial\", \"inherit\"]\n    }\n\n    setWordWrap (v) {\n        assert(this.wordWrapValidValues().contains(v))\n        this.setCssProperty(\"word-wrap\", v)\n        return this\n    }\n\n    wordWrap () {\n        return this.getCssProperty(\"word-wrap\")\n    }\n\n    // zoom\n\n    setZoom (s) {\n        this.setCssProperty(\"zoom\", s)\n        return this\n    }\n\n    zoom () {\n        return this.getCssProperty(\"zoom\")\n    }\n\n    zoomRatio () {\n        return Number(this.zoom().before(\"%\")) / 100\n    }\n\n    setZoomRatio (r) {\n        //console.log(\"setZoomRatio: \", r)\n        this.setZoomPercentage(r * 100)\n        return this\n    }\n\n    setZoomPercentage (aNumber) {\n        assert(Type.isNumber(aNumber))\n        this.setCssProperty(\"zoom\", aNumber + \"%\")\n        return this\n    }\n\n    // font family\n\n    setFontFamily (s) {\n        assert(Type.isString(s) || Type.isNull(s))\n        this.setCssProperty(\"font-family\", s)\n        return this\n    }\n\n    fontFamily () {\n        return this.getCssProperty(\"font-family\")\n    }\n\n    // font weight\n\n    fontWeightValidatorFunction (v) {\n       return (v) => { Type.isNumber(v) || [null, \"normal\", \"bold\", \"bolder\", \"lighter\", \"initial\", \"inherit\"].contains(v) }\n    }\n\n    setFontWeight (v) {\n        //assert(this.fontWeightValidatorFunction()(v))\n        this.setCssProperty(\"font-weight\", v)\n        return this\n    }\n\n    fontWeight () {\n        return this.getCssProperty(\"font-weight\")\n    }\n\n    // font size\n\n    setFontSizeAndLineHeight (s) {\n        this.setFontSize(s)\n        this.setLineHeight(s)\n        return this\n    }\n\n    setFontSize (s) {\n        this.setCssProperty(\"font-size\", s)\n        return this\n    }\n\n    fontSize () {\n        return this.getCssProperty(\"font-size\")\n    }\n\n    computedFontSize () {\n        return this.getComputedCssProperty(\"font-size\")\n    }\n\n    // px font size\n\n    setPxFontSize (s) {\n        this.setPxCssProperty(\"font-size\", s)\n        return this\n    }\n\n    pxFontSize () {\n        return this.getPxCssProperty(\"font-size\")\n    }\n\n    computedPxFontSize () {\n        return this.getComputedPxCssProperty(\"font-size\")\n    }\n\n    // text-shadow\n\n    setTextShadow (s) {\n        this.setCssProperty(\"text-shadow\", s)\n        return this\n    }\n\n    textShadow () {\n        return this.getCssProperty(\"text-shadow\")\n    }\n\n    // ---\n\n    // letter spacing\n\n    setLetterSpacing (s) {\n        this.setCssProperty(\"letter-spacing\", s)\n        return this\n    }\n\n    letterSpacing () {\n        return this.getCssProperty(\"letter-spacing\")\n    }\n\n    computedLetterSpacing () {\n        return this.getComputedCssProperty(\"letter-spacing\")\n    }\n\n    // margin\n\n    setMarginString (s) {\n        this.setCssProperty(\"margin\", s)\n        return this\n    }\n\n    // margin\n\n    setMargin (s) {\n        this.setCssProperty(\"margin\", s)\n        this.setMarginTop(null)\n        this.setMarginBottom(null)\n        this.setMarginLeft(null)\n        this.setMarginRight(null)\n        return this\n    }\n\n    margin () {\n        return this.getCssProperty(\"margin\")\n    }\n\n    // margin px\n\n    setMarginPx (s) {\n        this.setPxCssProperty(\"margin\", s)\n        this.setMarginTop(null)\n        this.setMarginBottom(null)\n        this.setMarginLeft(null)\n        this.setMarginRight(null)\n        return this\n    }\n\n    marginPx () {\n        return this.getPxCssProperty(\"margin\")\n    }\n\n    // margin top\n\n    setMarginTop (m) {\n        if (Type.isNumber(m)) {\n            this.setPxCssProperty(\"margin-top\", m)\n        } else {\n            this.setCssProperty(\"margin-top\", m)\n        }\n        return this\n    }\n\n    // margin bottom\n\n    setMarginBottom (m) {\n        if (Type.isNumber(m)) {\n            this.setPxCssProperty(\"margin-bottom\", m)\n        } else {\n            this.setCssProperty(\"margin-bottom\", m)\n        }\n        return this\n    }\n\n    // margin left\n\n    setMarginLeft (m) {\n        if (Type.isNumber(m)) {\n            this.setPxCssProperty(\"margin-left\", m)\n        } else {\n            this.setCssProperty(\"margin-left\", m)\n        }\n        return this\n    }\n\n    // margin right\n\n    setMarginRight (m) {\n        this.setCssProperty(\"margin-right\", m)\n        return this\n    }\n\n    marginRight () {\n        return this.getCssProperty(\"margin-right\")\n    }\n\n    // margin right px\n\n    setMarginRightPx (m) {\n        this.setPxCssProperty(\"margin-right\", m)\n        return this\n    }\n\n    marginRightPx () {\n        return this.getPxCssProperty(\"margin-right\")\n    }\n\n    // padding\n\n    setPadding (v) {\n        assert(Type.isNull(v) || Type.isString(v))\n        this.setPaddingTop(null)\n        this.setPaddingBottom(null)\n        this.setPaddingLeft(null)\n        this.setPaddingRight(null)\n        this.setCssProperty(\"padding\", v)\n        return this\n    }\n    \n    padding () {\n        return this.getCssProperty(\"padding\")\n    }\n\n    // top\n\n    setPaddingTop (v) {\n        assert(Type.isString(v) || Type.isNull(v))\n        this.setCssProperty(\"padding-top\", v)\n        return this\n    }\n\n    paddingTop () {\n        return this.getCssProperty(\"padding-top\")\n    }\n    // bottom\n\n    setPaddingBottom (v) {\n        assert(Type.isString(v) || Type.isNull(v))\n        this.setCssProperty(\"padding-bottom\", v)\n        return this\n    }\n\n    paddingBottom () {\n        return this.getCssProperty(\"padding-bottom\")\n    }\n\n    // left\n\n    setPaddingLeft (v) {\n        assert(Type.isString(v) || Type.isNull(v))\n        this.setCssProperty(\"padding-left\", v)\n        return this\n    }\n\n    paddingLeft () {\n        return this.getCssProperty(\"padding-left\")\n    }\n\n    // right\n    \n    setPaddingRight (v) {\n        assert(Type.isString(v) || Type.isNull(v))\n        this.setCssProperty(\"padding-right\", v)\n        return this\n    }\n\n    paddingRight () {\n        return this.getCssProperty(\"padding-right\")\n    }\n\n    // padding px\n\n    setPaddingPx (aNumber) {\n        this.setPxCssProperty(\"padding\", aNumber)\n        return this\n    }\n\n    paddingPx () {\n        return this.getPxCssProperty(\"padding\")\n    }\n\n    // padding right px\n\n    setPaddingRightPx (aNumber) {\n        this.setPxCssProperty(\"padding-right\", aNumber)\n        return this\n    }\n\n    paddingRightPx () {\n        return this.getPxCssProperty(\"padding-right\")\n    }\n\n    // padding left px\n\n    setPaddingLeftPx (aNumber) {\n        this.setPxCssProperty(\"padding-left\", aNumber)\n        return this\n    }\n\n    paddingLeftPx () {\n        return this.getPxCssProperty(\"padding-left\")\n    }\n\n    // padding top px\n\n    setPaddingTopPx (aNumber) {\n        this.setPxCssProperty(\"padding-top\", aNumber)\n        return this\n    }\n\n    paddingTopPx () {\n        return this.getPxCssProperty(\"padding-top\")\n    }\n\n    // padding bottom px\n\n    setPaddingBottomPx (aNumber) {\n        this.setPxCssProperty(\"padding-bottom\", aNumber)\n        return this\n    }\n\n    paddingBottomPx () {\n        return this.getPxCssProperty(\"padding-bottom\")\n    }\n\n    // background color\n\n    setBackgroundColor (v) {\n        this.setCssProperty(\"background-color\", v)\n        return this\n    }\n\n    backgroundColor () {\n        return this.getCssProperty(\"background-color\")\n    }\n\n    computedBackgroundColor () {\n        return this.getComputedCssProperty(\"background-color\")\n    }\n\n    // background image\n\n    setBackgroundImage (v) {\n        this.setCssProperty(\"background-image\", v)\n        return this\n    }\n\n    backgroundImage () {\n        return this.getCssProperty(\"background-image\")\n    }\n\n    setBackgroundImageUrlPath (path) {\n        this.setBackgroundImage(\"url(\\\"\" + path + \"\\\")\")\n        return this\n    }\n\n    // background size\n\n    setBackgroundSizeWH (x, y) {\n        this.setCssProperty(\"background-size\", x + \"px \" + y + \"px\")\n        return this\n    }\n\n    setBackgroundSize (v) {\n        assert(Type.isNull(v) || Type.isString(v))\n        this.setCssProperty(\"background-size\", v)\n        return this\n    }\n\n    makeBackgroundCover () {\n        this.setBackgroundSize(\"cover\")\n        return this\n    }\n\n    makeBackgroundContain () {\n        this.setBackgroundSize(\"contain\")\n        return this\n    }\n\n    // background repeat\n\n    makeBackgroundNoRepeat () {\n        this.setBackgroundRepeat(\"no-repeat\")\n        return this\n    }\n\n    setBackgroundRepeat (s) {\n        assert(Type.isString(s))\n        this.setCssProperty(\"background-repeat\", s)\n        return this\n    }\n\n    backgroundRepeat () {\n        return this.getCssProperty(\"background-repeat\")\n    }\n\n    // background position\n\n    makeBackgroundCentered () {\n        this.setBackgroundPosition(\"center\")\n        return this\n    }\n\n    setBackgroundPosition (s) {\n        this.setCssProperty(\"background-position\", s)\n        return this\n    }\n\n    backgroundPosition () {\n        return this.getCssProperty(\"background-position\")\n    }\n\n    // icons - TODO: find a better place for this\n\n    pathForIconName (aName) {\n        const pathSeparator = \"/\"\n        return [\"resources\", \"icons\", aName + \".svg\"].join(pathSeparator)\n    }\n\n    // transition\n\n    justSetTransition (s) {\n        this.setCssProperty(\"transition\", s)\n        return this\n    }\n\n    setTransition (s) {\n        this.justSetTransition(s)\n\n        if (this._transitions) {\n            //debugger;\n            this.transitions().syncFromDomView()\n        }\n\n        return this\n    }\n\n    transition () {\n        return this.getCssProperty(\"transition\")\n    }\n\n    // helper for hide/unhide transition\n\n    isTransitionHidden () {\n        return !Type.isNullOrUndefined(this.hiddenTransitionValue())\n    }\n\n    hideTransition () {\n        if (!this.isTransitionHidden()) {\n            this.setHiddenTransitionValue(this.transition())\n            this.setTransition(\"all 0s\")\n            this.subviews().forEach(sv => sv.hideTransition())\n        }\n        return this\n    }\n\n    unhideTransition () {\n        if (this.isTransitionHidden()) {\n            this.setTransition(this.hiddenTransitionValue())\n            this.setHiddenTransitionValue(null)\n            this.subviews().forEach(sv => sv.unhideTransition())\n        } else {\n            this.setTransition(null)\n        }\n        return this\n    }\n\n    // hide/unhide transition\n\n    /*\n    hideTransition () {\n        if (!Type.isNull(this.transition())) {\n            this.setHiddenTransitionValue(this.transition())\n            this.setTransition(null)\n            this.subviews().forEach(sv => sv.hideTransition())\n        }\n        return this\n    }\n\n    unhideTransition () {\n        if (Type.isNull(this.transition())) {\n            if (this.hiddenTransitionValue()) {\n                this.setTransition(this.hiddenTransitionValue())\n                this.setHiddenTransitionValue(null)\n                this.subviews().forEach(sv => sv.unhideTransition())\n            }\n        }\n        return this\n    }\n    */\n\n    // transitions\n\n    transitions () {\n        if (this._transitions == null) {\n            this._transitions = DomTransitions.clone().setDomView(this).syncFromDomView()\n        }\n        return this._transitions\n    }\n\n    // transforms\n\n    setTransform (s) {\n        this.setCssProperty(\"transform\", s)\n        return this\n    }\n\n    setTransformOrigin (s) {\n        //transform-origin: x-axis y-axis z-axis|initial|inherit;\n        //const percentageString = this.percentageNumberToString(aNumber)\n        this.setCssProperty(\"transform-origin\", s)\n        return this\n    }\n\n    /*\n    TODO: add setter/getters for:\n\n        perspective-origin: x-axis y-axis|initial|inherit;\n        transform-style: flat|preserve-3d|initial|inherit;\n        backface-visibility: hidden | visible;\n\n    */\n\n    // perspective\n\n    setPerspective (n) {\n        this.setPxCssProperty(\"perspective\", n)\n        return this\n    }\n\n    // opacity\n\n    opacityValidatorFunction () {\n        return (v) => { return Type.isNumber(v) || [null, \"auto\", \"inherit\", \"initial\", \"unset\"].contains(v) }\n    }\n\n    setOpacity (v) {\n        //assert(this.opacityValidatorFunction()(v))\n        this.setCssProperty(\"opacity\", v)\n        return this\n    }\n\n    opacity () {\n        return this.getCssProperty(\"opacity\")\n    }\n\n    // z index \n\n    setZIndex (v) {\n        this.setCssProperty(\"z-index\", v)\n        return this\n    }\n\n    zIndex () {\n        return this.getCssProperty(\"z-index\")\n    }\n\n    // cursor \n\n    setCursor (s) {\n        this.setCssProperty(\"cursor\", s)\n        return this\n    }\n\n    cursor () {\n        return this.getCssProperty(\"cursor\")\n    }\n\n    makeCursorDefault () {\n        this.setCursor(\"default\")\n        return this\n    }\n\n    makeCursorPointer () {\n        this.setCursor(\"pointer\")\n        return this\n    }\n\n    makeCursorText () {\n        this.setCursor(\"text\")\n        return this\n    }\n\n    makeCursorGrab () {\n        this.setCursor(\"grab\")\n        return this\n    }\n\n    makeCursorGrabbing () {\n        this.setCursor(\"grabbing\")\n        return this\n    }\n\n    makeCursorColResize () {\n        this.setCursor(\"col-resize\")\n        return this\n    }\n\n    makeCursorTileResize () {\n        this.setCursor(\"row-resize\")\n        return this\n    }\n\n\n    // top\n\n    setTop (v) {\n        assert(Type.isNull(v) || Type.isString(v))\n        this.setCssProperty(\"top\", v)\n        return this\n    }\n\n    top () {\n        return this.getCssProperty(\"top\")\n    }\n\n    // top px\n\n    setTopPx (v) {\n        assert(Type.isNull(v) || Type.isNumber(v))\n        this.setPxCssProperty(\"top\", v)\n        return this\n    }\n\n    topPx () {\n        return this.getPxCssProperty(\"top\")\n    }\n\n    // left\n\n    setLeft (v) {\n        assert(Type.isNull(v) || Type.isString(v))\n        this.setCssProperty(\"left\", v)\n        return this\n    }\n\n    left () {\n        return this.getCssProperty(\"left\")\n    }\n\n    // left px\n\n    setLeftPx (v) {\n        assert(Type.isNull(v) || Type.isNumber(v))\n        this.setPxCssProperty(\"left\", v)\n        return this\n    }\n\n    leftPx () {\n        return this.getPxCssProperty(\"left\")\n    }\n\n    // right\n\n    setRight (v) {\n        assert(Type.isNull(v) || Type.isString(v))\n        this.setCssProperty(\"right\", v)\n        return this\n    }\n\n\n    right () {\n        return this.getCssProperty(\"right\")\n    }\n\n    // right px\n\n    setRightPx (v) {\n        assert(Type.isNull(v) || Type.isNumber(v))\n        this.setPxCssProperty(\"right\", v)\n        return this\n    }\n\n    rightPx () {\n        return this.getPxCssProperty(\"right\")\n    }\n\n    // bottom\n\n    setBottom (v) {\n        assert(Type.isNull(v) || Type.isString(v))\n        this.setCssProperty(\"bottom\", v)\n        return this\n    }\n\n    bottom () {\n        return this.getCssProperty(\"bottom\")\n    }\n\n    // bottom px\n\n    setBottomPx (v) {\n        assert(Type.isNull(v) || Type.isNumber(v))\n        this.setPxCssProperty(\"bottom\", v)\n        return this\n    }\n\n    bottomPx () {\n        return this.getPxCssProperty(\"bottom\")\n    }\n\n    // float\n\n    setFloat (v) {\n        assert([null, \"left\", \"right\", \"none\", \"inline-start\", \"inline-end\", \"start\", \"end\", \"initial\", \"inherit\"].contains(v))\n        this.setCssProperty(\"float\", v)\n        return this\n    }\n\n    float () {\n        return this.getCssProperty(\"float\")\n    }\n\n    // box shadow\n\n    setBoxShadow (s) {\n        //this.debugLog(\".setBoxShadow(\" + s + \")\")\n        this.setCssProperty(\"box-shadow\", s)\n        return this\n    }\n\n    boxShadow () {\n        return this.getCssProperty(\"box-shadow\")\n    }\n\n    // sizing\n\n    setBoxSizing (s) {\n        //this.setBoxSizing(\"border-box\") content-box\n        return this.setCssProperty(\"box-sizing\", s)\n    }\n\n    boxSizing () {\n        return this.getCssProperty(\"box-sizing\")\n    }\n\n\n    // border \n\n    setBorder (s) {\n        this.setCssProperty(\"border\", s)\n        return this\n    }\n\n    border () {\n        return this.getCssProperty(\"border\")\n    }\n\n    // border style\n\n    setBorderStyle (s) {\n        this.setCssProperty(\"border-style\", s)\n        return this\n    }\n\n    borderStyle () {\n        return this.getCssProperty(\"border-style\")\n    }\n\n    // border color\n\n    setBorderColor (s) {\n        this.setCssProperty(\"border-color\", s)\n        return this\n    }\n\n    borderColor () {\n        return this.getCssProperty(\"border-color\")\n    }\n\n    // border top\n\n    setBorderTop (s) {\n        this.setCssProperty(\"border-top\", s)\n        return this\n    }\n\n    borderTop () {\n        return this.getCssProperty(\"border-top\")\n    }\n\n    setBorderTopStyle (s) {\n        this.setCssProperty(\"border-top-style\", s)\n        return this\n    }\n\n    setBorderTopWidth (s) {\n        this.setCssProperty(\"border-top-width\", s)\n        return this\n    }\n\n    setBorderTopColor (s) {\n        this.setCssProperty(\"border-top-color\", s)\n        return this\n    }\n\n    // border bottom\n\n    setBorderBottom (s) {\n        this.setCssProperty(\"border-bottom\", s)\n        return this\n    }\n\n    borderBottom () {\n        return this.getCssProperty(\"border-bottom\")\n    }\n\n    setBorderBottomStyle (s) {\n        this.setCssProperty(\"border-bottom-style\", s)\n        return this\n    }\n\n    setBorderBottomWidth (s) {\n        this.setCssProperty(\"border-bottom-width\", s)\n        return this\n    }\n\n    setBorderBottomColor (s) {\n        this.setCssProperty(\"border-bottom-color\", s)\n        return this\n    }\n\n    // border left\n\n    setBorderLeft (s) {\n        //this.debugLog(\" border-left set '\", s, \"'\")\n        this.setCssProperty(\"border-left\", s)\n        return this\n    }\n\n    borderLeft () {\n        return this.getCssProperty(\"border-left\")\n    }\n\n    setBorderLeftStyle (s) {\n        this.setCssProperty(\"border-left-style\", s)\n        return this\n    }\n\n    setBorderLeftWidth (s) {\n        this.setCssProperty(\"border-left-width\", s)\n        return this\n    }\n\n    setBorderLeftColor (s) {\n        this.setCssProperty(\"border-left-color\", s)\n        return this\n    }\n\n    // border right\n\n    setBorderRight (s) {\n        this.setCssProperty(\"border-right\", s)\n        return this\n    }\n\n    borderRight () {\n        return this.getCssProperty(\"border-right\")\n    }\n\n    borderRightPx () {\n        return this.getPxCssProperty(\"border-right\")\n    }\n\n    setBorderRightStyle (s) {\n        this.setCssProperty(\"border-right-style\", s)\n        return this\n    }\n\n    setBorderRightWidth (s) {\n        this.setCssProperty(\"border-right-width\", s)\n        return this\n    }\n\n    setBorderRightColor (s) {\n        this.setCssProperty(\"border-right-color\", s)\n        return this\n    }\n\n\n    // border radius\n\n    setBorderRadius (v) {\n        assert(Type.isNull(v) || Type.isString(v))\n        this.setCssProperty(\"border-radius\", v)\n        return this\n    }\n\n    borderRadius () {\n        return this.getCssProperty(\"border-radius\")\n    }\n\n    // border radius\n\n    setBorderRadiusPx (v) {\n        assert(Type.isNull(v) || Type.isNumber(v))\n        this.setPxCssProperty(\"border-radius\", v)\n        return this\n    }\n\n    borderRadiusPx () {\n        return this.getPxCssProperty(\"border-radius\")\n    }\n\n    // outline\n\n    setOutline (s) {\n        assert(Type.isString(s) || Type.isNull(s))\n        this.setCssProperty(\"outline\", s)\n        return this\n    }\n\n    outline () {\n        return this.getCssProperty(\"outline\")\n    }\n\n    // px line height\n\n    setPxLineHeight (aNumber) {\n        this.setPxCssProperty(\"line-height\", aNumber)\n        assert(this.lineHeight() === aNumber)\n        return this\n    }\n\n    pxLineHeight () {\n        return this.getPxCssProperty(\"line-height\")\n    }\n\n    // line height\n\n    setLineHeight (aString) {\n        assert(Type.isString(aString) || Type.isNull(aString))\n        this.setCssProperty(\"line-height\", aString)\n        return this\n    }\n\n    lineHeight () {\n        return this.getCssProperty(\"line-height\")\n    }\n\n    // alignment\n\n    validTextAlignValues () {\n        return [null, \"left\", \"right\", \"center\", \"justify\", \"justify-all\", \"start\", \"end\", \"match-parent\", \"initial\", \"inherit\", \"unset\"]\n    }\n\n    setTextAlign (v) {\n        assert(this.validTextAlignValues().contains(v))\n        this.setCssProperty(\"text-align\", v)\n        return this\n    }\n\n    textAlign () {\n        return this.getCssProperty(\"text-align\")\n    }\n\n    // clear\n\n    setClear (v) {\n        assert([null, \"none\", \"left\", \"right\", \"both\", \"initial\", \"inherit\"].contains(v))\n        this.setCssProperty(\"clear\", v)\n        return this\n    }\n\n    clear () {\n        return this.getCssProperty(\"clear\")\n    }\n\n    // flex \n\n    setFlex (v) {\n        assert(Type.isString(v) || Type.isNull(v))\n        this.setCssProperty(\"flex\", v)\n        return this\n    }\n\n    flex () {\n        return this.getCssProperty(\"flex\")\n    }\n\n    // flex wrap\n\n    setFlexWrap (v) {\n        assert([\"nowrap\", \"wrap\", \"wrap-reverse\", \"initial\", \"inherit\"].contains(v))\n        this.setCssProperty(\"flex-wrap\", v)\n        return this\n    }\n\n    flex () {\n        return this.getCssProperty(\"flex-wrap\")\n    }\n\n    // flex order\n\n    setOrder (v) {\n        assert(Type.isNull(v) || Type.isNumber(v) || [\"initial\", \"inherit\"].contains(v))\n        this.setCssProperty(\"order\", v)\n        return this\n    }\n\n    order () {\n        return this.getCssProperty(\"order\")\n    }\n\n    // flex align-items (flex-start, center, flex-end) - NOTE: alignment depends on direct of flex!\n\n    setAlignItems (v) {\n        assert([null, \"flex-start\", \"center\", \"flex-end\"].contains(v))\n        this.setCssProperty(\"align-items\", v)\n        return this\n    }\n\n    alignItems () {\n        return this.getCssProperty(\"align-items\")\n    }\n\n    // flex justify-content (flex-start, center, flex-end) - NOTE: alignment depends on direct of flex!\n    \n    setJustifyContent (v) {\n        assert([null, \"flex-start\", \"center\", \"flex-end\"].contains(v))\n        this.setCssProperty(\"justify-content\", v)\n        return this\n    }\n\n    justifyContent () {\n        return this.getCssProperty(\"justify-content\")\n    }\n\n    // flex direction - (row, column)\n\n    setFlexDirection (v) {\n        this.setCssProperty(\"flex-direction\", v)\n        return this\n    }\n\n    flexDirection () {\n        return this.getCssProperty(\"flex-direction\")\n    }\n\n    // flex grow\n\n    setFlexGrow (v) {\n        this.setCssProperty(\"flex-grow\", v)\n        return this\n    }\n\n    flexGrow () {\n        return this.getCssProperty(\"flex-grow\")\n    }\n\n    // flex shrink\n\n    setFlexShrink (v) {\n        this.setCssProperty(\"flex-shrink\", v)\n        return this\n    }\n\n    flexShrink () {\n        return this.getCssProperty(\"flex-shrink\")\n    }\n\n    // flex basis\n\n    setFlexBasis (v) {\n        if (Type.isNumber(v)) {\n            v = this.pxNumberToString(v)\n        }\n        this.setCssProperty(\"flex-basis\", v)\n        return this\n    }\n\n    flexBasis () {\n        return this.getCssProperty(\"flex-basis\")\n    }\n\n    // color\n\n    setColor (v) {\n        this.setCssProperty(\"color\", v)\n        return this\n    }\n\n    color () {\n        return this.getCssProperty(\"color\")\n    }\n\n    // filters\n\n    setFilter (s) {\n        this.setCssProperty(\"filter\", s)\n        return this\n    }\n\n    filter () {\n        return this.getCssProperty(\"filter\")\n    }\n\n    // visibility\n\n    setIsVisible (aBool) {\n        const v = aBool ? \"visible\" : \"hidden\"\n        this.setCssProperty(\"visibility\", v)\n        return this\n    }\n\n    isVisible () {\n        return this.getCssProperty(\"visibility\") !== \"hidden\";\n    }\n\n    // display\n\n    setDisplay (s) {\n        //assert(s in { \"none\", ...} );\n        this.setCssProperty(\"display\", s)\n        return this\n    }\n\n    display () {\n        return this.getCssProperty(\"display\")\n    }\n\n    // hide height\n\n\n    /*\n    hideHeight () {\n\t\tif (Type.isUndefined(this.hiddenMinHeight())) {\n            this.setHiddenMinHeight(this.minHeight())\n            this.setHiddenMaxHeight(this.maxHeight())\n            this.setMinAndMaxHeight(\"0em\")\n        }\n\t\treturn this\n\t}\n\t\n\tunhideHeight () {\n\t\tif (!Type.isUndefined(this.hiddenMinHeight())) {\n\t\t\tthis.setMinHeight(this.hiddenMaxHeight())\n\t\t\tthis.setHiddenMinHeight(undefined)\n\n\t\t\tthis.setMaxHeight(this.hiddenMaxHeight())\n\t\t\tthis.setHiddenMaxHeight(undefined)\n\t\t}\n\t\t\n\t\treturn this\n\t}\n    */\n\n    // helper for hide/show display\n\n    setDisplayIsHidden (aBool) {\n        if (aBool) {\n            this.hideDisplay()\n        } else {\n            this.unhideDisplay()\n        }\n        return this\n    }\n\n    isDisplayHidden () {\n        return this.display() === \"none\"\n    }\n\n    hideDisplay () {\n        if (this.display() !== \"none\") {\n            this.setHiddenDisplayValue(this.display())\n            this.setDisplay(\"none\")\n        }\n        return this\n    }\n\n    unhideDisplay () {\n        if (this.display() === \"none\") {\n            if (this._hiddenDisplayValue) {\n                this.setDisplay(this.hiddenDisplayValue())\n                this.setHiddenDisplayValue(null)\n            } else {\n                this.setDisplay(null)\n                // we don't now what value to set display to, so we have to raise an exception\n                //throw new Error(this.type() + \" attempt to unhide display value that was not hidden\")\n            }\n        }\n        return this\n    }\n\n    // visibility\n\n    setVisibility (s) {\n        this.setCssProperty(\"visibility\", s)\n        return this\n    }\n\n    visibility () {\n        return this.getCssProperty(\"visibility\")\n    }\n\n    // white space\n\n    setWhiteSpace (s) {\n        this.setCssProperty(\"white-space\", s)\n        return this\n    }\n\n    whiteSpace () {\n        return this.getCssProperty(\"white-space\")\n    }\n\n\n    // word-break\n\n    setWordBreak (s) {\n        assert(Type.isString(s))\n        this.setCssProperty(\"word-break\", s)\n        return this\n    }\n\n    wordBreak () {\n        return this.getCssProperty(\"word-break\")\n    }\n\n    // webkit specific\n\n    setWebkitOverflowScrolling (s) {\n        assert(Type.isString(s))\n        this.setSpecialCssProperty(\"-webkit-overflow-scrolling\", s)\n        assert(this.webkitOverflowScrolling() === s)\n        return this\n    }\n\n    webkitOverflowScrolling () {\n        return this.getSpecialCssProperty(\"-webkit-overflow-scrolling\")\n    }\n\n    // ms specific \n\n    setMsOverflowStyle (s) {\n        /* -ms-overflow-style: none; removes scrollbars on IE 10+  */\n        assert(Type.isString(s))\n        this.setSpecialCssProperty(\"-ms-overflow-style\", s)\n        assert(this.msOverflowStyle() === s)\n        return this\n    }\n\n    msOverflowStyle () {\n        return this.getSpecialCssProperty(\"-ms-overflow-style\")\n    }\n\n\n    // overflow\n\n    setOverflow (s) {\n        assert(Type.isString(s))\n        this.setCssProperty(\"overflow\", s)\n        return this\n    }\n\n    overflow () {\n        return this.getCssProperty(\"overflow\")\n    }\n\n    // overflow wrap\n\n    setOverflowWrap (s) {\n        assert(Type.isString(s))\n        this.setCssProperty(\"overflow-wrap\", s)\n        return this\n    }\n\n    overflowWrap () {\n        return this.getCssProperty(\"overflow-wrap\")\n    }\n\n    // overflow x\n\n    setOverflowX (s) {\n        assert(Type.isString(s))\n        this.setCssProperty(\"overflow-x\", s)\n        return this\n    }\n\n    overflowX () {\n        return this.getCssProperty(\"overflow-x\")\n    }\n\n    // overflow y\n\n    setOverflowY (s) {\n        assert(Type.isString(s))\n        this.setCssProperty(\"overflow-y\", s)\n        return this\n    }\n\n    overflowY () {\n        return this.getCssProperty(\"overflow-y\")\n    }\n\n    /*\t\n\n    // text over flow\n\n    // Overflow behavior at line end\n    // Right end if ltr, left end if rtl \n    text-overflow: clip;\n    text-overflow: ellipsis;\n    text-overflow: \"\";\n    text-overflow: fade;\n    text-overflow: fade(10px);\n    text-overflow: fade(5%);\n\n    // Overflow behavior at left end | at right end\n    // Directionality has no influence \n    text-overflow: clip ellipsis;\n    text-overflow: \"\" \"\";\n    text-overflow: fade clip;\n    text-overflow: fade(10px) fade(10px);\n    text-overflow: fade(5%) fade(5%);\n\n    // Global values \n    text-overflow: inherit;\n    text-overflow: initial;\n    text-overflow: unset;\n    */\n\n    setTextOverflow (s) {\n        this.setCssProperty(\"text-overflow\", s)\n        return this\n    }\n\n    textOverflow () {\n        return this.getCssProperty(\"text-overflow\")\n    }\n\n\n    // user select\n\n    userSelectKeys () {\n        return [\n            \"-moz-user-select\",\n            \"-khtml-user-select\",\n            \"-webkit-user-select\",\n            \"-o-user-select\"\n        ]\n    }\n\n    userSelect () {\n        const style = this.cssStyle()\n        let result = this.userSelectKeys().detect(key => style[key])\n        result = result || style.userSelect\n        return result\n    }\n\n    turnOffUserSelect () {\n        this.setUserSelect(\"none\");\n        return this\n    }\n\n    turnOnUserSelect () {\n        this.setUserSelect(\"text\")\n        return this\n    }\n\n    // user selection \n\n    setUserSelect (aString) {\n        const style = this.cssStyle()\n        //console.log(\"'\" + aString + \"' this.userSelect() = '\" + this.userSelect() + \"' === \", this.userSelect() == aString)\n        if (this.userSelect() !== aString) {\n            style.userSelect = aString\n            this.userSelectKeys().forEach(key => style[key] = aString)\n        }\n        return this\n    }\n\n    // spell check\n\n    setSpellCheck (aBool) {\n        this.element().setAttribute(\"spellcheck\", aBool);\n        return this\n    }\n\n    // tool tip\n\n    setToolTip (aName) {\n        if (aName) {\n            this.element().setAttribute(\"title\", aName);\n        } else {\n            this.element().removeAttribute(\"title\");\n        }\n        return this\n    }\n\n    // width and height\n\n    computedWidth () {\n        //return this.calcSize().width()\n        return this.getComputedPxCssProperty(\"width\")\n    }\n\n    computedHeight () {\n        //return this.calcSize().height()\n        return this.getComputedPxCssProperty(\"height\")\n    }\n\n    // desired size\n\n    desiredWidth () {\n        return this.calcWidth()\n    }\n\n    desiredHeight () {\n        return this.calcHeight()\n    }\n\n    // calculated size (outside of parent view)\n\n    calcSize () {\n        assert(this.parentView())\n\n        const e = this.element()\n        assert(e.parentNode)\n\n        // reads\n        this.didDomRead(\"display\")\n        //this.didDomRead(\"position\")\n        //this.didDomRead(\"width\")\n        const display = e.style.display\n        const position = e.style.position\n        const width = e.style.width\n\n        // writes\n        this.didDomWrite(\"display\")\n        //this.didDomWrite(\"position\")\n        //this.didDomWrite(\"width\")\n        e.style.display = \"block\"\n        e.style.position = \"absolute\"\n        e.style.width = \"auto\"\n\n        // read calc\n        this.didDomRead(\"clientWidth\")\n        //this.didDomRead(\"clientHeight\")\n        const w = (e.clientWidth + 1) \n        const h = (e.clientHeight + 1) \n        //const size = { width: w, height: h }\n        const size = Point.clone().setXY(w, h).freeze()\n\n        // write\n        this.didDomWrite(\"display\")\n        //this.didDomWrite(\"position\")\n        //this.didDomWrite(\"width\")\n        e.style.display = display\n        e.style.position = position\n        e.style.width = width\n\n        if (w === 1 && h === 1) {\n            assert(e.hasAncestor(document.body)) // client measurements will be zero if it's not in a document\n        }\n\n        this.setCachedSize(size)\n        return size\n    }\n\n    cacheClientSize () {\n        if (this.display() === \"none\") {\n            return Point.clone().freeze()\n        }\n\n        const e = this.element()\n        this.setCachedSize(Point.clone().setXY(e.clientWidth, e.clientHeight).freeze())\n        return this\n    }\n\n    cachedSize () {\n        if (this.display() === \"none\") {\n            return Point.clone().freeze()\n        }\n        return this._cachedSize\n    }\n\n    // calculated size (within parent view)\n\n    calcWidth () {\n        if (this.display() === \"none\") {\n            return 0\n        }\n        return this.calcSize().width()\n    }\n\n    calcHeight () {\n        if (this.display() === \"none\") {\n            return 0\n        }\n        return this.calcSize().height()\n    }\n\n    // width\n\n    setWidthString (v) {\n        assert(Type.isString(v) || Type.isNull(v))\n        this.setCssProperty(\"width\", v, () => { this.didChangeWidth() })\n        return this\n    }\n\n    widthString () {\n        return this.getCssProperty(\"width\")\n    }\n\n    setWidth (s) {\n        this.setWidthString(s)\n        return this\n    }\n\n    setWidthPercentage (aNumber) {\n        const newValue = this.percentageNumberToString(aNumber)\n        this.setCssProperty(\"width\", newValue, () => { this.didChangeWidth() })\n        return this\n    }\n\n    /*\n    hideScrollbar () {\n        // need to do JS equivalent of: .class::-webkit-scrollbar { display: none; }\n\t    // this.setCssProperty(\"-webkit-scrollbar\", { display: \"none\" }) // doesn't work\n\t    return this\n    }\n    */\n\n    // clientX - includes padding but not scrollbar, border, or margin\n\n    clientWidth () {\n        return this.getAttribute(\"clientWidth\")\n    }\n\n    clientHeight () {\n        return this.getAttribute(\"clientHeight\")\n    }\n\n    // offsetX - includes borders, padding, scrollbar \n\n    offsetWidth () {\n        return this.getAttribute(\"offsetWidth\")\n    }\n\n    offsetHeight () {\n        return this.getAttribute(\"offsetHeight\")\n    }\n\n    // width px\n\n    minWidthPx () {\n        const s = this.getCssProperty(\"min-width\")\n        // TODO: support em to px translation \n        return this.pxStringToNumber(s)\n    }\n\n    maxWidthPx () {\n        const w = this.getCssProperty(\"max-width\")\n        if (w === \"\") {\n            return null\n        }\n        return this.pxStringToNumber(w)\n    }\n\n    // height px\n\n    minHeightPx () {\n        const s = this.getCssProperty(\"min-height\")\n        // TODO: support em to px translation \n        return this.pxStringToNumber(s)\n    }\n\n    maxHeightPx () {\n        const s = this.getCssProperty(\"max-height\")\n        if (s === \"\") {\n            return null\n        }\n        return this.pxStringToNumber(s)\n    }\n\n    // -----------\n\n    cssStyle () {\n        return this.element().style\n    }\n\n    setMinWidth (v) {\n        if (Type.isNumber(v)) {\n            v = this.pxNumberToString(v)\n        }\n        this.setCssProperty(\"min-width\", v, () => { this.didChangeWidth() })\n        return this\n    }\n\n    didChangeWidth () {\n    }\n\n    didChangeHeight () {\n    }\n\n    // --- lock/unlock size ---\n\n    /*\n    lockSize () {\n        const h = this.computedHeight() \n        const w = this.computedWidth()\n        this.setMinAndMaxWidth(w)\n        this.setMinAndMaxHeight(h)\n        return this\n    }\n\n    unlockSize () {\n        this.setMinAndMaxWidth(null)\n        this.setMinAndMaxHeight(null)\n        return this\n    }\n    */\n\n    // ----\n\n    displayIsFlex () {\n        // TODO: choose a better name for this method?\n        return (this.display() === \"flex\" || this.hiddenDisplayValue() === \"flex\")\n    }\n\n    // fixed width\n\n    /*\n    setFixedWidthPx (v) {\n        assert(Type.isNumber(v))\n        if (this.displayIsFlex()) {\n            this.setFlexGrow(0)\n            this.setFlexShrink(0)\n            this.setFlexBasis(v + \"px\")\n        } else {\n            this.setMinAndMaxWidth(v)\n        }\n        return this\n    }\n\n    fixedWidthPx () {\n        if (this.displayIsFlex()) {\n            const w = this.getPxCssProperty(\"flex-basis\")\n            assert(Type.isNumber(w))\n            return w\n        } else {\n            const w1 = this.getPxCssProperty(\"min-width\")\n            const w2 = this.getPxCssProperty(\"max-width\")\n            assert(Type.isNumber(w1) && w1 === w2)\n            return w1\n        }\n    }\n    */\n\n    // fixed height\n    /*\n    setFixedHeightPx (v) {\n        assert(Type.isNumber(v))\n        if (this.displayIsFlex()) {\n            this.setFlexGrow(0)\n            this.setFlexShrink(0)\n            this.setFlexBasis(v + \"px\")\n        } else {\n            this.setMinAndMaxWidth(v)\n        }\n        return this\n    }\n\n    fixedHeightPx () {\n        if (this.displayIsFlex()) {\n            const w = this.getPxCssProperty(\"flex-basis\")\n            assert(Type.isNumber(w))\n            return w\n        } else {\n            const w1 = this.getPxCssProperty(\"min-width\")\n            const w2 = this.getPxCssProperty(\"max-width\")\n            assert(Type.isNumber(w1) && w1 === w2)\n            return w1\n        }\n    }\n    */\n\n    // ----\n\n    setMinAndMaxSize (aSize) {\n        this.setMinAndMaxWidth(aSize.x())\n        this.setMinAndMaxHeight(aSize.y())\n        return this\n    }\n\n    setMaxWidth (v) {\n        if (Type.isNumber(v)) {\n            v = this.pxNumberToString(v)\n        }\n        this.setCssProperty(\"max-width\", v, () => { this.didChangeWidth() })\n        return this\n    }\n\n    setMinAndMaxWidth (v) {\n        if (Type.isNumber(v)) {\n            v = this.pxNumberToString(v)\n        }\n        this.setCssProperty(\"max-width\", v, () => { this.didChangeWidth() })\n        this.setCssProperty(\"min-width\", v, () => { this.didChangeWidth() })\n        if (!Type.isNull(v)) {\n            this.setCssProperty(\"width\", v, null) // avoids weird behavior but not ideal if min and max settings change do diff values\n        }\n        return this\n    }\n\n    setMinAndMaxHeight (v) {\n        if (Type.isNumber(v)) {\n            v = this.pxNumberToString(v)\n        }\n        this.setCssProperty(\"min-height\", v, () => { this.didChangeHeight() })\n        this.setCssProperty(\"max-height\", v, () => { this.didChangeHeight() })\n        if (!Type.isNull(v)) {\n            this.setCssProperty(\"height\", v, null) // avoids weird behavior but not ideal if min and max settings change do diff values\n        }\n        return this\n    }\n\n    setMinAndMaxWidthAndHeight (v) {\n        this.setMinAndMaxWidth(v)\n        this.setMinAndMaxHeight(v)\n        return this\n    }\n\n    percentageNumberToString (aNumber) {\n        assert(Type.isNumber(aNumber) && (aNumber >= 0) && (aNumber <= 100))\n        return aNumber + \"%\"\n    }\n\n    pxNumberToString (aNumber) {\n        if (Type.isNull(aNumber)) {\n            return null\n        }\n\n        if (Type.isString(aNumber)) {\n            if (aNumber.startsWith(\"calc\") || aNumber.endsWith(\"px\")) {\n                return aNumber\n            }\n        }\n\n        assert(Type.isNumber(aNumber))\n        return aNumber + \"px\"\n    }\n\n    pxStringToNumber (s) {\n        assert(Type.isString(s))\n        \n        if (s === \"\") {\n            return 0\n        }\n        \n        if (s === \"auto\") {\n            return 0\n        }\n\n        if (s.contains(\"%\")) {\n            return 0\n        }\n\n        assert(s.endsWith(\"px\"))\n        return Number(s.replace(\"px\", \"\"))\n    }\n\n    setMinAndMaxHeightPercentage (aNumber) {\n        const newValue = this.percentageNumberToString(aNumber)\n        this.setCssProperty(\"min-height\", newValue, () => { this.didChangeHeight() })\n        this.setCssProperty(\"max-height\", newValue, () => { this.didChangeHeight() })\n        return this\n    }\n\n    setHeightPercentage (aNumber) {\n        // NOTE: %s don't work unless same parent view dimension is defined\n        const newValue = this.percentageNumberToString(aNumber)\n        this.setHeightString(newValue)\n        return this\n    }\n\n    setMinWidthPx (aNumber) {\n        this.setMinWidth(this.pxNumberToString(aNumber))\n        return this\n    }\n\n    setMinHeightPx (aNumber) {\n        this.setMinHeight(this.pxNumberToString(aNumber))\n        return this\n    }\n\n    setMaxHeightPx (aNumber) {\n        this.setMaxHeight(this.pxNumberToString(aNumber))\n        return this\n    }\n\n    maxHeight () {\n        return this.getCssProperty(\"max-height\")\n    }\n\n    minHeight () {\n        return this.getCssProperty(\"min-height\")\n    }\n\n    maxWidth () {\n        return this.getCssProperty(\"max-width\")\n    }\n\n    minWidth () {\n        return this.getCssProperty(\"min-width\")\n    }\n\n    setMinHeight (newValue) {\n        assert(Type.isString(newValue) || Type.isNull(newValue))\n        // <length> | <percentage> | auto | max-content | min-content | fit-content | fill-available\n        this.setCssProperty(\"min-height\", newValue, () => { this.didChangeHeight() })\n        return this\n    }\n\n    setMaxHeight (newValue) {\n        assert(Type.isString(newValue) || Type.isNull(newValue))\n        // <length> | <percentage> | none | max-content | min-content | fit-content | fill-available\n        this.setCssProperty(\"max-height\", newValue, () => { this.didChangeHeight() })\n        return this\n    }\n\n    setWidthPx (aNumber) {\n        this.setWidthString(this.pxNumberToString(aNumber))\n        return this\n    }\n\n    setHeightPx (aNumber) {\n        this.setHeightString(this.pxNumberToString(aNumber))\n        return this\n    }\n\n    setHeight (s) {\n        // height: auto|length|initial|inherit;\n\n        if (Type.isNumber(s)) {\n            return this.setHeightPx(s)\n        }\n        this.setHeightString(s)\n        return this\n    }\n\n    setWidthToAuto () {\n        this.setWidthString(\"auto\")\n        return this\n    }\n\n    setHeightToAuto () {\n        this.setHeightString(\"auto\")\n        return this\n    }\n\n    setHeightString (s) {\n        assert(Type.isString(s) || Type.isNull(s))\n        this.setCssProperty(\"height\", s, () => { this.didChangeHeight() })\n        return this\n    }\n\n    height () {\n        return this.getCssProperty(\"height\")\n    }\n\n    // --- string ---\n\n    setString (v) {\n        return this.setTextContent(v)\n        //return this.setInnerHtml(v)\n    }\n\n    string () {\n        return this.textContent()\n        //return this.innerHtml()\n    }\n\n    // --- innerHTML ---\n\n    innerHtml () {\n        return this.getAttribute(\"innerHTML\")\n        //return this.element().innerHTML\n    }\n\n    setInnerHtml (v) {\n        this.setAttribute(\"innerHTML\", v)\n        //this.element().innerHTML = v\n        return this\n    }\n\n    // --- innerText ---\n\n    setInnerText (v) {\n        const e = this.element().innerText = v\n        return this\n    }\n\n    innerText () {\n        const e = this.element()\n        return e.innerText \n        //return e.textContent || e.innerText || \"\";\n    }\n\n    // --- textContent ---\n\n    setTextContent (v) {\n        this.element().textContent = v\n        //this.setAttribute(\"textContent\", v)\n        return this\n    }\n\n    textContent () {\n        return this.element().textContent\n        //return this.getAttribute(\"textContent\")\n    }\n\n    // --- touch events ---\n\n    setTouchAction (s) {\n        this.setCssProperty(\"-ms-touch-action\", s) // needed?\n        this.setCssProperty(\"touch-action\", s)\n        return this\n    }\n\n    // scroll top\n\n    setScrollTop (v) {\n        this.setAttribute(\"scrollTop\", v)\n        return this\n    }\n\n    scrollTop () {\n        return this.getAttribute(\"scrollTop\")\n    }\n\n    // scroll width & scroll height\n\n    scrollWidth () { \n        // a read-only value\n        return this.getAttribute(\"scrollWidth\")\n    }\n\n    scrollHeight () {\n        // a read-only value\n        return this.getAttribute(\"scrollHeight\") \n    }\n\n    // offset width & offset height\n\n    offsetLeft () {\n        // a read-only value\n        return this.getAttribute(\"offsetLeft\")\n    }\n\n    offsetTop () {\n        // a read-only value\n        return this.getAttribute(\"offsetTop\")\n    }\n\n    boundingClientRect () {\n        this.didDomRead(\"boundingClientRect\")\n        return this.element().getBoundingClientRect()\n    }\n\n    viewportX () {\n        return this.boundingClientRect().x\n    }\n\n    viewportY () {\n        return this.boundingClientRect().y\n    }\n\n    /*\n    containsViewportPoint () {\n        throw new Error(\"unimplemented\")\n    }\n    */\n\n\n    // --------------------------------------------------------------\n    // --------------------------------------------------------------\n    // --------------------------------------------------------------\n\n\n    // view position helpers ----\n\n    setRelativePos (p) {\n        // why not a 2d transform?\n        this.setLeftPx(p.x())\n        this.setTopPx(p.y())\n        return this\n    }\n\n    containsPoint (aPoint) {\n        // point must be in document coordinates\n        return this.frameInDocument().containsPoint(aPoint)\n    }\n\n    // viewport coordinates helpers\n\n    frameInViewport () {\n        const origin = this.positionInViewport()\n        const size = this.sizeInViewport()\n        const frame = Rectangle.clone().setOrigin(origin).setSize(size)\n        return frame\n    }\n\n    positionInViewport () {\n        const box = this.boundingClientRect();\n        return Point.clone().set(Math.round(box.left), Math.round(box.top));\n    }\n\n    sizeInViewport () {\n        const box = this.boundingClientRect();\n        return Point.clone().set(Math.round(box.width), Math.round(box.height));\n    }\n\n    // document coordinates helpers\n\n    // --- document positioning ---\n\n    setFrameInDocument (aRect) {\n        this.setPosition(\"absolute\")\n        this.setLeftPx(aRect.origin().x())\n        this.setTopPx(aRect.origin().y())\n        this.setMinAndMaxSize(aRect.size())\n        return this\n    }\n\n    frameInDocument () {\n        const origin = this.positionInDocument()\n        const size = this.size()\n        const frame = Rectangle.clone().setOrigin(origin).setSize(size)\n\n        //const size = this.calcSize() // this.size()\n        //onst frame = Rectangle.clone().setOrigin(origin)\n        //frame.size().setX(size.width).setY(size.height)\n\n        return frame\n    }\n\n    // -------------------\n    // fixed - assumes position is absolute and width and height are fixed via min-width === max-width, etc\n    // -------------------\n\n    // fixed position\n\n    hasFixedX () {\n        return !Type.isNullOrUndefined(this.leftPx() ) \n    }\n\n    hasFixedY () {\n        return !Type.isNullOrUndefined(this.topPx() ) \n    }\n\n    hasFixedPosition () {\n        return this.position() === \"absolute\" && this.hasFixedX() && this.hasFixedY()\n    }\n\n    // fixed size\n\n    hasFixedSize () {\n        return this.hasFixedWidth() && this.hasFixedHeight()\n    }\n\n    hasFixedWidth () {\n        const v1 = this.minWidthPx()\n        const v2 = this.maxWidthPx()\n        return !Type.isNullOrUndefined(v1) && v1 === v2\n    }\n\n    hasFixedHeight () {\n        const v1 = this.minHeightPx()\n        const v2 = this.maxHeightPx()\n        return !Type.isNullOrUndefined(v1) && v1 === v2\n    }\n\n    decrementFixedWidth () {\n        assert(this.hasFixedWidth())\n        this.setMinAndMaxWidth(Math.max(0, this.minWidthPx()-1))\n        return this\n    }\n\n    decrementFixedHeight () {\n        assert(this.hasFixedHeight())\n        this.setMinAndMaxHeight(Math.max(0, this.minHeightPx()-1))\n        return this\n    }\n\n    // fixed frame\n\n    hasFixedFrame () {\n        return this.hasFixedPosition() && this.hasFixedSize()\n    }\n\n    fixedFrame () {\n        assert(this.hasFixedFrame())\n        const origin = Point.clone().set(Math.round(this.leftPx()), Math.round(this.topPx()))\n        const size   = Point.clone().set(Math.round(this.minWidthPx()), Math.round(this.minHeightPx()))\n        const frame  = Rectangle.clone().setOrigin(origin).setSize(size)\n        return frame\n    }\n\n    //--------------\n\n    estimatedWidthPx () {\n        const v1 = this.minWidthPx()\n        const v2 = this.maxWidthPx()\n        if (!Type.isNullOrUndefined(v1) && v1 === v2) {\n            return v1\n        }\n        return this.clientWidth()\n    }\n\n    estimatedHeightPx () {\n        const v1 = this.minHeightPx()\n        const v2 = this.maxHeightPx()\n        if (!Type.isNullOrUndefined(v1) && v1 === v2) {\n            return v1\n        }\n        return this.clientHeight()\n    }\n\n    // ------------------------\n\n    positionInDocument () {\n        this.didDomRead(\"scrollTop\")\n        //this.didDomRead(\"scrollLeft\")\n\n        const box = this.element().getBoundingClientRect();\n\n        // return Point.clone().set(Math.round(box.left), Math.round(box.top));\n\n        const body = document.body;\n        const docEl = document.documentElement;\n\n        const scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;\n        const scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;\n\n        const clientTop = docEl.clientTop || body.clientTop || 0;\n        const clientLeft = docEl.clientLeft || body.clientLeft || 0;\n\n        const top = box.top + scrollTop - clientTop;\n        const left = box.left + scrollLeft - clientLeft;\n\n        const p = Point.clone().set(Math.round(left), Math.round(top));\n        return p\n    }\n\n    size () {\n        return EventPoint.clone().set(this.clientWidth(), this.clientHeight());\n    }\n\n    // ---------------------\n\n    setFrameInParent (aRect) {\n        this.setPosition(\"absolute\")\n        this.setLeftPx(aRect.origin().x())\n        this.setTopPx(aRect.origin().y())\n        this.setMinAndMaxSize(aRect.size())\n        return this\n    }\n\n    frameInParentView () {\n        const origin = this.relativePos()\n        const size = this.size()\n        const frame = Rectangle.clone().setOrigin(origin).setSize(size)\n        return frame\n    }\n\n    // ---\n\n    relativePos () {\n        const pv = this.parentView()\n        if (pv) {\n            return this.positionInDocument().subtract(pv.positionInDocument())\n            //return pv.positionInDocument().subtract(this.positionInDocument())\n        }\n        return this.positionInDocument()\n    }\n\n    setRelativePos (p) {\n        //this.setPosition(\"absolute\")\n        this.setLeftPx(p.x())\n        this.setTopPx(p.y())\n        return this\n    }\n\n    // ---\n\n    viewPosForWindowPos (pos) {\n        return pos.subtract(this.positionInDocument())\n    }\n\n    // --------------\n\n    makeAbsolutePositionAndSize () {\n        const f = this.frameInParentView()\n        this.setFrameInParent(f)\n        return this \n    }\n\n    makeRelativePositionAndSize () {\n        // TODO: check if it's flex and set flex basis in flex direction instead?\n        this.setPosition(\"relative\")\n\n        this.setTopPx(null)\n        this.setLeftPx(null)\n        this.setRightPx(null)\n        this.setBottomPx(null)\n\n        this.setMinAndMaxWidth(null)\n        this.setMinAndMaxHeight(null)  \n        return this \n    }\n\n    // --------------\n\n    /*\n    cancelVerticallyAlignAbsolute () {\n        this.setPosition(\"relative\")\n    }\n    */\n\n    // --- scroll actions ---\n\n    scrollToTop () {\n        this.setScrollTop(0)\n        return this\n    }\n\n    setVerticalAlign (s) {\n        this.setCssProperty(\"vertical-align\", s)\n        return this\n    }\n\n    // --- css :after :before ---\n\n    setContentAfterOrBeforeString (aString, afterOrBefore) {\n        const uniqueClassName = \"UniqueClass_\" + this.puuid()\n        const e = this.element()\n        if (e.className.indexOf(uniqueClassName) === -1) {\n            const newRuleKey = \"DomView\" + uniqueClassName + \":\" + afterOrBefore\n            const newRuleValue = \"content: \\\"\" + aString + \"\\;\"\n            //console.log(\"newRule '\" + newRuleKey + \"', '\" + newRuleValue + \"'\")\n            document.styleSheets[0].addRule(newRuleKey, newRuleValue);\n            e.className += \" \" + uniqueClassName\n        }\n        return this\n    }\n\n    setContentAfterString (s) {\n        this.setContentAfterOrBeforeString(s, \"after\")\n        return this\n    }\n\n    setContentBeforeString (s) {\n        this.setContentAfterOrBeforeString(s, \"before\")\n        return this\n    }\n\n    didDomRead (opName) {\n        //ThrashDetector.shared().didRead(opName, this)\n        return this\n    }\n\n    didDomWrite (opName) {\n        //ThrashDetector.shared().didWrite(opName, this)\n        return this\n    }\n\n    // reflow thrash avoidance helpers\n\n\n}.initThisClass());\n",
  "wtNl0iLKG6Vae+4NquOpXxMPEJ27QCn4YjP5qJX+9BI=": "\"use strict\";\n\n/*\n    SubviewsDomView\n\n    Deals with subviews and parents.\n\n*/\n\n(class SubviewsDomView extends CssDomView {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"parentView\", null)\n        this.newSlot(\"subviews\", null)\n    }\n\n    init () {\n        super.init()\n        this.setSubviews([])\n        return this\n    }\n\n    // --- parentView ---\n\n    hasParentView () {\n        return Type.isNullOrUndefined(this.parentView()) === false\n    }\n    \n    didUpdateSlotParentView (oldValue, newValue) {\n        return this\n    }\n    \n    /*\n    didUpdateSlotParentView (oldValue, newValue) {\n        const parentless = this.thisClass().viewsWithoutParents()\n\n        assert(oldValue !== newValue);\n\n        if (newValue) {\n            if (parentless.has(newValue)) {\n                console.log(\"removing \" + this.typeId() + \" from parentless\")\n            }\n            parentless.delete(this)\n        } else if (Type.isNullOrUndefined(oldValue) && !Type.isNullOrUndefined(newValue)) {\n            if (parentless.size === 0) { // is this always correct?\n                this.scheduleMethod(\"retireParentlessViews\")\n            }\n            console.log(\"adding \" + this.typeId() + \" to parentless\")\n            parentless.add(this)\n        }\n\n        return this\n    }\n\n    retireParentlessViews () {\n        this.thisClass().retireParentlessViews()\n    }\n\n    */\n\n    // --- subviews ---\n\n    hasParentViewAncestor (aView) {\n        const pv = this.parentView()\n        \n        if (!pv) {\n            return false\n        }\n\n        if (pv === aView) {\n            return true\n        }\n\n        return pv.hasParentViewAncestor(aView)\n    }\n\n    hasSubviewDescendant (aView) {\n        if (aView == this) {\n            return true\n        }\n        return this.subviews().detect(sv => sv.hasSubviewDescendant(aView))\n    }\n\n    allSubviewsRecursively (allViews = new Set()) {\n        allViews.add(this)\n        this.subviews().forEach(view => {\n            view.allSubviewsRecursively(allViews)\n        })\n        return allViews\n    }\n    \n    // view chains\n\n    forEachAncestorView (fn) { // should we call this ancestorViews?\n        // returned list in order of very top parent first\n        let p = this.parentView()\n        while (p) {\n            fn(p)\n            p = p.parentView()\n        }\n    }\n\n    parentViewChain () { // should we call this ancestorViews?\n        // returned list in order of very top parent first\n        const chain = []\n        let p = this.parentView()\n        while (p) {\n            chain.push(p)\n            p = p.parentView()\n        }\n        return chain.reversed()\n    }\n\n    parentViewsOfClass (aClass) {\n        return this.parentViewChain().filter(v => v.thisClass().isSubclassOf(aClass))\n    }\n\n    // --- subviews ---\n\n    subviewCount () {\n        return this.subviews().length\n    }\n\n    hasSubview (aSubview) {\n        return this.subviews().contains(aSubview)\n    }\n\n    addSubviewIfAbsent (aSubview) {\n        if (!this.hasSubview(aSubview)) {\n            this.addSubview(aSubview)\n        }\n        return this\n    }\n\n    addSubview (aSubview) {\n        assert(!Type.isNullOrUndefined(aSubview)) \n        assert(aSubview.hasElement()) \n\n        if (this.hasSubview(aSubview)) {\n            throw new Error(this.type() + \".addSubview(\" + aSubview.type() + \") attempt to add duplicate subview \")\n        }\n\n        assert(Type.isNullOrUndefined(aSubview.parentView()))\n        /*\n        if (aSubview.parentView()) {\n            aSubview.removeFromParent()\n        }\n        */\n\n        this.willAddSubview(aSubview)\n\n        this.subviews().append(aSubview)\n        //.shared().didWrite(\"appendChild\", this)\n        this.element().appendChild(aSubview.element());\n        aSubview.setParentView(this)\n\n        this.didChangeSubviewList()\n        return aSubview\n    }\n\n    addSubviews (someSubviews) {\n        someSubviews.forEach(sv => this.addSubview(sv))\n        return this\n    }\n\n    swapSubviews (sv1, sv2) {\n        assert(sv1 !== sv2)\n        assert(this.hasSubview(sv1))\n        assert(this.hasSubview(sv2))\n        \n        const i1 = this.indexOfSubview(sv1)\n        const i2 = this.indexOfSubview(sv2)\n\n        this.removeSubview(sv1)\n        this.removeSubview(sv2)\n\n        if (i1 < i2) {\n            this.atInsertSubview(i1, sv2) // i1 is smaller, so do it first\n            this.atInsertSubview(i2, sv1)\n        } else {\n            this.atInsertSubview(i2, sv1) // i2 is smaller, so do it first          \n            this.atInsertSubview(i1, sv2)\n        }\n\n        assert(this.indexOfSubview(sv1) === i2)\n        assert(this.indexOfSubview(sv2) === i1)\n\n        return this\n    }\n\n    orderSubviewFront (aSubview) {\n        if (this.subviews().last() !== aSubview) {\n            this.removeSubview(aSubview)\n            this.addSubview(aSubview)\n        }\n        return this\n    }\n\n    orderFront () {\n        const pv = this.parentView()\n        if (pv) {\n            pv.orderSubviewFront(this)\n        }\n        return this\n    }\n\n    orderSubviewBack (aSubview) {\n        this.removeSubview(aSubview)\n        this.atInsertSubview(0, aSubview)\n        return this\n    }\n\n    orderBack () {\n        const pv = this.parentView()\n        if (pv) {\n            pv.orderSubviewBack(this)\n        }\n        return this\n    }\n\n    replaceSubviewWith (oldSubview, newSubview) {\n        assert(this.hasSubview(oldSubview))\n        assert(!this.hasSubview(newSubview))\n        \n        const index = this.indexOfSubview(oldSubview)\n        this.removeSubview(oldSubview)\n        this.atInsertSubview(index, newSubview)\n\n        // TODO: remove this sanity check\n        assert(this.indexOfSubview(newSubview) === index)\n        assert(this.hasSubview(newSubview))\n        assert(!this.hasSubview(oldSubview))\n        return this\n    }\n\n    atInsertSubview (anIndex, aSubview) {\n        this.subviews().atInsert(anIndex, aSubview)\n        assert(this.subviews()[anIndex] === aSubview)\n\n        //ThrashDetector.shared().didWrite(\"atInsertElement\", this)\n        this.element().atInsertElement(anIndex, aSubview.element())\n        assert(this.element().childNodes[anIndex] === aSubview.element())\n\n        aSubview.setParentView(this) // TODO: unify with addSubview\n        this.didChangeSubviewList() // TODO:  unify with addSubview\n        return aSubview\n    }\n\n    moveSubviewToIndex (aSubview, i) {\n        assert(i < this.subviews().length)\n        assert(this.subviews().contains(aSubview))\n\n        if (this.subviews()[i] !== aSubview) {\n            this.removeSubview(aSubview)\n            this.atInsertSubview(i, aSubview)\n        }\n        return this\n    }\n\n    updateSubviewsToOrder (orderedSubviews) {\n        assert(this.subviews() !== orderedSubviews)\n        assert(this.subviews().length === orderedSubviews.length)\n\n        for (let i = 0; i < this.subviews().length; i ++) {\n            const v2 = orderedSubviews[i]\n            this.moveSubviewToIndex(v2, i)\n        }\n        \n        return this\n    }\n\n    // --- subview utilities ---\n\n    sumOfSubviewHeights () {\n        return this.subviews().sum(subview => subview.clientHeight())\n    }\n\n    performOnSubviewsExcept (methodName, exceptedSubview) {\n        this.subviews().forEach(subview => {\n            if (subview !== exceptedSubview) {\n                subview[methodName].apply(subview)\n            }\n        })\n\n        return this\n    }\n\n    // -----------------------\n\n    removeFromParentView () {\n        this.parentView().removeSubview(this)\n        return this\n    }\n\n    removeAfterFadeDelay (delayInSeconds) {\n        // call removeSubview for a direct actions\n        // use justRemoteSubview for internal changes\n\n        this.setTransition(\"all \" + delayInSeconds + \"s\")\n\n        this.addTimeout(() => {\n            this.setOpacity(0)\n        }, 0)\n\n        this.addTimeout(() => {\n            this.parentView().removeSubview(this)\n        }, delayInSeconds * 1000)\n\n        return this\n    }\n\n    willRemove () {\n    }\n\n    didChangeSubviewList () {\n    }\n\n    hasSubview (aSubview) {\n        return this.subviews().indexOf(aSubview) !== -1;\n    }\n\n    hasChildElement (anElement) {\n        const children = this.element().childNodes\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i]\n            if (anElement === child) {\n                return true\n            }\n        }\n        return false\n    }\n\n    willAddSubview (aSubview) {\n        // for subclasses to over-ride\n    }\n\n    willRemoveSubview (aSubview) {\n        // for subclasses to over-ride\n    }\n\n    removeSubviewIfPresent (aSubview) {\n        if (this.hasSubview(aSubview)) {\n            this.removeSubview(aSubview)\n        }\n        return this\n    }\n\n    removeSubview (aSubview) {\n        //console.warn(\"WARNING: \" + this.type() + \" removeSubview \" + aSubview.type())\n\n        // sanity check - make sure it's in our subview list\n        if (!this.hasSubview(aSubview)) {\n            const msg = this.type() + \" removeSubview \" + aSubview.typeId() + \" failed - no child found among: \" + this.subviews().map(view => view.typeId())\n            //Error.showCurrentStack()\n            throw new Error(msg)\n            return aSubview\n        }\n\n        if (aSubview.parentView() !== this) {\n            throw new Error(\"attempt to remove subview by a non parent\")\n        }\n\n        // remove from subview list -  give subview a chance to deal with change\n        this.willRemoveSubview(aSubview)\n        aSubview.willRemove()\n\n        this.justRemoveSubview(aSubview)\n\n        this.didChangeSubviewList()\n\n        return aSubview\n    }\n\n    justRemoveSubview (aSubview) { // PRIVATE\n        this.subviews().remove(aSubview)\n\n        const e = aSubview.element()\n        if (this.hasChildElement(e)) { // sanity check - make we have child element \n            //ThrashDetector.shared().didWrite(\"removeChild\", this)\n            this.element().removeChild(e); // WARNING: this will trigger an immediate onBlur window event, which may cause sync actions\n\n            // sanity check - make sure element was removed\n            if (this.hasChildElement(e)) {\n                const msg = \"WARNING: \" + this.type() + \" removeSubview \" + aSubview.type() + \" failed - still has element after remove\"\n                //console.warn(msg)\n                //Error.showCurrentStack()\n                throw new Error(msg)\n            }\n        } else {\n            const msg = \"WARNING: \" + this.type() + \" removeSubview \" + aSubview.type() + \" parent element is missing this child element\"\n            throw new Error(msg)\n        }\n\n        aSubview.setParentView(null)\n        return this\n    }\n\n    removeAllSubviews () {\n        //const sv = this.subviews().shallowCopy()\n        //sv.forEach(subview => this.removeSubview(subview))\n        while(this.subviews().length) {\n            const sv = this.subviews().last()\n            this.removeSubview(sv)\n        }\n        assert(this.subviews().length === 0) // temp sanity check\n        return this\n    }\n\n    indexOfSubview (aSubview) {\n        return this.subviews().indexOf(aSubview)\n    }\n\n    subviewAfter (aSubview) {\n        const index = this.indexOfSubview(aSubview)\n        const nextIndex = index + 1\n        if (nextIndex < this.subviews().length) {\n            return this.subviews()[nextIndex]\n        }\n        return null\n    }\n\n    sendAllViewDecendants (methodName, argList) {\n        this.subviews().forEach((v) => {\n            v[methodName].apply(v, argList)\n            v.sendAllViewDecendants(methodName, argList)\n        })\n        return this\n    }\n\n    // --- updates ---\n\n    tellParentViews (msg, aView) {\n        const f = this[msg]\n        if (f) {\n            const r = f.call(this, aView) \n            if (r === true) {\n                return // stop propogation on first view returning non-false\n            }\n        }\n\n        const p = this.parentView()\n        if (p) {\n            p.tellParentViews(msg, aView)\n        }\n    }\n\n    askParentViews (msg, aView) {\n        const f = this[msg]\n        if (f) {\n            const r = f.call(this, aView)\n            return r\n        }\n\n        const p = this.parentView()\n        if (p) {\n            return p.getParentViewMethod(msg, aView)\n        }\n\n        return undefined\n    }\n\n    firstParentViewWithAncestorClass (aClass) {\n        const p = this.parentView()\n        if (p) {\n            if (p.isSubclassOf(aClass)) {\n                return p\n            }\n            return p.firstParentViewWithAncestorClass(aClass)\n        }\n        return undefined\n    }\n\n\n    // centering\n\n    fillParentView () {\n        this.setWidthPercentage(100)\n        this.setHeightPercentage(100)\n        return this\n    }\n\n    centerInParentView () {\n        this.setMinAndMaxWidth(null)\n        this.setMinAndMaxHeight(null)\n        //this.setWidth(\"100%\")\n        //this.setHeight(\"100%\")\n        this.setOverflow(\"auto\")\n        this.setMarginString(\"auto\")\n        this.setPosition(\"absolute\")\n        this.setTopPx(0).setLeftPx(0).setRightPx(0).setBottomPx(0)\n    }\n\n    /*\n    verticallyCenterFromTopNow () {\n        if (this.parentView() === null) {\n            console.warn(\"verticallyCenterFromTopNow called on view with no superview\")\n            return this\n        }\n\n        this.setPosition(\"absolute\")\n        this.setDisplay(\"inline-block\")\n\n        // timeout used to make sure div is placed and laid out first\n        // TODO: consider ordering issue\n        this.addTimeout(() => { \n            let sh = this.parentView().clientHeight()\n            let h = this.clientHeight()\n            this.setTopPx(sh/2 - h/2)\n        }, 1)\n\n        return this\n    }\n\n    horiontallyCenterFromLeftNow () {\n        if (this.parentView() === null) {\n            console.warn(\"horiontallyCenterFromLeftNow called on view with no superview\")\n            return this\n        }\n\n        this.setPosition(\"absolute\")\n        this.setDisplay(\"inline-block\")\n\n        // timeout used to make sure div is placed and laid out first\n        // TODO: consider ordering issue\n        this.addTimeout(() => { \n            let sw = this.parentView().clientWidth()\n            let w = this.clientWidth()\n            this.setTopPx(sw/2 - w/2)\n        }, 1)\n\n        return this\n    }\n    */\n\n    rootView () {\n        const pv = this.parentView()\n        if (pv) {\n            return pv.rootView()\n        }\n        return this\n    }\n\n    isInDocument () {\n        return this.rootView() === DocumentBody.shared()\n    }\n\n    containerize () {\n        // create a subview of same size as parent and put all other subviews in it\n        const container = DomView.clone()\n        container.setMinAndMaxHeight(this.clientHeight())\n        container.setMinAndMaxWidth(this.clientWidth())\n        this.moveAllSubviewsToView(container)\n        this.addSubview(container)\n        return container\n    }\n\n    uncontainerize () {\n        assert(this.subviewCount() === 1)\n        const container = this.subviews().first()\n        this.removeSubview(container)\n        container.moveAllSubviewsToView(this)\n        return this\n    }\n\n    moveAllSubviewsToView (aView) {\n        this.subviews().shallowCopy().forEach((sv) => {\n            this.remove(sv)\n            aView.addSubview(sv)\n        })\n        return this\n    }\n\n    // auto fit \n    // need to be careful about interactions as some of these change \n    // display and position attributes\n    // NOTE: when we ask parent to fit child, should we make sure child position attribute allows this?\n\n    hasAbsolutePositionChild () {\n        const match = this.subviews().detect(sv => sv.position() === \"absolute\")\n        return !Type.isNullOrUndefined(match)\n    }\n\n    // auto fit width\n\n    autoFitParentWidth () {\n        this.setDisplay(\"block\")\n        this.setWidth(\"-webkit-fill-available\")\n        //this.setHeight(\"fill-available\")\n        return this\n    }\n\n    autoFitChildWidth () {\n        //assert(!this.hasAbsolutePositionChild()) // won't be able to autofit!\n        this.setDisplay(\"inline-block\")\n        this.setWidth(\"auto\")\n        this.setOverflow(\"auto\")\n        return this\n    }\n\n    // auto fit height\n\n    autoFitParentHeight () {\n        this.setPosition(\"absolute\")\n        //this.setHeightPercentage(100)\n        this.setHeight(\"-webkit-fill-available\")\n        //this.setHeight(\"fill-available\")\n        return this\n    }\n\n    autoFitChildHeight () {\n        //assert(!this.hasAbsolutePositionChild()) // won't be able to autofit!\n        this.setPosition(\"relative\") // or static? but can't be absolute\n        this.setHeight(\"fit-content\")\n        return this\n    }\n\n    // organizing\n\n    moveToAbsoluteDocumentBody () {\n        const f = this.frameInDocument()\n        this.setFrameInDocument(f)\n        this.removeFromParentView()\n        DocumentBody.shared().addSubview(this)\n        return this\n    }\n\n    // organizing\n\n    absoluteOrganizeSubviewsVertically () {\n        let top = 0\n        this.subviews().shallowCopy().forEach((sv) => {\n            const h = sv.clientHeight()\n            sv.setLeftPx(0)\n            sv.setTopPx(top)\n            top += h\n        })\n    }\n\n    absoluteOrganizeSubviewsHorizontally () {\n        let left = 0\n        this.subviews().shallowCopy().forEach((sv) => {\n            const w = sv.clientWidth()\n            sv.setLeftPx(left)\n            sv.setTopPx(0)\n            left += x\n        })\n    }\n\n    // html duplicates\n\n    htmlDuplicateView () {\n        const v = DomView.clone()\n        v.setFrameInParent(this.frameInParentView())\n        v.setInnerHtml(this.innerHtml())\n        return v\n    }\n\n    htmlDuplicateViewAndSubviews (selectedSubviews) {\n        selectedSubviews.forEach(sv => asset(sv.parentView() === this))\n\n        const v = DomView.clone()\n        v.setFrameInParent(this.frameInParentView())\n        selectedSubviews.forEach(sv => v.addSubview(sv.htmlDuplicateView()))\n        return v\n    }\n\n    htmlDuplicateViewWithSubviews () {\n        const v = DomView.clone()\n        v.setFrameInParent(this.frameInParentView())\n        this.subviews().forEach(sv => v.addSubview(sv.htmlDuplicateView()))\n        return v\n    }\n\n    // fitting\n\n    fitSubviews () {\n        const f = this.frameFittingSubviewsInParent()\n        this.setFrameInParent(f)\n        return this\n    }\n\n    frameFittingSubviewsInParent () {\n        let u = null\n\n        this.subviews().forEach(sv => {\n            const f = sv.frameInParent()\n            if (u === null) {\n                u = f\n            } else {\n                u = u.unionWith(f)\n            }\n        })\n\n        return u\n    }\n\n    fixedFrameFittingSubviews () {\n        let u = null\n\n        this.subviews().forEach(sv => {\n            const f = sv.fixedFrame()\n            if (u === null) {\n                u = f\n            } else {\n                u = u.unionWith(f)\n            }\n        })\n\n        return u\n    }\n\n    convertFrameToDocument (aRect) {\n        const p = this.positionInDocument()\n        const newOrigin = aRect.origin().add(p)\n        return aRect.copy().setOrigin(newOrigin)\n    }\n\n    // ----\n\n    updateSubviews () {\n\n    }\n\n    resyncAllViews () {\n        this.updateSubviews() // NodeView already does this when it schedules syncFromNode, so don't call from NodeView\n        this.subviews().forEach(sv => sv.resyncAllViews())\n        return this\n    }\n\n}.initThisClass());\n",
  "ey7rl9OVhbdS2UZgzoBGsKvZArvO+0NGFkqiByLHLqs=": "\"use strict\";\n\n/*\n    ListenerDomView\n\n    Dealing with EventListers\n\n*/\n\n(class ListenerDomView extends SubviewsDomView {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"eventListenersMap\", null)\n    }\n\n    init () {\n        super.init()\n        this.setEventListenersMap(new Map())\n        return this\n    }\n\n    // --- event listener management ---\n\n    eventListeners () {\n        return this.eventListenersMap().valuesArray().map(v => v.allEventListeners()).flat()\n    }\n\n    removeAllListeners () {\n        const map = this.eventListenersMap()\n        map.forEachKV( (k, listener) => { \n            listener.setIsListening(false) \n        } )\n        map.clear()\n        return this\n    }\n\n    hasListenerNamed (className) {\n        const map = this.eventListenersMap()\n        return map.has(className)\n    }\n\n    listenerNamed (className) {\n        const map = this.eventListenersMap()\n        if (!map.has(className)) {\n            const proto = Object.getClassNamed(className)\n            assert(!Type.isNullOrUndefined(proto))\n            const instance = proto.clone().setListenTarget(this.element()).setDelegate(this)\n            map.set(className, instance)\n        }\n        return map.get(className)\n    }\n\n    // --- specific event listeners ---\n\n    animationListener () {\n        return this.listenerNamed(\"AnimationListener\")\n    }\n\n    clipboardListener () {\n        return this.listenerNamed(\"ClipboardListener\")\n    }\n\n    windowListener () {\n        return this.listenerNamed(\"WindowListener\") // listen target will be the window\n    }\n\n    documentListener () {\n        return this.listenerNamed(\"DocumentListener\") // listen target will be the window\n    }\n\n    browserDragListener () {\n        return this.listenerNamed(\"DragListener\")\n    }\n\n    dropListener () {\n        return this.listenerNamed(\"DropListener\")\n    }\n\n    focusListener () {\n        return this.listenerNamed(\"FocusListener\")\n    }\n\n    mouseListener () {\n        return this.listenerNamed(\"MouseListener\")\n    }\n\n    mouseMoveListener () {\n        return this.listenerNamed(\"MouseMoveListener\")\n    }\n\n    keyboardListener () {\n        return this.listenerNamed(\"KeyboardListener\")\n    }\n\n    touchListener () {\n        return this.listenerNamed(\"TouchListener\")\n    }\n\n    transitionListener () {\n        return this.listenerNamed(\"TransitionListener\")\n    }\n\n    // --- invoking event handler methods ---\n\n    invokeMethodNameForEvent (methodName, event) {\n        //this.debugLog(\".invokeMethodNameForEvent('\" + methodName + \"')\")\n        if (this[methodName]) {\n            //console.log(this.typeId() + \".invokeMethodNameForEvent('\" + methodName + \"')\")\n            const continueProp = this[methodName].apply(this, [event])\n            if (continueProp === false) {\n                //event.preventDefault()\n                event.stopPropagation()\n                return false\n            }\n        }\n\n        return true\n    }\n\n    // --- register window resize events ---\n\n    isRegisteredForWindowResize () {\n        return this.windowListener().isListening()\n    }\n\n    setIsRegisteredForWindowResize (aBool) {\n        this.windowListener().setIsListening(aBool)\n        return this\n    }\n\n    // --- handle window resize events ---\n\n    onWindowResize (event) {\n        return true\n    }\n\n    // --- register onClick events ---\n\n    isRegisteredForClicks () {\n        //return this.mouseListener().isListening()\n        return this.defaultTapGesture().isListening()\n    }\n\n    setIsRegisteredForClicks (aBool) {\n        //this.mouseListener().setIsListening(aBool)\n        this.setHasDefaultTapGesture(aBool) // use tap gesture instead of mouse click\n\n        if (aBool) {\n            this.makeCursorPointer()\n        } else {\n            this.makeCursorDefault()\n        }\n\n        return this\n    }\n\n\n    // --- registering for mouse events ---\n    /*\n        NOTE: onTap... is now used instead?\n    */\n\n    isRegisteredForMouse () {\n        return this.mouseListener().isListening()\n    }\n\n    setIsRegisteredForMouse (aBool, useCapture) {\n        debugger;\n        this.mouseListener().setUseCapture(useCapture).setIsListening(aBool) \n        return this\n    }\n\n    // --- mouse events ---\n\n    /*\n    // avoid declaring these as it will cause all views registered for mouse events to register for mousemove\n\n    onMouseMove (event) {\n        return true\n    }\n\n    onMouseOver (event) {\n        return true\n    }\n\n    onMouseLeave (event) {\n        return true\n    }\n\n    onMouseOver (event) {\n        return true\n    }\n    */\n\n    onMouseDown (event) {\n        const methodName = Mouse.shared().downMethodNameForEvent(event)\n        if (methodName !== \"onMouseDown\") {\n            this.debugLog(\".onMouseDown calling: \", methodName)\n            this.invokeMethodNameForEvent(methodName, event)\n        }\n        return true\n    }\n\n    onMouseUp (event) {\n        const methodName = Mouse.shared().upMethodNameForEvent(event)\n        if (methodName !== \"onMouseUp\") {\n            this.debugLog(\".onMouseUp calling: \", methodName)\n            this.invokeMethodNameForEvent(methodName, event)\n        }\n        return true\n    }\n\n    // --- registering for keyboard events ---\n\n    isRegisteredForKeyboard () {\n        return this.keyboardListener().isListening()\n    }\n\n    setIsRegisteredForKeyboard (aBool, useCapture) {\n        this.keyboardListener().setUseCapture(useCapture).setIsListening(aBool)\n\n        const e = this.element()\n        if (aBool) {\n            DomView.setTabCount(DomView.tabCount() + 1)\n            e.tabIndex = DomView.tabCount()  // need this in order for focus to work on BrowserColumn?\n            //this.setCssProperty(\"outline\", \"none\"); // needed?\n        } else {\n            delete e.tabindex\n        }\n\n        return this\n    }\n\n    // --- keyboard events ---\n\n    onKeyDown (event) {\n        //BMKeyboard.shared().showEvent(event)\n        // expand the method name to include combinations of meta keys (e.g. shift, function, control, option, command, etc)\n        const methodName = BMKeyboard.shared().downMethodNameForEvent(event)\n        //console.log(\" onKeyDown \", methodName)\n        const result = this.invokeMethodNameForEvent(methodName, event)\n\n        /*\n        if (event.repeat) { // should this be a different method name?\n            this.forceRedisplay() // can't tell if this works without disabling color transitions on tiles\n        }\n        */\n\n        return result\n    }\n\n    // --- registering for focus / blur events ---\n\n    isRegisteredForFocus () {\n        return this.focusListener().isListening()\n    }\n\n    setIsRegisteredForFocus (aBool) {\n        if (aBool === false && !this.hasListenerNamed(\"FocusListener\")) { // todo: clean this up\n            return\n        }\n        this.focusListener().setIsListening(aBool)\n        return this\n    }\n\n    // --- focus events ---\n\n    onFocusIn (event) {\n        return true\n    }\n\n    onFocusOut (event) {\n        return true\n    }\n\n    onFocus (event) {\n        //console.log(this.typeId() + \" onFocus\")\n        this.willAcceptFirstResponder();\n        // subclasses can override \n        //this.debugLog(\" onFocus\")\n        return true\n    }\n\n    onBlur (event) {\n        //console.log(this.typeId() + \" onBlur\")\n        this.didReleaseFirstResponder();\n        // subclasses can override \n        //this.debugLog(\" onBlur\")\n        return true\n    }\n\n    // --- registering for clipboard events ---\n\n    isRegisteredForClipboard () {\n        return this.clipboardListener().isListening()\n    }\n\n    setIsRegisteredForClipboard (aBool) {\n        this.clipboardListener().setIsListening(aBool)\n        return this\n    }\n        \n\n}.initThisClass());\n",
  "qy9KYI3SsrEYXwH2oWppz7vN8M8x5bjB31Sr6Pxfii0=": "\"use strict\";\n\n/*\n    VisibleDomView\n\n    Support for visibility events.\n\n*/\n\n(class VisibleDomView extends ListenerDomView {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"isRegisteredForVisibility\", false)\n        this.newSlot(\"intersectionObserver\", null)\n        this.newSlot(\"onVisibilityCallback\", null)\n    }\n\n    /*\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n    // visibility event\n\n    onVisibility () {\n        //this.debugLog(\".onVisibility()\")\n        const callback = this.onVisibilityCallback()\n        if (callback) {\n            callback()\n\n        }\n\n        this.unregisterForVisibility()\n        return true\n    }\n\n    isRegisteredForVisibility () {\n        return !Type.isNull(this.intersectionObserver())\n    }\n\n    setIsRegisteredForVisibility (aBool) {\n        if (aBool !== this.isRegisteredForVisibility()) {\n            if (aBool) {\n                this.registerForVisibility()\n            } else {\n                this.unregisterForVisibility()\n            }\n        }\n        return this\n    }\n\n    unregisterForVisibility () {\n        const obs = this.intersectionObserver()\n        if (obs) {\n            obs.disconnect()\n            this.setIntersectionObserver(null);\n            this._isRegisteredForVisibility = false\n        }\n        return this\n    }\n\n    visibilityRoot () {\n        // our element must be a decendant of the visibility root element\n        let root = document.body\n\n        if (this.parentView()) {\n            root = this.parentView().parentView().element() // hack for tile in scroll view - TODO: make more general\n            //root = this.parentView().element()\n        }\n        return root\n    }\n\n    registerForVisibility () { // this is a oneShot event, as onVisibility() unregisters\n        if (this.isRegisteredForVisibility()) {\n            return this\n        }\n\n        const intersectionObserverOptions = {\n            root: this.visibilityRoot(), // watch for visibility in the viewport \n            rootMargin: \"0px\",\n            threshold: 1.0\n        }\n\n        const obs = new IntersectionObserver((entries, observer) => {\n            EventManager.shared().safeWrapEvent(() => { this.handleIntersection(entries, observer) })\n            //this.handleIntersection(entries, observer)\n        }, intersectionObserverOptions)\n\n        this.setIntersectionObserver(obs);\n        obs.observe(this.element());\n\n        this._isRegisteredForVisibility = true\n        return this\n    }\n\n    handleIntersection (entries, observer) {\n        entries.forEach(entry => {\n            if (entry.isIntersecting) {\n                //  if (entries[0].intersectionRatio <= 0) return;\n\n                //console.log(\"onVisibility!\")\n   \n                this.onVisibility()\n            }\n        })\n    }\n\n\n}.initThisClass());\n",
  "6gBIZ4ql+MUHPNZJFPsx0Xw/tcQO6ofdlharuac1aCA=": "\"use strict\";\n\n/*\n    GesturableDomView\n\n    Handling gestures\n    \n*/\n\n(class GesturableDomView extends VisibleDomView {\n    \n    initPrototypeSlots () {\n        // Array - not a map as we might have multiple GRs of same type, but...\n        // would it be better to give GRs labels to use for map key?\n        // this could replace \"default\" gesture ivars?\n        this.newSlot(\"gestureRecognizers\", null) // array\n\n        // default gestures with typical settings \n        this.newSlot(\"defaultTapGesture\", null)\n        this.newSlot(\"defaultDoubleTapGesture\", null)\n        this.newSlot(\"defaultPanGesture\", null)\n    }\n\n    /*\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n    // gestures\n\n    gestureRecognizers () {\n        if (this._gestureRecognizers === null) {\n            this._gestureRecognizers = []\n        }\n        return this._gestureRecognizers\n    }\n\n    /*\n\n    // deprecated - GestureRecognizers are now used instead of direct touch events\n\n    isRegisteredForTouch () {\n        return this.touchListener().isListening()\n    }\n\n    setIsRegisteredForTouch (aBool) {\n        this.touchListener().setIsListening(aBool)\n\n        if (aBool) {\n            this.setTouchAction(\"none\") // testing\n        }\n\n        return this\n    }\n\n    onTouchStart (event) {\n    }\n\n    onTouchMove (event) {\n    }\n\n    onTouchCancel (event) {\n    }\n\n    onTouchEnd (event) {\n    }\n    */\n\n    // --- GestureRecognizers ---\n\n    hasGestureRecognizer (gr) {\n        return this.gestureRecognizers().contains(gr)\n    }\n\n    addGestureRecognizer (gr) {\n        assert(!this.hasGestureRecognizer(gr))\n        this.gestureRecognizers().append(gr)\n        gr.setViewTarget(this)\n        gr.start()\n        //console.log(this.typeId() + \" addGestureRecognizer(\" + gr.type() + \")\")\n        return gr\n    }\n\n    removeGestureRecognizer (gr) {\n        if (this.gestureRecognizers()) {\n            gr.stop()\n            gr.setViewTarget(null)\n            this.gestureRecognizers().remove(gr)\n        }\n        return this\n    }\n\n    /*\n    hasGestureType (typeName) {\n        return this.gesturesOfType(typeName).length > 0\n    }\n\n    addGestureRecognizerIfAbsent (gr) {\n        if (!this.hasGestureRecognizer(gr)) {\n            this.addGestureRecognizer(gr)\n        }\n        return this\n    }\n    \n    gesturesOfType (typeName) {\n        return this.gestureRecognizers().select(gr => gr.type() == typeName)\n    }\n\n    removeGestureRecognizersOfType (typeName) {\n        if (this.gestureRecognizers()) {\n            this.gestureRecognizers().select(gr => gr.type() == typeName).forEach(gr => this.removeGestureRecognizer(gr))\n        }\n        return this\n    }\n    */\n\n    removeAllGestureRecognizers () {\n        const grs = this.gestureRecognizers()\n        if (grs.length) {\n            //console.log(this.typeId() + \" removeAllGestureRecognizers \", grs.length)\n            grs.shallowCopy().forEach(gr => this.removeGestureRecognizer(gr))\n        }\n        return this\n    }\n\n    // default tap gesture\n\n    setHasDefaultTapGesture (aBool) {\n        if (aBool) {\n            this.addDefaultTapGesture()\n        } else {\n            this.removeDefaultTapGesture()\n        }\n        return this\n    }\n\n    addDefaultTapGesture () {\n        if (!this.defaultTapGesture()) {\n            const g = this.addGestureRecognizer(TapGestureRecognizer.clone())\n            g.setShouldRequestActivation(true) // TODO: this is usually what we want?\n            this.setDefaultTapGesture(g)\n        }\n        return this.defaultTapGesture()\n    }\n\n    removeDefaultTapGesture () {\n        if (this.defaultTapGesture()) {\n            this.removeGestureRecognizer(this.defaultTapGesture())\n            this.setDefaultTapGesture(null)\n        }\n        return this\n    }\n\n    // default double tap gesture\n\n    newDoubleTapGestureRecognizer () { // private\n        const tg = TapGestureRecognizer.clone()\n        tg.setNumberOfTapsRequired(2)\n        tg.setNumberOfFingersRequired(1)\n        tg.setGestureName(\"DoubleTap\")\n\n        // Do we want this, which allows single tap event and double tap, or do\n        // we want to wait to send single tap until double tap wait period expires?\n        tg.setShouldAcceptCancelRequest(false) // so single click doesn't cancel double click. \n        return tg\n    }\n\n    addDefaultDoubleTapGesture () { \n        if (!this.defaultDoubleTapGesture()) {\n            const gr = this.newDoubleTapGestureRecognizer()\n            this.setDefaultDoubleTapGesture(gr)\n            this.addGestureRecognizer(gr)\n        }\n        return this.defaultDoubleTapGesture()\n    }\n\n    removeDefaultDoubleTapGesture () { \n        if (this.defaultDoubleTapGesture()) {\n            this.removeGestureRecognizer(this.defaultDoubleTapGesture())\n            this.setDefaultDoubleTapGesture(null)\n        }\n        return this\n    }\n\n    // default pan gesture\n\n    addDefaultPanGesture () {\n        if (!this._defaultPanGesture) {\n            this._defaultPanGesture = this.addGestureRecognizer(PanGestureRecognizer.clone()) \n        }\n        return this._defaultPanGesture\n    }\n\n    defaultPanGesture () {\n        return this._defaultPanGesture\n    }\n\n    removeDefaultPanGesture () {\n        if (this._defaultPanGesture) {\n            this.removeGestureRecognizer(this._defaultPanGesture)\n            this._defaultPanGesture = null\n        }\n        return this\n    }\n\n    // orient testing\n\n    /*\n    onOrientBegin (aGesture) {\n        this.debugLog(\".onOrientBegin()\")\n        aGesture.show()\n    }\n\n    onOrientMove (aGesture) {\n        this.debugLog(\".onOrientMove()\")\n        aGesture.show()\n    }\n\n    onOrientComplete (aGesture) {\n        this.debugLog(\".onOrientComplete()\")\n        aGesture.show()\n    }\n    */\n\n    cancelAllGesturesExcept (aGesture) {\n        this.gestureRecognizers().forEach((gr) => {\n            //if (gr.type() !== aGesture.type()) {\n            if (gr !== aGesture) {\n                //this.debugLog(\"cancelling gesture \", gr.type())\n                gr.cancel()\n            }\n        })\n        return this\n    }\n\n\n}.initThisClass());\n",
  "f63Zph4WY/eNir6UZLHPhX5OpSXg5Fyyo2m7uZd7XKQ=": "\"use strict\";\n\n/*\n    ResponderDomView\n\n    Dealing with controlling focus and handling focus events,\n    manaing firstResponder, tabbing between key views\n    \n*/\n\n(class ResponderDomView extends GesturableDomView {\n    \n    static initClass () {\n        this.newClassSlot(\"tabCount\", 0)\n    }\n\n    initPrototypeSlots () {\n        this.newSlot(\"acceptsFirstResponder\", false)\n\n        // browser looks at element.tabindex to find next element \n        // to focus on tab press, but we may want more behavior\n        //this.newSlot(\"interceptsTab\", true)\n        this.newSlot(\"nextKeyView\", null)\n        //this.newSlot(\"canMakeKey\", true)\n    }\n\n    /*\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n    // --- focus ---\n\n    scheduleRegisterForFocus () {\n        if (this.element().parentElement) {\n            this.setIsRegisteredForFocus(true);\n        } else {\n            // only need timeout when create dom element in same event?\n            this.addTimeout(() => { \n                this.setIsRegisteredForFocus(true); \n            }, 0) \n        }\n    }\n\n    hasFocusedDecendantView () {\n        const focusedView = WebBrowserWindow.shared().activeDomView()\n        if (focusedView) {\n            return this.hasSubviewDescendant(focusedView)\n        }\n        return false\n    }\n\n    focus () {\n        if (!this.isActiveElement()) {\n            //console.log(this.typeId() + \" focus <<<<<<<<<<<<<<<<<<\")\n            /*\n            const focusedView = WebBrowserWindow.shared().activeDomView()\n\n            // TODO: need a better solution to this problem\n            if (focusedView && !this.hasFocusedDecendantView()) {\n                \n                if (focusedView && focusedView.type() === \"TextField\") {\n                    console.log(\"  -- taking focus from \" + focusedView.typeId())\n                }\n                \n                //this.debugLog(\".focus() \" + document.activeElement.domView())\n                this.addTimeout(() => { this.element().focus() }, 0)\n            }\n            */\n            //this.addTimeout(() => { this.element().focus() }, 0)\n\n            //ThrashDetector.shared().didWrite(\"focus\", this)\n            this.element().focus()\n        }\n        return this\n    }\n\n    focusAfterDelay (seconds) {\n        this.addTimeout(() => {\n            const e = this.element()\n            if (e) {\n                // in case element has retired during the timeout\n                e.focus()\n            }\n        }, seconds * 1000)\n        return this\n    }\n\n    hasFocus () {\n        return this.isActiveElement()\n    }\n\n    blur () { \n        // i.e. unfocus\n        this.element().blur()\n        return this\n    }\n\n    // --- active element ---\n\n    isActiveElement () {\n        return document.activeElement === this.element()\n    }\n\n    isActiveElementAndEditable () {\n        return this.isActiveElement() && this.contentEditable()\n    }\n\n    isFocused () {\n        return this.isActiveElement()\n    }\n\n    // --- inner html ---\n\n    setInnerHtml (v) {\n     //   debugger\n        const oldValue = this.element().innerHTML\n\n        if (v === null) {\n            v = \"\"\n        }\n\n        v = \"\" + v\n\n        if (v === oldValue) {\n            return this\n        }\n\n        const isFocused = this.isActiveElementAndEditable()\n\n        if (isFocused) {\n            this.blur()\n            const savedSelection = this.saveSelection()\n            //console.log(\"savedSelection:\", savedSelection)\n            this.element().innerHTML = v\n            savedSelection.collapse()\n            this.restoreSelection(savedSelection)\n            this.focus()\n        } else {\n            this.element().innerHTML = v\n        }\n\n        return this\n    }\n\n    forceRedisplay () {\n        // NOTE: not sure this works\n        const p = this.parentView()\n        if (p) {\n            const d = p.display()\n            p.setDisplay(\"none\")\n            p.setDisplay(d)  \n        }\n        return this\n    }\n\n    /*\n    onKeyPress (event) { // no longer used or registered\n        console.log(\"onKeyPress\")\n        return true\n    }\n    */\n\n    onKeyUp (event) {\n        let shouldPropogate = true\n        //this.debugLog(\" onKeyUp \", event._id)\n        const methodName = BMKeyboard.shared().upMethodNameForEvent(event)\n        //console.log(\"methodName: \", methodName)\n        this.invokeMethodNameForEvent(methodName, event)\n        return shouldPropogate\n    }\n\n    didEdit () {\n        this.debugLog(\"didEdit\")\n        this.tellParentViews(\"onDidEdit\", this)\n        return this\n    }\n\n    onEnterKeyUp (event) {\n        return true\n    }\n\n    // --- tabs and next key view ----\n\n    onTabKeyDown (event) {\n        // need to implement this on key down to prevent browser from handling tab?\n        //this.debugLog(\" onTabKeyDown \", event._id)\n\n        if (this.selectNextKeyView()) {\n            //event.stopImmediatePropagation() // prevent other listeners from getting this event\n            //console.log(\"stopImmediatePropagation \")\n        }\n        return false\n    }\n\n    onTabKeyUp (event) {\n        //this.debugLog(\" onTabKeyUp \", event._id)\n        return false\n    }\n\n    becomeKeyView () { \n        // use this method instead of focus() in order to give the receiver \n        // a chance to give focus to one of it's decendant views\n        this.focus()\n        return this\n    }\n\n    selectNextKeyView () {\n        // returns true if something is selected, false otherwise\n\n        //this.debugLog(\" selectNextKeyView\")\n        const nkv = this.nextKeyView()\n        if (nkv) {\n            nkv.becomeKeyView()\n            return true\n        } else {\n            const p = this.parentView()\n            if (p) {\n                return p.selectNextKeyView()\n            }\n        }\n        return false\n    }\n\n    // --- error checking ---\n\n    isValid () {\n        return true\n    }\n\n    // --- focus and blur event handling ---\n\n    willAcceptFirstResponder () {\n        //this.debugLog(\".willAcceptFirstResponder()\")\n        return this\n    }\n\n    didReleaseFirstResponder () {\n        // called on blur event from browser?\n        return this\n    }\n\n    // --- firstResponder --- \n\n    isFirstResponder () {\n        return document.activeElement === this.element()\n    }\n\n    willBecomeFirstResponder () {\n        // called if becomeFirstResponder accepts\n    }\n\n    becomeFirstResponder () {\n        if (this.acceptsFirstResponder()) {\n            this.willBecomeFirstResponder()\n            this.focus()\n        } else if (this.parentView()) {\n            this.parentView().becomeFirstResponder()\n        }\n        return this\n    }\n\n    releaseFirstResponder () {\n        // walk up parent view chain and focus on the first view to \n        // answer true for the acceptsFirstResponder message\n        //this.debugLog(\".releaseFirstResponder()\")\n\n        if (this.isFocused()) { \n            this.blur()\n        }\n\n        this.tellParentViews(\"decendantReleasedFocus\", this)\n        /*\n        if (this.parentView()) {\n            this.parentView().becomeFirstResponder()\n        }\n        */\n        return this\n    }\n\n\n\n    // helpers\n\n    /*\n    mouseUpPos () { \n        return this.viewPosForWindowPos(Mouse.shared().upPos())\n    }\n\n    mouseCurrentPos () { \n        return this.viewPosForWindowPos(Mouse.shared().currentPos())\n    }\n    */\n\n    /*\n    mouseDownPos () {\n        return this.viewPosForWindowPos(Mouse.shared().downPos())\n    }\n    */\n\n\n    // ------------------------------------------------\n\n    disablePointerEventsUntilTimeout (ms) {\n        // typically used to disbale view until an animation is complete\n\n        this.setPointerEvents(\"none\")\n        this.debugLog(\" disabling pointer events\")\n\n        this.addTimeout(() => {\n            this.debugLog(\" enabling pointer events\")\n            this.setPointerEvents(\"inherit\")\n        }, ms)\n\n        return this\n    }\n\n}.initThisClass());\n",
  "oPuOQ8sgZBQTZvR6SMPlSxN7j5h/9rc1KYwYqbuZAs4=": "\"use strict\";\n\n/*\n    ControlDomView\n\n    Target / action state and behavior.\n\n*/\n\n(class ControlDomView extends ResponderDomView {\n    \n    initPrototypeSlots () {\n        // Targetable - target / action\n        this.newSlot(\"target\", null)\n        this.newSlot(\"action\", null)\n    }\n\n    /*\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n    // --- target/action ---\n\n    hasTargetAndAction () {\n        return (this.target() !== null) && (this.action() !== null)\n    }\n\n    setTarget (anObject) {\n        this._target = anObject\n        this.setIsRegisteredForClicks(this.hasTargetAndAction())\n        return this\n    }\n\n    setAction (anActionString) {\n        this._action = anActionString\n        this.setIsRegisteredForClicks(this.hasTargetAndAction())\n        return this\n    }\n\n    // ---\n\n    onClick (event) {\n        debugger;\n        this.debugLog(\".onClick()\")\n        this.sendActionToTarget()\n        event.stopPropagation()\n        return false\n    }\n\n    onTapComplete (aGesture) {\n        this.debugLog(\".onTapComplete()\")\n        this.sendActionToTarget()\n        return this\n    }\n\n    sendActionToTarget () {\n        if (!this.action()) {\n            return null\n        }\n\n        const t = this.target()\n        if (!t) {\n            throw new Error(\"no target for action \" + this.action())\n        }\n\n        const method = t[this.action()]\n        if (!method) {\n            throw new Error(\"no target for action \" + this.action())\n        }\n\n        return method.call(t, this)\n    }\n\n    onDoubleClick (event) {\n        return true\n    }\n    \n}.initThisClass());\n",
  "82TxSItt2CLO0RMNIvNvbx3G/kLHfOYUOSVnPKlqbfY=": "\"use strict\";\n\n/*\n    EditableDomView\n\n    For subclasses to extend. Ancestors of this class are organizational parts of DomView.\n\n*/\n\n(class EditableDomView extends ControlDomView {\n    \n    initPrototypeSlots () {\n        //this.newSlot(\"unfocusOnEnterKey\", false)\n        //this.newSlot(\"showsHaloWhenEditable\", false)\n    }\n\n    /*\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n    /*\n    onEnterKeyDown (event) {\n        this.debugLog(\" onEnterKeyDown\")\n        if (this.unfocusOnEnterKey() && this.isFocused()) {\n            this.debugLog(\" releasing focus\")\n            // this.releaseFocus() // TODO: implement something to pass focus up view chain to whoever wants it\n            //this.element().parentElement.focus()\n            if (this.parentView()) {\n                this.parentView().focus()\n            }\n        }\n        return this\n    }\n    */\n\n\n    // --- set caret ----\n\n    insertTextAtCursor(text) {\n        const savedSelection = this.saveSelection()\n\n        if (window.getSelection) {\n            const sel = window.getSelection();\n            if (sel.getRangeAt && sel.rangeCount) {\n                const range = sel.getRangeAt(0);\n                range.deleteContents();\n                range.insertNode( document.createTextNode(text) );\n            }\n        } else if (document.selection && document.selection.createRange) {\n            document.selection.createRange().text = text;\n        }\n        savedSelection.collapse()\n        this.restoreSelection(savedSelection)\n\n        return this\n    }\n\n    saveSelection () {\n        if (window.getSelection) {\n            const sel = window.getSelection();\n            if (sel.getRangeAt && sel.rangeCount) {\n                return sel.getRangeAt(0);\n            }\n        } else if (document.selection && document.selection.createRange) {\n            return document.selection.createRange();\n        }\n        return null;\n    }\n    \n    restoreSelection (range) {\n        if (range) {\n            if (window.getSelection) {\n                const sel = window.getSelection();\n                sel.removeAllRanges();\n                sel.addRange(range);\n            } else if (document.selection && range.select) {\n                range.select();\n            }\n        }\n    }\n\n    // --- set caret ----\n\n    moveCaretToEnd () {\n        const contentEditableElement = this.element()\n        let range, selection;\n\n        if (document.createRange) {\n            //Firefox, Chrome, Opera, Safari, IE 9+\n            range = document.createRange(); //Create a range (a range is a like the selection but invisible)\n            range.selectNodeContents(contentEditableElement); //Select the entire contents of the element with the range\n            range.collapse(false); //collapse the range to the end point. false means collapse to end rather than the start\n            selection = window.getSelection(); //get the selection object (allows you to change selection)\n            selection.removeAllRanges(); //remove any selections already made\n            selection.addRange(range); //make the range you have just created the visible selection\n        }\n        else if (document.selection) {\n            //IE 8 and lower\n            range = document.body.createTextRange(); //Create a range (a range is a like the selection but invisible)\n            range.moveToElementText(contentEditableElement); //Select the entire contents of the element with the range\n            range.collapse(false); //collapse the range to the end point. false means collapse to end rather than the start\n            range.select();//Select the range (make it the visible selection\n        }\n        return this\n    }\n\n    // --- text selection ------------------\n\n    selectAll () {\n        if (document.selection) {\n            const range = document.body.createTextRange();\n            range.moveToElementText(this.element());\n            range.select();\n        } else if (window.getSelection) {\n            const selection = window.getSelection(); \n            const range = document.createRange();\n            range.selectNodeContents(this.element());\n            selection.removeAllRanges();\n            selection.addRange(range);  \n        }\n    }\n\n    // --- paste from clipboardListener ---\n\n    onPaste (event) {\n        //debugger;\n        // prevent pasting text by default after event\n        event.preventDefault();\n\n        const clip = event.clipboardData;\n        const html = clip.getData(\"text/html\");\n        const text = clip.getData(\"text/plain\");\n\n        const htmlToPlainTextFunc = function (html) {\n            const e = document.createElement(\"DIV\");\n            e.innerHTML = html;\n            return e.textContent || e.innerText || \"\";\n        }\n\n        if (html && html.trim().length !== 0) {\n            const s = htmlToPlainTextFunc(html)\n            this.replaceSelectedText(s)\n            return false; // prevent returning text in clipboard\n        }\n\n        if (text && text.trim().length !== 0) {\n            const s = htmlToPlainTextFunc(text)\n            this.replaceSelectedText(s)\n            return false; // prevent returning text in clipboard\n        }\n\n        return true\n    }\n\n    // ------------\n\n    replaceSelectedText (replacementText) {\n        let range;\n        if (window.getSelection) {\n            const sel = window.getSelection();\n            if (sel.rangeCount) {\n                range = sel.getRangeAt(0);\n                range.deleteContents();\n                range.insertNode(document.createTextNode(replacementText));\n            }\n\n            console.log(\"inserted node\")\n        } else if (document.selection && document.selection.createRange) {\n            range = document.selection.createRange();\n            range.text = replacementText;\n            console.log(\"set range.text\")\n        }\n\n        if (range) {\n            // now move the selection to just the end of the range\n            range.setStart(range.endContainer, range.endOffset);\n        }\n\n        return this\n    }\n\n    // untested\n\n    getCaretPosition () {\n        const editableElement = this.element()\n        let caretPos = 0\n        if (window.getSelection) {\n            const sel = window.getSelection();\n            if (sel.rangeCount) {\n                const range = sel.getRangeAt(0);\n                if (range.commonAncestorContainer.parentNode == editableElement) {\n                    caretPos = range.endOffset;\n                }\n            }\n        } else if (document.selection && document.selection.createRange) {\n            const range = document.selection.createRange();\n            if (range.parentElement() == editableElement) {\n                const tempEl = document.createElement(\"span\");\n                editableElement.insertBefore(tempEl, editableElement.firstChild);\n                const tempRange = range.duplicate();\n                tempRange.moveToElementText(tempEl);\n                tempRange.setEndPoint(\"EndToEnd\", range);\n                caretPos = tempRange.text.length;\n            }\n        }\n        return caretPos;\n    }\n\n    setCaretPosition (caretPos) {\n        const e = this.element();\n\n        if (e != null) {\n            if (e.createTextRange) {\n                const range = e.createTextRange();\n                range.move(\"character\", caretPos);\n                range.select();\n            }\n            else {\n                if (e.selectionStart) {\n                    e.focus();\n                    e.setSelectionRange(caretPos, caretPos);\n                } else {\n                    e.focus();\n                }\n            }\n        }\n    }\n\n    // ---------------\n\n    clearSelection () {\n        if (window.getSelection) {\n            window.getSelection().removeAllRanges();\n        } else if (document.selection) {\n            document.selection.empty();\n        }\n        return this\n    }\n\n}.initThisClass());\n",
  "Ov6PCLdjNPHK6Lw4UhFHdD0GWZvXVrTSMTybxChsEXw=": "\"use strict\";\n\n/*\n    DomView\n\n    For subclasses to extend. Ancestors of this class are organizational parts of DomView.\n\n*/\n\n(class DomView extends EditableDomView {\n    \n    initPrototypeSlots () {\n    }\n\n    /*\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n}.initThisClass());\n",
  "bJ+n86XtuR3tv3qvX+MC6xYTbPq1gwlc+U06a3tY1kc=": "\"use strict\";\n\n/*\n    DomViewanimations\n\n    Helper methods for animations.\n\n*/\n\n(class DomView_animations extends DomView {\n\n    // --- movement animations ---\n\n    scrollToBottom () {\n        const focusedElement = document.activeElement\n        const needsRefocus = focusedElement !== this.element()\n        // console.log(\"]]]]]]]]]]]] \" + this.typeId() + \".scrollToTop() needsRefocus = \", needsRefocus)\n\n        this.setScrollTop(this.scrollHeight())\n\n        if (needsRefocus) {\n            focusedElement.focus()\n        }\n        //e.animate({ scrollTop: offset }, 500); // TODO: why doesn't this work?\n        return this\n    }\n\n    scrollSubviewToTop (aSubview) {\n        console.log(\"]]]]]]]]]]]] \" + this.typeId() + \".scrollSubviewToTop()\")\n        assert(this.hasSubview(aSubview))\n        //this.setScrollTop(aSubview.offsetTop())\n        //this.setScrollTopSmooth(aSubview.offsetTop())\n        //this.setScrollTop(aSubview.offsetTop() + aSubview.scrollHeight())\n        this.animateValue(\n            () => { return aSubview.offsetTop() },\n            () => { return this.scrollTop() },\n            (v) => { this.setScrollTop(v) },\n            200)\n        return this\n    }\n\n    // --- animation ---\n\n    animateValue (targetFunc, valueFunc, setterFunc, duration) { // duration in milliseconds         \n        console.log(\"]]]]]]]]]]]] \" + this.typeId() + \".animateValue()\")\n        if (duration == null) {\n            duration = 200\n        }\n        //duration = 1500\n        const startTime = Date.now();\n\n        const step = () => {\n            const dt = (Date.now() - startTime)\n            let r = dt / duration\n            r = Math.sin(r * Math.PI / 2)\n            r = r * r * r\n\n            const currentValue = valueFunc()\n            const currentTargetValue = targetFunc()\n\n            //console.log(\"time: \", dt, \" /\", duration, \" r:\", r, \" top:\", currentValue, \"/\", currentTargetValue)\n\n            if (dt > duration) {\n                setterFunc(currentTargetValue)\n            } else {\n                const newValue = currentValue + (currentTargetValue - currentValue) * r\n                setterFunc(newValue)\n                window.requestAnimationFrame(step);\n            }\n        }\n\n        window.requestAnimationFrame(step);\n        return this\n    }\n\n    setScrollTopSmooth (newScrollTop, scrollDuration) {\n        this.animateValue(() => { return newScrollTop }, () => { return this.scrollTop() }, (v) => { this.setScrollTop(v) }, scrollDuration)\n        return this\n    }\n\n    dynamicScrollIntoView () {\n        this.parentView().scrollSubviewToTop(this)\n        return this\n    }\n\n    scrollIntoView () {\n        // TODO: return immediately if already visible\n        if (this.isScrolledIntoView()) {\n            return false\n        }\n\n        const focusedView = WebBrowserWindow.shared().activeDomView()\n        //console.log(\"]]]]]]]]]]]] \" + this.typeId() + \".scrollIntoView() needsRefocus = \", focusedView !== this)\n\n        // if another view is focused, the scrolling will unfocus it, so we\n        // need a way to return focus after scrolling is complete\n        if (focusedView && focusedView !== this) {\n            //console.log(\"scrollIntoView - registerForVisibility\")\n            // this hack is needed to return focus that scrollIntoView grabs from other elements\n            // need to do this before element().scrollIntoView appearently\n            this.registerForVisibility()\n            // hack around lack of end of scrollIntoView event \n            // needed to return focus that scrollIntoView grabs from other elements\n            this.setOnVisibilityCallback(() => {\n                //console.log(\"_endScrollIntoViewFunc - returning focus\")\n                //focusedView.focus()\n                // need delay to allow scroll to finish - hack - TODO: check for full visibility\n                focusedView.focusAfterDelay(0.2)\n            })\n        }\n\n        this.addTimeout(() => {\n            // have browser do scroll\n            //ThrashDetector.shared().didOp(\"scrollIntoView\")\n            this.element().scrollIntoView({ \n                block: \"start\", \n                inline: \"nearest\", \n                behavior: \"smooth\", \n            })\n        }, 0)\n\n        this.element().addEventListener('transitionend', (transitionEvent) => {\n            console.log(\"completed scrollIntoView transition?:\", transitionEvent.propertyName)\n        });\n\n        /*\n        if (focusedView !== this) {\n            focusedView.focusAfterDelay(0.5) // TODO: get this value from transition property\n        }\n        */\n        return this\n    }\n    \n    isScrolledIntoView () {\n        const r = this.boundingClientRect()\n        const isVisible = (r.top >= 0) && (r.bottom <= window.innerHeight);\n        return isVisible;\n    }\n\n    verticallyAlignAbsoluteNow () {\n        const pv = this.parentView()\n        if (pv) {\n            this.setPosition(\"absolute\")\n            const parentHeight = pv.computedHeight() //pv.calcHeight() // computedHeight?\n            const height = this.computedHeight()\n            this.setTopPx((parentHeight / 2) - (height / 2))\n        } else {\n            throw new Error(\"missing parentView\")\n        }\n        return this\n    }\n\n    horizontallyAlignAbsoluteNow () {\n        const pv = this.parentView()\n        if (pv) {\n            this.setPosition(\"absolute\")\n            this.addTimeout(() => {\n                this.setRightPx(pv.clientWidth() / 2 - this.clientWidth() / 2)\n            }, 0)\n        }\n        return this\n    }\n    // ----------------------\n\n    animateToDocumentFrame (destinationFrame, seconds, completionCallback) {\n        this.setTransition(\"all \" + seconds + \"s\")\n        assert(this.position() === \"absolute\")\n        this.addTimeout(() => {\n            this.setTopPx(destinationFrame.origin().y())\n            this.setLeftPx(destinationFrame.origin().x())\n            this.setMinAndMaxWidth(destinationFrame.size().width())\n            this.setMinAndMaxHeight(destinationFrame.size().height())\n        }, 0)\n\n        this.addTimeout(() => {\n            completionCallback()\n        }, seconds * 1000)\n        return this\n    }\n\n    animateToDocumentPoint (destinationPoint, seconds, completionCallback) {\n        this.setTransition(\"all \" + seconds + \"s\")\n        assert(this.position() === \"absolute\")\n        this.addTimeout(() => {\n            this.setTopPx(destinationPoint.y())\n            this.setLeftPx(destinationPoint.x())\n        }, 0)\n\n        this.addTimeout(() => {\n            completionCallback()\n        }, seconds * 1000)\n        return this\n    }\n\n    // --- hide and fade animations ---\n\n    hideAndFadeIn () {\n        this.setOpacity(0)\n        //this.setTransition(\"all 0.5s\")\n        this.addTimeout(() => {\n            this.setOpacity(1)\n        }, 0)\n    }\n\n    fadeInToDisplayInlineBlock () {\n        this.transitions().at(\"opacity\").updateDuration(\"0.3s\")\n        this.setDisplay(\"inline-block\")\n        this.setOpacity(0)\n        this.addTimeout(() => {\n            this.setOpacity(1)\n        }, 0)\n        return this\n    }\n\n    fadeOutToDisplayNone () {\n        this.transitions().at(\"opacity\").updateDuration(\"0.3s\")\n        this.setOpacity(0)\n        this.addTimeout(() => {\n            this.setDisplay(\"none\")\n        }, 200)\n        return this\n    }\n\n    // --- fade + height animations ----\n\n    fadeInHeightToDisplayBlock () {\n        this.setDisplay(\"block\")\n        this.setOpacity(1)\n        this.setMinHeight(\"100%\")\n        this.setMaxHeight(\"100%\")\n        return this\n/*\n        this.setMinHeight(\"100%\")\n        this.setMaxHeight(\"100%\")\n        const targetHeight = this.calcHeight()\n\n        this.setOverflow(\"hidden\")\n        this.transitions().at(\"opacity\").updateDuration(\"0.3s\")\n        this.transitions().at(\"min-height\").updateDuration(\"0.2s\")\n        this.transitions().at(\"max-height\").updateDuration(\"0.2s\")\n\n        this.setDisplay(\"block\")\n        this.setOpacity(0)\n        this.setMinAndMaxHeight(0)\n\n        this.addTimeout(() => {\n            this.setOpacity(1)\n            this.setMinAndMaxHeight(targetHeight)\n        }, 0)\n        */\n        return this\n    }\n\n    fadeOutHeightToDisplayNone () {\n        this.setOverflow(\"hidden\")\n        this.transitions().at(\"opacity\").updateDuration(\"0.2s\")\n        this.transitions().at(\"min-height\").updateDuration(\"0.3s\")\n        this.transitions().at(\"max-height\").updateDuration(\"0.3s\")\n\n        this.addTimeout(() => {\n            this.setOpacity(0)\n            this.setMinAndMaxHeight(0)\n        }, 1)\n\n        /*\n        this.addTimeout(() => {\n            this.setDisplay(\"none\")\n        }, 300)\n        */\n        return this\n    }\n\n\n}.initThisCategory());\n",
  "r8o3Yp6p+ffqppilbAKxRb7atERjdIdYTYQAQdl6p9k=": "\"use strict\";\n\n/*\n    DomView_browserDragAndDrop\n\n    For subclasses to extend. Ancestors of this class are organizational parts of DomView.\n\n*/\n\n(class DomView_browserDragAndDrop extends DomView {\n    \n    // -- browser register for drop ---\n\n    isRegisteredForBrowserDrop () {\n        return this.dropListener().isListening()\n    }\n\n    setIsRegisteredForBrowserDrop (aBool) {\n        this.dropListener().setIsListening(aBool)\n        return this\n    }\n\n    acceptsDrop () {\n        return true // make ivar?\n    }\n\n    // ---------------------\n\n    onBrowserDragEnter (event) {\n        // triggered on drop target\n        //console.log(\"onBrowserDragEnter acceptsDrop: \", this.acceptsDrop());\n        event.preventDefault() // needed?\n\n        if (this.acceptsDrop(event)) {\n            this.onBrowserDragOverAccept(event)\n            return true\n        }\n\n        return false;\n    }\n\n    onBrowserDragOver (event) {\n        // triggered on drop target\n        //console.log(\"onBrowserDragOver acceptsDrop: \", this.acceptsDrop(event), \" event:\", event);\n\n        event.preventDefault()\n\n        if (this.acceptsDrop(event)) {\n            event.dataTransfer.dropEffect = \"copy\";\n            event.dataTransfer.effectAllowed = \"copy\";\n            this.onBrowserDragOverAccept(event)\n            return true\n        }\n\n        return false;\n    }\n\n    onBrowserDragOverAccept (event) {\n        //console.log(\"onBrowserDragOverAccept \");\n        this.dragHighlight()\n    }\n\n    onBrowserDragLeave (event) {\n        // triggered on drop target\n        //console.log(\"onBrowserDragLeave \", this.acceptsDrop(event));\n        this.dragUnhighlight()\n        return this.acceptsDrop(event);\n    }\n\n    dragHighlight () {\n\n    }\n\n    dragUnhighlight () {\n\n    }\n\n    // --- browser drop ---\n\n    onBrowserDrop (event) {\n        if (this.acceptsDrop(event)) {\n            //const file = event.dataTransfer.files[0];\n            //console.log('onDrop ' + file.path);\n            this.onBrowserDataTransfer(event.dataTransfer)\n            this.dragUnhighlight()\n            event.preventDefault();\n            event.stopPropagation()\n            return true;\n        }\n        event.preventDefault();\n        return false\n    }\n\n    dropMethodForMimeType (mimeType) {\n        let s = mimeType.replaceAll(\"/\", \" \")\n        s = s.replaceAll(\"-\", \" \")\n        s = s.capitalizeWords()\n        s = s.replaceAll(\" \", \"\")\n        return \"onBrowserDrop\" + s\n    }\n\n    onBrowserDataTransfer (dataTransfer) {\n        // TODO: we need a way to avoid handling the same item twice...\n\n        if (dataTransfer.files.length) {\n            for (let i = 0; i < dataTransfer.files.length; i++) {\n                const file = dataTransfer.files[i]\n                this.onBrowserDropFile(file)\n            }\n        } else if (dataTransfer.items) {\n            let data = dataTransfer.items\n\n            let dataTransferItems = []\n            for (let i = 0; i < data.length; i++) {\n                dataTransferItems.push(data[i])\n            }\n\n            dataTransferItems = dataTransferItems.reversed()\n\n            for (let i = 0; i < dataTransferItems.length; i++) {\n                const dataTransferItem = dataTransferItems[i]\n                const mimeType = dataTransferItem.type\n\n                // Example MIME types: \n                // text/plain, text/html, text/uri-list\n\n                if (mimeType) {\n                    dataTransferItem.getAsString((s) => {\n                        const chunk = BMDataUrl.clone()\n                        chunk.setMimeType(mimeType)\n                        chunk.setDecodedData(s)\n                        console.log(\"mimeType:\", mimeType)\n                        console.log(\"    data:\", s)\n                        this.onBrowserDropChunk(chunk)\n                    })\n                }\n                break; // only send the first MIME type for now\n            }\n        }\n    }\n\n    onBrowserDropFile (file) {\n        const mimeType = file.type\n        const reader = new FileReader();\n        reader.onload = (event) => {\n            const data = event.target.result\n            this.onBrowserDropMimeTypeAndRawData(mimeType, data)\n        }\n        reader.readAsDataURL(file);\n    }\n\n    onBrowserDropMimeTypeAndRawData (mimeType, dataUrl) {\n        const dd = BMDataUrl.clone().setDataUrlString(dataUrl)\n        this.onBrowserDropChunk(dd)\n    }\n\n    onBrowserDropChunk (dataChunk) {\n        // if the view has a method for the mime type of the file\n        // e.g. onBrowserDropImageJpeg\n        // then we call it. If the view wants to handle all types,\n        // it can override this method.\n\n        const methodName = this.dropMethodForMimeType(dataChunk.mimeType())\n        const method = this[methodName]\n        console.log(\"onBrowserDropFile => \", methodName)\n\n        if (method) {\n            method.call(this, dataChunk)\n        }\n    }\n\n    // --- browser dragging ---\n\n    setDraggable (aBool) {\n        assert(Type.isBoolean(aBool))\n        this.element().setAttribute(\"draggable\", aBool)\n        return this\n    }\n\n    draggable () {\n        return this.element().getAttribute(\"draggable\")\n    }\n\n    isRegisteredForBrowserDrag () {\n        return this.browserDragListener().isListening()\n    }\n\n    setIsRegisteredForBrowserDrag (aBool) {\n        this.browserDragListener().setIsListening(aBool)\n        this.setDraggable(aBool)\n        return this\n    }\n\n    onBrowserDragStart (event) {\n        return false;\n    }\n\n    onBrowserDragEnd (event) {\n        // triggered in element being dragged\n        this.dragUnhighlight();\n        //console.log(\"onDragEnd\");\n    }\n\n}.initThisCategory());\n",
  "/qz4S55tVOHzFAvRDcGcRxkfXVu9EfmJrIjYfsbP2ck=": "\"use strict\";\n\n/*\n    FlexDomView\n\n\n*/\n\n(class FlexDomView extends DomView {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"flex\")\n        return this\n    }\n\n    makeFlexAndCenterContent () {\n        this.setDisplay(\"flex\")\n        this.setAlignItems(\"center\")\n        this.setJustifyContent(\"center\")\n        return this\n    }\n\n    canSplit () {\n        return this.subviews().length === 0\n    }\n\n    addSubviewCount (count) {\n        for (let i = 0; i < count; i++) {\n            this.newFlexSubview()     \n        }\n        return this\n    }\n\n    newFlexSubview () {\n        const v = FlexDomView.clone()\n        v.setDisplay(\"flex\")\n        v.setMinHeight(\"0em\")\n        v.setMinWidth(\"0em\")\n        const order = this.subviews().length\n        v.setOrder(order)\n        this.addSubview(v) \n        return v\n    }\n\n    makeSubviewsOrdered () {\n        this.subviews().forEachKV((i, sv) => {\n            sv.setOrder(i)\n        })\n    }\n\n    makeSubviewsReverseOrdered () {\n        const count = this.subviews().length\n        this.subviews().forEachKV((i, sv) => {\n            sv.setOrder(count - 1 - i)\n        })\n    }\n\n    /*\n    flexSplitIntoTilesNamed (nameList) {\n        this.flexSplitIntoTiles(nameList.length)\n        for (let i = 0; i < nameList.length; i++) {\n            const name = nameList.at(i)\n            const subview = this.subviews().at(i)\n            this.newSlot(name, subview, true)\n        }\n        return this\n    }\n    */\n\n    flexSplitIntoTiles (count) {\n        assert(this.canSplit()) // temporary\n        this.setDisplay(\"flex\")\n        this.setFlexDirection(\"column\")\n        this.addSubviewCount(count)\n        this.debugBorders()\n        return this\n    }\n\n    flexSplitIntoColumns (count) {\n        assert(this.canSplit()) // temporary\n        this.setDisplay(\"flex\")\n        this.setFlexDirection(\"row\")\n        this.addSubviewCount(count)\n        this.debugBorders()\n        return this\n    }\n\n    flexCenterContent () {\n        this.setJustifyContent(\"center\")\n        this.setAlignItems(\"center\")\n        return this\n    }\n\n    makeStandardFlexView () {\n        this.setDisplay(\"flex\")\n        this.setPosition(\"relative\")\n        this.flexCenterContent()\n        this.setOverflow(\"hidden\")\n        return this\n    }\n\n    debugBorders () {\n        //this.subviews().forEach(sv => sv.setBorder(\"1px solid rgba(255, 255, 255, 0.2)\"))\n    }\n\n}.initThisClass());\n",
  "pNW0QLG8zFqT2LLXpL1JVWZwcK1U+9WOjWMaE9qQoMQ=": "\"use strict\";\n\n/*\n    StyledDomView\n\n    (a step towards eliminating the remaining css files)\n\n    A base view to handle styles in a uniform way. \n    Holds an instance of BMViewStyles which holds a set of BMViewStyle instances, one for each style.\n\n    Overview:\n\n        StyledDomView\n          styles -> BMViewStyles\n                        selected -> BMViewStyle\n                        unselected -> BMViewStyle\n                                        color\n                                        backgroundColor\n                                        opacity\n                                        borderLeft\n                                        borderRight\n\n                       \n    \n\n    Supported styles:\n\n    - unselected\n    - selected\n    - active \n    - disabled\n\n*/\n\n\n(class StyledDomView extends FlexDomView {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"themeClassName\", null)\n        this.newSlot(\"isSelected\", false).setOwnsSetter(true).setDoesHookSetter(true)\n        this.newSlot(\"isActive\", false).setOwnsSetter(true).setDoesHookSetter(true)\n        this.newSlot(\"isDisabled\", false).setOwnsSetter(true).setDoesHookSetter(true)\n        this.newSlot(\"lockedStyleAttributeSet\", null)\n    }\n\n    init () {\n        super.init()\n        this.setLockedStyleAttributeSet(new Set())\n        Broadcaster.shared().addListenerForName(this, \"onActivateView\") // NOTE: do we want *every* view to do this \n        return this\n    }\n\n    syncStateFrom (aView) {\n        this.setIsSelected(aView.isSelected())\n        this.setIsActive(aView.isActive())\n        return this\n    }\n\n    // theme path\n\n    themeClassNamePath () {\n        // search up the view ancestors and compose a path\n        if (this.themeClassName()) {\n            const path = [this.themeClassName()]\n            this.forEachAncestorView(view => {\n                if (view.themeClassName) {\n                    const k = view.themeClassName()\n                    if (k) {\n                        path.push(k)\n                    }\n                }\n            })\n            path.reverse()\n            return path\n        }\n        return null\n    }\n\n    // styles\n\n    /*\n    recursivelyApplyStyles () {\n        this.applyStyles()\n        this.allSubviewsRecursively().forEach(view => {\n            if (view.applyStyles) {\n                view.applyStyles()\n            }\n        })\n        return this\n    }\n    */\n\t\n    applyStyles () {\n        // we default to using the current theme, but \n        // we need to give view a chance to override style\n        // also, NodeView should override this method to give node a chance to override style\n\n        const state = this.currentThemeState()\n        if (state) {\n            state.applyToView(this)\n        }\n        return this\n    }\n\n    // --- activate ---\n\n    didUpdateSlotIsActive (oldValue, newValue) {\n        // sent by hooked setter\n        this.applyStyles()\n        this.updateSubviews()\n        return this\n    }\n\n    activate () {\n        this.select()\n        this.setIsActive(true)\n        Broadcaster.shared().broadcastNameAndArgument(\"onActivateView\", this)\n    }\n\n    onActivateView (aView) {\n        if (aView !== this & this.isActive()) {\n            this.setIsActive(false)\n            this.applyStyles()\n        }\n    }\n\n    // --- select ---\n\n    didUpdateSlotIsSelected (oldValue, newValue) {\n        // sent by hooked setter\n        this.applyStyles()\n        this.updateSubviews()\n        return this\n    }\n\n    toggleSelection () {\n        if (this.isSelected()) {\n            this.unselect()\n        } else {\n            this.select()\n        }\n        return this\n    }\n\n    select () {\n        this.setIsSelected(true)\n        return this\n    }\n\n    unselect () {\n        if (this.isSelected()) { // for debugging \n            this.setIsSelected(false)\n        }\n        return this\n    }\n\n    // -----------------------------------------\n\n    themePathArray () {\n        // using this is problematic as we may want to make the path \n        // dependent of complex things e.g. if the themeClassName isn't\n        // found, we will default to DefaultThemeClass - or we may want\n        // to continue the search for a themeClass by walking up the View's\n        // class hierarchy names\n\n        const path = []\n\n        const themeClassName = this.themeClassName()\n        if (themeClassName) {\n            path.push(themeClassName)\n        } else {\n            path.push(\"DefaultThemeClass\")\n        }\n\n        const stateName = this.currentThemeStateName() \n        path.push(stateName)\n\n        return path\n    }\n\n    currentThemeClass () {\n        const theme = BMThemeResources.shared().activeTheme()\n        if (!theme) {\n            return null\n        }\n        const className = this.themeClassName() ? this.themeClassName() : \"DefaultThemeClass\"\n        const themeClass = theme.firstSubnodeWithTitle(className)\n        return themeClass\n    }\n\n    currentThemeStateName () {\n        let stateName = \"unselected\"\n\n        if (this.isDisabled()) {\n            stateName = \"disabled\" // should this mix with selected?\n        }\n\n        if (this.isSelected()) {\n            stateName = \"selected\"\n        }\n\n        if (this.isActive()) {\n            stateName = \"active\"\n        }\n\n        return stateName\n    }\n\n    currentThemeState () {\n        const tc = this.currentThemeClass() \n        let state = null\n        if (tc) {\n            let stateName = this.currentThemeStateName()\n            const state = tc.firstSubnodeWithTitle(stateName)\n            assert(state)\n            return state\n        }\n        return null\n    }\n\n    themePathString () {\n        return this.themePathArray().join(\" / \")\n    }\n\n    themeValueForAttribute (attributeName) {\n        const stateNode = this.currentThemeState()\n        if (stateNode) {\n            const attribtueNode = stateNode.firstSubnodeWithTitle(attributeName)\n            if (attribtueNode) {\n                const value = attribtueNode.value()\n                if (!value) {\n                    console.log(\"no color found for \", this.themePathString() + \" / \" + attributeName)\n                    return null\n                }\n                //console.log(\"theme: \" + fullPathString + \" = \" + value)\n                return value\n            }\n        }\n\n        //console.log(\"no attribute node found for \", this.themePathString() + \" / \" + attributeName)\n        return null\n    }\n\n    // -------------------------------------\n\n    currentColor () {\n        const v = this.themeValueForAttribute(\"color\")\n        if (v) {\n            return v\n        }\n        //console.log(this.typeId() + \".themeValueForAttribute('color') = \", v)\n        //debugger;\n        return \"inherit\"\n        //return \"yellow\"\n    }\n\n    currentBgColor () {\n        const v = this.themeValueForAttribute(\"backgroundColor\")\n        if (v) {\n            return v\n        }\n        return \"inherit\"\n        //return \"orange\"\n    }\n\n    resyncAllViews () {\n        this.syncStylesToSubviews()\n        this.applyStyles()\n        super.resyncAllViews()\n        return this\n    }\n\n    syncStylesToSubviews () {\n        return this\n    }\n\t\n}.initThisClass());\n",
  "OPz/LENEAiTsUcf15lUmocUduIcu9m7OSBRDtg/kHoc=": "\"use strict\";\n\n/*\n\n    BooleanView\n\n    The checkbox is composed of 2 overlapping inner views,\n    one for the inner check itself, and one for the outer border around.\n    The check components are rendered with scalable SVG and \n    are synced to match the color of the parent view's text color by\n    getting the computed color and applying it to the fill or stroke of the\n    svg views.\n\n    TODO: support disabled/uneditable color style?\n\n*/\n\n(class BooleanView extends StyledDomView {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"doesClearOnReturn\", false)  // needed?\n        this.newSlot(\"doesHoldFocusOnReturn\", false)  // needed?\n        this.newSlot(\"value\", false)\n        this.newSlot(\"isEditable\", false)\n        this.newSlot(\"innerCheckView\", null)\n        this.newSlot(\"outerCheckView\", null)\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"flex\")\n        this.setPosition(\"relative\")\n        this.setFilter(\"blur(0.2px)\")\n        this.flexCenterContent()\n        //this.setBorder(\"1px dashed red\")\n       \n        this.turnOffUserSelect()\n        this.setSpellCheck(false)\n        this.setContentEditable(false)\n\n        const size = this.checkboxSize()\n        this.setMinAndMaxWidthAndHeight(size)\n        //this.setMinAndMaxWidthAndHeight(\"fit-content\")\n\n        this.setOverflow(\"hidden\")\n\n        /*\n        const iconSetView = DomView.clone().setElementClassName(\"IconSetView\")\n        //this.setBorder(\"1px dashed white\")\n        iconSetView.setDisplay(\"flex\")\n        iconSetView.setPosition(\"relative\")\n        //iconSetView.setWidth(\"fit-content\").setHeight(\"fit-content\")\n        iconSetView.setMinAndMaxWidthAndHeight(size)\n        this.addSubview(iconSetView)\n        */\n\n        {\n            const inner = SvgIconView.clone().setIconName(\"inner-checkbox\")\n            //inner.setBorder(\"1px dashed blue\")\n            inner.setDisplay(\"flex\")\n            inner.setPosition(\"absolute\")\n            inner.setTopPx(0)\n            inner.setLeftPx(0)\n            inner.setMinAndMaxWidthAndHeight(size)\n            inner.setStrokeColor(\"transparent\")\n            this.setInnerCheckView(inner)\n            this.addSubview(inner)\n        }\n\n        {\n            const outer = SvgIconView.clone().setIconName(\"outer-checkbox\")\n            //outer.setBorder(\"1px dashed green\")\n            outer.setDisplay(\"flex\")\n            outer.setPosition(\"absolute\")\n            outer.setTopPx(0)\n            outer.setLeftPx(0)\n            outer.setMinAndMaxWidthAndHeight(size)\n            outer.setFillColor(\"transparent\")\n            this.setOuterCheckView(outer)\n            this.addSubview(outer)\n        }\n        \n        this.setIsEditable(this.isEditable())\n\n        return this\n    }\n\n    checkboxSize () {\n        return \"1em\"\n    }\n\n    // editable\n    \n    setIsEditable (aBool) {        \n        this._isEditable = aBool\n        \n        if (this._isEditable) {\n            const g = this.addDefaultTapGesture()\n            g.setShouldRequestActivation(false) // so the tile doesn't block the initial tap\n        } else {\n            this.removeDefaultTapGesture()\n        }\n        \n        this.updateAppearance()\n        \n        return this\n    }\n    \n    toggle () {\n        this.setValue(!this.value())\n        this.didEdit()\n        return this\n    }\n    \n    activate () {\n        this.toggle()\n        return this\n    }\n    \n    // ------------------\n    \n    setValue (v) {\n        if (Type.isNullOrUndefined(v)) {\n            v = false;\n        }\n        \n\t    this._value = v\n\n        this.updateAppearance()\n        return this\n    }\n\t\n    value () {\n\t    return this._value\n    }\n\t\n    isChecked () {\n\t    return this.value()\n    }\n    \n    setBackgroundColor (s) {\n        // needed?\n        return this\n    }\n\t\n    // svg icon\n\n    updateAppearance () {\n        // sent by superview when it changes or syncs to a node\n        // so we can update our appearance to match changes to the parent view's style\n\n        //const color = this.getComputedCssProperty(\"color\") // this can cause a reflow, so avoid it\n        const color = \"white\"\n\n        this.outerCheckView().setStrokeColor(color)\n        this.innerCheckView().setFillColor(this.value() ? color : \"transparent\")\n        \n        return this\n    }\n\n    onTapComplete (aGesture) {\n        super.sendActionToTarget()\n        this.toggle()\n        return false\n    }\n    \n}.initThisClass());\n",
  "OwqOKy9ZxGMCduxtXPlYG68E8JhsGkYjtlY8YyxCVVQ=": "\"use strict\";\n\n/*\n\n    ButtonView\n\n    A simple push button view with a TextView label.\n\n\n    .BMActionNodeView {\n        min-height: 28px;\n\n        padding-top: 8px;\n        padding-bottom: 8px;\n\n        background-color: #888;\n        color: #ccc;\n\n        border-style: none;\n        border-radius: 5px;\n        border-width: 1px;\n        border-color:#888;\n        \n        text-align: center;\n        vertical-align: center;\n\n    }\n\n    .BMActionNodeView:hover {\n        color: white;\n        background-color: #888;\n    }\n\n*/\n\n(class ButtonView extends FlexDomView {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"titleView\", null)\n        this.newSlot(\"isEnabled\", true)\n        this.newSlot(\"iconView\", null)\n        this.newSlot(\"info\", null)\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"flex\")\n        this.flexCenterContent()\n        this.setHeight(\"fit-content\")\n        this.setWidth(\"100%\")\n        this.setMinHeight(\"1em\")\n\n        this.setPaddingTop(\"0.75em\")\n        this.setPaddingBottom(\"0.85em\")\n\n        this.setPaddingLeft(\"1em\")\n        this.setPaddingRight(\"1em\")\n\n        this.turnOffUserSelect()\n        this.setBorderRadiusPx(1)\n        \n        {\n            const tv = TextField.clone()\n            this.setTitleView(tv)\n            this.addSubview(tv)\n            tv.fillParentView()\n            tv.setPaddingTop(\"0.1em\").setPaddingBottom(\"0.1em\")\n            tv.setPaddingLeft(\"1em\").setPaddingRight(\"1em\")\n            tv.flexCenterContent()\n            tv.setTextAlign(\"center\")\n            tv.setMinHeight(\"1em\")\n            tv.setWhiteSpace(\"nowrap\")\n            tv.setTextOverflow(\"ellipsis\")\n\n            \n        }\n\n        this.setTitle(\"\")\n\n        const icon = SvgIconView.clone() //.setElementClassName(\"RightActionView\")\n        icon.setMinAndMaxWidth(12)\n        icon.setMinAndMaxHeight(15)\n        icon.setFillColor(\"white\")\n        icon.setStrokeColor(\"white\")\n        icon.setOpacity(1)\n        icon.hideDisplay()\n        this.setIconView(this.addSubview(icon))\n\n        this.addDefaultTapGesture()\n\n        return this\n    }\n\n    setIconName (aName) {\n        this.iconView().setIconName(aName)\n        return this\n    }\n\n    setTitle (s) {\n        if (s === \"\" || Type.isNullOrUndefined(s)) { \n            s = \" \"; //\"&nbsp;\" // to avoid weird html layout issues\n        }\n\n        this.titleView().setValue(s)\n        //this.titleView().setDisplayIsHidden(!s)\n        return this\n    }\n\n    title () {\n        return this.titleView().value()\n    }\n\n    setHasOutline (aBool) {\n        if (aBool) {\n            this.setBoxShadow(\"0px 0px 1px 1px rgba(255, 255, 255, 0.2)\")\n        } else {\n            this.setBoxShadow(\"none\")\n        }\n        return this\n    }\n\n    setTitleIsVisible (aBool) {\n        this.titleView().setDisplayIsHidden(!aBool)\n        return this\n    }\n\n    setIsEditable (aBool) {\n        this.titleView().setIsEditable(aBool)\n        return this\n    }\n\n    isEditable () {\n        return this.titleView().isEditable()\n    }\n\n    sendActionToTarget () {\n        if (!this.isEditable()) {\n            super.sendActionToTarget()\n        }\n        return this\n    }\n\n    onTapComplete (aGesture) {\n        //this.debugLog(\".onTapComplete()\")\n        this.sendActionToTarget()\n        return false\n    }\n    \n}.initThisClass());\n",
  "vV11YRpn+4e+hsptHxDaXW8PgFxnr7OlT1y4aQLRKYM=": "\"use strict\";\n\n\n/* \n\n    CloseButton\n\n    TODO: make subclass of ButtonView?\n\n*/\n\n(class CloseButton extends FlexDomView {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"isEnabled\", true)\n        this.newSlot(\"iconView\", null)\n    }\n\n    init () {\n        super.init()\n        this.makeFlexAndCenterContent()\n        this.setPadding(\"0em\")\n        this.turnOffUserSelect()\n        //this.setDisplay(\"table\") // to center svg\n\n        const iv = SvgIconView.clone().setIconName(\"close\")\n        iv.setColor(\"white\")\n\n        iv.setMinAndMaxWidth(10)\n        iv.setMinAndMaxHeight(10)\n                \n        //iv.setWidth(\"fit-content\")\n        //iv.setHeight(\"fit-content\")\n\n        iv.makeFlexAndCenterContent()\n        //iv.setTopPx(0)\n        //iv.setLeftPx(0)\n        //iv.setMarginBottom(\"1px\") // TODO: fix the SVG for this icon so this isn't needed?\n\n\n        this.setIconView(iv)\n        this.addSubview(iv)\n\n        this.setAction(\"close\")\n        this.addDefaultTapGesture()\n        return this\n    }\n\n    setIconName (aString) {\n        this.iconView().setIconName(aString)\n        return this\n    }\n\n    // --- editable ---\n    \n    setIsEnabled (aBool) {\n        if (this._isEnabled !== aBool) {\n            this._isEnabled = aBool\n            this.syncEnabled()\n        }\n\n        return this\n    }\n\n    syncEnabled () {\n        //this.setDisplayIsHidden(!this.isEnabled())\n        return this\n    }\n\n    onTapComplete (aGesture) {\n        //this.debugLog(\".onTapComplete()\")\n        if (!this.isEditable()) {\n            this.sendActionToTarget()\n        }\n        return false\n    }\n    \n}.initThisClass());\n",
  "CBlbNeAmKDdF17VsQ5hvTg6mEeWMyTWQIGSZxLZ9KFI=": "\"use strict\";\n\n/*\n\n    DocumentBody\n\n*/\n\n(class DocumentBody extends DomView {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n\n        // setup shared devices for later use\n        Devices.shared().setupIfNeeded()\n        \n        //this.documentListener().setIsListening(true)\n        this.setIsRegisteredForBrowserDrop(true) // to avoid dropping on window\n\n        return this\n    }\n\n    acceptsDrop (event) { // to avoid dropping on window\n        event.preventDefault();\n        return false\n    }\n    \n    setupElement () {\n        //document.body.setDomView(this)\n        this._element = document.body\n        this._element.setDomView(this)\n        // get this from element override\n        return this\n    }\n    \n    element () {\n        return document.body\n    }\n    \n    zoomAdjustedWidth () {\n        return WebBrowserWindow.shared().width() * this.zoomRatio()\n    }\n    \n    zoomAdjustedHeight () {\n        return WebBrowserWindow.shared().width() * this.zoomRatio()\n    }\n    \n    zoomAdjustedSize () { // TODO: move to Point\n        return { width: this.zoomAdjustedWidth(), height: this.zoomAdjustedHeight() }\n    }\n\n    allDomElements () {\n        const domElements = this.element().getElementsByTagName(\"*\");\n        return domElements\n    }\n\n    viewsUnderPoint (aPoint) {\n        const elements = document.elementsFromPoint(aPoint.x(), aPoint.y())\n        const views = elements.map(e => this.firstViewForElement(e)).nullsRemoved()\n        return views\n    }\n\n    firstViewForElement (e) {\n        // search up the dom element parents to find one\n        // associated with a DomView instance \n\n        while (e) {\n            const view = e.domView()\n            if (view) {\n                return view\n            }\n            e = e.parentElement\n        }\n\n        return null\n    }\n\n    /*\n    onWindowResize (event) {\n        super.onWindowResize(event)\n    }\n    */\n   \n}.initThisClass());\n\n",
  "rLXDzxa5cqO8877OeQ+l1f1FarBhtjYWzvPqaK33rw4=": "\"use strict\";\n\n/* \n\n    DragBarView\n\n*/\n\n\n(class DragBarView extends DomView {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"isEnabled\", true)\n        this.newSlot(\"isHighlighted\", false)\n        this.newSlot(\"isDragging\", false)\n        this.newSlot(\"normalColor\", \"#333\")\n        this.newSlot(\"highlightColor\", \"#555\")\n        this.newSlot(\"dragColor\", \"#999\")\n        this.newSlot(\"delegate\", null)\n        this.newSlot(\"thickness\", 2)\n        this.newSlot(\"isVerticalDrag\", true)\n    }\n\n    init () {\n        super.init()\n\n        this.turnOffUserSelect()\n\n        this.setElementClassName(\"DragBarView\")\n        this.setDisplay(\"inline-block\")\n\n        this.setIsRegisteredForMouse(true)\n        this.syncHighlighted()\n        this.syncEnabled()\n\n        this._mouseMoveTrackerFunc = (event) => {\n            this.mouseMoveTracker(event)\n            return true\n        }\n\n        this._mouseUpTrackerFunc = (event) => {\n            this.mouseUpTracker(event)\n            return true\n        }\n\n        this.setBackgroundColor(this.normalColor())\n        return this\n    }\n\n    hoverCursorType () {\n        if (this.isVerticalDrag()) {\n            return \"row-resize\"\n        }\n\n        return \"col-resize\"\n    }\n\n    setIsVertical (aBool) {\n        if (this._isVertical !== aBool) {\n            this._isVertical = aBool\n            //console.log(\"this.hoverCursorType() = \", this.hoverCursorType())\n            this.setCursor(this.hoverCursorType())\n        }\n        return this\n    }\n\n    // --- editable ---\n    \n    setIsEnabled (aBool) {\n        if (this._isEnabled !== aBool) {\n            this._isEnabled = aBool\n            this.syncEnabled()\n        }\n\n        return this\n    }\n\n    syncEnabled () {\n        this.setDisplayIsHidden(!this.isEnabled())\n        return this\n    }\n\n    // --- highlighted ---\n    \n    setIsHighlighted (aBool) {\n        if (this._isHighlighted !== aBool) {\n            this._isHighlighted = aBool\n            this.syncHighlighted()\n        }\n\n        return this\n    }\n\n    syncHighlighted () {\n        if (this.isDragging()) {\n            return this\n        }\n\n        if (this.isHighlighted()) {\n            this.setBackgroundColor(this.highlightColor())\n        } else {\n            this.setBackgroundColor(this.normalColor())\n        }\n        this.syncCursor()\n\n        return this\n    }\n\n    syncCursor () {\n        if (this.isHighlighted()) {\n            this.setCursor(this.hoverCursorType())\n        } else {\n            this.setCursor(null)\n        }\n        return this\n    }\n\n    // --- mouse ---\n\n    mouseMoveTracker (event) {\n        //console.log(\"mouse pos: \", event.clientX, \" x \", event.clientY)\n        if (this.delegate()) {\n            this.delegate().didDragDivider(Math.floor(event.clientX), Math.floor(event.clientY))\n        }\n    }\n\n    mouseUpTracker (event) {\n        //console.log(\"mouse pos: \", event.clientX, \" x \", event.clientY)\n        this.onMouseUp(event)\n    }\n\n    setIsDragging (b) {\n        this._isDragging = b;\n        if (b) {\n            this.setBackgroundColor(this.dragColor())\n            this.parentView().setBorder(\"1px dashed white\")\n        } else {\n            this.setBackgroundColor(this.normalColor())\n            this.parentView().setBorder(\"0px dashed white\")\n        }\n        return this\n    }\n\n    onMouseDown (event) {\n        //this.debugLog(\" onMouseDown\")\n        this.setIsDragging(true)\n\n        this.removeParentTracking()\n        return false\n    }\n\n    addParentTracking () {\n        const r = this.documentBodyView()\n        r.element().removeEventListener(\"mousemove\", this._mouseMoveTrackerFunc, false);\n        r.element().removeEventListener(\"mouseup\", this._mouseUpTrackerFunc, false);\n        return this\n    }\n\n    removeParentTracking () {\n        const r = this.documentBodyView()\n        r.element().addEventListener(\"mousemove\", this._mouseMoveTrackerFunc, false);\n        r.element().addEventListener(\"mouseup\", this._mouseUpTrackerFunc, false);\n        return this\n    }\n\n    onMouseMove (event) {\n        return false\n    }\n\n    onMouseOver (event) {\n        //this.debugLog(\" onMouseOver\")\n        this.setIsHighlighted(true)\n        return false\n    }\n\n    onMouseLeave (event) {\n        //this.debugLog(\" onMouseLeave\")\n        this.setIsHighlighted(false)\n        return false\n    }\n\n    onMouseUp (event) {\n        this.setIsDragging(false)\n        this.addParentTracking()\n        return false\n    }\n    \n}.initThisClass());\n",
  "rYpxyOmje/80nwR6Gf7KgsM6i3mn000ukFeMd1ycCsU=": "\"use strict\";\n\n/*\n\n    DragView\n    \n    A view to globally drag and drop another view or data.\n\n    Dragging Protocol\n\n        Messages sent to the Item \n            \n            - onDragItemBegin\n            - onDragItemCancelled\n            - onDragItemDropped   \n\n        Messages sent to Source \n            \n            - onDragSourceBegin\n            - onDragSourceHover\n            - onDragSourceCancelled // dropped on a view that doesn't accept it\n            - onDragSourceDropped\n            - onDragSourceEnd\n\n            // using these messages avoids a bunch of conditions in the receiver \n            // the source is repsonsible for completing the drag operation\n            // the DragView will set it's destination slot before calling these\n            \n            - onDragSourceMoveToDestination \n            - onDragSourceCopyToDestination\n            - onDragSourceLinkToDestination\n            \n            - onDragSourceMoveToSelf\n            - onDragSourceCopyToSelf\n            - onDragSourceLinkToSelf\n        \n            \n        Messages sent to Destination or Hover target \n            \n            - acceptsDropHover\n            - onDragDestinationEnter // not sent if destination === source\n            - onDragDestinationHover\n            - onDragDestinationExit\n            - acceptsDropHoverComplete\n            - onDragDestinationDropped\n            - onDragDestinationEnd\n\n        Messages sent by Destination to item\n\n            - onDragRequestRemove() // return true if approved\n\n        Notifications sent\n\n            - onDragViewOpen\n            - onDragViewClose\n\n    Example use (from within a view to be dragged):\n\n    onLongPressComplete (longPressGesture) {\n        const dv = DragView.clone().setItem(this).setSource(this.column())\n        dv.openWithEvent(longPressGesture.currentEvent()) // TODO: eliminate this step?\n    } \n\n*/\n\n(class DragView extends StyledDomView {\n    \n    initPrototypeSlots () {\n        // the view that will be dragged when operation is complete\n        //this.newSlot(\"item\", null)\n\n        // the set of views that will be dragged\n        this.newSlot(\"items\", [])\n\n        // a place for the source to store any extra info about the drag operation,\n        // such as the indexes of the items\n        this.newSlot(\"info\", null)\n\n        // the view which is the owner of the view being dragged that implements the source protocol\n        this.newSlot(\"source\", null)\n\n        // the view on which the item is dropped\n        this.newSlot(\"destination\", null)\n\n        this.newSlot(\"validOperations\", new Set([\"move\", \"copy\", \"link\", \"delete\"]))\n\n        // a list of views that self is currently hovering over\n        this.newSlot(\"hoverViews\", null)\n\n        // start position in screen coordinates \n        this.newSlot(\"dragStartPos\", null)\n\n        // the drag operation type: move, copy, link, delete\n        this.newSlot(\"dragOperation\", \"move\").setDoesHookSetter(true)\n\n        this.newSlot(\"slideBackPeriod\", 0.2) // seconds\n        this.newSlot(\"isClosed\", false) \n    }\n\n    didUpdateSlotDragOperation () {\n        assert(this.validOperations().has(this.dragOperation()))\n    }\n\n    init () {\n        super.init()\n        this.setHoverViews([])\n\n        this.setDisplay(\"flex\")\n        this.setPosition(\"absolute\")\n        this.turnOffUserSelect()\n        this.setOverflow(\"hidden\")\n        this.setMinWidthPx(10)\n        this.setMinHeightPx(10)\n        this.setWidth(\"fit-content\")\n        this.setMinHeight(\"fit-content\")\n        this.setOpacity(0.9)\n        this.setInfo({})\n\n        this.setIsDebugging(false)\n        return this\n    }\n\n    // operation type helpers\n\n    isCopyOp () {\n        return this.dragOperation() === \"copy\"\n    }\n\n    isMoveOp () {\n        return this.dragOperation() === \"move\"\n    }\n\n    isLinkOp () {\n        return this.dragOperation() === \"link\"\n    }\n\n    isDeleteOp () {\n        return this.dragOperation() === \"delete\"\n    }\n\n    // ----\n\n    setItem (aView) {\n        this.setItems([aView])\n        return this\n    }\n\n    item () {\n        return this.items().first()\n    }\n\n    // ----\n\n    setupView () {\n        if (this.items().length === 1) {\n            this.setupSingleItemView()\n        } else {\n            this.setupMultiItemView()\n        }\n        this.setZIndex(10)\n        return this\n    }\n\n    setupMultiItemView () {\n        const parentView = this.items().first().parentView()\n\n        // copy parent frame\n        const f = parentView.frameInDocument()\n        this.setFrameInDocument(f)\n        this.setBackgroundColor(\"transparent\")\n\n        // duplicate item subviews\n        this.items().forEach(sv => {\n            const dup = sv.htmlDuplicateView()\n            this.addSubview(dup)\n            assert(dup.hasFixedFrame())\n            //console.log(\"item dup subview frameInDocument: \" + dup.frameInDocument().asString())\n            //console.log(\"item dup subview frameInParentView: \" + dup.frameInParentView().asString())\n        })\n\n        const ff = this.fixedFrameFittingSubviews()\n        const nf = parentView.convertFrameToDocument(ff)\n        this.setFrameInDocument(nf)\n        //this.setFrameInDocument(this.fixedFrameFittingSubviewsInDocument())\n        //this.setBorder(\"1px dashed yellow\")\n\n        // make subviews inline-block\n        this.subviews().forEach(sv => {\n            sv.setDisplay(\"inline-block\")\n            sv.setPosition(\"relative\")\n            sv.setTop(null)\n            sv.setLeft(null)\n            sv.setBorder(null)\n            sv.setFloat(\"left\")\n            /*\n            sv.decrementFixedWidth()\n            sv.decrementFixedHeight()\n            sv.decrementFixedWidth()\n            sv.decrementFixedHeight()\n            sv.setMinAndMaxWidth(150)\n            sv.setBorder(\"1px dashed blue\")\n            */\n            //sv.setMinAndMaxHeight(30)\n        })\n        \n        this.setDisplay(\"block\")\n        this.setWhiteSpace(\"normal\")\n        this.setOverflow(\"hidden\")\n        this.setWidth(null)\n        this.setHeight(null)\n\n        this.setWidth(\"fit-content\")\n        this.setHeight(\"fit-content\")\n        this.setMinAndMaxWidth(null)\n        this.setMinAndMaxHeight(null)\n        /*\n        let maxWidth = this.items().map(v => v.frameInDocument().width()).maxValue()\n        let minX = this.items().map(v => v.frameInDocument().left()).minValue()\n        let minY = this.items().map(v => v.frameInDocument().top()).minValue()\n        //let maxY = this.items().map(v => v.frameInDocument().bottom()).maxValue()\n\n        //this.setMinAndMaxHeight(maxY - minY)\n        let offset = minY - f.top()\n        this.setTopPx(minY)\n\n        // initial positions\n        let y = 0\n        this.items().map((item) => {\n            const h = item.frameInDocument().height()\n            const v = item.htmlDuplicateView()\n            const vf = item.frameInParentView()\n            v.setPosition(\"absolute\")\n            v.setLeftPx(vf.x())\n            v.setTopPx(vf.y() - offset)\n            v._targetTop = y\n            y += h\n            v.setTransition(\"top 0.2s\")\n            this.addSubview(v)\n        })\n        this.setMinAndMaxHeight(y)\n        this.setOverflow(\"visible\")\n\n        this.addTimeout(() => {\n            this.subviews().forEach(v => v.setTopPx(v._targetTop))\n        }, 1)\n        */\n\n        /*\n        // target positions\n        let y = 0\n        this.items().map((item) => {\n            const h = item.frameInDocument().height()\n            const v = item.htmlDuplicateView()\n            const vf = item.frameInParentView()\n            v.setPosition(\"absolute\")\n            v.setTopPx(y)\n            y += h\n            //this.addSubview(v)\n        })\n        this.setMinAndMaxHeight(y)\n        */\n\n    }\n\n    setupSingleItemView () {\n        const aView = this.item()\n        this.setFrameInDocument(aView.frameInDocument())\n        this.setInnerHtml(aView.innerHtml())\n        //const clonedElement = aView.element().cloneNode(true);\n        this.setOverflow(\"visible\")\n    }\n\n    // --- \n\n    hasPan () {\n        return !Type.isNull(this.defaultPanGesture())\n    }\n\n    openWithEvent (event) {\n        // TODO: this is a hack, find a way to init pan without this\n        // setup the Pan Gesture to already be started\n\n        const pan = this.addDefaultPanGesture()\n        pan.setShouldRemoveOnComplete(true)\n        pan.setMinDistToBegin(0)\n        pan.onDown(event)\n        pan.attemptBegin()\n\n        this.setTransition(\"all 0s, transform 0.1s, box-shadow 0.1s\")\n        this.open()\n        \n        return this\n    }\n\n    acceptsPan () {\n        return true\n    }\n\n    // --------------------------\n\n    open () {        \n        this.setupView()\n        DocumentBody.shared().addSubview(this)\n        this.orderFront()\n        this.onBegin()\n        this.postNoteNamed(\"onDragViewOpen\")\n        return this\n    }\n\n    onBegin () {\n        this.sendProtocolMessage(this.source(), \"onDragSourceBegin\")\n    }\n    \n    // --- panning ---\n\n    onPanBegin (aGesture) {\n        this.debugLog(\"onPanBegin\")\n        this.setDragStartPos(this.item().positionInDocument())\n\n        // animate the start of the drag\n\n        this.addTimeout(() => {\n            this.addPanStyle()\n        })\n\n        this.onPanMove(aGesture)\n    }\n\n    updatePosition () {\n        const newPosition = this.dragStartPos().add(this.defaultPanGesture().diffPos()) \n        this.setLeftPx(newPosition.x())\n        this.setTopPx(newPosition.y())\n    }\n\n    onPanMove (aGesture) {\n        this.updatePosition()\n        \n        this.addTimeout(() => { \n            this.hoverOverViews()\n        })\n    }\n\n    onPanCancelled (aGesture) {\n        const destFrame = this.source().dropCompleteDocumentFrame()\n\n        const completionCallback = () => { \n            this.sendProtocolMessage(this.source(), \"onDragSourceCancelled\")\n            this.sendProtocolMessage(this.source(), \"onDragSourceEnd\")\n            this.close() \n        }\n\n        this.animateToDocumentFrame(destFrame, this.slideBackPeriod(), completionCallback)\n        this.removePanStyle()\n    }\n\n    firstAcceptingDropTarget () {\n        return this.hoverViews().detect((v) => {\n            return v.acceptsDropHoverComplete && v.acceptsDropHoverComplete(this)\n        })\n    }\n\n    currentOperation () {\n        const keyboard = BMKeyboard.shared()\n\n        if (keyboard.alternateKey().isDown()) {\n            return \"copy\"\n        }\n\n        if (keyboard.alternateKey().isDown()) {\n            return \"link\"\n        }\n\n        return \"move\"\n    }\n\n    onPanComplete (aGesture) {\n        this.debugLog(\"onPanComplete\")\n\n        //this.setDragOperation(this.currentOperation())\n\n        const destView = this.firstAcceptingDropTarget()\n        \n        if (!destView) {\n            this.onPanCancelled(aGesture)\n            return;\n        }\n\n        const isSource = (destView === this.source())\n\n        this.setDestination(destView)\n\n        if (destView) {\n            const completionCallback = () => {\n                this.sendProtocolAction(destView, \"Dropped\") // onDragSourceDropped onDragDestinationDropped\n\n                this.sendProtocolMessage(this.source(), \"onDragSourceEnd\")\n                if (destView !== this.source()) {\n                    this.sendProtocolMessage(destView, \"onDragDestinationEnd\")\n                }\n\n                this.close()\n            }\n            const destFrame = destView.dropCompleteDocumentFrame()\n            this.animateToDocumentFrame(destFrame, this.slideBackPeriod(), completionCallback)\n            this.removePanStyle()\n            this.hoverViews().remove(destView) // so no exit hover message will be sent to it\n        } else {\n            this.close()\n        }\n    }\n\n    // --- hovering behaviors ---\n\n    viewsUnderDefaultPan () {\n        return DocumentBody.shared().viewsUnderPoint(this.dropPoint())\n    }\n\n    dropPoint () {\n        return this.defaultPanGesture().currentPosition()\n    }\n\n    newHoverViews () {\n        //console.log(\"dropPoint: \" + this.dropPoint().asString())\n        return this.viewsUnderDefaultPan().select(v => v.acceptsDropHover && v.acceptsDropHover(this))\n    }\n\n    hoverOverViews () {\n        const oldViews = this.hoverViews()\n        const newViews = this.newHoverViews()\n\n        // if new view was not in old one's, we must be entering it\n        const enteringViews = newViews.select(v => !oldViews.contains(v))\n\n        // if new view was in old one's, we're still hovering\n        const hoveringViews = newViews.select(v => oldViews.contains(v))\n\n        // if old view isn't in new ones, we must have exited it\n        const exitingViews = oldViews.select(v => !newViews.contains(v))\n \n        // onDragSourceEnter onDragDestinationEnter \n        enteringViews.forEach(aView => this.sendProtocolAction(aView, \"Enter\"))\n\n        // onDragSourceHover onDragDestinationHover\n        hoveringViews.forEach(aView => this.sendProtocolAction(aView, \"Hover\"))\n\n        // onDragSourceExit onDragDestinationExit \n        exitingViews.forEach(aView =>  this.sendProtocolAction(aView, \"Exit\")) \n\n        this.setHoverViews(newViews)\n        return this\n    }\n\n    exitAllHovers () {\n        this.hoverViews().forEach((aView) => { this.sendProtocolAction(aView, \"Exit\") })\n        this.setHoverViews([])\n    }\n\n    // drop hover protocol\n\n    sendProtocolAction (aView, action) {\n        // onDragSourceHover & onDragDestinationHover\n        const isSource = aView === this.source()\n        const methodName = \"onDrag\" + (isSource ? \"Source\" : \"Destination\") + action\n        //this.debugLog(aView.node().title() + \" \" + methodName)\n        this.sendProtocolMessage(aView, methodName)\n    }\n\n    sendProtocolMessage (receiver, methodName) {\n        if (!methodName.contains(\"Hover\") && this.isDebugging()) {\n\n            let msg = receiver.typeId() + \" \" + methodName \n\n            if (methodName.contains(\"Dropped\")) {\n                msg += \" \" + this.dragOperation()\n            }\n    \n            if (!receiver[methodName]) {\n                msg += \" <<<<<<<<<<<<<< NOT FOUND \"\n            }\n\n            this.debugLog(msg)\n        }\n\n        if (receiver[methodName]) {\n            // this fails on onDragDestinationEnd method triggered by onMouseUpCapture\n            receiver[methodName].call(receiver, this)\n        }\n    }\n    \n    // close\n\n    close () {\n        this.debugLog(\"close\")\n        this.postNoteNamed(\"onDragViewClose\")\n        // handle calling this out of seqence?\n\n        this.exitAllHovers()\n        // TODO: animate move to end location before removing\n\n        this.removePanStyle()\n        DocumentBody.shared().removeSubview(this)\n        assert(Type.isNullOrUndefined(this.element().parentNode)) // sanity check\n        this.setItems([])\n        this.setIsClosed(true)\n\n\n        return this\n    }\n\n    // --- drag style ---\n\n    addPanStyle () {\n        const s = \"0px 0px 10px 10px rgba(0, 0, 0, 0.5)\"\n        const r = 1.05 // 1.1 * (1/Math.sqrt(this.items().length))\n        this.setTransform(\"scale(\" + r + \")\")\n        if (this.subviews().length) {\n            this.subviews().forEach(v => v.setBoxShadow(s))\n        } else {\n            this.setBoxShadow(s)\n        }\n        return this\n    }\n\n    removePanStyle () {\n        const s = \"none\"\n        this.setTransform(\"scale(1)\")\n        if (this.subviews().length) {\n            this.subviews().forEach(v => v.setBoxShadow(s))\n        } else {\n            this.setBoxShadow(s)\n        }\n        return this\n    }\n\n}.initThisClass());\n",
  "2MvhkMBacdiHPOSEqlBQU1jPtg/ue7j711wYOS4rKWw=": "\"use strict\";\n\n/*\n\n    PanelView\n\n*/\n\n(class PanelView extends DomView {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"titleView\", null)\n        this.newSlot(\"subtitleView\", null)\n        this.newSlot(\"button1\", null)\n        this.newSlot(\"isDragging\", false)\n    }\n\n    init () {\n        super.init()\n        this.setPosition(\"absolute\")\n        this.setTitleView(TextField.clone().setElementClassName(\"PanelTitleView\"))\n        this.addSubview(this.titleView())\n        this.titleView().setTextAlign(\"center\")\n        this.titleView().setHeight(\"3em\")\n        this.titleView().setWhiteSpace(\"normal\")\n        this.titleView().centerInParentView()\n        this.titleView().setValue(\"hello\")\n        this.titleView().setColor(\"white\")\n\n        //this.setSubtitleView(TextField.clone().setElementClassName(\"PanelSubtitleView\"))\n        //this.addSubview(this.subtitleView())\n\n        this.setButton1(ButtonView.clone())\n        this.addSubview(this.button1())\n        this.button1().setPosition(\"absolute\").setRightPx(10).setBottomPx(10)\n        this.button1().setMinAndMaxWidth(100)\n        this.button1().setTitle(\"OK\")\n        this.button1().setTarget(this).setAction(\"hitButton1\")\n\n        this.setMinAndMaxWidth(500)\n        this.setMinAndMaxHeight(200)\n        this.setBackgroundColor(\"black\")\n        //this.setBorder(\"1px solid #ccc\")\n        this.setPosition(\"absolute\")\n        this.setLeftPx(0)\n        this.setTopPx(0)\n        //this.setupForDraggingWithMouse()\n        this.setBorderRadiusPx(5)\n        this.centerInParentView()\n\n        this._mouseMoveTrackerFunc = (event) => {\n            this.mouseMoveTracker(event)\n        }\n\n        /*\n        this._mouseUpTrackerFunc = (event) => {\n            //\n        }\n        */\n\n        return this\n    }\n\n    setTitle (s) {\n        this.titleView().setValue(s)\n        return this\n    }\n\n\n    // --- dragging ---\n\n    setupForDraggingWithMouse () {\n        this.setIsRegisteredForMouse(true)\n    }\n\n    mouseMoveTracker (event) {\n        //console.log(\"mouse pos: \", event.clientX, \" x \", event.clientY)\n        if (this.isDragging()) {\n            this.setLeftPx(event.clientX - (this._startClientX - this._startLeft))\n            this.setTopPx(event.clientY  - (this._startClientY - this._startTop))\n        }\n    }\n\n    onMouseDown (event) {\n        //console.log(\"onMouseDown\")\n        this.setIsDragging(true)\n\n        this.parentView().element().addEventListener(\"mousemove\", this._mouseMoveTrackerFunc, false);\n\n        this._startLeft = this.left()\n        this._startTop = this.top()\n        this._startClientX = event.clientX\n        this._startClientY = event.clientY\n    }\n\n    onMouseMove (event) {\n    }\n\n    onMouseUp (event) {\n        this.setIsDragging(false)\n        //this.setBackgroundColor(this.normalColor())\n        this.parentView().element().removeEventListener(\"mousemove\", this._mouseMoveTrackerFunc, false);\n    }\n\n    hitButton1 () {\n        this.close()\n        return this\n    }\n\n    close () {\n        this.removeFromParentView()\n        return this\n    }\n    \n}.initThisClass());\n",
  "CCI4Si/GPRQIPNoAgRhpTaKgLbLe+WYML/hufnfPRLU=": "\"use strict\";\n\n/*\n\n    SvgIconCache\n\n    Singleton that manages cached Svg objects in document.\n\n*/\n\n(class SvgIconCache extends ProtoClass {\n\n    static initClass () {\n        this.setIsSingleton(true)\n\t\treturn this\n    }\n\n    initPrototypeSlots () {\n        this.newSlot(\"hashToElementMap\", new Map())\n        this.newSlot(\"svgCacheElement\", null)\n    }\n\n    svgIdForString (s) {\n        return \"SvgId-\" + s.hashCode()\n    }\n\n    svgContentIdForString (s) {\n        return \"SvgContentId-\" + s.hashCode()\n    }\n\n    cacheSvgForStringIfNeeded (s) {\n        const map = this.hashToElementMap()\n        const h = this.svgIdForString(s)\n        if (!map.has(h)) {\n            assert(document.getElementById(h) === null)\n            const e = this.elementForSvgString(s)\n            assert(e.id === h)\n            this.svgCacheElement().appendChild(e)\n            assert(document.getElementById(h) !== null)\n            map.set(h, e)\n        }\n        return map.at(h)\n    }\n\n    svgCacheElement () {\n        if (!this._svgCacheElement) {\n            const e = document.createElement(\"defs\");\n            e.id = \"SvgIconCache\"\n            e.style.display = \"none\"\n            document.body.appendChild(e)\n            this._svgCacheElement = e\n        }\n        return this._svgCacheElement\n    }\n\n    elementForSvgString (s) {\n        // NOTES: \n        // - style.position of SVG needs to be absolute if in a flex container\n        // - need to use createElementNS and setAttributeNS or things silently fail (e.g. width being 0)\n \n        const xmlns = \"http://www.w3.org/2000/svg\";\n\n        // create a temporary element to put innerHTML in so we can extract svg element\n        const e = document.createElement(\"g\"); \n        e.innerHTML = s\n\n        // get the SVG element (as there may be comments, etc\n        const svg = e.getElementsByTagName(\"svg\")[0]\n        svg.id = this.svgIdForString(s)\n        svg.style.position = \"absolute\" \n\n        // to be able to reference the svg content from a use tag, \n        // we need to group the content into a g tag and add an id\n        //const content = svg.addSymbolLayer()\n        const content = svg.addSvgGroupLayer()\n        content.id = this.svgContentIdForString(s)\n\n        // set up fill, stroke as variables and remove them from descendants\n        // this only works if we want them to be uniform, as we typically do for icons\n        // and it lets us set the colors without creating a new icon\n        svg.setAttributesAndRemoveFromDecendants(this.variableAttributeMap()) \n        //svg.setAttribute(\"preserveAspectRatio\", \"xMidYMin slice\")\n        return svg\n    }\n\n    newLinkElementForSvgString (s) {\n        const cachedSvg = this.cacheSvgForStringIfNeeded(s)\n        // e.g. <use xlink:href=\"#fire\" />\n        const xmlns = \"http://www.w3.org/2000/svg\";\n        const svg = document.createElementNS(xmlns, \"svg\");\n        svg.copyAttributesFrom(cachedSvg)\n        /*\n        svg.setAttributeNS(xmlns, \"x\", \"0\")\n        svg.setAttributeNS(xmlns, \"y\", \"0\")\n        svg.setAttributeNS(xmlns, \"width\", \"100%\")\n        svg.setAttributeNS(xmlns, \"height\", \"100%\")\n        */\n        svg.copyStyleFrom(cachedSvg)\n\n        // need this to avoid zero width issue\n        // https://stackoverflow.com/questions/58792503/why-is-svg-width-0-if-container-is-display-flex\n        svg.style.position = \"absolute\" \n\n        const use = document.createElementNS(xmlns, \"use\"); // is document.createElementNS needed?\n        use.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\", \"#\" + this.svgContentIdForString(s))\n        //use.style.width = \"100%\"\n        //use.style.height = \"100%\"\n        //use.style.width = \"15px\"\n        //use.style.height = \"15px\"\n        //use.style.overflow = \"visible\"\n        //use.setAttribute(\"width\", \"100%\")\n        //use.setAttribute(\"height\", \"100%\")\n        svg.appendChild(use)\n        return svg\n    }\n \n    // --- variable maps ---\n    \n    variableAttributeMap () {\n        const m = new Map()\n        m.set(\"fill\", \"var(--fillColor)\")\n        m.set(\"stroke\", \"var(--strokeColor)\")\n        //m.set(\"strokeWidth\", \"var(--strokeWidth)\")\n        //m.set(\"transition\", \"var(--transition)\")\n        return m\n    }\n\n    /*\n    parentVariableAttributeMap () {\n        const m = new Map()\n        m.set(\"fill\", \"var(--color)\")\n        m.set(\"stroke\", \"var(--color)\")\n        m.set(\"strokeWidth\", \"var(--strokeWidth)\")\n        m.set(\"transition\", \"var(--transition)\")\n        return m\n    }\n    */\n\n\n}.initThisClass());\n",
  "gBHcfifdKvzR+JfINFPiI3eoqrFO47tkf0rLtX1BxVE=": "\"use strict\";\n\n/*\n\n    SvgIconView\n\n    A view to render scalable SVG within a view that can be \n    synced to match the color of the parent view's text color by\n    getting the computed color and applying it to the fill or stroke of the\n    svg views.\n\n    TODO: support disabled/uneditable color style?\n\n\n    Example use:\n\n    SvgIconView.clone().setIconName(\"add\")\n\n*/\n\n(class SvgIconView extends FlexDomView {\n    \n    static initClass () {\n        this.newClassSlot(\"sharedSvgMap\", new Map()) // svgStringHash -> hidden svg element defined in document\n\t\treturn this\n    }\n\n    initPrototypeSlots () {\n        this.newSlot(\"svgElement\", null)\n        this.newSlot(\"svgString\", \"\")\n        this.newSlot(\"url\", null)\n        this.newSlot(\"iconName\", null)\n        \n        this.newSlot(\"doesMatchParentColor\", false).setDoesHookSetter(true)\n        this.newSlot(\"strokeColor\", \"white\").setDoesHookSetter(true)\n        this.newSlot(\"fillColor\", \"white\").setDoesHookSetter(true)\n        this.newSlot(\"strokeWidth\", 1).setDoesHookSetter(true)\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"flex\")\n        this.setPosition(\"relative\")\n        this.setElementClassName(\"SvgIconView\")\n        this.turnOffUserSelect()\n        this.setOverflow(\"hidden\")\n\n        //this.setPosition(\"absolute\")\n        //this.setTopPx(0)\n        //this.setLeftPx(0)\n\n        this.setPadding(\"0em\")\n        this.setMargin(\"0em\")\n        \n        // /this.setOverflow(\"hidden\")\n        this.setOverflow(\"visible\")\n        //this.setBorder(\"1px yellow dashed\")\n        this.syncColors()\n\n        return this\n    }\n\n    debugTypeId () {\n        const name = this.iconName()\n        return  super.debugTypeId() + (name ? \" '\" + name + \"'\" : \"\")\n    }\n\n    clear () {\n        this.setSvgString(null)\n        this.hideDisplay()\n    }\n\n    setIconName (name) {\n        if (this._iconName !== name) {\n            this._iconName = name\n\n            if (name === null) {\n                this.clear()\n                return this\n            }\n\n            const icons = BMIconResources.shared()\n            const iconNode = icons.firstSubnodeWithTitle(name)\n\n            if (iconNode) {\n                this.setSvgString(iconNode.svgString())\n                this.unhideDisplay()\n            } else {\n                const error = \"can't find icon '\" + name + \"'\"\n                console.log(error)\n                debugger;\n                //throw new Error(error) \n                this.clear()\n                return this\n            }\n\n            this.setElementId(this.debugTypeId() + \" '\" + this.svgId() + \"'\")\n        }\n\n        return this\n    }\n\n    svgId () {\n        return \"svgid-\" + this.iconName() \n        //return \"svgid-\" + this.svgString().hashCode()\n    }\n\n    setSvgString (s) {\n        this._svgString = s\n\n        if (s) {\n            // remove and old svg element\n            while (this.element().lastChild) {\n                this.element().removeChild(this.element().lastChild);\n            }\n\n            // add svg element\n            const e = SvgIconCache.shared().newLinkElementForSvgString(s)\n            this.element().appendChild(e)\n            this.setSvgElement(e)\n            //e.style.border = \"1px blue dashed\"\n        }\n\n        return this\n    }\n\n    // --- color ---\n\n    setColor (aColor) {\n        this.setFillColor(aColor)\n        this.setStrokeColor(aColor)\n        return this\n    }\n        \n    // --- didUpdateSlot hooks ---\n\n    syncColors () {\n        const style = this.element().style\n        style.setProperty(\"--fillColor\", this.fillColor())\n        style.setProperty(\"--strokeColor\", this.strokeColor())\n        style.setProperty(\"--strokeWidth\", this.strokeWidth())\n    }\n\n    didUpdateSlotFillColor (oldValue, newValue) {\n        this.setCssProperty(\"--fillColor\", newValue)\n    }\n\n    didUpdateSlotStrokeColor (oldValue, newValue) {\n        this.setCssProperty(\"--strokeColor\", newValue)\n    }\n\n    didUpdateSlotStrokeWidth (oldValue, newValue) {\n        this.setCssProperty(\"--strokeWidth\", newValue)\n    }\n\n    // --- variable maps ---\n    \n    variableAttributeMap () {\n        const m = new Map()\n        m.set(\"fill\", \"var(--fillColor)\")\n        m.set(\"stroke\", \"var(--strokeColor)\")\n        m.set(\"strokeWidth\", \"var(--strokeWidth)\")\n        m.set(\"transition\", \"var(--transition)\")\n        return m\n    }\n\n    parentVariableAttributeMap () {\n        const m = new Map()\n        m.set(\"fill\", \"var(--color)\")\n        m.set(\"stroke\", \"var(--color)\")\n        m.set(\"strokeWidth\", \"var(--strokeWidth)\")\n        m.set(\"transition\", \"var(--transition)\")\n        return m\n    }\n\n}.initThisClass());\n",
  "UaFugKRcF3+FQwBtmhNKRTEumQLcK8wrf2VS1Kdk2Tg=": "\"use strict\";\n\n/*\n\n    TextField\n    \n    A view for a single line of text. \n    For multi-line text, use TextArea.\n    \n    Behavior:\n    On Return/Enter key, it passes focus to the nextResponder/parent.\n\n    Notes:\n    To watch for changes during editable content editing, we could use:\n\n*/\n\n(class TextField extends StyledDomView {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"selectedColor\", null)\n        this.newSlot(\"unselectedColor\", null)\n        this.newSlot(\"doesClearOnReturn\", false)\n        this.newSlot(\"doesHoldFocusOnReturn\", false)\n        this.newSlot(\"doesTrim\", false)\n        this.newSlot(\"didTextInputNote\", null)\n        this.newSlot(\"didTextEditNote\", null)\n        this.newSlot(\"doesInput\", false)\n        this.newSlot(\"allowsSetStringWhileFocused\", false)\n        //this.newSlot(\"hasBackground\", false)\n\n        // has to start false for proper state setup\n        this.newSlot(\"usesDoubleTapToEdit\", false) \n\n        // need to separate from contentEditable since we want to override when usesDoubleTapToEdit is true.\n        this.newSlot(\"isEditable\", false).setOwnsSetter(true).setDoesHookSetter(true)\n\n        this.newSlot(\"editableBorder\", \"1px solid rgba(255, 255, 255, 0.2)\")\n        this.newSlot(\"uneditableBorder\", \"none\")\n        this.newSlot(\"showsBorderWhenEditable\", false)\n        this.newSlot(\"mutationObserver\", null)\n        this.newSlot(\"isMultiline\", false)\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"flex\")\n        this.setJustifyContent(\"flex-start\")\n        this.setAlignItems(\"flex-start\")\n        this.turnOffUserSelect()\n        this.setWhiteSpace(\"pre-wrap\")\n        this.setWordWrap(\"normal\")\n        this.setOverflow(\"hidden\")\n        this.setOverflowWrap(\"normal\")\n        this.setTextOverflow(\"ellipsis\")\n        this.setWordBreak(\"keep-all\")\n        this.setSpellCheck(false)\n        this.setMinWidth(10)\n        this.setPaddingLeft(\"0.5em\")\n        this.setPaddingRight(\"0.5em\")\n        this.setPaddingTop(\"0.3em\")\n        this.setPaddingBottom(\"0.3em\")\n        this.setLineHeight(\"1.15em\")\n        this.setMinHeight(\"1em\")\n\t\t\n        this.setIsRegisteredForFocus(true) // need this to call unpauseGestures when editing ends\n\n        //this.setUnfocusOnEnterKey(true)\n        //this.setIsRegisteredForKeyboard(true) // gets set by setContentEditable()\n        //this.formatValue()\n\n        //this.setDidTextInputNote(this.newNoteNamed(\"didTextInput\"))\n        //this.setDidTextEditNote(this.newNoteNamed(\"didTextEdit\"))\n\n        this.setIsDebugging(false)\n        //this.lockedStyleAttributeSet().add(\"backgroundColor\")\n\n        return this\n    }\n\n    setupElement () {\n        super.setupElement()\n        //this.scheduleRegisterForFocus() // TODO: make this lazy\n        return this\n    }\n\n    // --- sub-element mutation observer ---\n\n    startMutationObserver () {\n        debugger;\n        if (!this.mutationObserver()) {\n            const config = { \n                subtree: true,\n                childList: true, \n                attributes: true, \n                attributeOldValue: true, \n                //characterDataOldValue: true,\n                characterData: true\n            };\n\n            const obs = new MutationObserver((mutationList, observer) => this.onDomMutation(mutationList, observer));\n            obs.observe(this.element(), config);\n            this.setMutationObserver(obs)\n        }\n        return this\n    }\n\n    stopMutationObserver () {\n        const obs = this.mutationObserver()\n        if (obs) {\n            obs.disconnect()\n            this.setMutationObserver(null)\n        }\n        return this\n    }\n\n    onDomMutation (mutationList, observer) {\n     //   console.log(\"onDomMutation --------------> \", mutationList)\n\n        for(const mutation of mutationList) {\n            if (mutation.type === 'characterData') {\n                this.onCharacterDataMutation(mutation)\n            }\n            /*\n            if (mutation.type === 'childList') {\n                console.log('A child node has been added or removed.');\n            }\n            else if (mutation.type === 'attributes') {\n                console.log('The ' + mutation.attributeName + ' attribute was modified.');\n            }\n            */\n        }\n    }\n\n    onCharacterDataMutation (mutation) {\n        console.log(\"onCharacterDataMutation --------------> \", mutation)\n    }\n\n    setContentEditable (aBool) {\n        super.setContentEditable(aBool)\n\n        /*\n        if (aBool) {\n            this.startMutationObserver()\n        } else {\n            this.stopMutationObserver()\n        }\n        */\n\n        //this.debugLog(\".setContentEditable(\" + aBool + \") = \", this.contentEditable())\n        //this.setIsRegisteredForClicks(this.contentEditable())  // is this needed after move to tap?\n\n        return this\n    }\n\n    // ---\n\n    setPaddingTop (v) {\n        if (v === \"0.6em\") {\n            console.log(this.value() + \" setPaddingTop \" + v)\n        }\n        return super.setPaddingTop(v)\n    }\n\n    // editing control\n\n    /*\n    setIsEditable (aBool) {\n        if (this._isEditable !== aBool) {\n            this._isEditable = aBool\n            this.syncEditingControl()\n        }\n        return this\n    }\n\n    \n    isEditable () {\n        return this._isEditable\n    }\n    */\n    \n    didUpdateSlotIsEditable () {\n        this.syncEditingControl()\n    }\n\n    setUsesDoubleTapToEdit (aBool) {\n        if (this._usesDoubleTapToEdit !== aBool) {\n            this._usesDoubleTapToEdit = aBool\n            this.syncEditingControl()\n        }\n        return this\n    }\n\n    syncBorder () {\n        let b = this.uneditableBorder()\n\n        if (this.isEditable()) {\n            if (this.showsBorderWhenEditable()) {\n                b = this.editableBorder()\n            }\n        }\n        this.setBorder(b)\n        return this\n    }\n\n    syncEditingControl () {\n        this.syncBorder()\n\n        if (this.isEditable()) {\n            if (this.usesDoubleTapToEdit()) {\n                //debugger;\n                this.addDefaultDoubleTapGesture()\n                this.setContentEditable(false)\n            } else {\n                this.setContentEditable(true)\n            }\n        } else {\n            if (this.usesDoubleTapToEdit()) {\n                this.removeDefaultDoubleTapGesture()\n            }\n            this.setContentEditable(false)\n        }\n\n        return this\n    }\n\n    onDoubleTapCancelled (aGesture) {\n        console.log(this.value() + \" onDoubleTapCancelled\")\n    }\n\n    onDoubleTapComplete (aGesture) {\n        //debugger;\n        //console.log(this.value() + \" onDoubleTapComplete\")\n        // make content editable and select text\n        //this.debugLog(\".onDoubleTapComplete()\")\n        if (this.contentEditable()) {\n            return this\n        }\n\n        \n        this.setContentEditable(true)\n        this.focus()\n        this.selectAll()\n        this.pauseGestures()\n\n        //this.setBorder(\"1px dashed white\")\n        return this\n    }\n\n    pauseGestures () {\n        GestureManager.shared().pause() // so things like text selection don't trigger gestures\n    }\n\n    unpauseGestures () {\n        GestureManager.shared().unpause() // so things like text selection don't trigger gestures\n    }\n\n    onFocusIn () {\n        super.onFocusIn()\n        //console.log(this.typeId() + \" '\" + this.string() + \"' onFocusIn\")\n        if (this.contentEditable()) {\n            this.pauseGestures()\n        }\n    }\n\n    onFocusOut () {\n        super.onFocusOut()\n        //console.log(this.typeId() + \" '\" + this.string() + \"' onFocusOut\")\n        this.unpauseGestures() // do we need to check for (!this.contentEditable())?\n    }\n\n    onBlur () {\n        console.log(this.value() + \" onBlur\")\n        super.onBlur()\n        if (this.usesDoubleTapToEdit()) {\n            this.setContentEditable(false)\n            this.setBorder(\"none\")\n            this.turnOffUserSelect()\n        }\n        this.unpauseGestures()\n    }\n\n    setPxFontSize (aNumber) {\n        super.setPxFontSize(aNumber)\n        this.setMinAndMaxHeight(aNumber + 2) // make sure TextfField can fit font size\n        this.didEdit()\n        return this\n    }\n\t\n    returnStrings () {\n        return [\"<div><br></div>\", \"<br><br>\"]\n    }\n\t\n    containsReturns () {\n        const value = this.value() // correct?\n        return returnStrings.detect(returnString => value.contains(returnString))\t\t\n    }\n\t\n    // ------------------\n\n    setInnerHtml (s) {\n        return super.setInnerHtml(s)\n    }\n\n    setInnerText (s) {\n        return super.setInnerText(s)\n    }\n\n    setValue (newValue) {\n        return this.setString(newValue)\n    }\n\n    value () {\n        // this.element().text ?\n        return this.string()\n    }\n\n    \n    setString (newValue) {\n        if (Type.isNullOrUndefined(newValue)) {\n            newValue = \"\"\n        }\n\n        if (!Type.isString(newValue)) {\n            newValue = newValue.toString()\n        }\n\n        const oldValue = this.string()\n        //let oldValue = this.visibleValue()\n        if (oldValue !== newValue) {\n\n            if (this.isFocused()) {\n                if (this.allowsSetStringWhileFocused()) {\n                    super.setString(newValue)\n                } \n                //throw new Error(\"attempt to call TextField.setString while it's focused\")\n\n            } else {\n                //this.isFocused()\n                super.setString(newValue)\n            }\n            \n            /*\n            console.log(\" setString(\")\n            console.log(\"    old: '\" + oldValue + \"'\")\n            console.log(\"    new: '\" + newValue + \"'\")\n            console.log(\"---\")\n            */            \n        }\n        return this\n    }\n\n    // ------------------\n\n    adjustFontSizeWithKeyboard () {\n        const kb = BMKeyboard.shared()\n        const controlDown   = kb.controlKey().isDown()\n        const equalSignDown = kb.equalsSignKey().isDown()\n        const minusDown     = kb.minusKey().isDown()\n\n        // adjust font size (testing this out)\n        if (controlDown) {\n            const fontSize = this.computedFontSize()\n\n            if (equalSignDown) {\n                this.setPxFontSize(fontSize + 1)\n            } else if (minusDown) {\n                if (fontSize > 1) { \n                    this.setPxFontSize(fontSize - 1)\n                }\n            }\n        }\n        return this\n    }\n\n    onAlternateEnterKeyUp (event) {\n        console.log(this.typeId() + \" onAlternateEnterKeyDown\")\n        //this.insertEnterAtCursor()\n        //this.afterEnter()\n    }\n\n    insertEnterAtCursor (event) {\n        if (this.isFocused()) {\n            this.insertTextAtCursor(\"\\n\")\n        }   \n    }\n\n\n    onKeyDown (event) {\n        let result = super.onKeyDown(event)\n        const returnKeyCode = 13\n\n        console.log(this.debugTypeId() + \" onKeyDown event.keyCode = \", event.keyCode)\n\n        if (!this.isMultiline() && event.keyCode === returnKeyCode) {\n            console.log(\"blocking return key\")\n            event.preventDefault()\n        }\n\n        \n        /*\n        if (this.isContentEditable()) {\n            return false // stop propogation\n        }\n        */\n       //debugger;\n        return true\n    }\n\n        \n    /*\n    onKeyUp (event) {\n        //this.debugLog(\" onKeyUp \", event)\n        //this.adjustFontSizeWithKeyboard()\n        super.onKeyUp(event)\n        //this.debugLog(\" onKeyUp value: [\" + this.value() + \"]\")\n        this.didEdit()\n        return false\n    }\n    */\n    \n    onKeyUp (event) {\n        let result = super.onKeyUp(event)\n        this.didEdit()\n\n        //event.preventDefault()\n       // return result\n\n        //console.log(this.debugTypeId() + \" onKeyUp event.keyCode = \", event.keyCode)\n\n        /*\n        if (this.isContentEditable()) {\n            return false // stop propogation\n        }\n        */\n        //debugger;\n\n        return false\n    }\n    \n    \n    onEnterKeyDown (event) {    \n        // insert 2 returns as cursor won't go to the second line with 1\n        //document.execCommand('insertHTML', false, \"\\n\\n\");\n        // prevent the default behaviour of return key pressed\n        return false;\n    }\n    \n\n    onEnterKeyUp (event) {\n        if (!this.isContentEditable()) {\n            return \n        }\n        /*\n        if (!this.doesInput()) {\n            //this.insertEnterAtCursor()\n            return\n        }\n        */\n\t    //this.debugLog(\".onEnterKeyUp()\")\n\t    //this.didEdit()\n\n        this.formatValue()\n        this.afterEnter()\n    }\n\n\n    onEscapeKeyDown (event) {\n        this.releaseFirstResponder()\n        event.stopPropagation()\n        return false\n    }\n\n    afterEnter (event) {\n        this.tellParentViews(\"didInput\", this) \n            \n        if (!this.doesHoldFocusOnReturn()) {\n            this.releaseFirstResponder()\n        }\n        \n        if (this.doesClearOnReturn()) {\n            this.setInnerHtml(\"\")\n            //this.focusAfterDelay(.125) // hack to get focus back after chat view scrolling - TODO: fix this\n        }\n\n        if (this.didTextInputNote()) {\n            this.didTextInputNote().post()\n        }\n        \n        if (event) {\n            event.stopPropagation()\n        }\n\n        return false\n    }\n\t\n    formatValue () {\n        this.setTextContent(this.textContent()) // removes formatting?\n        /*\n\t    const oldValue = this.innerHtml()\n\t    let newValue = this.innerText() // removes returns\n        \n        if (this.doesTrim()) {\n            newValue = newValue.trim()\n        } \n\n        if (true) {\n            //newValue.replaceAll(\"\\n\", \"<br>\")\n        }\n        \n        if (newValue !== oldValue) {\n            this.debugLog(\"formatValue newValue !== oldValue\")\n            this.debugLog(\" newValue: [\" + newValue + \"]\")\n            this.setInnerHtml(newValue)\n            this.didEdit()\n        }\n        */\n\t    //console.trace(this.type() + \" formatValue '\" + oldValue + \"' -> '\" + this.innerHtml() + \"'\")\n        //this.debugLog(\" after formatValue: '\" + this.innerHtml() + \"'\")\n        return this\n    }\n    \n    /*\n    setInput (s) {\n        const n = this.node()\n        if (n) {\n            const m = n.nodeInputFieldMethod()\n            if (m) {\n                n[m].apply(n, [s])\n            }\n        }\n        return this\n    }\n    \n    */\n\n    setThemeClassName (aName) {\n        if (this.themeClassName() === \"FieldKey\") {\n            debugger;\n        }\n\n        super.setThemeClassName(aName)\n        if (aName === \"FieldKey\") {\n            assert(this.themeClassName() === \"FieldKey\")\n        }\n         return this\n    }\n\n    applyStyles () {\n        /*\n        if (this.themeClassName() === \"FieldKey\") {\n            debugger;\n        }\n        */\n        super.applyStyles()\n        return this\n    }\n\n    activate () {\n        if (this.usesDoubleTapToEdit()) {\n            this.onDoubleTapComplete()\n        } else {\n            this.focus()\n        }\n        return this\n    }\n    \n    onClick (event) {\n        // needed to prevent click-to-edit event from selecting the background row\n        //this.debugLog(\".onClick()\")\n\n        if (this.contentEditable()) {\n            this.sendActionToTarget()\n            event.stopPropagation()\n            return false\n        }\n\n        return super.onClick(event)\n    }\n    \n    setBorder (v) {\n        /*\n        if (this.value() === \"a\") {\n            console.log(\"break\")\n        }\n        */\n        return super.setBorder(v)\n    }\n\n    setBackgroundColor (aColor) {\n        super.setBackgroundColor(aColor)\n        return this\n    }\n\n}.initThisClass());\n",
  "Fp/gcSEHXQ84Ma5A5oElvrwckDgtpcA8Vnmd79YyBes=": "\"use strict\";\n\n/*\n    BMDataUrl\n\n    exmaples of setting up a dataTransfer for a drag out of browser event:\n\n        event.dataTransfer.setData(\"DownloadURL\", \"application/json:hello.json:data:application/json;base64,\" + btoa(\"[1,2,3]\"));\n        event.dataTransfer.setData(\"DownloadURL\", \"text/plain:hello.txt:data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D\");\n*/\n\n(class BMDataUrl extends ProtoClass {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"dataUrl\", null) // for drop\n        this.newSlot(\"transferMimeType\", \"DownloadURL\") // for drag\n        this.newSlot(\"fileName\", \"file.txt\") // for drag\n        this.newSlot(\"mimeType\", null)\n        this.newSlot(\"decodedData\", \"\") // non-base64 version\n    }\n\n    mimeTypeDescription () {\n        const mimeType = this.mimeType()\n        if (mimeType) {\n            const name = this.mimeTypeToFileSuffixDict()[mimeType]\n            if (name) {\n                return name\n            }\n            return mimeType\n        }\n        return null\n    }\n\n    isXml () {\n        return this.mimeType() === \"application/xml\"\n    }\n\n    isJson () {\n        return this.mimeType() === \"application/json\"\n    }\n\n    isText () {\n        return this.mimeType() === \"text/plain\"\n    }\n\n    isHtml () {\n        return this.mimeType() === \"text/html\"\n    }\n\n    mimeTypeToFileSuffixDict () {\n        return {\n            \"application/json\" : \"json\",\n            \"application/xml\" : \"xml\",\n            \"text/javascript\" : \"js\",\n            \"text/plain\" : \"txt\", \n            \"text/html\" : \"html\", \n            //\"text/uri-list\" \n        }\n    }\n\n    /*\n    validMimeTypeSet () {\n        return new Set([\n            \"application/json\",\n            \"text/javascript\",\n            \"text/plain\", \n            \"text/html\", \n            \"text/uri-list\" \n        ])\n    }\n    */\n\n   dataUrlString () {\n        // e.g.: \"application/json:hello.json:data:application/json;base64,\" + btoa(\"[1,2,3]\"));\n        const header = this.mimeType() + \":\" + this.fileName() + \":data:\" + this.mimeType() + \";base64,\"  \n        const content = btoa(this.decodedData())\n        const s = header + content\n        return s\n    }\n\n    setDataUrlString (dataUrl) {\n        const type = dataUrl.before(\":\")\n        assert(type === \"data\")\n        const afterData = dataUrl.after(\"data:\")\n        const mimeType = afterData.before(\";\")\n        const encodedData = afterData.after(\"base64,\")\n        const decodedData = encodedData.base64Decoded()\n        \n        this.setDataUrl(dataUrl)\n        this.setMimeType(mimeType)\n        this.setDecodedData(decodedData)\n        return this\n    }\n\n    /*\n    attachToEvent (event) {\n        event.dataTransfer.setData(this.transferMimeType(), this.dataUrlString())\n    }\n    */\n\n}.initThisClass());\n",
  "JSSczx20j1Lo4XBrqDlMSb+FJqV7dPN7kqKcqUMtFPs=": "\"use strict\";\n\n/*\n\n    SubnodesArray\n\n    Just here to avoid name changes for array type used in BMNode.\n\n*/\n\n(class SubnodesArray extends SortedArray {\n\n    static from (oldArray) {\n        const newArray = this.clone()\n        oldArray.forEach(v => newArray.push(v)) // make sure any method hooks are called\n        return newArray\n    }\n\n    shouldStore () {\n        return true\n    }\n\n}.initThisClass());",
  "MWeQ+Em/IKogKkyue6RBoeJmvCcuV7iZw/EbaxJSjlg=": "\"use strict\";\n\n/*\n\n    BMNode\n \n    The base class of model objects that supports the protocol \n    used to sync with views (subclasses of NodeView).\n\n    State and behavior here are focused on managing subnodes.\n\n    The BMStorableNode subclass is used to sync the model to\n    the persistence system.\n\n\n        Notifications (intended for views):\n\n            - didUpdateNode // lets views know they need to scheduleSyncFromNode\n            - shouldFocusSubnode // request that the UI focus on the sender\n\n        Update messages sent to self:\n            - didUpdateSlotParentNode(oldValue, newValue)\n            \n            - didChangeSubnodeList // hook to resort if needed and call didReorderParentSubnodes\n            - prepareForFirstAccess // sent to self on first access to subnodes\n            - prepareToAccess // sent to sent whenever a subnode is accessed\n\n        Update messages sent to parent:\n            - didUpdateNode // let parent know a subnode has changed\n\n        Update messages sent to subnodes:\n            - didReorderParentSubnodes // sent on subnode order change\n\n        Protocol helpers:\n            - watchOnceForNote(aNote) // typically used to watch for appDidInit\n\n*/\n\n(class BMNode extends ProtoClass {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n\n    static primitiveNodeClasses () {\n        const classes = BMNode.allSubclasses()\n        return classes.filter(aClass => aClass.availableAsNodePrimitive())\n    }\n\n    // --- for CreatorNode Prototypes ---\n\n    static visibleClassName () {\n        let name = this.type()\n        name = name.sansPrefix(\"BM\")\n        name = name.sansSuffix(\"Field\")\n        name = name.sansSuffix(\"Node\")\n        return name\n    }\n\n    static availableAsNodePrimitive () {\n        return false\n    }\n\n    static nodeCreate () {\n        // we implemnet this on BMNode class and prototype so \n        // it works for both instance and class creator prototypes\n        return this.clone()\n    }\n\n    static nodeCreateName () {\n        return this.visibleClassName()\n    }\n\n    // --- mime types ---\n\n    static canOpenMimeType (mimeTypeString) {\n        return false\n    }\n\n    static openMimeChunk (dataChunk) {\n        return null\n    }\n\n    // ----\n\n    initPrototypeSlots () {\n \n        {\n            const slot = this.newSlot(\"nodeType\", null)\n            slot.setCanInspect(true)\n            slot.setLabel(\"type\")\n            slot.setSlotType(\"String\")\n            slot.setCanEditInspection(false)\n        }\n\n        // parent node, subnodes\n\n        {\n            const slot = this.newSlot(\"parentNode\", null)\n        }\n\n        {\n            const slot = this.newSlot(\"nodeCanReorderSubnodes\", false)\n        }\n\n        {\n            const slot = this.newSlot(\"subnodes\", null)\n            slot.setInitProto(SubnodesArray)\n            slot.setDoesHookSetter(true)\n        }\n\n        {\n            const slot = this.newSlot(\"shouldStoreSubnodes\", true)\n            slot.setDuplicateOp(\"duplicate\") //.setShouldStore(true)\n        }\n\n        {\n            const slot = this.newSlot(\"subnodeClasses\", []) //.setInitProto([]) // ui will present creator node if more than one option\n        }\n\n        // notification notes\n\n        {\n            const slot = this.newSlot(\"didUpdateNodeNote\", null) // private\n        }\n\n        {\n            const slot = this.newSlot(\"shouldFocusSubnodeNote\", null) // private\n        }\n\n        {\n            const slot = this.newSlot(\"shouldFocusAndExpandSubnodeNote\", null) // private\n\n        }\n\n        // view related, but computed on node\n\n        {\n            const slot = this.newSlot(\"nodeVisibleClassName\", null)\n            slot.setDuplicateOp(\"copyValue\")\n        }\n\n        {\n            const slot = this.newSlot(\"canDelete\", false)\n            slot.setDuplicateOp(\"copyValue\")\n        }\n    }\n\n    init () {\n        super.init()\n        this.setDidUpdateNodeNote(this.newNoteNamed(\"didUpdateNode\"))\n        this.setShouldFocusSubnodeNote(this.newNoteNamed(\"shouldFocusSubnode\"))\n        this.setShouldFocusAndExpandSubnodeNote(this.newNoteNamed(\"shouldFocusAndExpandSubnode\"))\n        this.watchSubnodes()\n        return this\n    }\n\n    registerForAppDidInit () {\n        // need this in case app has already done init,\n        // or if appDidInit notification itself inited objects\n        // who register for appDidInit\n        // TODO: generalize this for all notifications somehow\n        // maybe register for note with object directly\n        \n        //debugger;\n        if (App.shared().hasDoneAppInit()) {\n            this.appDidInit()\n        } else {\n            this.watchOnceForNote(\"appDidInit\")\n        }\n    }\n\n    nodeType () {\n        return this.type()\n    }\n\n    /*\n    prepareToRetire () {\n        super.prepareToRetire() // will remove notification observations\n        this._subnodes.removeMutationObserver(this)\n    }\n    */\n\n    nodeCreate () {\n        // we implemnet this on BMNode class and prototype so \n        // it works for both instance and class creator prototypes\n        return this.duplicate()\n    }\n    \n    nodeCreateName () {\n        return this.title()\n    }\n\n    duplicate () {\n        const dup = super.duplicate()\n        if (!this.shouldStore() || this.shouldStoreSubnodes()) {\n            dup.copySubnodes(this.subnodes().map(sn => sn.duplicate()))\n        }\n        return dup\n    }\n\n    pid () { // TODO: unify with puuid?\n        return this.puuid()\n    }\n\n    // -----------------------\n    \n    nodeVisibleClassName () {\n        if (this._nodeVisibleClassName) {\n            return this._nodeVisibleClassName\n        }\n\t\t\n        return this.type().sansPrefix(\"BM\")\n    }\n\n    // --- subnodes ----------------------------------------\n    \n    setParentNode (aNode) {\n        assert(aNode !== this) // sanity check\n\n        if (aNode !== this._parentNode) { \n            if (this._parentNode && aNode) {\n                console.warn(this.debugTypeId() + \" setParentNode(\" + aNode.debugTypeId() + \")  already has parent \" + this._parentNode.debugTypeId())\n                //debugger;\n            }\n            \n            const oldNode = this._parentNode\n            this._parentNode = aNode\n            this.didUpdateSlotParentNode(oldNode, aNode)\n        }\n        return this\n    }\n\n    didUpdateSlotParentNode (oldValue, newValue) {\n        // for subclasses to override\n    }\n\n    rootNode () {\n        const pn = this.parentNode()\n        if (pn) {\n            return pn.rootNode()\n        }\n        return this\n    }\n\n    // subnodes\n\n    subnodeCount () {\n        return this._subnodes.length\n    }\n\n    hasSubnodes () {\n        return this.subnodeCount() > 0\n    }\n\n    justAddSubnode (aSubnode) {\n        assert(!this.hasSubnode(aSubnode))\n        return this.justAddSubnodeAt(aSubnode, this.subnodeCount())\n    }\n\t\n    justAddSubnodeAt (aSubnode, anIndex) {\n        assert(!this.hasSubnode(aSubnode))\n        this.subnodes().atInsert(anIndex, aSubnode)\n        aSubnode.setParentNode(this)\n        return aSubnode        \n    }\n\n    addSubnodeAt (aSubnode, anIndex) {\n        assert(!this.hasSubnode(aSubnode))\n\n        assert(anIndex >= 0)\n        this.justAddSubnodeAt(aSubnode, anIndex)\n        //this.didChangeSubnodeList() // happens automatically from hooked array\n        return aSubnode\n    }\n\n    subnodeBefore (aSubnode) {\n        const index = this.indexOfSubnode(aSubnode)\n        assert(index !== -1)\n        if (index > 0) {\n            return this.subnodes().at(index - 1)\n        }\n        return null\n    }\n\n    replaceSubnodeWith (aSubnode, newSubnode) {\n        assert(!this.hasSubnode(newSubnode))\n\n        const index = this.indexOfSubnode(aSubnode)\n        assert(index !== -1)\n        this.removeSubnode(aSubnode)\n        this.addSubnodeAt(newSubnode, index)\n        return newSubnode\n    }\n\n    moveSubnodesToIndex (movedSubnodes, anIndex) {\n        this.subnodes().moveItemsToIndex(movedSubnodes, anIndex)\n        return this\n    }\n\n    addSubnode (aSubnode) {\n        assert(!this.hasSubnode(aSubnode))\n        return this.addSubnodeAt(aSubnode, this.subnodeCount())\n    }\n\n    addLinkSubnode (aNode) {\n        /*\n        if (aNode.parentNode()) {\n            console.warn(\"adding a link subnode to a node with no parent (yet)\")\n        }\n        */\n        const link = BMLinkNode.clone().setLinkedNode(aNode)\n        this.addSubnode(link)\n        return link\n    }\n\n    addSubnodes (subnodes) {\n        subnodes.forEach(subnode => this.addSubnode(subnode))\n        return this\n    }\n\n    addSubnodesIfAbsent (subnodes) {\n        subnodes.forEach(subnode => this.addSubnodeIfAbsent(subnode))\n        return this\n    }\n    \n    addSubnodeIfAbsent (aSubnode) {\n        if (!this.hasSubnode(aSubnode)) {\n            this.addSubnode(aSubnode)\n            return true\n        }\n        return false\n    }\n\n    subnodeProto () {\n        return this.subnodeClasses().first()\n    }\n\n    setSubnodeProto (aProto) {\n        this.subnodeClasses().removeAll()\n        this.subnodeClasses().appendIfAbsent(aProto)\n        return this\n    }\n\n    acceptedSubnodeTypes () {\n        const types = []\n        this.subnodeClasses().forEach(c => types.push(c.type()))\n        return types\n    }\n\n    acceptsAddingSubnode (aSubnode) {\n        if (aSubnode === this) {\n            return false\n        }\n\n        /*\n        if (this.hasSubnode(aSubnode)) {\n            return false\n        }\n        */\n        //const type = aSunode.type()\n        const ancestors = aSubnode.thisClass().ancestorClassesTypesIncludingSelf()\n        const match = this.acceptedSubnodeTypes().detect(type => ancestors.contains(type))\n        return !Type.isNullOrUndefined(match)\n    }\n\n    forEachSubnodeRecursively (fn) {\n        this.subnodes().forEach(sn => {\n            fn(sn)\n            sn.forEachSubnodeRecursively(fn)\n        })\n    }\n\n    selectSubnodesRecursively (fn) {\n        const results = []\n        this.forEachSubnodeRecursively(subnode => {\n            if (fn(subnode)) {\n                results.push(subnode)\n            }\n        })\n        return results\n    }\n\n    // --------\n\t\n    isEqual (aNode) {\n\t    return this === aNode\n    }\n\n    hash () {\n        // don't assume hash() always returns the puuid as\n        // subclasses can override to measure equality in their own way\n        return this.puuid()\n    }\n\n    createSubnodesIndex () {\n        this.subnodes().setIndexClosure( v => v.hash() )\n        return this\n    }\n\t\n    hasSubnode (aSubnode) {\n        const subnodes = this.subnodes()\n        if (subnodes.length > 100) {\n            this.createSubnodesIndex()\n            return subnodes.indexHasItem(aSubnode) \n        }\n        //return subnodes.detect(subnode => subnode === aSubnode)\n        return subnodes.detect(subnode => subnode.isEqual(aSubnode))\n    }\n    \n    justRemoveSubnode (aSubnode) { // private method \n        this.subnodes().remove(aSubnode)\n        \n        if (aSubnode.parentNode() === this) {\n            aSubnode.setParentNode(null)\n        }\n        \n        return aSubnode\n    }\n    \n    removeSubnode (aSubnode) {\n        this.justRemoveSubnode(aSubnode)\n        //this.didChangeSubnodeList() handled by hooked array\n        return aSubnode\n    }\n\n    removeSubnodes (subnodeList) {\n        subnodeList.forEach(sn => this.removeSubnode(sn))\n        return this\n    }\n    \n    removeAllSubnodes () {\n\t    if (this.subnodeCount()) {\n    \t\tthis.subnodes().slice().forEach((subnode) => {\n    \t\t\tthis.justRemoveSubnode(subnode)\n    \t\t})\n    \t\t\n            //this.didChangeSubnodeList() handled by hooked array but this could be more efficient\n        }\n        return this\n    }\n\n    didReorderParentSubnodes () {\n    }\n\n    onDidReorderSubnodes () {\n        this.subnodes().forEach(subnode => subnode.didReorderParentSubnodes())\n    }\n\n    didChangeSubnodeList () {\n        //this.subnodes().forEach(subnode => assert(subnode.parentNode() === this)) // TODO: remove after debugging\n        this.scheduleMethod(\"onDidReorderSubnodes\")\n        //this.subnodes().forEach(subnode => subnode.didReorderParentSubnodes())\n        this.didUpdateNode()\n        return this\n    }\n\n    copySubnodes (newSubnodes) {\n        this.subnodes().copyFrom(newSubnodes)\n        return this\n    }\n\n    nodeReorderSudnodesTo (newSubnodes) {\n        this.copySubnodes(newSubnodes)\n        return this\n    }\n\n    orderFirst () {\n        this.parentNode().orderSubnodeFirst(this)\n        return this\n    }\n\n    orderLast () {\n        this.parentNode().orderSubnodeLast(this)\n        return this  \n    }\n\n    orderSubnodeFirst (aSubnode) {\n        assert(this.hasSubnode(aSubnode))\n        const subnodes = this.subnodes().shallowCopy()\n        subnodes.remove(aSubnode)\n        subnodes.atInsert(0, aSubnode)\n        this.nodeReorderSudnodesTo(subnodes)\n        return this\n    }\n\n    orderSubnodeLast (aSubnode) {\n        assert(this.hasSubnode(aSubnode))\n        const subnodes = this.subnodes().shallowCopy()\n        subnodes.remove(aSubnode)\n        subnodes.push(aSubnode)\n        this.nodeReorderSudnodesTo(subnodes)\n        return this\n    }\n    \n    // --- update / sync system ----------------------------\n    \n    didUpdateNode () {\n        if (!this.hasDoneInit()) {\n            return\n        }\n\n        const note = this.didUpdateNodeNote()\n\n        if (note) {\n            //console.log(\"Node '\" + this.title() + \"' POST didUpdateNode\")\n            note.post()\n        }\n\n        \n        // TODO: make this more efficient, as we don't always need it\n        \n        if (this.parentNode()) {\n            assert(this.parentNode() !== this)\n            this.parentNode().didUpdateNode()\n        }\n    }\n\n    hasDuplicateSubnodes () {\n        return this.subnodes().hasDuplicates()\n    }\n\n    indexOfSubnode (aSubnode) {\n        return this.subnodes().indexOf(aSubnode);\n    }\n\n    subnodeIndexInParent () {\n        const p = this.parentNode()\n        if (p) {\n            return p.indexOfSubnode(this)\n        }\n        return 0\n    }\n\n    nodeDepth () {\n        const p = this.parentNode()\n        if (p) {\n            return p.nodeDepth() + 1\n        }\n        return 0\n    }\n\n    // ---------------------------------------\n\n    prepareToAccess () {\n        // this should be called whenever subnodes need to be accessed? See willGetSlotSubnodes\n        if (!this._didPrepareForFirstAccess) {\n            this._didPrepareForFirstAccess = true\n            this.prepareForFirstAccess()\n        }\n    }\n\n    prepareForFirstAccess () {\n        // subclasses can override \n    }\n\n    /*\n    willGetSlotSubnodes () {\n        debugger\n        this.prepareToAccess() // infinite loop?\n    }\n    */\n    \n    // --- parent chain notifications ---\n    \n    tellParentNodes (msg, aNode) {\n        const f = this[msg]\n        if (f && f.apply(this, [aNode])) {\n            return\n        }\n\n        const p = this.parentNode()\n        if (p) {\n            p.tellParentNodes(msg, aNode)\n        }\n    }\n    \n    // --- log ------------------------\n    \n    log (msg) {\n        //const s = this.nodePathString() + \" --  \" + msg\n        if (this.isDebugging()) {\n        \tconsole.log(\"[\" +  this.nodePathString() + \"] \" + msg)\n        }\n    }\n\n    // --- post notifications ----------------------------------------\n    \n    postShouldFocusSubnode (aSubnode) {\n        assert(aSubnode)\n        this.shouldFocusSubnodeNote().setInfo(aSubnode).post()\n        return this\n    }\n\n    postShouldFocusAndExpandSubnode (aSubnode) {\n        assert(aSubnode)\n        this.shouldFocusAndExpandSubnodeNote().setInfo(aSubnode).post()\n        return this\n    }\n\n    // -- adding subnodes by instantiating subnode class ----\n    \n    justAddAt (anIndex) {\n        const classes = this.subnodeClasses().shallowCopy()\n\n        let newSubnode = null\n        if (classes.length === 0) {\n            newSubnode = null\n        } else if (classes.length === 1) {\n            newSubnode = classes.first().clone()\n        } else {\n            newSubnode = BMCreatorNode.clone()\n            newSubnode.addSubnodesForObjects(classes)\n        }\n\n        if (newSubnode) {\n            this.addSubnodeAt(newSubnode, anIndex)\n        }\n        return newSubnode\n    }\n\n    justAdd (anIndex) {  \n        return this.justAddAt(this.subnodeCount())\n    }\n\n    addAt (anIndex) {\n        const newSubnode = this.justAddAt(anIndex)\n        if (newSubnode) {\n            this.didUpdateNode()\n            this.postShouldFocusAndExpandSubnode(newSubnode)\n        }\n        return newSubnode\n    }\n\n    add () {  \n        return this.addAt(this.subnodeCount())\n    }\n\n    removeFromParentNode () {\n        const pn = this.parentNode()\n        if (pn) {\n            pn.removeSubnode(this)\n        } else {\n            throw new Error(\"missing parentNode\")\n        }\n        return this\n    }\n\t\n    delete () {\n        this.removeFromParentNode()\n        return this\n    }\n\n    /*\n    nodeParentHasDeleteAction () {\n        const p = this.parentNode()\n        return p && p.hasAction(\"delete\")\n    }\n    */\n\n    /*\n    canDelete () {\n        if (this._canDelete) {\n            return true\n        }\n\n        return this.nodeParentHasDeleteAction()\n    }\n    */\n\n    canSelfAddSubnode () {\n        return this.hasAction(\"add\")\n    }\n\n    // --- utility -----------------------------\n    \n    parentNodeOfType (className) {\n        if (this.type() === className) {\n            return this\n        }\n        \n        if (this.parentNode()) {\n            return this.parentNode().parentNodeOfType(className)\n        }\n        \n        return null\n    }\n\n    parentNodes () {\n        const node = this.parentNode()\n        const results = []\n\t\t\n        while (node) {\n            results.push(node)\n            node = this.parentNode()\n        }\n        return results\n    }\n\t\n    parentNodeTypes () {\n        return this.parentNodes().map(node => node.type())\n    }\n    \n    // --- subnode lookup -----------------------------\n    \n    subnodesSans (aSubnode) {\n\t    return this.subnodes().select(subnode => subnode !== aSubnode)\n    }\n\t\n    firstSubnodeOfType (aProto) {\n        return this.subnodes().detect(subnode => subnode.type() === aProto.type())\n    }\n\n        \n    sendRespondingSubnodes (aMethodName, argumentList) {\n        this.subnodes().forEach((subnode) => { \n            if (subnode[aMethodName]) {\n                subnode[aMethodName].apply(subnode, argumentList)\n            }\n        })\n        return this\n    }\n    \n    // --- subnodes -----------------------------\n    \n    subnodesCount () {\n        return this.subnodes().length\n    }\n\n    onDidMutateObject (anObject) {\n        if (anObject === this._subnodes) {\n            assert(!this.subnodes().hasDuplicates())\n            this.didChangeSubnodeList()\n        }\n    }\n\n    watchSubnodes () {\n   //     debugger;\n        this._subnodes.addMutationObserver(this)\n        return this\n    }\n\n    didUpdateSlotSubnodes (oldValue, newValue) {\n        if (oldValue) {\n            oldValue.removeMutationObserver(this)\n        }\n\n        if (newValue.type() !== \"SubnodesArray\") {\n        //    debugger;\n            this._subnodes = SubnodesArray.from(newValue)\n            newValue.removeDuplicates()\n            newValue = this._subnodes\n            assert(newValue.type() === \"SubnodesArray\")\n        } else {\n            if(this.hasDuplicateSubnodes()) {\n                console.warn(this.debugTypeId() + \" hasDuplicateSubnodes - removing duplicates and continuing\")\n              //  debugger;\n                newValue.removeDuplicates()\n            }\n        }\n\n        this.watchSubnodes()\n        if (this._subnodes.contains(null)) { // what would cause this?\n            //debugger;\n            console.warn(\"found null in subnodes array - removing\")\n            this._subnodes.filterInPlace(sn => !(sn === null) )\n        }\n        this._subnodes.forEach(sn => sn.setParentNode(this))\n        this.didChangeSubnodeList() // not handled automatically\n        return this\n    }\n    \n    assertSubnodesHaveParentNodes () {\n        const missing = this.subnodes().detect(subnode => !subnode.parentNode())\n        if (missing) {\n            throw new Error(\"missing parent node on subnode \" + missing.type())\n        }\n        return this\n    }\n\n    // --- subnode sorting ---\n\t\n    setSubnodeSortFunc (f) {\n        this.subnodes().setSortFunc(f)\n\t    return this\n    }\n\t\n    doesSortSubnodes () {\n\t    return this.subnodes().doesSort()\n    }\n    \n    // --- subnode indexing ---\n\t\n    lazyIndexedSubnodes () {\n        if (!this.subnodes().indexClosure()) {\n            this.subnodes().setIndexClosure( sn => sn.hash() )\n        }\n\t    return this.subnodes()\n    }\n\t\n    subnodeWithHash (h) {\n        return this.lazyIndexedSubnodes().itemForIndexKey(h)\n    }\n\t\n    removeSubnodeWithHash (h) {\n\t    const subnode = this.subnodeWithHash(h)\n\t    if (subnode) {\n\t        this.removeSubnode(subnode)\n\t    }\n\t    return this\n    }\n\t\n    hasSubnodeWithHash (h) {\n\t    return this.lazyIndexedSubnodes().hasIndexKey(h)\n    }\n\t\n    // visibility\n\t\n    nodeBecameVisible () {\n\t    return this\n    }\n\n    // -- view selection request events ---\n\n    onRequestSelectionOfDecendantNode () {\n        return false // allow propogation up the parentNode line\n    }\n\n    onRequestSelectionOfNode () {\n        this.tellParentNodes(\"onRequestSelectionOfDecendantNode\", this)\n        return this\n    }\n\n    onTapOfNode () {\n        this.tellParentNodes(\"onTapOfDecendantNode\", this)\n        return this\n    }\n\n    debugTypeId () {\n        return this.typeId() + \" '\" + this.title() + \"'\"\n    }\n\n\n}.initThisClass());\n\n\n\n\n",
  "5saZb8sNzyYeV2v5iTrRwPFGM8bZhBRrFbXzJN7Ipxo=": "\"use strict\";\n\n/*\n\n    TitledNode\n \n    BMNode -> TitledNode -> ActionableNode -> InspectableNode -> ViewableNode -> StyledNode -> BaseNode -> StorableNode\n\n    Class for handling a node's:\n\n        title\n        subtitle\n        summary\n        icon/thumbnail (move to viewable?)\n\n*/\n\n(class TitledNode extends BMNode {\n\n    initPrototypeSlots () {\n\n        {\n            const slot = this.newSlot(\"title\", null)\n            slot.setDuplicateOp(\"copyValue\")\n        }\n\n        {\n            const slot = this.newSlot(\"subtitle\", null)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setCanInspect(true)\n            slot.setLabel(\"value\")\n            slot.setSlotType(\"String\")\n            slot.setInspectorPath(\"Subtitle\")\n            slot.setShouldStoreSlot(true)\n        }\n\n        {\n            const slot = this.newSlot(\"note\", null)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setShouldStoreSlot(true)\n        }\n\n        {\n            const slot = this.newSlot(\"noteIconName\", null)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setCanInspect(true)\n            slot.setLabel(\"icon\")\n            slot.setSlotType(\"String\")\n            slot.setValidValuesClosure(() => BMIconResources.shared().iconNames())\n            slot.setInspectorPath(\"Note\")\n        }\n\n        {\n            const slot = this.newSlot(\"nodeCanEditTitle\", false)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setShouldStoreSlot(true)\n        }\n\n        {\n            const slot = this.newSlot(\"nodeCanEditSubtitle\", false)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setCanInspect(true)\n            slot.setLabel(\"editable\")\n            slot.setSlotType(\"Boolean\")\n            slot.setInspectorPath(\"Subtitle\")\n            slot.setShouldStoreSlot(true)\n        }\n\n        {\n            const slot = this.newSlot(\"subtitleIsSubnodeCount\", false)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setShouldStoreSlot(true)\n        }\n\n        {\n            const slot = this.newSlot(\"noteIsSubnodeCount\", false)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setShouldStoreSlot(true)\n        }\n\n    }\n\n    // subtitle and note\n    \n    subtitle () {\n        if (this.subtitleIsSubnodeCount() && this.subnodesCount()) {\n            return this.subnodesCount()\n        }\n        \n        return this._subtitle\n    }\n    \n    note () {\n        //console.log(this.title() + \" noteIsSubnodeCount: \" + this.noteIsSubnodeCount())\n        if (this.noteIsSubnodeCount() && this.subnodesCount()) {\n            return this.subnodesCount()\n        }\n        \n        return this._note\n    }\n\n    nodeHeaderTitle () {\n        return this.title()\n    }\n\n    // --- title based paths ---\n    \n    nodePath () {\n        if (this.parentNode()) {\n            const parts = this.parentNode().nodePath()\n            parts.push(this)\n            return parts\n        }\n        return [this]\n    }\n\n    nodePathArrayForPathComponents (pathComponents, results = []) {\n        results.push(this)\n\n        const link = this.nodeTileLink()\n        if (link && link !== this) {\n            return link.nodePathArrayForPathComponents(pathComponents) \n        }\n\n        const pathComponent = pathComponents.first()\n        if (pathComponent) {\n            const nextNode = this.firstSubnodeWithTitle(pathComponent)\n            if (nextNode) {\n                return nextNode.nodePathArrayForPathComponents(pathComponents.rest())\n            }\n        }\n        return results\n    }\n    \n    nodePathString () {\n        return this.nodePath().map(node => node.title()).join(\"/\")\n    }\n    \n    nodeAtSubpathString (pathString) {\n        return this.nodeAtSubpath(pathString.split(\"/\"));        \n    }\n    \n    nodeAtSubpath (subpathArray) {\n        if (subpathArray.length) {\n            const t = subpathArray.first()\n\n            let subnode = null\n            if (Type.isArray(t)) {\n                // supports a path component that is an ordered list of subnodes titles \n                subnode = this.firstSubnodeWithTitles(t)\n            } else {\n                subnode = this.firstSubnodeWithTitle(t)\n            }\n\n            if (subnode) {\n                return subnode.nodeAtSubpath(subpathArray.rest())\n            }\n            return null\n        }        \n        return this\n    }\n\n    // --- lookups and ops on subnodes via title/subtitle -------------------------------\n\n\n    removeFirstSubnodeWithTitle (aString) {\n        const sn = this.firstSubnodeWithTitle(aString)\n        if (sn) {\n            sn.delete()\n        }\n        return this\n    }\n\n    firstSubnodeWithTitle (aString) {\n        return this.subnodes().detect(subnode => subnode.title() === aString)\n    }\n\n    firstSubnodeWithTitles (titlesArray) {\n        for (let i = 0; i < titlesArray.length; i++) {\n            const title = titlesArray[i]\n            const subnode = this.firstSubnodeWithTitle(title)\n            if (subnode) {\n                return subnode\n            }\n        }\n        return null\n    }\n\n    firstSubnodeWithSubtitle (aString) {\n        return this.subnodes().detect(subnode => subnode.subtitle() === aString)\n    }\n\n    rootNode () {\n        //debugger;\n        const store = this.defaultStore()\n        const root = store.rootObject()\n        //root.setTitle(\"root\")\n        return root\n    }\n\n    rootSubnodeWithTitleForProto (aString, aProto) {\n        return this.rootNode().subnodeWithTitleIfAbsentInsertProto(aString, aProto)\n    }\n\n    subnodeWithTitleIfAbsentInsertProto (aString, aProto) {\n        const subnode = this.firstSubnodeWithTitle(aString)\n\n        if (subnode) {\n            if (subnode.type() !== aProto.type()) {\n                const newSubnode = aProto.clone()\n                try {\n                    //newSubnode.copyFrom(subnode, true)\n                    newSubnode.copyFromAndIgnoreMissingSlots(subnode)\n                } catch (error) {\n                    if (error instanceof MissingSlotError) {\n                        debugger;\n                    } else {\n                        throw error\n                    }\n                }\n                // TODO: Do we need to replace all references in pool and reload?\n                this.replaceSubnodeWith(subnode, newSubnode)\n                this.removeOtherSubnodeWithSameTitle(newSubnode)\n                return newSubnode\n            }\n\n            this.removeOtherSubnodeWithSameTitle(subnode)\n            return subnode\n        }\n\n        return this.subnodeWithTitleIfAbsentInsertClosure(aString, () => aProto.clone())\n    }\n\n    removeSubnodesWithTitle (aString) {\n        this.subnodes().select(sn => sn.title() === aString).forEach(sn => sn.delete())\n        return this\n    }\n\n    /*\n    removeOtherSubnodeInstances (aSubnode) {\n        assert(this.hasSubnode(aSubnode))\n        this.subnodes().shallowCopy().forEach((sn) => {\n            if (sn !== aSubnode) {\n                if (sn.thisClass() === aSubnode.thisClass()) {\n                    this.removeSubnode(sn)\n                }\n            }\n        })\n        return this\n    }\n    */\n\n    removeOtherSubnodeWithSameTitle (aSubnode) {\n        assert(this.hasSubnode(aSubnode))\n        this.subnodes().shallowCopy().forEach((sn) => {\n            if (sn !== aSubnode) {\n                if (sn.title() === aSubnode.title()) {\n                    this.removeSubnode(sn)\n                }\n            }\n        })\n        return this\n    }\n\n    subnodeWithTitleIfAbsentInsertClosure (aString, aClosure) {\n        let subnode = this.firstSubnodeWithTitle(aString)\n\n        if (!subnode && aClosure) {\n            subnode = aClosure()\n            subnode.setTitle(aString)\n\n            this.addSubnode(subnode)\n        }\n\n        return subnode\n    }\n\n    // --- sorting helper ---\n\n    makeSortSubnodesByTitle () {\n        this.setSubnodeSortFunc( (a, b) => a.title().localeCompare(b.title()) )\n        return this\n    }\n\n    // --- node view badge ---\n\n    nodeViewShouldBadge () {\n        return false\n    }\n\n    nodeViewBadgeTitle () {\n        return null\n    }\n\n    // --- summary ---\n\n    summary () {\n        return this.title() + \" \" + this.subtitle()\n    }\n\n    \n}.initThisClass());\n\n\n\n\n",
  "s4zOX/u7rWDhiPbwdrDlyeR4RoA/LyQ0pQQ0+wdQ8N0=": "\"use strict\";\n\n/*\n\n    ActionableNode\n\n    BMNode -> TitledNode -> ActionableNode -> InspectableNode -> ViewableNode -> StyledNode -> BaseNode -> StorableNode\n\n    Handles a list of actions the node can perform from the user interface (or other APIs).\n\n*/\n\n(class ActionableNode extends TitledNode {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"actions\", null)\n            slot.setInitProto(Array)\n        }\n    }\n\n    /*\n    init () {\n        super.init()\n        return this\n    }\n    */\n    \n    // --- standard actions -----------------------------\n    \n    addAction (actionString) {\n        if (!this.actions().contains(actionString)) {\n\t        this.actions().push(actionString)\n            this.didUpdateNode()\n        }\n        return this\n    }\n\n    removeAction (actionString) {\n        if (this.actions().contains(actionString)) {\n        \tthis.actions().remove(actionString)\n            this.didUpdateNode()\n        }\n        return this\n    }\n    \n    addActions (actionStringList) {\n        actionStringList.forEach( (action) => {\n            this.addAction(action)\n        })\n        return this\n    }\n    \n    hasAction (actionName) {\n        return this.actions().contains(actionName)\n    }\n    \n    performAction (actionName) {\n        return this[actionName].apply(this)\n    }\n\n   \n    /*\n    nodeParentHasDeleteAction () {\n        const p = this.parentNode()\n        return p && p.hasAction(\"delete\")\n    }\n    */\n\n    /*\n    canDelete () {\n        if (this._canDelete) {\n            return true\n        }\n\n        return this.nodeParentHasDeleteAction()\n    }\n    */\n\n    canSelfAddSubnode () {\n        return this.hasAction(\"add\")\n    }\n\n}.initThisClass());\n\n\n\n\n",
  "jg4ospKwwNhLBfwowJV+WFoNcj7JZ5g3yeFhID+unr4=": "\"use strict\";\n\n/*\n\n    InspectableNode\n \n    BMNode -> TitledNode -> ActionableNode -> InspectableNode -> ViewableNode -> StyledNode -> BaseNode -> StorableNode\n\n    Handles creating inspector nodes and related fields.\n    Slot has some logic for this too.\n\n*/\n\n(class InspectableNode extends ActionableNode {\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"nodeCanInspect\", true)\n            slot.setDuplicateOp(\"copyValue\")\n        }\n\n        {\n            const slot = this.newSlot(\"nodeInspector\", null)\n        }\n    }\n\n    /*\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n    // --- node inspector ---\n\n    nodeInspector () {\n        if (!this._nodeInspector) {\n            this._nodeInspector = BaseNode.clone()\n            this.initNodeInspector()\n        }\n        return this._nodeInspector\n    }\n\n    initNodeInspector () {  // TODO: merge with setupInspectorFromSlots?\n        this.setupInspectorFromSlots()\n        return this\n    }\n\n    setupInspectorFromSlots () {\n        this.thisPrototype().allSlotsMap().forEachV(slot => {\n            if (slot.canInspect()) {\n                const field = slot.newInspectorField()\n                if (field) {\n                    field.setTarget(this)\n                    const pathNodes = this.nodeInspector().createNodePath(slot.inspectorPath())\n                    pathNodes.last().addSubnode(field)\n                }\n            }\n        })\n        return this\n    }    \n\n    // --- helpful for setting up inspector paths ---\n\n    createNodePath (aPath, pathSubnodeType = \"BMFolderNode\") {\n        const pathNodes = [this]\n\n        if (aPath) {\n            const components = aPath.split(\"/\")\n            let node = this\n\n            components.forEach(component => {\n                node = node.subnodeWithTitleIfAbsentInsertClosure(component, () => {\n                    //debugger\n                    const nodeClass = Object.getClassNamed(pathSubnodeType)\n                    const newNode = nodeClass.clone()\n                    newNode.setNodeCanReorderSubnodes(false) // should this be here?\n                    newNode.setTitle(component)\n                    newNode.removeAction(\"add\")\n                    //console.log(\"newNode.actions():\", newNode.actions())\n                    //debugger\n                    return newNode\n                })\n                pathNodes.push(node)\n            })\n        }\n\n        return pathNodes\n    }\n\n    // --- fields ---\n    \n    /*\n    addLinkFieldForNode (aNode) {\n        const field = BMLinkField.clone().setName(aNode.title()).setValue(aNode)\n        return this.addStoredField(field)\n    }\n    */\n    \n    addField (aField) {\n        throw new Error(\"addField shouldn't be called - use BMFieldSetNode\")\n        return this.addSubnode(aField)\n    }\n        \n    nodeTileLink () {\n        // used by UI tile views to browse into next column\n        return this\n    }\n\n    // nodeTileLinkMethods\n    // used by UI tile views to choose the node ref to use for the next column\n    // if returns null, the tile won't open another column\n    // \n    // The two typical use cases are :\n    //\n    // 1) A pointer tile which links to some other node.\n    //\n    // 2) A means to toggle between viewing the row's node or\n    //    skipping to one of its subnodes. This allows a node\n    //    to have inspector separated from \"subnode\" browsing.\n    //    Example: a Server object might have the subnodes:\n    //    [ StringFieldNode (for server name),  \n    //      ActionNode (to connect/disconnect),\n    //      ServerClientsNode (holds list of connected server clients)\n    //\n\n    thisNode () {\n        return this\n    }\n\n    nodeTileLinkMethods () {\n        return [\"thisNode\"]\n    }\n\n    defaultNodeTileLinkMethod () {\n\n    }\n\n\n}.initThisClass());\n\n\n\n\n",
  "DHP2MWi1QxRtLeGsXAqg66JWS+6OnuV1EMu43W37GdA=": "\"use strict\";\n\n/*\n\n    ViewableNode\n \n    BMNode -> TitledNode -> ActionableNode -> InspectableNode -> ViewableNode -> StyledNode -> BaseNode -> StorableNode\n\n    Class for handling a node's connection to the user interface.\n    Views can reference nodes, but nodes should not reference views. \n    Views can query nodes for info or tell them to take actions, but otherwise \n    nodes should only communicate with views via notfications.\n\n*/\n\n(class ViewableNode extends InspectableNode {\n    \n    initPrototypeSlots () {\n\n        {\n            const slot = this.newSlot(\"nodeViewClassName\", null)\n        }\n\n        {\n            const slot = this.newSlot(\"nodeTileClassName\", null)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setCanInspect(true)\n            slot.setLabel(\"tile class name\")\n            slot.setSlotType(\"String\")\n            slot.setShouldStoreSlot(true)\n        }\n\n        {\n            const slot = this.newSlot(\"nodeThumbnailUrl\", null)\n        }\n\n        {\n            const slot = this.newSlot(\"nodeIsVertical\", true)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setCanInspect(true)\n            slot.setLabel(\"is vertical\")\n            slot.setSlotType(\"Boolean\")\n            slot.setInspectorPath(\"Layout\")\n            slot.setShouldStoreSlot(true)\n        }\n\n        {\n            const slot = this.newSlot(\"nodeTileIsSelectable\", true)\n            slot.setDuplicateOp(\"copyValue\")\n        }\n\n        {\n            const slot = this.newSlot(\"nodeTilesStartAtBottom\", false)\n            slot.setDuplicateOp(\"copyValue\")\n        }\n\n        {\n            const slot = this.newSlot(\"nodeNavBorderHint\", true)\n            slot.setDuplicateOp(\"copyValue\")\n        }\n\n        {\n            const slot = this.newSlot(\"nodeMinTileHeight\", 0)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setShouldStoreSlot(true)\n            slot.setInspectorPath(\"style\")\n        }\n\n        {\n            const slot = this.newSlot(\"nodeMinTileWidth\", 0)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setShouldStoreSlot(true)\n            slot.setInspectorPath(\"style\")\n        }\n\n        // html\n\n        {\n            const slot = this.newSlot(\"acceptsFileDrop\", false)\n        }\n\n        // input hook\n\n        {\n            const slot = this.newSlot(\"nodeInputFieldMethod\", null)\n        }\n\n        // column settings - TODO: auto adjust to fit?\n\n        //this.newSlot(\"nodeMinWidth\", 200).setDuplicateOp(\"copyValue\") // no longer used - we calc sizes of tiles instead\n        \n        {\n            const slot = this.newSlot(\"nodeFillsRemainingWidth\", false).setDuplicateOp(\"copyValue\")\n            slot.setSlotType(\"Boolean\")\n            slot.setLabel(\"fills remaining\")\n            slot.setCanEditInspection(false)\n            slot.setCanInspect(false)\n            slot.setInspectorPath(\"Layout\")\n        }\n\n        {\n            const slot = this.newSlot(\"nodeFillsWindow\", false)\n            slot.setSlotType(\"Boolean\")\n            slot.setLabel(\"fills window\")\n            slot.setCanEditInspection(true)\n            slot.setCanInspect(true)\n            slot.setShouldStoreSlot(true)\n            slot.setInspectorPath(\"Layout\")\n        }\n\n        {\n            const slot = this.newSlot(\"nodeCanEditTileHeight\", false)\n            slot.setDuplicateOp(\"copyValue\") // TODO: change to NavHeight\n        }\n\n        {\n            const slot = this.newSlot(\"nodeCanEditColumnWidth\", false)\n            slot.setDuplicateOp(\"copyValue\") // TODO: change to NavWidth\n        }\n                \n    }\n\n    /*\n    init () {\n        super.init()\n    }\n    */\n\n    nodeOrientation () {\n        return this.nodeIsVertical() ? \"right\" : \"down\" \n    }\n\n     // --- nodeViewClass and nodeTileClass ---\n    \n     nodeViewClass () {\n        const name = this.nodeViewClassName()\n        if (name) {\n            const proto = Object.getClassNamed(name)\n            if (proto) {\n                return proto\n            }\n            console.warn(\"no class found for nodeViewClassName:'\" + name + \"'\")\n            debugger \n        }\n        \n\t  \treturn this.firstAncestorClassWithPostfix(\"View\") \n    }\n\n    // --- nodeTileClass ---\n\n    nodeTileClass () {  \n        // This is used (instead of nodeViewClass) by TilesView to \n        // get it's subnode's views. Other views (typically) use nodeViewClass.\n        const name = this.nodeTileClassName()\n\n        if (name) {\n            const proto = Object.getClassNamed(name)\n            if (proto) {\n                return proto\n            }\n            console.warn(\"no class found for nodeTileClassName:'\" + name + \"'\")\n        }\n\n\t  \treturn this.firstAncestorClassWithPostfix(\"Tile\")\n    }\n\n    onBrowserDropChunk (dataChunk) {\n        const mimeType = dataChunk.mimeType()\n        const canOpenNodes = BMNode.allSubclasses().select((aClass) => aClass.canOpenMimeType(mimeType))\n        const okTypes = this.acceptedSubnodeTypes()\n        const canUseNodes = canOpenNodes /// canOpenNodes.select(nodeType => okTypes.contains(nodeType))\n\n        if (canUseNodes.length) {\n\n            if (canUseNodes.length === 1) {\n                const match = canUseNodes.first()\n                const newNode = match.openMimeChunk(dataChunk)\n                this.addSubnode(newNode)\n\n                //if (this.acceptsAddingSubnode(match)) {\n                //    this.addSubnode(match)\n                //}\n                \n            } else {\n                // TODO: add CreatorNode with those types and\n                // hook to instantiate from mime data\n            }\n        }\n    }\n\n    // --- update / sync system ----------------------------\n    \n    didUpdateSlot (aSlot, oldValue, newValue) {\n        super.didUpdateSlot(aSlot, oldValue, newValue)\n\n        if (aSlot.syncsToView()) { \n            this.scheduleSyncToView()\n        }\n    }\n\n    scheduleSyncToView () {\n        this.didUpdateNode()\n        //SyncScheduler.shared().scheduleTargetAndMethod(this, \"syncToView\")\n        return this\n    }\n\n\n    // --- shelf ---\n\t\n    /*\n    shelfSubnodes () {\n        return []\n    }\n\n    shelfIconName () {\n\t    return null\n    }\n\t\n    shelfIconUrl () {\n\t    return null\n    }\n    */\n    \n    prepareToSyncToView () {\n        this.prepareToAccess();\n    }\n\t\n    // visibility\n\t\n    nodeBecameVisible () {\n\t    return this\n    }\n\n    // -- selection requests ---\n\n    onRequestSelectionOfDecendantNode () {\n        return false // allow propogation up the parentNode line\n    }\n\n    onRequestSelectionOfNode () {\n        this.tellParentNodes(\"onRequestSelectionOfDecendantNode\", this)\n        return this\n    }\n\n    onTapOfNode () {\n        this.tellParentNodes(\"onTapOfDecendantNode\", this)\n        return this\n    }\n\n}.initThisClass());\n\n\n\n\n",
  "HJw0Tmda/2LZWXFz8AXbaYgv5GX6rRbB3NH/CzLuKBU=": "\"use strict\";\n\n/*\n\n    StyledNode\n \n    BMNode -> TitledNode -> ActionableNode -> InspectableNode -> ViewableNode -> StyledNode -> BaseNode -> StorableNode\n\n    For state and behavior specific to styling of views.\n\n*/\n\n(class StyledNode extends ViewableNode {\n    \n    initPrototypeSlots () {\n        // view style overrides\n        {\n            //const slot = this.newSlot(\"themeClassName\", \"DefaultThemeClass\")\n            const slot = this.newSlot(\"themeClassName\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n            slot.setSlotType(\"String\")\n            slot.setLabel(\"Theme Class\")\n            slot.setSyncsToView(true)\n            slot.setInspectorPath(\"Style\")\n        }\n    }\n\n    /*\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n}.initThisClass());\n\n\n\n\n",
  "MSMhjC6uIA++17idzh8l9WIqRHgIjz/vybguXgA4OpA=": "\"use strict\";\n\n/*\n\n    BaseNode\n \n    Something for everone to extend. Under neath, we break up the node into \n    various classes of sub state and behavior.\n\n*/\n\n(class BaseNode extends StyledNode {\n    \n\n}.initThisClass());\n\n\n\n\n",
  "lKUhh2JY5puv9pSUVOW2lf+oD3CiQC5pKLU/do7Xwig=": "\"use strict\";\n\n\n(class ProtoClass_store extends ProtoClass {\n\n    recordForStore (aStore) { // should only be called by Store\n        const aRecord = {\n            type: this.type(), \n            entries: [], \n        }\n\n        this.forEachSlotKV((slotName, slot) => {\n            //if (slot.shouldStoreSlot()) {\n            if (slot.shouldStoreSlotOnInstance(this)) {\n                const v = slot.onInstanceGetValue(this)\n                //assert(!Type.isUndefined(v))\n                aRecord.entries.push([slotName, aStore.refValue(v)])\n            }\n        })\n\n        return aRecord\n    }\n\n    lazyPids (puuids = new Set()) {\n        // when doing Store.collect() will need to check for lazy slot pids on active objects\n        this.allSlotsMap().forEachV(slot => {\n            // only need to do this on unloaded store refs in instances\n            const storeRef = slot.onInstanceGetValueRef(this)\n            if (storeRef) {\n                puuids.add(storeRef.pid())\n            }\n        })\n        return puuids\n    }\n\n    loadFromRecord (aRecord, aStore) {\n        aRecord.entries.forEach((entry) => {\n            const k = entry[0]\n            const v = entry[1]\n\n            const slot = this.thisPrototype().slotNamed(k)\n            // TODO: replace with slot.onInstanceSetValueFromEntry(this, entry, aStore)\n\n            if (slot) {\n                    if (!slot.hasSetterOnInstance(this)) {\n                    // looks like the schema has changed \n                    // TODO: add something the schedule a didMutate?\n                    console.warn(\"no setter for slot?\")\n                    debugger;\n                } else {\n                    /*if (slot.isLazy()) {\n                        const pid = v[\"*\"]\n                        assert(pid)\n                        const storeRef = StoreRef.clone().setPid(pid).setStore(aStore)\n                        //console.log(this.typeId() + \".\" + slot.name() + \" [\" + this.title() + \"] - setting up storeRef \")\n                        slot.onInstanceSetValueRef(this, storeRef)\n                    } else */\n                    {\n                        const unrefValue = aStore.unrefValue(v)\n                        slot.onInstanceSetValue(this, unrefValue)\n                    }\n                }\n            } else {\n                console.warn(\"loadFromRecord found missing slot '\" + k + \"' - did schema change?\")\n                this.scheduleMethod(\"didMutate\", 1000) // to force it to save - use high priorty number to cause it to be done after mutations on loading objects are being ignored e.g. before scheduled didInitLoadingPids is complete \n                //debugger;\n            }\n        })\n\n        return this\n    }\n\n    /*\n    didLoadFromStore (aStore) {\n        // called by ObjectPool.didInitLoadingPids() after all objects are deserialized\n        super.didLoadFromStore(aStore)\n    }\n    */\n\n}).initThisCategory();\n",
  "PYOekWo7o9rnAvNwYR/euUtSc8dwSPDwyAtpApTAaIk=": "\"use strict\";\n\n(class BMNode_store extends BMNode {\n    \n/*\n\n    Placeholder for store related methods. \n    This state/behavor is currently in BMStorableNode.\n\n*/\n\n}).initThisCategory();\n",
  "ktLB/qwG0NUPntPdzT7wZmSiDgJCRuhg2O+VA4PFRWo=": "\"use strict\";\n\n\n(class Array_store extends Array {\n\n    static lengthOfRecord (aRecordObj) {\n        return aRecordObj.values.length\n    }\n\n    recordForStore (aStore) { // should only be called by Store\n        const dict = {\n            type: Type.typeName(this), \n            values: this.map(v => aStore.refValue(v))\n        }\n\n        return dict\n    }\n\n    loadFromRecord (aRecord, aStore) {\n        const loadedValues = aRecord.values.map(v => aStore.unrefValue(v))\n        if (this.unhooked_push) {\n            loadedValues.forEach( v => this.unhooked_push(v) )\n        } else {\n            loadedValues.forEach( v => this.push(v) )\n        }\n        return this\n    }\n\n    refsPidsForJsonStore (puuids = new Set()) {\n        this.forEach(v => { \n            if (!Type.isNull(v)) { \n                v.refsPidsForJsonStore(puuids)\n            } \n        })\n        return puuids\n    }\n\n}).initThisCategory();\n",
  "KZLEE+1tEv6wvFXEAYOe9Y8u1nBePVeWdUHySYREXic=": "\"use strict\";\n\n\n(class ArrayBuffer_store extends ArrayBuffer {\n\n    static instanceFromRecordInStore (aRecord, aStore) { // should only be called by Store\n        //assert(aRecord.type === \"ArrayBuffer\")\n        const bytes = aRecord.bytes\n        const obj = new ArrayBuffer(bytes.length)\n        return obj\n    }\n\n    loadFromRecord (aRecord, aStore) {\n        assert(aRecord.bytes.length === this.length)\n        const bytes = aRecord.bytes\n        for (let i = 0; i < bytes.length; i++) {\n            this[i] = bytes[i]\n        }\n        return this\n    }\n\n    bytes () {\n        const bytes = []\n        for (let i = 0; i < this.byteLength; i++) {\n            bytes.push(this[i])\n        }\n        return bytes\n    }\n\n    recordForStore (aStore) { // should only be called by Store\n        return {\n            type: \"ArrayBuffer\", //Type.typeName(this), \n            bytes: this.bytes(),\n        }\n    }\n\n    refsPidsForJsonStore (puuids = new Set()) {\n        return puuids\n    }\n    \n}).initThisCategory();\n\n\n\n",
  "wFfjR4Sbch69mgtsXbrV+klzjPStuhsxinCrpXWUAJw=": "\"use strict\";\n\n\n(class Date_store extends Date {\n\n    loadFromRecord (aRecord, aStore) {\n        this.setTime(aRecord.time)\n        return this\n    }\n\n    recordForStore (aStore) { // should only be called by Store\n        return {\n            type: this.type(), \n            time: this.getTime() // toJSON is a standard library Date method\n        }\n    }\n\n    shouldStore () {\n        return true\n    }\n\n    refsPidsForJsonStore (puuids = new Set()) {\n        return puuids\n    }\n\n}).initThisCategory();\n",
  "UIys9Ns+c7Dm6Kfcw7vD1ezcz8VmtnbbD3UQROO09QI=": "\"use strict\";\n\n\n(class Map_store extends Map {\n\n    loadFromRecord (aRecord, aStore) {\n        aRecord.entries.forEach((entry) => {\n            const key = entry[0]\n            const value = aStore.unrefValue(entry[1])\n            this.atPut(key, value)\n        })\n\n        return this\n    }\n\n    recordForStore (aStore) { // should only be called by Store\n        let iterator = this.entries();\n        let entry = iterator.next().value\n        const entries = []\n        while (entry) {\n            const key = entry[0]\n            const value = entry[1]\n            entries.push([key, aStore.refValue(value)])\n            entry = iterator.next().value\n        }\n\n        return {\n            type: this.type(), \n            entries: entries\n        }\n    }\n\n    shouldStore () {\n        return true\n    }\n\n    refsPidsForJsonStore (puuids = new Set()) {\n        this.forEach(v => { \n            if (!Type.isNull(v)) { \n                v.refsPidsForJsonStore(puuids)\n            } \n        })\n        return puuids\n    }\n\n}).initThisCategory();\n\n\n\n",
  "3YJiLdZ61gZQKijqvy29HztDOY3AkwWPu1lzSCiOeok=": "\"use strict\";\n\n\n(class Set_store extends Set {\n\n    loadFromRecord (aRecord, aStore) {\n        const values = aRecord.values.map(v => aStore.unrefValue(v))\n        values.forEach(v => this.add(v))\n        return this\n    }\n\n    recordForStore (aStore) { // should only be called by Store\n        return {\n            type: Type.typeName(this), \n            values: this.valuesArray().map(v => aStore.refValue(v))\n        }\n    }\n\n    shouldStore () {\n        return true\n    }\n\n    refsPidsForJsonStore (puuids = new Set()) {\n        this.forEach(v => { \n            if (!Type.isNull(v)) { \n                v.refsPidsForJsonStore(puuids)\n            } \n        })\n        return puuids\n    }\n\n}).initThisCategory();\n\n\n\n\n",
  "rNSHW151yVr1dZC8xS1KtruMsmS1WdhrplwgB0iCNoM=": "\"use strict\";\n\n\n(class Object_store extends Object {\n\n    static instanceFromRecordInStore (aRecord, aStore) { // should only be called by Store\n        return this.clone()\n    }\n\n    loadFromRecord (aRecord, aStore) {\n        aRecord.entries.forEach((entry) => {\n            const k = entry[0]\n            const v = entry[1]\n            this[k] = aStore.unrefValue(v)\n        })\n        return this\n    }\n\n    recordForStore (aStore) { // should only be called by Store\n        const entries = []\n\n        Object.keys(this).forEach((k) => {\n            const v = this[k]\n            entries.push([k, aStore.refValue(v)])\n        })\n\n        return {\n            type: this.type(), \n            entries: entries, \n        }\n    }\n\n    refsPidsForJsonStore (puuids = new Set()) {\n        if (this.hasOwnProperty(\"*\")) {\n            puuids.add(this[\"*\"])\n        } else {\n            throw new Error(\"dictionaries are reserved for pointers, but we found a non-pointer\")\n        }\n        return puuids\n    }\n    \n    defaultStore () {\n        return PersistentObjectPool.shared()\n    }\n\n    // ---\n\n    didLoadFromStore () { \n        // See Object_init notes for docs on when/how to use this properly.\n        // Here for subclasses to override.\n        return this\n    }\n\n    // --- shouldStore ---\n \n    setShouldStore (aBool) {\n        if (aBool != this._shouldStore) {\n            //this.willMutate(\"shouldStore\")\n            Object.defineSlot(this, \"_shouldStore\", aBool)\n            //this.didMutate(\"shouldStore\")\n        }\n        return this\n    }\n \n    shouldStore () {\n        return this._shouldStore\n    }\n    \n}).initThisCategory();\n",
  "sFwdt9+4Geh3hc4TVx5562HO4KbitBjWlJ3a/GcRg18=": "\"use strict\";\n\n/*\nType.typedArrayTypeNames().forEach((name) => {\n    const aClass = Object.getClassNamed(name)\n\n    if (Type.isUndefined(aClass)) {\n        console.warn(\"TypeArray-store error: missing type \" + name)\n        return\n    }\n\n    Object.defineSlots(aClass, {\n        instanceFromRecordInStore: function(aRecord, aStore) { // should only be called by Store\n            const obj = new this.thisClass()(aRecord.length)\n            //obj.loadFromRecord(aRecord, aStore)\n            return obj\n        },\n    })\n\n    Object.defineSlots(aClass.prototype, {\n\n        loadFromRecord: function(aRecord, aStore) {\n            const values = aRecord.values\n            for (let i = 0; i < values.length; i++) {\n                this[i] = values[i]\n            }\n            return this\n        },\n\n        valuesArray: function() {\n            return Array.fromIterator(this.values())\n        },\n\n        recordForStore: function(aStore) { // should only be called by Store\n            return {\n                type: this.type(), \n                values: this.valuesArray() \n            }\n        },\n\n        refsPidsForJsonStore: function(puuids = new Set()) {\n            // no references in a TypedArray\n            return puuids\n        },\n    })\n\n})\n*/\n\nconst typedArrayClass = Int8Array.__proto__ // just using int array to get to abstract parent TypeArray class, as we can't use TypeArray name directly\n\nObject.defineSlots(typedArrayClass, {\n    instanceFromRecordInStore: function(aRecord, aStore) { // should only be called by Store\n        const obj = new this.thisClass()(aRecord.length)\n        return obj\n    },\n})\n\nObject.defineSlots(typedArrayClass.prototype, {\n\n    loadFromRecord: function(aRecord, aStore) {\n        const values = aRecord.values\n        for (let i = 0; i < values.length; i++) {\n            this[i] = values[i]\n        }\n        return this\n    },\n\n    valuesArray: function() {\n        return Array.fromIterator(this.values())\n    },\n\n    recordForStore: function(aStore) { // should only be called by Store\n        return {\n            type: this.type(), \n            values: this.valuesArray() \n        }\n    },\n\n    refsPidsForJsonStore: function(puuids = new Set()) {\n        // no references in a TypedArray\n        return puuids\n    },\n})\n",
  "kIknma36/5ymKETQtT9pDYPtE+6nN3w7i3gOdcIcLok=": "\"use strict\";\n\n(class String_store extends String {\n\n    refsPidsForJsonStore (puuids = new Set()) {\n        return puuids\n    }\n\n}).initThisCategory();\n\n",
  "r/Ki2TaRj9WzljePmlL/gtxGuoVuQLcIpNrFUrMAIsA=": "\"use strict\";\n\n(class Boolean_store extends Boolean {\n\n    refsPidsForJsonStore (puuids = new Set()) {\n        return puuids\n    }\n\n}).initThisCategory();\n\n",
  "jJpd0nRHyZ3ZDCAe7TJgoAJgNW0uTLYYjjNsPg6ykE0=": "\"use strict\";\n\n(class Number_store extends Number {\n\n    refsPidsForJsonStore (puuids = new Set()) {\n        return puuids\n    }\n\n}).initThisCategory();\n\n",
  "+hOw+wFojjEGnKbAtuZ2xFsYTZIHrhRxeN8yZ1psyOE=": "\"use strict\";\n\n/*\n\n    ObjectPool\n\n        For persisting a object tree to a JSON formatted representation and back.\n        Usefull for both persistence and exporting object out the the app/browser and onto desktop or other browsers.\n\n        This is a parent class for PersistentObjectPool, which just swaps out the recordDict AtomicMap, \n        with a PersistentAtomicMap.\n\n        An object pool can also be created by pointing at an object within another pool.\n\n        JSON format of pool:\n\n            {\n                rootPid: \"rootPid\",\n                puuidToDict: {\n                    \"<objPid>\" : <Record>\n                }\n            }\n\n        Example use:\n    \n            // converting a node to json\n            const poolJson = ObjectPool.clone().setRoot(rootNode).asJson()\n            \n            // converting json to a node\n            const rootObject = ObjectPool.clone().fromJson(poolJson).root()\n\n        Notes:\n\n        Objects to be stored must implement:\n\n            // writing methods\n            puuid\n            recordForStore (aStore)\n\n            // reading methods\n            static instanceFromRecordInStore (aRecord, aStore)\n            loadFromRecord (aRecord, aStore)\n\n        These are implemented on Object, and other primitives such as Array, Set, etc.\n\n*/\n\n(class ObjectPool extends ProtoClass {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"name\", \"defaultDataStore\")\n        this.newSlot(\"rootObject\", null)\n\n        // AtomicMap\n        this.newSlot(\"recordsMap\", null) \n\n        // Map - objects known to the pool (previously loaded or referenced)\n        this.newSlot(\"activeObjects\", null) \n\n        // Map - subset of activeObjects containing objects with mutations that need to be stored\n        this.newSlot(\"dirtyObjects\", null)\n\n        // Set - pids of objects that we're loading in this event loop\n        this.newSlot(\"loadingPids\", null)\n\n        // Set - pids of objects that we're storing in this event loop\n        this.newSlot(\"storingPids\", null)\n\n        // Date - WARNING: vulnerable to system time changes/differences\n        this.newSlot(\"lastSyncTime\", null)\n\n        //this.newSlot(\"isReadOnly\", false)\n\n        // Set of puuids\n        this.newSlot(\"markedSet\", null) \n\n        // Notification - sent after pool opens - TODO: change name to objectPoolDidOpen?\n        this.newSlot(\"nodeStoreDidOpenNote\", null)\n\n        // Bool - set to true during method didInitLoadingPids() - used to ignore mutations during this period\n        this.newSlot(\"isFinalizing\", false)\n\n        // String or Error\n        this.newSlot(\"error\", null) // most recent error, if any\n\n        this.newSlot(\"collectablePidSet\", null) // used during collection to store keys before tx begins\n    }\n\n    init () {\n        super.init()\n        this.setRecordsMap(ideal.AtomicMap.clone())\n        this.setActiveObjects(new Map())\n        this.setDirtyObjects(new Map())\n        this.setLoadingPids(new Set())\n        this.setLastSyncTime(null)\n        this.setMarkedSet(null)\n        this.setNodeStoreDidOpenNote(this.newNoteNamed(\"nodeStoreDidOpen\"))\n        this.setIsDebugging(true)\n        return this\n    }\n\n    clearCache () {\n        this.setActiveObjects(new Map())\n        this.setDirtyObjects(new Map())\n        this.readRoot()\n        //this.setRootObject(this.objectForPid(this.rootObject().puuid()))\n        return this\n    }\n\n    // --- open ---\n\n    open () { // this class can also be used with synchronous AtomicMap\n        this.recordsMap().setName(this.name())\n        this.recordsMap().open()\n        this.onPoolOpenSuccess()\n        return this\n    }\n\n    promiseOpen () { \n        const map = this.recordsMap()\n        map.setName(this.name())\n        return map.promiseOpen().then(() => {\n            this.onPoolOpenSuccess()\n        }).catch((error) => {\n            this.onPoolOpenFailure(error)\n        })\n    }\n\n    onPoolOpenSuccess () {\n        //debugger\n        // here so subclasses can easily hook\n        this.onRecordsDictOpen()\n    }\n\n    onPoolOpenFailure (error) {\n        debugger\n        // here so subclasses can easily hook\n        throw error\n    }\n\n    /*\n    postOpenNote () {\n        this.postNoteNamed(\"objectPoolDidOpen\")\n    }\n    */\n\n    show (s) {\n        const comment = s ? \" \" + s + \" \" : \"\"\n        console.log(\"---\" + comment + \"---\")\n        const max = 40\n        console.log(this.recordsMap().count() + \" records: \")\n        this.recordsMap().forEachKV((k, v) => {\n            if (v.length > max) {\n                v = v.slice(0, max) + \"...\"\n            }\n            console.log(\"   '\" + k + \"': '\" + v + \"'\")\n        })\n\n        console.log(\"------\")\n    }\n\n    onRecordsDictOpen () {\n        //debugger\n        //this.show(\"ON OPEN\")\n        this.promiseCollect()\n        //this.show(\"AFTER COLLECT\")\n        this.nodeStoreDidOpenNote().post()\n        return this\n    }\n\n    isOpen () {\n        return this.recordsMap().isOpen()\n    }\n\n    // --- root ---\n\n    rootKey () {\n        return \"root\"\n    }\n\n    setRootPid (pid) { \n        // private - it's assumed we aren't already in storing-dirty-objects tx\n        const map = this.recordsMap()\n        if (map.at(this.rootKey()) !== pid) {\n            map.atPut(this.rootKey(), pid)\n            console.log(\"---- SET ROOT PID \" + pid + \" ----\")\n            //debugger;\n        }\n        assert(this.hasStoredRoot())\n        return this\n    }\n\n    rootPid () {\n        return this.recordsMap().at(this.rootKey())\n    }\n\n    hasStoredRoot () {\n        return this.recordsMap().hasKey(this.rootKey())\n    }\n\n    rootOrIfAbsentFromClosure (aClosure) {\n        //debugger;\n        if (this.hasStoredRoot()) {\n            this.readRoot()\n        } else {\n         //   debugger\n            const newRoot = aClosure()\n            assert(newRoot)\n            this.setRootObject(newRoot)\n        }\n        return this.rootObject()\n    }\n\n    readRoot () {\n        //console.log(\" this.hasStoredRoot() = \" + this.hasStoredRoot())\n        if (this.hasStoredRoot()) {\n            const root = this.objectForPid(this.rootPid()) // this call will actually internally set this._rootObject as we may need it while loading the root's refs\n            assert(!Type.isNullOrUndefined(root))\n            this._rootObject = root\n            //this.setRootObject(root) // this is for setting up new root\n            return this.rootObject()\n        }\n        throw new Error(\"missing root object\")\n    }\n\n    knowsObject (obj) { // private\n        const puuid = obj.puuid()\n        const foundIt = this.recordsMap().hasKey(puuid) ||\n            this.activeObjects().has(puuid) ||\n            this.dirtyObjects().has(puuid) // dirty objects check redundant with activeObjects?\n        return foundIt\n    }\n\n    assertOpen () {\n        assert(this.isOpen())\n    }\n\n    /*\n    changeOldPidToNewPid (oldPid, newPid) {\n        // flush and change pids on all activeObjects \n        // and pids and pidRefs in recordsMap \n        throw new Error(\"unimplemented\")\n        return this\n    }\n    */\n    \n    setRootObject (obj) { // only used for setting up a new root object\n        this.assertOpen()\n        if (this._rootObject) {\n            // can support this if we change all stored and\n            //this.changeOldPidToNewPid(\"root\", Object.newUuid())\n            throw new Error(\"can't change root object yet, unimplemented\")\n        }\n\n        assert(!this.knowsObject(obj))\n\n        //debugger;\n        //this.setRootPid(obj.puuid()) // this is set when the dirty root object is stored\n        this._rootObject = obj\n        this.debugLog(\" adding rootObject \" + obj.debugTypeId())\n        this.addActiveObject(obj)\n        this.addDirtyObject(obj)\n        return this\n    }\n\n    // ---  ---\n\n    asJson () {\n        return this.recordsMap().asJson()\n    }\n\n    updateLastSyncTime () {\n        this.setLastSyncTime(Date.now())\n        return this\n    }\n\n    // --- active and dirty objects ---\n\n    hasActiveObject (anObject) {\n        const puuid = anObject.puuid()\n        return this.activeObjects().has(puuid)\n    }\n    \n    addActiveObject (anObject) {\n        assert(!anObject.isClass())\n\n        if (!anObject.shouldStore()) {\n            const msg = \"attempt to addActiveObject '\" + anObject.type() + \"' but shouldStore is false\"\n            console.warn(msg)\n            anObject.shouldStore()\n            //throw new Error(msg)\n            return false\n        }\n\n        if (!anObject.isInstance()) {\n            const msg = \"can't store non instance of type '\" + anObject.type() + \"'\"\n            console.log(msg)\n            anObject.isKindOf(ProtoClass) \n            throw new Error(msg)\n        }\n\n        //debugger;\n\n        if (!this.hasActiveObject(anObject)) {\n            const title = anObject.title ? anObject.title() : \"-\";\n            //this.debugLog(() => anObject.debugTypeId() + \".addMutationObserver(\" + this.debugTypeId() + \" '\" + title + \"')\")\n            anObject.addMutationObserver(this)\n            this.activeObjects().set(anObject.puuid(), anObject)\n            //this.addDirtyObject(anObject)\n        }\n\n        return true\n    }\n\n    close () {\n        this.removeMutationObservations()\n        this.setActiveObjects(new Map())\n        this.setDirtyObjects(new Map())\n        return this\n    }\n\n    removeMutationObservations () {\n        this.activeObjects().forEachKV((puuid, obj) => obj.removeMutationObserver(this)) // activeObjects is super set of dirtyObjects\n        return this\n    }\n\n    hasDirtyObjects () {\n        return !this.dirtyObjects().isEmpty()\n    }\n\n    /*\n    hasDirtyObject (anObject) {\n        const puuid = anObject.puuid()\n        return this.dirtyObjects().has(puuid)\n    }\n    */\n\n    onObjectUpdatePid (anObject, oldPid, newPid) {\n        // sanity check for debugging - could remove later\n        if (this.hasActiveObject(anObject)) {\n            const msg = \"onObjectUpdatePid \" + anObject.typeId() + \" \" + oldPid + \" -> \" + newPid\n            console.log(msg)\n            throw new Error(msg)\n        }\n    }\n\n    onDidMutateObject (anObject) {\n        //if (anObject.hasDoneInit() && ) {\n        if (this.hasActiveObject(anObject) && !this.isLoadingObject(anObject)) {\n            this.addDirtyObject(anObject)\n        }\n    }\n\n    isStoringObject (anObject) {\n        const puuid = anObject.puuid()\n        if (this.storingPids()) {\n            if (this.storingPids().has(puuid)) {\n                return true\n            }\n        }\n        return false\n    }\n\n    isLoadingObject (anObject) { // private\n        if (this.loadingPids()) {\n            if (this.loadingPids().has(puuid)) {\n                return true\n            }\n        }\n        return false\n    }\n\n    addDirtyObject (anObject) { // private\n        if (!this.hasActiveObject(anObject)) {\n            console.log(\"looks like it hasn't been referenced yet\")\n            throw new Error(\"not referenced yet\")\n        }\n\n        const puuid = anObject.puuid()\n\n        if (this.isStoringObject(anObject)) {\n            return this\n        }\n\n        if (this.isLoadingObject(anObject)) {\n            return this\n        }\n\n        if (!this.dirtyObjects().has(puuid)) {\n            //this.debugLog(() => \"addDirtyObject(\" + anObject.typeId() + \")\" )\n            if (this.storingPids() && this.storingPids().has(puuid)) {\n                throw new Error(\"attempt to double store? did object change after store? is there a loop?\")\n            }\n            this.dirtyObjects().set(puuid, anObject)\n            this.scheduleStore()\n        }\n\n        return this\n    }\n\n    scheduleStore () {\n        if (!this.isOpen()) {\n            console.log(this.typeId() + \" can't schedule store yet, not open\")\n            return this\n        }\n        assert(this.isOpen())\n        const scheduler = SyncScheduler.shared()\n        const methodName = \"commitStoreDirtyObjects\"\n        if (!scheduler.isSyncingTargetAndMethod(this, methodName)) {\n            if (!scheduler.hasScheduledTargetAndMethod(this, methodName)) {\n                //console.warn(\"scheduleStore currentAction = \", SyncScheduler.currentAction() ? SyncScheduler.currentAction().description() : null)\n                scheduler.scheduleTargetAndMethod(this, methodName, 1000)\n            }\n        }\n        return this\n    }\n\n    // --- storing ---\n\n    commitStoreDirtyObjects () {\n        if (this.hasDirtyObjects()) {\n            //this.debugLog(\"--- commitStoreDirtyObjects begin ---\")\n            //debugger;\n            this.recordsMap().begin()\n            const storeCount = this.storeDirtyObjects()\n            this.recordsMap().promiseCommit()\n            this.debugLog(\"--- commitStoreDirtyObjects end --- stored \" + storeCount + \" objects\")\n            //this.show(\"AFTER commitStoreDirtyObjects\")\n        }\n    }\n\n    storeDirtyObjects () { // PRIVATE\n        // store the dirty objects, if they contain references objects unknown to pool,\n        // they'll be added as active + dirty objects which will be stored on next loop. \n        // We continue until there are no dirty objects left.\n\n        let totalStoreCount = 0\n        this.setStoringPids(new Set())\n\n        while (true) { // easier to express clearly than do/while in this case\n            let thisLoopStoreCount = 0\n            const dirtyBucket = this.dirtyObjects()\n            this.setDirtyObjects(new Map())\n\n            dirtyBucket.forEachKV((puuid, obj) => {\n                //console.log(\"  storing pid \" + puuid)\n\n                if (this.storingPids().has(puuid)) {\n                    const msg = \"ERROR: attempt to double store \" + obj.typeId()\n                    console.log(msg)\n                    throw new Error(msg)\n                }\n\n                this.storingPids().add(puuid)\n                //debugger;\n                this.storeObject(obj)\n\n                thisLoopStoreCount ++\n            })\n\n            if (thisLoopStoreCount === 0) {\n                break\n            }\n\n            totalStoreCount += thisLoopStoreCount\n            //this.debugLog(() => \"totalStoreCount: \" + totalStoreCount)\n        }\n\n        this.setStoringPids(null)\n        return totalStoreCount\n    }\n\n    // --- reading ---\n\n    classNameConversionMap () {\n        const m = new Map()\n        /*\n        m.set(\"BMMenuNode\", \"BMFolderNode\")\n        */\n       return m;\n    }\n\n    classForName (className) { \n        const m = this.classNameConversionMap()\n        if (m.has(className)) {\n            return Object.getClassNamed(m.get(className))\n        } \n\n        return Object.getClassNamed(className)\n    }\n\n    objectForRecord (aRecord) { // private\n        const className = aRecord.type\n        //console.log(\"loading \" + className + \" \" + aRecord.id)\n        const aClass = this.classForName(className)\n\n        if (!aClass) {\n            const error = \"missing class '\" + className + \"'\"\n            console.warn(error)\n            //throw new Error(error)\n            debugger\n            return null\n        }\n        \n        assert(!Type.isNullOrUndefined(aRecord.id))\n        const obj = aClass.instanceFromRecordInStore(aRecord, this)\n        assert(!this.hasActiveObject(obj))\n        obj.setPuuid(aRecord.id)\n        this.addActiveObject(obj)\n        if (obj.puuid() === this.rootPid()) {\n            this._rootObject = obj; // bit of a hack to make sure root ref is set before we load root contents\n            // might want to split this method into one to get ref and another to load contents instead\n        }\n        obj.loadFromRecord(aRecord, this)\n        return obj\n    }\n\n    activeObjectForPid (puuid) {\n        return this.activeObjects().get(puuid)\n    }\n\n    objectForPid (puuid) { // PRIVATE (except also used by StoreRef)\n        //console.log(\"objectForPid \" + puuid)\n\n        // return active object for pid, if there is one\n        const activeObj = this.activeObjectForPid(puuid)\n        if (activeObj) {\n            return activeObj\n        }\n\n        // schedule didInitLoadingPids to occur at end of event loop \n\n        if (!this.isFinalizing() && this.loadingPids().count() === 0) {\n            SyncScheduler.shared().scheduleTargetAndMethod(this, \"didInitLoadingPids\")\n        }\n\n        this.loadingPids().add(puuid)\n        \n        const aRecord = this.recordForPid(puuid)\n        if (Type.isUndefined(aRecord)) {\n            return undefined\n        }\n        const loadedObj = this.objectForRecord(aRecord)\n        return loadedObj\n    }\n\n    didInitLoadingPids () {\n        assert(!this.isFinalizing()) // sanity check\n        this.setIsFinalizing(true)\n        while (!this.loadingPids().isEmpty()) { // while there are still loading pids\n            const lastSet = this.loadingPids()\n            this.setLoadingPids(new Set())\n\n            lastSet.forEach(loadedPid => { // sends didLoadFromStore to each matching object\n                const obj = this.activeObjectForPid(loadedPid)\n                if (Type.isUndefined(obj)) {\n                    const errorMsg = \"missing activeObjectForPid \" + loadedPid\n                    console.warn(errorMsg)\n                    //throw new Error(errorMsg)\n                } else if (obj.didLoadFromStore) {\n                    obj.didLoadFromStore() // should this be able to trigger an objectForPid() that would add to loadingPids?\n                }\n            })\n        }\n        this.setIsFinalizing(false)\n    }\n\n    //\n\n    headerKey () {\n        return \"header\" // no other key looks like this as they all use PUUID format\n    }\n\n    allPidsSet () {\n        const keySet = this.recordsMap().keysSet()\n        keySet.delete(this.headerKey())\n        return keySet\n    }\n\n    allPids () {\n        const keys = this.recordsMap().keysArray()\n        keys.remove(this.rootKey())\n        return keys\n    }\n\n    activeLazyPids () { // returns a set of pids\n        const pids = new Set()\n        this.activeObjects().forEachKV((pid, obj) => {\n            if (obj.lazyPids) {\n                obj.lazyPids(pids)\n            }\n        })\n        return pids\n    }\n\n    // --- references ---\n\n    refForPid (aPid) {\n        return { \"*\": this.pid() }\n    }\n\n    pidForRef (aRef) {\n        return aRef.getOwnProperty(\"*\")\n    }\n\n    unrefValueIfNeeded (v) {\n        return this.unrefValue(v)\n    }\n\n    unrefValue (v) {\n        if (Type.isLiteral(v)) {\n            return v\n        }\n        const puuid = v.getOwnProperty(\"*\")\n        assert(puuid)\n        const obj = this.objectForPid(puuid)\n        return obj\n    }\n\n    refValue (v) {\n        if (Type.isLiteral(v)) {\n            return v\n        }\n\n        assert(!v.isClass())\n\n        if (!v.shouldStore()) {\n            console.log(\"WARNING: called refValue on \" + v.type() + \" which has shouldStore=false\")\n            return null\n        }\n\n        if (!this.hasActiveObject(v)) {\n            this.addActiveObject(v)\n            this.addDirtyObject(v)\n        }\n        const ref = { \"*\": v.puuid() }\n        return ref\n    }\n\n    // read a record\n\n    recordForPid (puuid) { // private\n        if (!this.recordsMap().hasKey(puuid)) {\n            return undefined\n        }\n        const jsonString = this.recordsMap().at(puuid)\n        assert(Type.isString(jsonString))\n        const aRecord = JSON.parse(jsonString)\n        aRecord.id = puuid\n        return aRecord\n    }\n\n    // write an object\n\n    storeObject (obj) {\n        assert(obj.shouldStore())\n        const puuid = obj.puuid()\n        assert(!Type.isNullOrUndefined(puuid))\n\n        if (obj === this.rootObject()) {\n            this.setRootPid(puuid)\n        }\n\n        const jsonString = JSON.stringify(obj.recordForStore(this))\n        //this.debugLog(() => \"store \" + obj.puuid() + \" <- \" + jsonString )\n        this.recordsMap().set(puuid, jsonString)\n        return this\n    }\n\n    // -------------------------------------\n\n    flushIfNeeded () {\n        if (this.hasDirtyObjects()) {\n            this.storeDirtyObjects()\n            assert(!this.hasDirtyObjects())\n        }\n        return this\n    }\n\n    promiseCollect () {\n        if (Type.isUndefined(this.rootPid())) {\n            console.log(\"---- NO ROOT PID FOR COLLECT - clearing! ----\")\n            //debugger\n            this.recordsMap().begin()\n            this.recordsMap().clear()\n            this.recordsMap().promiseCommit()\n            //debugger;\n            return 0;\n        }\n        //debugger;\n        // this is an on-disk collection\n        // in-memory objects aren't considered\n        // so we make sure they're flushed to the db first \n        this.recordsMap().begin()\n        this.flushIfNeeded() // store any dirty objects\n\n        this.debugLog(() => \"--- begin collect --- with \" + this.recordsMap().count() + \" pids\")\n        this.setMarkedSet(new Set())\n        this.markedSet().add(this.rootKey()) // so rootKey->rootPid entry isn't swept\n        this.markPid(this.rootPid())\n        this.activeObjects().forEachK(pid => this.markPid(pid))\n        this.activeLazyPids().forEachK(pid => this.markPid(pid))\n        const deleteCount = this.sweep()\n        this.setMarkedSet(null)\n\n        const promise = this.recordsMap().promiseCommit()\n        this.debugLog(() => \"--- end collect --- collected \" + deleteCount + \" pids ---\")\n\n        const remainingCount = this.recordsMap().count()\n        this.debugLog(() => \" keys count after commit: \" + remainingCount)\n        return promise\n    }\n\n    markPid (pid) { // private\n        //this.debugLog(() => \"markPid(\" + pid + \")\")\n        if (!this.markedSet().has(pid)) {\n            this.markedSet().add(pid)\n            const refPids = this.refSetForPuuid(pid)\n            //this.debugLog(() => \"markPid \" + pid + \" w refs \" + JSON.stringify(refPids))\n            refPids.forEach(refPid => this.markPid(refPid))\n            return true\n        }\n        return false\n    }\n\n    refSetForPuuid (puuid) {\n        const record = this.recordForPid(puuid)\n        const puuids = new Set()\n\n        if (record) {\n            Object.keys(record).forEach(k => this.puuidsSetFromJson(record[k], puuids))\n        }\n\n        return puuids\n    }\n\n    puuidsSetFromJson (json, puuids = new Set()) {\n        // json can only contain array's, dictionaries, and literals.\n        // We store dictionaries as an array of entries, \n        // and reserve dicts in the json for pointers with the format { \"*\": \"<puuid>\" }\n\n        //console.log(\" json: \", JSON.stringify(json, null, 2))\n\n        if (Type.isLiteral(json)) {\n            // we could call refsPidsForJsonStore but none will add any pids,\n            // and null raises exception, so we can just skip it for now\n        } else if (Type.isObject(json) && json.refsPidsForJsonStore) {\n            json.refsPidsForJsonStore(puuids)\n        } else {\n            throw new Error(\"unable to handle json type: \" + typeof(json) + \" missing refsPidsForJsonStore() method?\")\n        }\n        \n        return puuids\n    }\n\n    // ------------------------\n\n    sweep () {\n        const unmarkedPidSet = this.allPidsSet().difference(this.markedSet()) // allPids doesn't contain rootKey\n\n        // delete all unmarked records\n        let deleteCount = 0\n        const recordsMap = this.recordsMap()\n        recordsMap.keysArray().forEach(pid => {\n            if (!this.markedSet().has(pid)) {\n                //this.debugLog(\"deletePid(\" + pid + \")\")\n                const count = recordsMap.count()\n                recordsMap.removeKey(pid)\n                assert(recordsMap.count() === count - 1)\n                deleteCount ++\n            }\n        })\n        return deleteCount\n    }\n\n    promiseDeleteAll () {\n        assert(this.isOpen())\n        // assert not loading or storing?\n        const map = this.recordsMap()\n        map.begin()\n        map.forEachK(pid => map.removeKey(pid)) // the remove applies to the changeSet\n        return map.promiseCommit()\n    }\n\n    promiseClear () {\n        return this.recordsMap().promiseClear(resolve, reject)\n    }\n\n    // ---------------------------\n\n    rootSubnodeWithTitleForProto (aTitle, aProto) {\n        return this.rootObject().subnodeWithTitleIfAbsentInsertProto(aTitle, aProto)\n    }\n\n    totalBytes () {\n        return this.recordsMap().totalBytes()\n    }\n\n    // ---------------------------\n\n    /*\n    activeObjectsReferencingObject (anObject) {\n        // useful for seeing if we can unload an object\n        // BUT, to do full collect, do a mark/sweep on active objects\n        // where sweep only removes unmarked from activeObjects and records cache?\n\n        assert(this.hasActiveObject(anObject)) \n\n        const referencers = new Set()\n        const pid = anObject.puuid()\n\n        this.activeObjects().forEachKV((pid, obj) => {\n            const refPids = this.refSetForPuuid(obj.puuid())\n            if (refPids.has(pid)) {\n                referencers.add(obj)\n            }\n        })\n\n        return referencers\n    }\n    */\n\n    /*\n    static selfTestRoot () {\n        const aTypedArray = Float64Array.from([1.2, 3.4, 4.5])\n        const aSet = new Set(\"sv1\", \"sv2\")\n        const aMap = new Map([ [\"mk1\", \"mv1\"], [\"mk2\", \"mv2\"] ])\n        const aNode = BMStorableNode.clone()\n        const a = [1, 2, [3, null], { foo: \"bar\", b: true }, aSet, aMap, new Date(), aTypedArray, aNode]\n        return a\n    }\n\n    static selfTest () {\n        console.log(this.type() + \" --- self test start --- \")\n        const store = ObjectPool.clone()\n        store.open()\n\n        store.rootOrIfAbsentFromClosure(() => BMStorableNode.clone())\n        store.flushIfNeeded()\n        console.log(\"store:\", store.asJson())\n        console.log(\" --- \")\n        store.promiseCollect()\n        store.clearCache()\n        const loadedNode = store.rootObject()\n        console.log(\"loadedNode = \", loadedNode)\n        console.log(this.type() + \" --- self test end --- \")\n    }\n    */\n\n}.initThisClass());\n\n\n\n",
  "zBBKY+Lcp9UJQtRCt9t0EOr3uAFFDkGDBJ6uY/jLSJU=": "\"use strict\";\n\n/*\n\n    PersistentObjectPool\n\n        An ObjectPool that uses a PersistentAtomicMap\n        to store it's records.\n\n*/\n\n(class PersistentObjectPool extends ObjectPool {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setName(\"defaultDataStore\")\n        this.setRecordsMap(PersistentAtomicMap.clone())\n        this.setIsDebugging(false)\n        return this\n    }\n\n    open () {\n        throw new Error(this.type() + \" synchronous open not available - use promiseOpen()\")\n    }\n\n    promiseSelfTest () {\n        console.log(this.type() + \" --- self test start --- \")\n        const store = this.thisClass().clone()\n        return store.promiseOpen().then(() => this.selfTestOnStore(store))\n    }\n\n    selfTestOnStore (store) {\n        store.rootOrIfAbsentFromClosure(() => BMStorableNode.clone())\n        //store.flushIfNeeded()\n        console.log(\"store:\", store.asJson())\n        console.log(\" --- \")\n        store.collect()\n        store.clearCache()\n        const loadedNode = store.rootObject()\n        console.log(\"loadedNode = \", loadedNode)\n        console.log(this.type() + \" --- self test end --- \")\n    }\n\n    static promiseSelfTest () {\n        return new Promise((resolve, reject) => {\n            this.addTimeout(() => { return PersistentObjectPool.promiseSelfTest() }, 1000)\n        })\n    }\n    \n}.initThisClass());\n\n\n\n",
  "Ou6mRkgr7WVGZqQ8s6z0SaWDFHNpxFtt536d5ylkgkE=": "\"use strict\";\n\n/*\n\n    StoreRef\n\n*/\n\n\n(class StoreRef extends Object {\n\n    init () {\n        super.init()\n        Object.defineSlot(this, \"_store\", null) // move to initPrototype?\n    }\n\n    setPid (aPid) {\n        this[\"*\"] = aPid\n        return this\n    }\n\n    pid () {\n        return this.getOwnProperty(\"*\")\n    }\n\n    setStore (aStore) {\n        this._store = aStore\n        return this\n    }\n\n    store () {\n        return this._store\n    }\n\n    unref () {\n        return this.store().objectForPid(this.pid())\n    }\n\n    ref () {\n        return this.store().refForPid(this.pid())\n    }\n    \n}.initThisClass());\n\n",
  "ZrHLd1mlC1gtVw2gQZeIuONdvrABGB0gsw1pl0ITOiM=": "\"use strict\";\n\n/*\n\n    BMStorableNode \n\n    Thin subclass to:\n\n    - override some slots and mark them as shouldStore\n    - hook didUpdateSlot() to didMutate so ObjectPool (if observing mutations) gets told it needs to store the change\n    \n*/\n\n(class BMStorableNode extends StyledNode {\n\n\n    initPrototypeSlots () {\n        this.setShouldStore(true)\n        this.setShouldScheduleDidInit(true)\n        //this.setShouldStoreSubnodes(true)\n\n        {\n            const slot = this.overrideSlot(\"canDelete\", false)\n            slot.setShouldStoreSlot(true)  // defined in BMNode, but we want to store it\n        }\n\n        {\n            const slot = this.overrideSlot(\"title\", null)\n            slot.setShouldStoreSlot(true)\n        }\n\n        {\n            const slot = this.overrideSlot(\"subtitle\", \"\")\n            slot.setShouldStoreSlot(true)\n        }\n\n        {\n            const slot = this.overrideSlot(\"nodeFillsRemainingWidth\", false)\n            slot.setShouldStoreSlot(true)\n            slot.setCanEditInspection(true)\n            slot.setCanInspect(true)\n        }\n\n        {\n            const slot = this.overrideSlot(\"subnodes\", null)\n            //subnodesSlot.setOwnsSetter(true)\n            slot.setShouldStoreSlot(true)\n            slot.setDoesHookGetter(true)\n            //slot.setHookedGetterIsOneShot(true)\n            //slot.setIsLazy(true) // no point in using this until we have coroutines?\n            slot.setInitProto(SubnodesArray)\n\n            assert(slot.doesHookGetter())\n        }\n        \n        {\n            const slot = this.newSlot(\"lazySubnodeCount\", null)\n            slot.setShouldStoreSlot(true)\n        }\n    }\n\n    didInit () {\n        super.didInit()\n        return this\n    }\n\n    // --- udpates ---\n\t\n    didUpdateSlot (aSlot, oldValue, newValue) {\n        super.didUpdateSlot(aSlot, oldValue, newValue)\n\n\t    if (!this.shouldStore() || !this.isInstance()) {\n\t        return this\n\t    }\n\t    \n        if (aSlot.shouldStoreSlot()) { \n            this.didMutate()\n        }\n        \n        // TODO: HACK, add a switch for this feature\n        // TODO: find a way to avoid this?\n        if (newValue !== null && this._subnodes && this._subnodes.includes(oldValue)) { \n            newValue.setParentNode(this)\n            this.subnodes().replaceOccurancesOfWith(oldValue, newValue)\n            //this.debugLog(\" this.subnodes().replaceOccurancesOfWith(\", oldValue, \",\", newValue, \")\")\n        }\n    }\n\n    /*\n    didUpdateSlotSubnodes (oldValue, newValue) {\n        super.didUpdateSlotSubnodes(oldValue, newValue)\n        this.updateLazySubnodeCount()        \n        return this\n    }\n    */\n\n    updateLazySubnodeCount () {\n        if (this._subnodes) {\n            this.setLazySubnodeCount(this.subnodes().length)\n        }\n    }\n\n    didChangeSubnodeList () {\n        super.didChangeSubnodeList()\n        this.updateLazySubnodeCount()\n        return this\n    }\n\n    // --- stored slots ---\n    \n    initStoredSubnodeSlotWithProto (name, proto) {\n        const obj = proto.clone()\n        this.newSlot(name, obj)\n        this.justAddSubnode(obj)\n        this.addStoredSlot(name)\n        return this\n    }\n\t\n    // subnodes\n    \n    subnodeCount () {\n        if (!this._subnodes) {\n            return this.lazySubnodeCount()\n        }\n        return this._subnodes.length\n    }\n\n    prepareForFirstAccess () {\n        super.prepareForFirstAccess()\n        return this\n    }\n\n}.initThisClass());\n",
  "jPC/xqnlhR+xzpZcTqaF0MXhcQZhHQ1WB7AY6cJsAq8=": "\n\"use strict\";\n\n/*\n\n    BMStoredDatedSetNode\n\n*/\n\n(class BMStoredDatedSetNode extends BMStorableNode {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"maxAgeInSeconds\", 30*24*60*60)\n            slot.setShouldStoreSlot(true)\n        }\n\n        {\n            const slot = this.newSlot(\"autoCheckPeriod\", 1*60*60)\n            slot.setShouldStoreSlot(true)\n        }\n\n        {\n            const slot = this.newSlot(\"dict\", null)\n            slot.setShouldStoreSlot(true)\n        }\n    }\n\n    initPrototype () {\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(false)\n    }\n\n    init () {\n        super.init()\n        this.setDict({})\n        //this.setNoteIsSubnodeCount(true)\n    }\n    \n    didUpdateSlotAutoCheckPeriod (seconds) {\n        if (seconds && this._autoCheckPeriod !== seconds) {\n            this._autoCheckPeriod = seconds\n            this.autoCheck()\n        }\n    }\n    \n    autoCheck () {\n        this.deleteExpiredKeys()\n        this.addTimeout(() => { this.autoCheck() }, this.autoCheckPeriod()*1000)\n    }\n    \n    didLoadFromStore () {\n        super.didLoadFromStore()\n        this.deleteExpiredKeys()\n    }\n\n    addKey (h) {\n        if (!this.dict().at(h)) {\n            this.dict().atPut(h, Date.now())\n        }\n        return this\n    }\n    \n    hasKey (h) {\n        return this.dict().hasOwnProperty(h)\n    }\n    \n    removeKey (h) {\n        if (this.dict()[h]) {\n            this.dict().removeAt(h)\n        }\n        return this\n    }\n    \n    ageInSecondsOfKey (h) {\n        if (this.hasKey(h)) {\n            const ageInSeconds = Date.now() - this.dict()[h]\n            return ageInSeconds\n        }\n        \n        return null\n    }\n\n    deleteExpiredKeys () {\n        const max = this.maxAgeInSeconds()\n        const keys = Object.keys(this.dict())\n        \n        keys.forEach((k) => {\n            if (this.ageInSecondsOfKey(k) > max) {\n                this.removeKey(k)\n            }\n        })\n\n        return this\n    }\n    \n}.initThisClass());\n",
  "axh63W09uTowPOuAfg/5tLdVMLtVz/gnDCmQ6uGC0us=": "\"use strict\";\n\n/*\n\n    BMDataStore\n\n    A visible representation of the storage system\n    \n*/\n\n(class BMDataStore extends BaseNode {\n    \n    static initClass () {\n        this.setIsSingleton(true)\n        return this\n    }\n\n    initPrototypeSlots () {\n        this.newSlot(\"lastSyncTime\", 0)\n    }\n\n    init () {\n        super.init()\n        this.setTitle(\"Storage\")\n    }\n\n    subtitle () {\n        return this.defaultStore().totalBytes().byteSizeDescription()\n    }\n\n    storeHasChanged () {\n        return this.defaultStore().lastSyncTime() !== this.lastSyncTime()\n    }\n\n    prepareToSyncToView () {\n        //console.log(\"this.storeHasChanged() = \", this.storeHasChanged())\n\n        if (this.subnodeCount() === 0 || this.storeHasChanged()) {\n            this.defaultStore().collect()\n            this.setLastSyncTime(this.defaultStore().lastSyncTime())\n            this.refreshSubnodes()\n        }\n    }\n\n    store () {\n        return this.defaultStore()\n    }\n\n    refreshSubnodes () {\n        //this.debugLog(\" refreshSubnodes\")\n        this.removeAllSubnodes()\n        this.store().allPids().forEach((pid) => {\n            const aRecord = this.store().recordForPid(pid)\n            this.addRecord(aRecord)\n        })\n    }\n\n    subnodeForClassName (aClassName) {\n        let subnode = this.firstSubnodeWithTitle(aClassName)\n        if (!subnode) {\n            subnode = BaseNode.clone().setTitle(aClassName).setNoteIsSubnodeCount(true)\n            this.justAddSubnode(subnode)\n        }\n        return subnode\n    }\n\n    addRecord (aRecord) {\n        const subnode = BMDataStoreRecord.clone()\n        //subnode.setTitle(aRecord.type + \" \" + aRecord.id)\n        subnode.setTitle(aRecord.id)\n        subnode.setKey(aRecord.id)\n        subnode.setStore(this.store())\n        const size = JSON.stringify(aRecord).length\n        subnode.setSubtitle(size.byteSizeDescription())\n\n        const classNode = this.subnodeForClassName(aRecord.type)\n        classNode.justAddSubnode(subnode)\n\n        return this\n    }\n    \n}.initThisClass());\n",
  "ZFCfTwRY3+C7yeNu/FfITJntNd1keu2juu5LAMQ8QG8=": "\"use strict\";\n\n/*\n    \n    BMSummaryNode\n    \n    A node that contains Text, stores it's:\n        content, color, font, padding, margin\n    and has an inspector for these attributes\n    \n    support for links?\n\n*/\n\n(class BMSummaryNode extends BMStorableNode {\n    \n    initPrototypeSlots () {\n\n        {\n            const slot = this.newSlot(\"nodeSummarySuffix\", \" \")\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setCanInspect(true)\n            slot.setSlotType(\"String\")\n            slot.setLabel(\"suffix\")\n            slot.setInspectorPath(\"Summary\")\n            slot.setSyncsToView(true)\n        }\n\n        {\n            const slot = this.newSlot(\"nodeSubtitleIsChildrenSummary\", false)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setLabel(\"is children summary\")\n            slot.setInspectorPath(\"Subtitle\")\n            slot.setSyncsToView(true)\n        }\n\n        {\n            const slot = this.newSlot(\"hasNewlineAferSummary\", false)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setLabel(\"has new line ending\")\n            slot.setInspectorPath(\"Summary\")\n            slot.setSyncsToView(true)\n        }\n\n        {\n            const slot = this.newSlot(\"summaryFormat\", \"value\")\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setCanInspect(true)\n            slot.setSlotType(\"String\")\n            slot.setLabel(\"format\")\n            slot.setValidValues([\"none\", \"key\", \"value\", \"key value\", \"value key\"])\n            slot.setSyncsToView(true)\n            slot.setInspectorPath(\"Summary\")\n        }\n\n        {\n            const slot = this.overrideSlot(\"subtitleIsSubnodeCount\", false)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setLabel(\"is subnode count\")\n            slot.setInspectorPath(\"Subtitle\")\n            slot.setSyncsToView(true)\n        }\n\n        {\n            const slot = this.overrideSlot(\"noteIsSubnodeCount\", false)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setLabel(\"is subnode count\")\n            slot.setInspectorPath(\"Note\")\n            slot.setSyncsToView(true)\n        }\n    }\n\n    initPrototype () {\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(true)\n\n        this.setTitle(\"title\")\n    }\n\n    init () {\n        super.init()\n    }\n\n    didUpdateSlotSummaryFormat () {\n        this.didUpdateNode()\n    }\n\n    summaryKey () {\n        return this.title()\n    }\n\n    summaryValue () {\n        return this.subtitle()\n    }\n\n    subtitle () {\n        if (this.nodeSubtitleIsChildrenSummary()) {\n            return this.childrenSummary()\n        }\n\n        return super.subtitle()\n    }\n\n    didUpdateSlotNodeSubtitleIsChildrenSummary (oldValue, newValue) {\n        if (oldValue === true) {\n            this.setSubtitle(null)\n        }\n    }\n\n    // --- summary ---\n    \t\t\n    summary () {\n        const k = this.summaryKey()\n        let v = this.summaryValue()\n\n        if (Type.isNull(v)) {\n            v = \"\"\n        }\n\n        // make this optional? \n        if (v === \"\") {\n            return \"\"\n        }\n\n        const f = this.summaryFormat()\n        let end = this.nodeSummarySuffixOut()\n\n        if (this.hasNewlineAferSummary()) {\n            //end = \"<br>\"\n            end = \"\\n\"\n        }\n\n        if (f === \"key\") { \n            return k + end\n        }\n    \n        if (f === \"value\") { \n            return v + end\n        }\n\n        const j = \" \"\n\n        if (f === \"key value\") { \n            return k + j + v + end\n        }\n\n        if (f === \"value key\") { \n            return v + j + k + end\n        }\n\n        return \"\"\n    }\n        \n    childrenSummary () {\n        return this.subnodes().map(subnode => subnode.summary()).filter(s => s.length).join(\"\")\n    }\n\n    nodeSummarySuffixOut () {\n        let s = this._nodeSummarySuffix\n        \n        if (s === \"newline\") {\n            return \"<br>\"\n        } else {\n            s = s.replaceAll(\"<br>\", \"\")\n        }\n        \n        return s\n    }\n    \n}.initThisClass());\n\n",
  "IUvvW78V8wFS86aJYBki/TKJo76spvi/vK5zxtt8M0I=": "\"use strict\";\n\n/*\n    \n    BMFolderNode\n    \n    A node that supports for adding, reordering, etc other nodes to it within the UI.\n    \n*/\n\n(class BMFolderNode extends BMSummaryNode {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n    \n    initPrototypeSlots () {\n        // These slots are useful for implementing menus \n        {\n            const slot = this.newSlot(\"label\", \"\")\n            slot.setShouldStoreSlot(true)\n        }\n\n        {\n            const slot = this.newSlot(\"target\", null)\n        }\n\n        {\n            const slot = this.newSlot(\"methodName\", null)\n        }\n\n        {\n            const slot = this.newSlot(\"info\", null)\n        }\n    }\n\n    initPrototype () {\n        this.setCanDelete(true)\n        this.setNodeCanInspect(true)\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(true)\n\n        this.setTitle(\"title\")\n        this.setNodeCanEditTitle(true)\n        \n        this.setNodeCanReorderSubnodes(true)\n\n        this.setNodeCanInspect(true) \n        //this.setNoteIconName(\"right-arrow\")\n    }\n\n    init () {\n        super.init()\n        this.addAction(\"add\")\n        this.setSubnodeClasses(BMNode.primitiveNodeClasses())\n    }\n\n    title () {\n        return this.label()\n    }\n\n    setTitle (aString) {\n        this.setLabel(aString)\n        return this\n    }\n\n    acceptedSubnodeTypes () {\n        return BMCreatorNode.fieldTypes()\n    }\n\n    sendMenuAction () {\n       const t = this.target()\n       const m = this.methodName()\n\n       if (t && m && t[m]) {\n           t[m].apply(t, [this])\n       }\n    }\n\n    onTapOfNode (aNode) {\n        super.onTapOfNode()\n        this.sendMenuAction()\n        return this\n    }\n\n    didUpdateSlotParentNode (oldValue, newValue) {\n        this.scheduleSyncToView()\n    }\n\n}.initThisClass());\n\n",
  "21d9h8ImmCUE4S7z/u9wTJk4r3fhaLLOAgsg4seOq5M=": "\"use strict\";\n\n/*\n\n    BMImageNode\n    \n*/\n\n(class BMImageNode extends BMStorableNode {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"dataURL\", null)\n            slot.setShouldStoreSlot(true)\n        }\n    }\n\n    initPrototype () {\n        this.setNodeCanEditTitle(true)\n        this.setNodeCanEditSubtitle(false)\n        this.setTitle(\"Untitled\")\n        this.setSubtitle(null)\n        this.setCanDelete(true)\n    }\n\n    init () {\n        super.init()\n        this.addActions([\"add\"])\n    }\n    \n    onDidEditNode () {\n        this.debugLog(\" onDidEditNode\")\n    }\n    \n}.initThisClass());\n",
  "57Gd54WNogY23sZ+CDZ1qOpIYV+GdJWMWTrBf8V2dz8=": "\"use strict\";\n\n/*\n    \n    BMTextNode\n    \n    A node that contains Text, stores it's:\n        content, color, font, padding, margin\n    and has an inspector for these attributes\n    \n*/\n\n(class BMTextNode extends BMStorableNode {\n    static availableAsNodePrimitive () {\n        return true\n    }\n\n    initPrototypeSlots () {\n        /*\n        {\n            const slot = this.newSlot(\"nodeUrlLink\", \"\")\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n            slot.setSlotType(\"String\")\n            slot.setLabel(\"URL\")\n            //slot.setSyncsToView(true)\n            //slot.setInspectorPath(\"Style\")\n        }\n        */\n\n        {\n            const slot = this.newSlot(\"value\", \"...\")\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n            slot.setSlotType(\"String\")\n            slot.setLabel(\"value\")\n            slot.setSyncsToView(true)\n            //slot.setInspectorPath(\"Style\")\n        }\n    }\n\n    initPrototype () {\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(true)\n        this.setCanDelete(true)\n        this.setNodeCanInspect(true)\n\n        this.setTitle(\"title\")\n        this.setNodeCanEditTitle(true)\n        \n        this.setNodeCanReorderSubnodes(true)\n  \n        this.setNodeCanEditTileHeight(true)\n        this.setNodeCanEditColumnWidth(true)\n    }\n\n    /*\n    init () {\n        super.init()\n    }\n    */\n\n    acceptedSubnodeTypes () {\n        return []\n    }\n\n}.initThisClass());\n\n",
  "eeYNm5IDGTH0yHyGZ0xAO+rwVy22t0yZ0pfgawXbSV4=": "\"use strict\";\n\n/*\n    \n    BMLinkNode\n    \n    A node that to represent a link to another node, which is not a subnode\n    \n*/\n\n(class BMLinkNode extends BMSummaryNode {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"linkedNode\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"copyValue\")\n        }\n        \n        {\n            const slot = this.newSlot(\"willDuplicateLinkedObject\", false)\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setLabel(\"Will duplicate linked object\")\n        }\n    }\n\n    initPrototype () {\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(false)\n        this.setCanDelete(true)\n        this.setNodeCanInspect(true)\n        this.setNodeCanEditTitle(true)\n\n        this.setCanDelete(true)\n        this.setNodeCanInspect(true) \n    }\n\n    /*\n    init () {\n        super.init()\n    }\n    */\n\n    nodeAcceptsDrop (aNode) {\n        return true\n    }\n\n    nodeDropped (aNode) {\n        this.setLinkedNode(aNode)\n    }\n\n    duplicate () {\n        const obj = super.duplicate()\n        if (this.willDuplicateLinkedObject()) {\n            const ln = this.linkedNode()\n            if (ln) {\n                obj.setLinkedNode(ln.duplicate())\n            }\n        }\n        return obj\n    }\n\n    title () {\n        const ln = this.linkedNode()\n        if (ln) {\n            return ln.title()\n        }\n        return \"Unlinked\"\n    }\n\n    subtitle () {\n        const ln = this.linkedNode()\n        if (ln) {\n            return ln.subtitle()\n        }\n        return \"drop tile to link\"    \n    }\n\n    /*\n    title () {\n        if (Type.isNull(super.title()) && this.linkedNode()) {\n            return this.linkedNode().title()\n        }\n\n        return super.title()\n    }\n    */\n\n    acceptedSubnodeTypes () { \n        // TODO: have browser use nodeTileLink for this protocol?\n        return []\n    }\n    \n    note () {\n        if (this.linkedNode()) {\n            return this.linkedNode().note()\n        }\n\n        return null\n    }\n\n    noteIconName () {\n        //return this.nodeTileLink() ? \"double right caret\" : null\n        return null\n    }\n\n    nodeTileLink () {\n        return this.linkedNode()\n    }\n\n    nodeCanReorderSubnodes () {\n        const ln = this.linkedNode()\n        return ln ? ln.nodeCanReorderSubnodes() : false // have this operation done in the browser?\n    }\n\n    addSubnodeAt (aSubnode, anIndex) {\n        return super.addSubnodeAt(aSubnode, anIndex)\n    }\n\n}.initThisClass());\n\n",
  "b7xB7xBDOusHwHZWbRk2S4HaaiS/q/t/BGb2kTMQAvs=": "\"use strict\";\n\n/*\n\n    BMPrototypesNode\n \n \n\n*/\n\n(class BMPrototypesNode extends BMStorableNode {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        this.setTitle(\"Prototypes\")\n        this.setNodeCanReorderSubnodes(true)\n        //this.setupSubnodes()\n        return this\n    }\n\n    setupSubnodes () {\n        /*\n        let primitives = BMFolderNode.clone().setTitle(\"Primitives\")\n        primitives.setShouldStoreSubnodes(false)\n\n        this.addSubnode(primitives)\n\n        primitives.addSubnodes(this.primitiveSubnodes())\n        */\n        return this\n    }\n\n}.initThisClass());\n\n",
  "sUvKPNR6EkcXpKqSfwIrnJ62fks0eo43xhpL6/VlzRY=": "\"use strict\";\n\n/*\n\n    BMFieldSetNode\n\n    Useful for node's which are to be viewed and interacted with as forms\n    \n    child nodes are of type BMField and should only be added via addFieldNamed()\n    This method sets the target of the field to this and the method to the field name.\n                    \n    example use in subclass \n\n    in BMCustomFormNode class:\n    \n        init () {\n            super.init()\n\n            this.addFieldNamed(\"from\")\n            this.addFieldNamed(\"to\")\n            this.addFieldNamed(\"subject\")\n            this.addFieldNamed(\"body\").setNodeMinTileHeight(-1)\n\n            this.setActions([\"send\"])\n            this.setCanDelete(true)\n        }\n\n        ...\n\n*/  \n        \n(class BMFieldSetNode extends BMStorableNode {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"status\", \"\")\n        this.newSlot(\"isEditable\", true)\n    }\n\n    initPrototype () {\n        this.setShouldStoreSubnodes(false)\n    }\n\n    init () {\n        super.init()\n    }\n    \n    didUpdateField (aField) {\n        // override to implement hooks\n    }\n\t\n    // --- fields ---\n\n    addField (aField) {\n        aField.setTarget(this) \n        aField.getValueFromTarget()\n        this.addSubnode(aField)\n        return aField\n    }\n\n    addFieldNamed (name) {\t\n        const field = BMField.clone().setKey(name)\n        field.setTarget(this)\n        field.setValueMethod(name)\n        this.addStoredField(field)\n        return field\n    }\n    \n    fieldNamed (aName) {\n        return this.subnodes().detect( (subnode) => { \n            return subnode.valueMethod() === aName || subnode.key() === aName\n        })\n    }\n    \n    /*\n    valueForFieldNamed (aName) {\n        return this.fieldNamed(aName).value()\n    }\n    */\n\n    // --- validation ---\n\n    validate () {\n        return this.invalidSubnodes().length === 0\n    }\n\n    invalidSubnodes () {\n        return this.subnodes().select(subnode => !subnode.validate())\n    }\n\n    isValid () {\n        return this.validate() // could cache this later...\n    }\n\n}.initThisClass());\n",
  "0dxS5DJHj/jSU/kRc1cELys0ymKbBzTtXQH17sCgcxA=": "\"use strict\";\n\n/*\n\n    BMField\n\n    A BMStorageNode that has a key, value, and valueMethod (among other properties),\n    that's useful for automatically constructing a UI to interact with properties of a parent Node.\n    \n*/\n        \n\n(class BMField extends BMSummaryNode {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"isVisible\", true)\n        }\n\n        {\n            const slot = this.newSlot(\"isEnabled\", true)\n        }\n\n        // key\n        {\n            const slot = this.newSlot(\"key\", \"key\")\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"duplicate\")\n            slot.setCanInspect(true)\n            slot.setSlotType(\"String\")\n            slot.setLabel(\"key\")\n            slot.setInspectorPath(\"Key\")\n        }\n\n\n        {\n            const slot = this.newSlot(\"keyIsVisible\", true)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"duplicate\")\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setLabel(\"visible\")\n            slot.setInspectorPath(\"Key\")\n        }\n\n        {\n            const slot = this.newSlot(\"keyIsEditable\", false)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"duplicate\")\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setLabel(\"editable\")\n            slot.setInspectorPath(\"Key\")\n        }\n\n        // value\n        {\n            const slot = this.newSlot(\"value\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"duplicate\")\n        }\n\n        {\n            const slot = this.newSlot(\"valueIsVisible\", true)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"duplicate\")\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setLabel(\"visible\")\n            slot.setInspectorPath(\"Value\")\n        }\n\n        {\n            const slot = this.newSlot(\"valueIsEditable\", true)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"duplicate\")\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setLabel(\"editable\")\n            slot.setInspectorPath(\"Value\")\n        }\n\n        this.newSlot(\"link\", null)\n        this.newSlot(\"ownsLink\", null)\n\n        {\n            const slot = this.newSlot(\"valuePrefix\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"duplicate\")\n        }\n\n        {\n            const slot = this.newSlot(\"valuePostfix\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"duplicate\")\n        }\n\n        {\n            const slot = this.newSlot(\"valueMethod\", null).setDuplicateOp(\"duplicate\")\n        }\n        \n        {\n            const slot = this.newSlot(\"noteMethod\", null)  // fetches note from a parent node method\n        }\n        \n        {\n            const slot = this.newSlot(\"keyError\", null).setSyncsToView(true)\n        }\n        \n        {\n            const slot = this.newSlot(\"valueError\", null).setSyncsToView(true)\n        }\n        \n        {\n            const slot = this.newSlot(\"target\", null)\n        }\n    }\n\n    initPrototype () {\n        this.setShouldStore(true)\n    }\n\n    didLoadFromStore () {\n        super.didLoadFromStore()\n        this.validate()\n    }\n\n    static nodeCreate () {\n        const newNode = super.nodeCreate()\n\n        if (newNode.setKeyIsEditable) {\n            newNode.setKeyIsEditable(true)\n            newNode.setValueIsEditable(true)\n        }\n\n        if (newNode.setIsEditable) {\n            newNode.setIsEditable(true)\n        }\n\n        newNode.setNodeCanInspect(true)\n        newNode.setNodeCanEditTitle(true)\n        return newNode\n    }\n\n    title () {\n        return this.key()\n    }\n\n    /*\n    target () {\n        assert(!Type.isNull(this._target)) \n\n        if (this._target) {\n            return this._target\n        }\n\t\t\n        return this.parentNode() // we can't do this because we want to support free floating Fields\n    }\n    */\n\n    /*\n    setKey (newValue) {\n        this._key = newValue\n        return this\n    }\n    */\n\n    didUpdateSlotValue (oldValue, newValue) {  // setValue() is called by View on edit\n        if (this.target() && this.valueMethod()) {\n            this.setValueOnTarget(newValue)\n        } else {\n            this.validate()\n        }\n\n        this.didUpdateNode()\n    }\n\n    setValueOnTarget (v) { // called by View on edit\n        //console.log(\"setValue '\" + v + \"'\")\n        const target = this.target()\n        const setter = this.setterNameForSlot(this.valueMethod())\n\n        v = this.normalizeThisValue(v)\n        \n        if (target[setter]) {\n            target[setter].apply(target, [v])\n            target.didUpdateNode()\n            this.validate()\n        } else {\n            console.warn(this.type() + \" target \" + target.type() + \" missing slot '\" + setter + \"'\")\n        }\n\t\t\n        return this\n    }\n\t\n    normalizeThisValue (v) {\n\t    return v\n    }\n\t\n    value () {\n        if (this.target()) {\n            this._value = this.getValueFromTarget()\n        }\n        return this._value\n    }\n\n    getValueFromTarget () {\n        const target = this.target()\n        const slotName = this.valueMethod()\n\n        //console.log(\"target = \" + target.type() + \" getter = '\" + getter + \"'\")\n        if (target[slotName]) {\n            const value = target[slotName].apply(target)\n            return value\n        } else {\n            console.warn(this.type() + \" target \" + target.type() + \" missing slot '\" + slotName + \"'\")\n        }\n\n        return null\n    }\n\t\n    note () {\n        const target = this.target()\n        const slotName = this.noteMethod()\n\n        if (target && slotName) {\n            if (target[slotName]) {\n                return target[slotName].apply(target)\n            } else {\n                console.warn(this.type() + \" target \" + target.type() + \" missing note getter slot '\" + slotName + \"'\")\n            }\n        }\n        return null\n    }\n\t\n    didUpdateView (aFieldView) {        \n        let parentNode = this.parentNode()\n        if (!parentNode) {\n            parentNode = this.target()\n        }\n\n        if (parentNode.didUpdateField) {\n            parentNode.didUpdateField(this)\n        }\n        \n        return this\n    }\n\t\n    visibleValue () {\n        return this.value()\n    }\n\n    validate () {\n        // subclasses should override if needed\n        return true\n    }\n\t\n    nodeTileLink () {\n        return null\n    }\n\n    summaryKey () {\n        return this.key()\n    }\n\n    summaryValue () {\n        return this.value()\n    }\n\n    setNodeSummaryShowsKey () {\n    }\n\n    setNodeSummaryShowsValue () {\n    }\n\n    jsonArchive () {\n        return this.value()\n    }\n\n    setJson (json) {\n        this.setValue(json) \n        return this\n    }\n    \n}.initThisClass());\n",
  "qNg9j7HO4h5qo6ukFYk9fOATwsxu1czYJACY+ynqFss=": "\"use strict\";\n\n/*\n\n    BMActionNode\n    \n    An abstraction of a UI visible action that can be performed on an object.\n    the value is the action method name, the target is the field owner.\n\n*/\n\n(class BMActionNode extends BMStorableNode {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n    \n    initPrototypeSlots () {\n        this.overrideSlot(\"title\", null).setShouldStoreSlot(true).setCanInspect(true).setSlotType(\"String\").setLabel(\"Title\")\n\n        this.newSlot(\"methodName\", null).setShouldStoreSlot(true)\n        this.newSlot(\"info\", null).setShouldStoreSlot(true)\n        this.newSlot(\"isEnabled\", true).setShouldStoreSlot(true)\n        this.newSlot(\"isEditable\", false).setShouldStoreSlot(true)\n        this.newSlot(\"target\", null)\n    }\n\n    initPrototype () {\n        this.setShouldStore(true)\n        this.setNodeTileIsSelectable(true)\n        this.setNodeCanInspect(true)\n    }\n\n    init () {\n        super.init()\n    }\n\n    setTitle (s) {\n        super.setTitle(s)\n        return this\n    }\n\n    canDoAction () {\n        const t = this.target()\n        const m = this.methodName()\n        return t && t[m]\n    }\n\n    doAction () {\n        if (this.canDoAction()) {\n            const func = this.target()[this.methodName()]\n            \n            if (Type.isFunction(func)) {\n                func.call(this.target(), this)\n            } else {\n                //this.setValueError(\"no method with this name\")\n                console.warn(\"no method with this name\")\n            }\n        } else {\n            this.debugLog(\" can't perform action \", this.methodName(), \" on \", this.target())\n        }\n\t    \n\t    return this\n    }\n    \n}.initThisClass());\n",
  "GqhZwCCqyBEOZuYr/wil0Blymx6z5qLNKU8bfnlBMZo=": "\"use strict\";\n\n/*\n\n    BMJsonNode\n    \n\n*/\n        \n(class BMJsonNode extends BMStorableNode {\n    \n    static canOpenMimeType (mimeType) {\n        return mimeType === \"application/json\"\n    }\n\n    static openMimeChunk (dataChunk) {\n        const data = dataChunk.decodedData()\n        //console.log(\"data = '\" + data + \"'\")\n        let json = null\n\n        try {\n            json = JSON.parse(data)\n            //console.log(\"drop json = \" + JSON.stringify(json, 2, 2) + \"\")\n        } catch (error) {\n            // return an error node instead?\n        }\n\n        const aNode = this.nodeForJson(json)\n        return aNode\n    }\n\n    jsonClasses () {\n        return [BMJsonArrayNode, BMBooleanField, BMJsonNullField, BMNumberField, BMJsonDictionaryNode, BMStringField]\n    }\n    \n\n    static jsonToProtoNameDict () {\n        return {\n            \"Array\"   : \"BMJsonArrayNode\",\n            \"Boolean\" : \"BMBooleanField\",\n            \"Null\"    : \"BMJsonNullField\",\n            \"Number\"  : \"BMNumberField\",\n            \"Object\"  : \"BMJsonDictionaryNode\",\n            \"String\"  : \"BMStringField\",\n        }\n    }\n    \n    static nodeForJson(json) {\n        const t = Type.typeName(json)\n        const protoName = this.jsonToProtoNameDict()[t]  \n        if (protoName) {\n            const proto = Object.getClassNamed(protoName)\n            if (proto) {\n                const instance = proto.clone().setJson(json)\n                return instance\n            }\n        }\n\n        return null\n    }\n\n    init () {\n        super.init()\n        this.setNodeCanEditTitle(true)\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(true)\n        this.setNodeCanReorderSubnodes(true)\n        this.setCanDelete(true)\n        this.setNoteIconName(\"right-arrow\")\n\n        this.addAction(\"add\")\n        this.setSubnodeClasses(this.jsonClasses())\n        this.setTitle(\"JSON\")\n    }\n\n    \n}.initThisClass());\n",
  "lENNcaxNX75PdNYNgFoKBpJYYOejLeDzZe/NLn+fUkk=": "\"use strict\";\n\n/*\n\n    BMJsonArrayNode\n    \n\n*/\n        \n(class BMJsonArrayNode extends BMJsonNode {\n    \n    static canOpenMimeType (mimeType) {\n        return false\n    }\n\n    static availableAsNodePrimitive () {\n        return true\n    }\n    \n    initPrototypeSlots () {\n    }\n\n    /*\n    init () {\n        super.init()\n    }\n    */\n\n    subtitle () {\n        return \"Array\"\n    }\n\n    // --------------\n\n    replaceSubnodeWith (oldNode, newNode) {\n        newNode = this.prepareSubnode(newNode)\n        return super.replaceSubnodeWith(oldNode, newNode)\n    }\n\n    addSubnodeAt (aSubnode, anIndex) {\n        return super.addSubnodeAt(this.prepareSubnode(aSubnode), anIndex)\n    }\n\n    prepareSubnode (aSubnode) {\n        aSubnode.setCanDelete(true)\n\n        if (aSubnode.keyIsVisible) {\n            aSubnode.setKey(\"\")\n            aSubnode.setKeyIsVisible(false)\n            aSubnode.setKeyIsEditable(false)\n            const editableValueTypes = [\"BMStringField\", \"BMNumberField\", \"BMBooleanField\"]\n            if (editableValueTypes.contains(aSubnode.type())) {\n                aSubnode.setValueIsEditable(true)\n            }\n         }\n\n        //aSubnode.setTitle(null)\n        aSubnode.setNodeCanEditTitle(false)\n        return aSubnode\n    }\n\n    // -------\n\n    jsonArchive () {\n        return this.subnodes().map(sn => sn.jsonArchive())\n    }\n\n    setJson (json) {\n        let index = 0\n        json.forEach((v) => {\n            const aNode = BMJsonNode.nodeForJson(v)\n            //aNode.setTitle(index)\n            this.addSubnode(aNode)\n            index ++\n        })\n        return this\n    }\n\n    getBMDataUrl () {\n        //const json = this.node().copyArchiveDict() \n        const json = this.jsonArchive() \n        const bdd = BMDataUrl.clone()\n        bdd.setMimeType(\"application/json\")\n        bdd.setFileName(this.title() + \".json\")\n        bdd.setDecodedData(JSON.stringify(json, null, 4))\n        return bdd\n    }\n    \n}.initThisClass());\n",
  "RySpdjIDdaO0BrYbF7k7jOu1gTbXHfZzcdXDr/sn14U=": "\"use strict\";\n\n/*\n\n    BMJsonDictionaryNode\n    \n\n*/\n        \n(class BMJsonDictionaryNode extends BMJsonNode {\n    \n    static canOpenMimeType (mimeType) {\n        return false\n    }\n\n    initPrototypeSlots () {\n        this.setNodeCanEditTitle(true)\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(true)\n        this.setNodeCanReorderSubnodes(true)\n        this.setCanDelete(true)\n        this.setNoteIconName(\"right-arrow\")\n    }\n\n    init () {\n        super.init()\n    }\n\n    subtitle () {\n        return \"Dictionary\"\n    }\n\n    // ------------------------------\n\n    setJson (json) {\n        json.ownForEachKV((k, v) => {\n            const aNode = this.thisClass().nodeForJson(v)\n            aNode.setTitle(k)\n            if (aNode.setKey) {\n                aNode.setKey(k)\n            }\n            this.addSubnode(aNode)\n        })\n        return this\n    }\n\n    // ----------\n\n    addSubnodeAt (newNode, anIndex) {\n        newNode = this.prepareSubnode(newNode)\n        return super.addSubnodeAt(this.prepareSubnode(newNode), anIndex)\n    }\n\n    replaceSubnodeWith (oldNode, newNode) {\n        newNode = this.prepareSubnode(newNode)\n        return super.replaceSubnodeWith(oldNode, newNode)\n    }\n\n    prepareSubnode (aSubnode) {\n        aSubnode.setCanDelete(true)\n\n        if (aSubnode.keyIsVisible) {\n            aSubnode.setKeyIsVisible(true)\n            aSubnode.setKeyIsEditable(true)\n        }\n\n        aSubnode.setNodeCanEditTitle(true)\n        return aSubnode\n    }\n\n    // ------------\n\n    jsonArchive () {\n        const dict = {}\n        this.subnodes().forEach((sn) => {\n            const key = sn.key ? sn.key() : sn.title()\n            const value = sn.jsonArchive()\n            dict[key] = value\n        })\n        return dict\n    }\n\n    getBMDataUrl () {\n        const json = this.jsonArchive() \n        const bdd = BMDataUrl.clone()\n        bdd.setMimeType(\"application/json\")\n        bdd.setFileName(this.title() + \".json\")\n        bdd.setDecodedData(JSON.stringify(json, null, 4))\n        return bdd\n    }\n    \n}.initThisClass());\n",
  "mfRjIL9i18BLjwvneWBCtdV/H48vVG01D3jyCaE8rro=": "\"use strict\";\n\n/*\n\n    BMJsonNullField\n    \n\n*/\n        \n(class BMJsonNullField extends BMField {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        this.setNodeCanEditTitle(true)\n        this.setNodeCanEditSubtitle(false)\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(false)\n        this.setNodeCanReorderSubnodes(false)\n        this.setCanDelete(true)\n        //this.setNoteIconName(\"right-arrow\")\n\n        this.setKeyIsVisible(false)\n        this.setValue(\"NULL\")\n        //this.setValueIsEditable(false)\n        //this.overrideSlot(\"valueIsEditable\", false).setInitValue(false)\n    }\n\n    jsonArchive () {\n        return null\n    }\n\n    setJson (json) {\n        return this\n    }\n\n\n    setValueIsEditable (aBool) {\n        /*\n        if (aBool) {\n            console.log(this.type() + \" setValueIsEditable true\")\n        }\n        */\n        return super.setValueIsEditable(false)\n    }\n    \n}.initThisClass());\n",
  "30xp4rBKC9PmkiwZ7cYzZhpAVDZyv0LWEZyDdR2SLuk=": "\"use strict\";\n\n/*\n\n    BMCreatorNode\n    \n    A stand-in node that let's the user select field to replace it with.\n\n*/\n        \n(class BMCreatorNode extends BMStorableNode {\n    \n    initPrototypeSlots () {\n        this.overrideSlot(\"subnodes\").setShouldStoreSlot(false)\n        this.newSlot(\"typeChoices\", []).setInitProto(Array)\n    }\n\n    init () {\n        super.init()\n        this.setNodeCanEditTitle(false)\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(false)\n        this.setNodeCanReorderSubnodes(false)\n        this.setCanDelete(true)\n        this.setNoteIconName(\"right-arrow\")\n        this.setTitle(\"Chose type\")\n    }\n\n    prepareForFirstAccess () {\n        super.prepareForFirstAccess()\n        this.setupSubnodes()\n    }\n\n    static fieldTypes () {\n        return [\n            \"BMActionNode\", \n            \"BMBooleanField\", \n            \"BMDateNode\",\n            \"BMImageWellField\", \n            \"BMJsonDictionaryNode\",\n            \"BMJsonArrayNode\",\n            \"BMFolderNode\", \n            \"BMNumberField\", \n            \"BMOptionsNode\",\n            \"BMStringField\",\n            \"BMTextAreaField\",\n            //\"BMTextNode\",\n            \"BMTimeNode\",\n            \"BMLinkNode\",\n            \"BMUrlField\",\n        ]\n    }\n\n    protoObjects () {\n        return []\n        /*\n        const app = this.rootNode()\n        const protosNode = app.firstSubnodeWithTitle(\"Prototypes\")\n        const protos = protosNode.subnodes()\n        return protos\n        */\n    }\n\n    setupSubnodes () {\n        if (this.subnodes().length == 0) {\n            this.addSubnodesForObjects(BMNode.primitiveNodeClasses())\n            //this.addSubnodesForObjects(this.protoObjects())\n        }\n        return this\n    }\n    \n    addSubnodesForObjects (objects) {\n        const newSubnodes = objects.map((aClass) => {\n            const newNode = BMFolderNode.clone()\n            newNode.setTitle(aClass.nodeCreateName())\n            newNode.setNodeCanEditTitle(false)\n            newNode.setNodeCanEditSubtitle(false)\n            newNode.setNoteIconName(null)\n            newNode.setTarget(this).setMethodName(\"didChoose\").setInfo(aClass)\n            newNode.setCanDelete(false)\n            return newNode\n        })\n        this.addSubnodes(newSubnodes)\n    }\n\n   didChoose (actionNode) {\n        const obj = actionNode.info()\n        const newNode = obj.nodeCreate()\n        newNode.setCanDelete(true)\n        this.replaceSelfWithNode(newNode)\n        return this\n   }\n\n    replaceSelfWithNode (newNode) {\n        const parentNode = this.parentNode()\n        assert(parentNode)\n        parentNode.replaceSubnodeWith(this, newNode)\n        parentNode.postShouldFocusAndExpandSubnode(newNode) \n    }\n\n    nodeSummary () {\n        return \"\"\n    }\n    \n}.initThisClass());\n",
  "d8uxKdQkCvJm+4AJlqiIgOMxoguaDIkO5P+FJSmtt5I=": "\"use strict\";\n      \n/*\n\n    BMBooleanField\n\n    \n*/\n\n(class BMBooleanField extends BMField {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n    \n    initPrototypeSlots () {\n        this.newSlot(\"unsetVisibleValue\", \"unset\")\n    }\n\n    init () {\n        super.init()\n        this.setKeyIsEditable(false)\n        this.setValueIsEditable(false)\n        this.setValue(false) // why was this commented out?\n    }\n\n    valueIsBool () {\n        const b = this.value()\n        return Type.isBoolean(b);\n    }\n\t\n    validate () {\n        const isValid = this.valueIsBool()\n\t\t\n        if (!isValid) {\n            this.setValueError(\"This needs to be a boolean (true or false).\")\n        } else {\n            this.setValueError(null)\n        } \n\t\t\n        return isValid\n    }\n\t\n    normalizeThisValue (v) {\n\t    if (v === true || v === \"t\" || v === \"true\" | v === 1) { return true; }\n\t    return false\n    }\n\t\n    didUpdateNode () {\n        this.validate()\n        return super.didUpdateNode()\n    }\n\n    jsonArchive () {\n        return this.value() ? true : false\n    }\n\n    setJson (json) {\n        assert(Type.isBoolean(json))\n        this.setValue(json) \n        return this\n    }\n\n}.initThisClass());\n",
  "PdYoHUIJLYAaaOc7xisAQG/L9Jihdv6ii1npe6uYIJ4=": "\"use strict\";\n\n/*\n\n    BMColorField\n    \n*/\n\n(class BMColorField extends BMField {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"red\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Number\")\n        }\n\n        {\n            const slot = this.newSlot(\"green\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Number\")\n        }\n\n        {\n            const slot = this.newSlot(\"blue\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Number\")\n        }\n\n        {\n            const slot = this.newSlot(\"alpha\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Number\")\n        }\n    }\n\n    initPrototype () {\n        this.setNodeCanEditTitle(true)\n        this.setNodeCanEditSubtitle(false)\n        this.setTitle(\"color\")\n        this.setSubtitle(null)\n        this.setCanDelete(true)\n        this.setNodeCanInspect(true) \n    }\n\n    init () {\n        super.init()\n        this.addActions([\"add\"])\n    }\n\n    asCssColor () {\n        return CssColor.clone().set(this.red(), this.green(), this.blue(), this.alpha())\n    }\n\n    fromCssColor (aCssColor) {\n        return this\n    }\n    \n}.initThisClass());\n",
  "QyRp/yvaUh/Z3Vsm0iIcaZoPH5OHsJXrDEuePQ+3JL0=": "\"use strict\";\n\n/*\n\n    BMIdentityField\n\n*/\n\n(class BMIdentityField extends BMField {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setKeyIsEditable(false)\n        this.setValueIsEditable(false)\n    }\n\n    validate () {\n        if (!bitcore.PublicKey.isValid(this.value())) {\n            this.setValueError(\"invalid address\")\n        } else {\n            this.setValueError(null)\n        }\n    }\n\t\n    setValue (inValue) { // called by View on edit\n        if (Type.isNull(inValue)) {\n            console.log(\"WARNING: \" + this.type() + \" setValue(null)\")\n            return this\n        }\n\t    //console.log(\"inValue = '\" + inValue + \"'\")\n\t    let newValue = inValue.strip()\n\t    \n        const parts = newValue.split(\" \").concat(newValue.split(\"\\n\")).concat(newValue.split(\",\"))\n\t    //console.log(\"parts = '\", parts)\n        const validPart = parts.detect((part) => { return bitcore.PublicKey.isValid(part) })\n\n        if (validPart) {\n            newValue = validPart\n        }\n\n        if (inValue !== newValue) {\n            this.scheduleSyncToView() \n        }\n        \n        //console.log(\"newValue = '\" + newValue + \"'\")\n        super.setValue(newValue)\n\t\t\n        return this\n    }\n\n}.initThisClass());\n",
  "lT1k4kVdvMkISvZIf7GmQeorYk6ZlHZzTuc1zCCaj5w=": "\"use strict\";\n\n/*\n\n    BMImageWellField\n\n*/\n        \n(class BMImageWellField extends BMField {\n\n    static availableAsNodePrimitive () {\n        return true\n    }\n    \n    static supportedMimeTypes () {\n        return new Set([\"image/jpeg\", \"image/gif\", \"image/png\"])\n    }\n\n    static canOpenMimeType (mimeType) {\n        return this.supportedMimeTypes().has(mimeType)\n    }\n\n    static openMimeChunk (dataChunk) {\n        const newNode = this.clone()\n        newNode.setValue(dataChunk.dataUrl())\n        //newNode.setValue(dataChunk.decodedData())\n        newNode.setKeyIsEditable(true)\n        newNode.setValueIsEditable(true)\n        newNode.setCanDelete(true)\n        return newNode\n    }\n\n    initPrototypeSlots () {\n        this.newSlot(\"onlyShowsKeyWhenEmpty\", false)\n        this.newSlot(\"isEditable\", true)\n        \n        this.overrideSlot(\"nodeMinTileHeight\").setShouldStoreSlot(true)\n    }\n\n    initPrototype () {\n        this.setKey(\"Image title\")\n        this.setKeyIsEditable(false)\n        this.setValueIsEditable(false)\n        this.setNodeCanEditTileHeight(true)\n    }\n\n    init () {\n        super.init()\n    }\n\n    summaryValue () {\n        return \"\"\n    }\n   \n}.initThisClass());\n",
  "wKfhUgtN3tCJOIHDfhjmylwavmReTnws3iVA9bsLr7A=": "\"use strict\";\n\n/*\n\n    BMNumberField\n\n    A named number field that validates that the \n    value is a number and shows an appropraite error message.\n\n*/\n        \n(class BMNumberField extends BMField {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"unsetVisibleValue\", \"unset\")\n        }\n\n        {\n            const slot = this.newSlot(\"isInteger\", false)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setSlotType(\"Boolean\")\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n            slot.setCanEditInspection(true)\n            slot.setLabel(\"Is integer\")\n            slot.setInspectorPath(\"Number\")\n            //slot.setSyncsToView(true)\n        }\n\n        {\n            const slot = this.newSlot(\"hasLimits\", false)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setSlotType(\"Boolean\")\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n            slot.setCanEditInspection(true)\n            slot.setLabel(\"Has limits\")\n            slot.setInspectorPath(\"Number\")\n            //slot.setSyncsToView(true)\n        }\n\n        {\n            const slot = this.newSlot(\"minValue\", 0)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setSlotType(\"Number\")\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n            slot.setCanEditInspection(true)\n            slot.setLabel(\"Min Value\")\n            slot.setInspectorPath(\"Number\")\n            //slot.setSyncsToView(true)\n        }\n\n        {\n            const slot = this.newSlot(\"maxValue\", 1)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setSlotType(\"Number\")\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n            slot.setCanEditInspection(true)\n            slot.setLabel(\"Max value\")\n            slot.setInspectorPath(\"Number\")\n            //slot.setSyncsToView(true)\n        }\n    }\n\n    // --- \n    // TODO: \n    // - add a Slot.validatorMethod or methodHook so this can be done dynamically?\n\n    didUpdateSlotIsInteger () {\n        this.validate()\n    }\n\n    didUpdateSlotHasLimits () {\n        this.validate()\n    }\n\n    didUpdateSlotMinValue () {\n        this.validate()\n    }\n\n    didUpdateSlotMaxValue () {\n        this.validate()\n    }\n    \n\n    // ----\n\n    init () {\n        super.init()\n        this.setKey(\"Number title\")\n        this.setKeyIsEditable(false)\n        this.setValueIsEditable(true)\n        this.setValue(0)\n    }\n\n    setValue (v) {\n        super.setValue(Number(v))\n        return this\n    }\n\n    valueIsNumeric () {\n        const n = this.value()\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\t\n    validate () {\n        const v = Number(this.value())\n        const errors = []\n        \n        if (!this.valueIsNumeric()) {\n            errors.push(\"This needs to be a number.\")\n        }\n\n        if (this.hasLimits()) {\n            if (v < this.minValue()) {\n                errors.push(\"Must be >= \" + this.minValue() + \".\")\n            }\n            if (v > this.maxValue()) {\n                errors.push(\"Must be <= \" + this.maxValue() + \".\")\n            }\n        }\n\n        if (this.isInteger()) {\n            if (!Number.isInteger(v)) {\n                errors.push(\"Must be an integer.\")\n            }\n        }\n\n        if (errors.length) {\n            this.setValueError(errors.join(\"\\n\"))\n        } else {\n            this.setValueError(null)\n        }\n        \n        const isValid = this.valueError() === null\n        return isValid\n    }\n    \n}.initThisClass());\n",
  "dQ3BubLCMvAwzvLIR18PDzrPjiPkDi8IPc5wALq7neI=": "\"use strict\";\n\n/*\n\n    BMPointerField\n\n    A field that's a pointer to another node.\n  (sometimes the other node is used as a list of items, but not always)\n\n*/\n        \n(class BMPointerField extends BMField {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setKeyIsEditable(false)\n        this.setValueIsEditable(false)\n        this.setKeyIsVisible(true)\n        this.setValueIsVisible(true)\n        this.setNodeTileIsSelectable(true)\n    }\n\n    /*\n    setValue (v) {\n        console.warn(\"WARNING: BMPointerField setValue '\" + v + \"'\")\n        return this\n    }\n    */\n\n    title () {\n        return this.value().title()\n    }\n\t\n    subtitle () {\n        return this.value().subtitle()\n    }\n\t\n    note () {\n        return this.value().note()\n    }\n\t\n    nodeTileLink () {\n        return this.value()\n    }\n\n}.initThisClass());\n",
  "kpmQcrwBLBFBNGyTPoAkAfFKBeQtVg/uubKUVQS0/Y8=": "\"use strict\";\n\n/*\n\n    BMStampField\n\n*/\n\n(class BMStampField extends BMField {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        //this.setKeyIsVisible(false)\n        //this.setKey(\"drop images here\")\n        this.setKeyIsEditable(false)\n        this.setValueIsEditable(false)\n    }\n    \n}.initThisClass());\n",
  "XeZWNzCPq0Pi4ko39W/ZpXWX9rWKFSxyp0i//2GWY2U=": "\"use strict\";\n\n/*\n\n    BMStringField\n\n*/\n        \n(class BMStringField extends BMField {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n\n    initPrototypeSlots () {\n        this.newSlot(\"unsetVisibleValue\", \"\")\n    }\n\n    initPrototype () {\n\n    }\n\n    init () {\n        super.init()\n        this.setKey(\"String title\")\n\n        this.setKeyIsVisible(true)\n        this.setKeyIsEditable(true)\n\n        this.setValueIsVisible(true)\n        this.setValueIsEditable(true)\n    }\n    \n}.initThisClass());\n",
  "vRAUw2Rfoa9yPks5UQEZbKR9Ir85N5xg1S4UusMaXGs=": "\"use strict\";\n\n/*\n\n    BMTextAreaField\n    \n*/\n\n(class BMTextAreaField extends BMField {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n\n    static canOpenMimeType (mimeType) {\n        return mimeType.startsWith(\"text/plain\")\n    }\n\n    static openMimeChunk (dataChunk) {\n        const newNode = this.clone()\n        newNode.setValue(dataChunk.decodedData())\n        newNode.setKeyIsEditable(true)\n        newNode.setValueIsEditable(true)\n        newNode.setCanDelete(true)\n        return newNode\n    }\n\n    initPrototypeSlots () {\n        this.newSlot(\"isMono\", false)\n    }\n\n    init () {\n        super.init()\n        this.setKeyIsVisible(false)\n    }\n    \n}.initThisClass());\n",
  "xMb2li+HUb61+9C+DDsHeQf42TldmXx2RLvywAn9Uuk=": "\"use strict\";\n\n/*\n\n    BMUrlField\n    \n*/\n\n(class BMUrlField extends BMField {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n\n    static canOpenMimeType (mimeType) {\n        return mimeType.startsWith(\"text/uri-list\")\n    }\n\n    static openMimeChunk (dataChunk) {\n        const newNode = this.clone()\n        const uris = dataChunk.decodedData().split(\"\\n\")\n        const uri = uris.first()\n\n        try {\n            const url = new URL(uri)\n            newNode.setKey(url.hostname)\n            const path = url.pathname\n            const p = path.fileName()\n            if (p) {\n                newNode.setKey(p)\n            }\n        } catch (error) {\n            newNode.setKey(\"?\")\n        }\n\n        newNode.setValue(uri)\n        newNode.setValueIsVisible(false)\n\n        return newNode\n    }\n\n    initPrototypeSlots () {\n        // scheme : // userinfo @host : port / path ? query # fragment\n        this.newStringSlotNamed(\"href\", \"\")\n        \n        this.newStringSlotNamed(\"protocol\", \"http\")\n        this.newStringSlotNamed(\"username\", \"\")\n        this.newStringSlotNamed(\"password\", \"\")\n        this.newStringSlotNamed(\"hostname\", \"hostname\")\n        this.newStringSlotNamed(\"port\", \"\")\n        this.newStringSlotNamed(\"pathname\", \"\")\n        this.newStringSlotNamed(\"search\", \"\")\n        this.newStringSlotNamed(\"hash\", \"\")\n        this.newSlot(\"isUpdatingHref\", false)\n    }\n\n    /*\n    initSlots () {\n        debugger;\n        super.initSlots()\n        assert(this.directSetProtocol)\n    }\n*/\n\n    newStringSlotNamed (slotName, defaultValue) {\n        //debugger\n        const slot = this.newSlot(slotName, defaultValue)\n        //slot.setShouldStoreSlot(true)\n        slot.setOwnsSetter(true)\n        slot.setDoesHookSetter(true)\n        slot.setDuplicateOp(\"copyValue\")\n        slot.setCanInspect(true)\n        slot.setSlotType(\"String\")\n        slot.setLabel(slotName.capitalized())\n        slot.setInspectorPath(\"URL\")\n\n        if (slotName !== \"href\") {\n            //slot.setCanEditInspection(false)\n        }\n        return slot\n    }\n\n    init () {\n        super.init()\n\n        this.setKey(\"Link\")\n        this.setKeyIsVisible(true)\n        this.setKeyIsEditable(true)\n\n        this.setValueIsEditable(true)\n        this.setValueIsVisible(true)\n\n        this.setCanDelete(true)\n\n        this.setNodeCanInspect(true)\n    }\n\n    nodeInspector () {\n        return super.nodeInspector()\n    }\n\n    urlFromValue () {\n        const s = this.value()\n        if (s.trim() === \"\") {\n            return null\n        }\n        \n        try {\n            const url = new URL(s)\n            return url\n        } catch (e) {\n            //this.setError(e.message)\n        }\n        return null\n    }\n\n    didUpdateSlotValue () {\n        this.parseValue()\n    }\n\n    didUpdateSlotHref () {\n        this.setIsUpdatingHref(true)\n        this.setValue(this.href())\n        this.parseValue()\n        this.setIsUpdatingHref(false)\n    }\n\n    // slots\n\n    scheduleUnparse () {\n        if (this.hasDoneInit()) {\n            //this.scheduleSelfFor(\"unparseValue\")\n            this.unparseValue()\n        }\n    }\n    \n    didUpdateSlotProtocol () {\n        this.scheduleUnparse()\n    }\n\n    didUpdateSlotUsername () {\n        this.scheduleUnparse()\n    }\n\n    didUpdateSlotPassword () {\n        this.scheduleUnparse()\n    }\n\n    didUpdateSlotHostName () {\n        this.scheduleUnparse()\n    }\n\n    didUpdateSlotPort () {\n        this.scheduleUnparse()\n    }\n\n    didUpdateSlotPathname () {\n        this.scheduleUnparse()\n    }\n\n    didUpdateSlotSearch () {\n        this.scheduleUnparse()\n    }\n\n    didUpdateSlotHash () {\n        this.scheduleUnparse()\n    }\n    \n    // parse / unparse\n\n    parseValue () {\n        // set slots using the value\n        const url = this.urlFromValue()\n        if (!url) {\n            return this\n        }\n        \n        this.directSetProtocol(url.protocol)\n        this.directSetUsername(url.username)\n        this.directSetPassword(url.password)\n        this.directSetHostname(url.hostname)\n        this.directSetPort(url.port)\n        this.directSetPathname(url.pathname)\n        this.directSetSearch(url.search)\n        this.directSetHash(url.hash)\n        this.directSetHref(url.href)\n        \n        return this\n    }\n\n    urlFromComponents () {\n        const url = new URL(\"http://test.com\")\n        url.protocol = this.protocol()\n        url.username = this.username()\n        url.password = this.password()\n        url.hostname = this.hostname()\n        url.port = this.port()\n        url.pathname = this.pathname()\n        url.search = this.search()\n        url.hash = this.hash()\n        return url \n    }\n\n    unparseValue () {\n        // set the value using the slots\n        const url = this.urlFromComponents()\n        this.directSetHref(url.href)\n        //this.directSetValue(url.href)\n        return this\n    }\n\n    nodeUrlLink () {\n        return this.value()\n    }\n\n    validate () {\n        const isValid = this.valueIsValidUrl()\n\t\t\n        if (!isValid) {\n            this.setValueError(\"Invalid URL\")\n        } else {\n            this.setValueError(null)\n        } \n\t\t\n        return isValid\n    }\n\n    valueIsValidUrl () {\n        //debugger\n        if (Type.isNullOrUndefined(this.value())) {\n            this.setValue(\"\")\n        }\n        \n        const url = this.value()\n        try {\n            const urlObject = new URL(url)\n            return true\n        } catch (error) {\n            return false\n        }\n\n        //const result = url.match(/(http(s)?:\\/\\/.)?(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)/g);\n        //return result !== null\n        throw new Error(\"what happened?\")\n    }\n    \n}.initThisClass());\n",
  "uOd1yp6QVDKYX807dTtMtsc0ezuSH7kXVNTCKTX5klY=": "\"use strict\";\n\n/*\n\n    BMOptionsNode \n    \n*/\n\n(class BMOptionsNode extends BMField {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n\n    initPrototypeSlots () {\n        {\n            const picksSlot = this.newSlot(\"allowsMultiplePicks\", false)\n            picksSlot.setLabel(\"Multiple picks\").setCanInspect(true).setSlotType(\"Boolean\")\n            picksSlot.setShouldStoreSlot(true)\n        }\n\n        this.overrideSlot(\"key\", \"\").setShouldStoreSlot(true)\n\n        this.newSlot(\"optionsSource\", null).setShouldStoreSlot(false).setDuplicateOp(\"copyValue\")\n        this.newSlot(\"optionsSourceMethod\", null).setShouldStoreSlot(false).setDuplicateOp(\"copyValue\")\n    }\n\n    prepareToAccess () {\n        super.prepareToAccess()\n        if (this.subnodes().length === 0) {\n            // as this might be expensive, we should lazy load it first time\n            // and maybe 1) have some sort of change timestamp to check next time it's visible\n            // and/or 2) have a way of getting notifications for changes when possible?\n            const source = this.optionsSource()\n            const method = this.optionsSourceMethod()\n            if (source && method) {\n                const values = source[method].apply(source)\n                this.setValidValues(values)\n            }\n        }\n    }\n\n    initPrototype () {\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(true)\n\n        this.setCanDelete(true)\n        this.setNodeCanInspect(true)\n\n        this.setKey(\"Options\")\n        this.setKeyIsVisible(true)\n        this.setNodeCanEditTitle(true)\n\n        this.setNodeCanReorderSubnodes(true)\n    }\n\n    init () {\n        super.init()\n        this.addAction(\"add\")\n        this.setSummaryFormat(\"value\")\n        this.setSubnodeProto(BMOptionNode)\n        this.setNoteIconName(\"right-arrow\")\n    }\n\n    /*\n    setValue (v) {\n        super.setValue(v)\n        return this\n    }\n    */\n    \n    title () {\n        return this.key()\n    }\n    \n    setTitle (s) {\n        this.setKey(s)\n        return this\n    }\n\n    childrenSummary () {\n        const picked = this.pickedSubnodes()\n        if (picked.length === 0) {\n            return \"No selection\"\n        }\n        return picked.map(subnode => subnode.summary()).join(\"\")\n    }\n\n    setSubtitle (aString) {\n        return this\n    }\n\n    didToggleOption (anOptionNode) {\n        if (anOptionNode.isPicked() && !this.allowsMultiplePicks()) {\n            this.unpickSubnodesExcept(anOptionNode)\n        }\n\n        let pickedValues = this.pickedSubnodes().map(s => s.value())\n        //this.setValue(pickedValues)\n        \n        if (pickedValues.length) {\n            if (this.allowsMultiplePicks()) {\n                this.setValue(pickedValues)\n            } else {\n                this.setValue(pickedValues.first())\n            }\n        } else {\n            this.setValue(null)\n        }\n\n        return this\n    }\n\n    unpickSubnodesExcept (anOptionNode) {\n        this.subnodes().forEach(subnode => {\n            if (subnode !== anOptionNode) { \n                subnode.setIsPicked(false) \n            }\n        })\n        return this\n    }\n\n    pickedSubnodes () {\n        return this.subnodes().select(subnode => subnode.isPicked())\n    }\n\n    // syncing\n\n    pickSubnodesMatchingValue () {\n        const v = this.value()\n        this.subnodes().forEach(option => {\n            if (Type.isArray(v)) {\n                option.justSetIsPicked(v.contains(option.value()))\n            } else {\n                option.justSetIsPicked(v == option.value())\n            }\n        })\n    }\n\n    acceptedSubnodeTypes () {\n        return [BMOptionNode.type()]\n    }\n\n    setValidValues (values) {\n        if (!this.validValues().equals(values)) {\n            this.removeAllSubnodes()     \n            const options = values.map(v => {\n                const optionNode = BMOptionNode.clone().setTitle(v).setValue(v)\n                if (v == this.value()) {\n                    optionNode.justSetIsPicked(true)\n                }\n                //optionNode.setIsPicked(v == this.value())\n                optionNode.setNodeCanEditTitle(false)\n                return optionNode\n            })\n            this.addSubnodes(options)\n            //this.copySubnodes(options)\n        }\n        return this\n    }\n\t\n    validValues () {\n        return this.subnodes().map(sn => sn.value())\n    }\n    \n    nodeTileLink () {\n        // used by UI tile views to browse into next column\n        return this\n    }\n    \n}.initThisClass());\n",
  "dPqgwTKHNCLGPKkMcX4Wl5R6c68hkOFxlY1R7ARgwPQ=": "\"use strict\";\n\n/*\n\n    BMOptionNode\n    \n    A single option from a set of options choices.\n\n*/\n        \n(class BMOptionNode extends BMStorableNode {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"label\", \"Option Title\").setShouldStoreSlot(true).setDuplicateOp(\"copyValue\")\n        this.newSlot(\"value\", null).setShouldStoreSlot(true).setDuplicateOp(\"copyValue\")\n        this.newSlot(\"isPicked\", false).setShouldStoreSlot(true).setDuplicateOp(\"copyValue\")\n    }\n\n    initPrototype () {\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(false)\n        this.setNodeCanReorderSubnodes(false)\n        this.setCanDelete(true)\n        this.setNodeCanEditTitle(true)\n    }\n\n    /*\n    init () {\n        super.init()\n    }\n    */\n\n    justSetIsPicked (aBool) {\n        assert(Type.isBoolean(aBool))\n        this._isPicked = aBool\n        return this\n    }\n\n    didUpdateSlotIsPicked (oldValue, newValue) {\n        if (this.parentNode()) {\n            this.parentNode().didToggleOption(this)\n            this.didUpdateNode()\n        }\n    }\n\n    toggle () {\n        this.setIsPicked(!this.isPicked())\n        return this\n    }\n\n    setTitle (aString) {\n        this.setLabel(aString)\n        return this\n    }\n    \n    title () {\n        return this.label()\n    }\n\n    value () {\n        return this.title()\n    }\n\n\n    subtitle () {\n        return null\n    }\n\n    summary () {\n        return this.title()\n    }\n\n    note () {\n        return this.isPicked() ? \"\" : \"\"\n    }\n\n}.initThisClass());\n",
  "nYCrSYh08lmvfFoSzzyXJzZEyFyUSo6x14PtMh6h+zY=": "\"use strict\";\n\n/*\n\n    BMDateNode\n    \n    \n\n*/\n        \n(class BMDateNode extends BMSummaryNode {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n    \n    initPrototypeSlots () {        \n\n        {\n            const slot = this.overrideSlot(\"subnodes\")\n            slot.setShouldStoreSlot(false)\n        }\n\n        {\n            const slot = this.newSlot(\"year\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setDoesHookSetter(true)\n            slot.setDuplicateOp(\"copyValue\")\n        }\n\n        {\n            const slot = this.newSlot(\"month\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setDoesHookSetter(true)\n            slot.setDuplicateOp(\"copyValue\")\n        }\n\n        {\n            const slot = this.newSlot(\"day\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setDoesHookSetter(true)\n            slot.setDuplicateOp(\"copyValue\")\n        }\n\n        {\n            const slot = this.newSlot(\"startYear\", 2000)\n            slot.setShouldStoreSlot(true)\n            slot.setDoesHookSetter(true)\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Number\")\n            slot.setLabel(\"Start year\")\n        }\n\n        {\n            const slot = this.newSlot(\"yearRange\", 20)\n            slot.setShouldStoreSlot(true)\n            slot.setDoesHookSetter(true)\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Number\")\n            slot.setLabel(\"Year range\")\n        }\n    }\n\n    init () {\n        super.init()\n        \n        this.setNoteIconName(\"right-arrow\")\n\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(false)\n        this.setNodeCanReorderSubnodes(false)\n        this.setCanDelete(true)\n\n        this.setTitle(\"Date\")\n        this.setNodeCanEditTitle(true)\n        this.setNodeCanEditSubtitle(false)\n        this.setNodeCanInspect(true)\n    }\n\n    hasDate () {\n        return !Type.isNull(this.year())\n    }\n\n    jsDate () {\n        //new Date(year, month, day, hours, minutes, seconds, milliseconds)\n        if (this.hasDate()) {\n            const d = new Date(this.year(), this.month(), this.day(), 0, 0, 0, 0, 0)\n            //console.log(\"d = \", d)\n            return d\n        }\n        return null\n    }\n\n    subtitle () {\n        if (this.hasDate()) {\n            const d = this.jsDate()\n            const s = d.monthName() + \" \" + d.dateNumberName() + \", \" + d.getFullYear()\n            const s2 = [this.year(), this.month(), this.day()].join(\"-\")\n            return s2 //+ \" - \" + s\n            return s\n        }\n\n        return \"No date selected\"\n    }\n\n    prepareToSyncToView () {\n        // called after DateNode is selected\n        if (!this.hasSubnodes()) {\n            this.setupSubnodes()\n        }\n    }\n\n    setupSubnodes () {\n        this.removeAllSubnodes()\n        \n        const startYear = this.startYear()\n        const range = this.yearRange()\n\n        const years = []\n        for (let i = startYear; i < startYear + range; i++) {\n            const year = BMYearNode.clone().setValue(i)\n            year.setCanDelete(false)\n            years.push(year)\n        }\n        this.setSubnodes(years)\n    }\n\n    onTapOfDecendantNode (aNode) {\n        if (aNode.type() === \"BMDayNode\") {\n            const dayNode = aNode\n            const monthNode = dayNode.parentNode()\n            const yearNode = monthNode.parentNode()\n            this.setDay(dayNode.value())\n            this.setMonth(monthNode.value())\n            this.setYear(yearNode.value())\n            this.scheduleSyncToView()\n            this.parentNode().postShouldFocusSubnode(this)\n        }\n        return true\n    }\n\n    endYear () {\n        return this.startYear() + this.yearRange()\n    }\n\n    yearRangeOk () {\n        return this.startYear() <= this.endYear()\n    }\n\n    didUpdateSlotStartYear () {\n        if (!this.hasDoneInit()) { // so we ignore the initial setup as a change\n            return\n        }\n\n        if (!this.yearRangeOk()) {\n            this.setEndYear(this.startYear())\n        }\n        this.setupSubnodes()\n    }\n\n    didUpdateSlotEndYear () {\n        if (!this.hasDoneInit()) {\n            return\n        }\n\n        if (!this.yearRangeOk()) {\n            this.setStartYear(this.endYear())\n        }\n        this.setupSubnodes()\n    }\n\n    jsonArchive () {\n        const d = this.jsDate()\n        return d ? d.toString() : null\n    }\n\n}.initThisClass());\n",
  "9FvSxeMGBQzMGPSwjyimmKxYKDv8pBBHTVOsI3B6EEE=": "\"use strict\";\n\n/*\n\n    BMYearNode \n    \n*/\n\n(class BMYearNode extends BaseNode {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"allowsMultiplePicks\", false)\n        this.newSlot(\"value\", 0)\n    }\n\n    init () {\n        super.init()\n\n        this.setCanDelete(true)\n        this.setNodeCanEditTitle(true)\n\n        //this.setSubnodeProto(BMFolderNode)\n        this.setSubnodeProto(BMOptionNode)\n        this.setNodeCanReorderSubnodes(true)\n\n        //this.setNodeViewClassName(\"BMOptionsNodeView\")\n    }\n\n    title () {\n        return this.value()\n    }\n\n    hasSubnodes () {\n        return true;\n    }\n    \n    prepareToAccess () {\n        //console.log(\"this.storeHasChanged() = \", this.storeHasChanged())\n        if (this.subnodeCount() === 0) {\n            //this.refreshSubnodes()\n        }\n    }\n    \n    nodeTileLink () {\n        // used by UI tile views to browse into next column\n        return this\n    }\n\n    prepareToSyncToView () {\n        // called after Node is selected\n        if (!this.subnodeCount()) {\n            for (let i = 1; i < 12 + 1; i++) {\n                const month = this.addSubnode(BMMonthNode.clone().setValue(i))\n                month.setCanDelete(false)\n            }\n        }\n    }\n    \n}.initThisClass());\n",
  "9NCxYCmbPFW337BxeueMqAlVn4odIrOnY35ms6Yvnkk=": "\"use strict\";\n\n/*\n\n    BMMonthNode \n    \n*/\n\n(class BMMonthNode extends BaseNode {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"value\", 1).setComment(\"month value starts with 1\")\n    }\n\n    init () {\n        super.init()\n        this.setNoteIconName(\"right-arrow\")\n\n        this.setCanDelete(false)\n        this.setNodeCanInspect(false)\n\n        this.setTitle(\"a month\")\n        this.setNodeCanEditTitle(true)\n\n        //this.setSubnodeProto(BMOptionNode)\n        //this.setNodeCanReorderSubnodes(false)\n\n        //this.setNodeViewClassName(\"BMOptionsNodeView\")\n    }\n\n    setValue (v) {\n        assert(Number.isInteger(v) && v > 0 && v < 13)\n        this._value = v\n        return this\n    }\n\n    year () {\n        const year = this.parentNode().value()\n        return year\n    }\n\n    daysThisMonth () {\n        return new Date(this.year(), this.value() - 1, 0).getDate();\n    }\n\n    monthNames () {\n        return [\"January\", \"February\", \"March\", \"April\", \n            \"May\", \"June\", \"July\", \"August\", \n            \"September\", \"October\", \"November\", \"December\"];\n    }\n\n    monthName () {\n        return this.monthNames()[this.value()-1]\n    }\n\n    title () {\n        return this.monthName()\n    }\n\n    zeroPaddedMonthNumber () {\n        let v = this.value()\n        if (v < 10) { \n            v = \"0\" + v \n        }\n        return v\n    }\n\n    subtitle () {\n        //return this.zeroPaddedMonthNumber()\n        return null\n    }\n    \n    nodeTileLink () {\n        // used by UI tile views to browse into next column\n        return this\n    }\n\n    prepareToSyncToView () {\n        // called after Node is selected\n        if (!this.subnodeCount()) {\n\n            for (let i = 1; i < this.daysThisMonth() + 1; i++) {\n                const day = BMDayNode.clone().setValue(i)\n                day.setCanDelete(false)\n                this.addSubnode(day)\n            }\n        }\n    }\n    \n}.initThisClass());\n",
  "9Rua3nP3EtdAhb5A2SHC4K+s0M5dxIMzfs+CvCNUVv8=": "\"use strict\";\n\n/*\n\n    BMDayNode \n    \n*/\n\n(class BMDayNode extends BaseNode {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"value\", 1).setComment(\"day value starts with 1\")\n    }\n\n    init () {\n        super.init()\n\n        this.setCanDelete(false)\n        this.setNodeCanInspect(false)\n\n        this.setTitle(\"a day\")\n        this.setNodeCanEditTitle(false)\n\n        this.setNodeCanReorderSubnodes(false)\n    }\n\n    setValue (v) {\n        assert(Number.isInteger(v) && v > 0 && v < 32)\n        this._value = v\n        return this\n    }\n\n    dayName () {\n        const v = this.value()\n        return v + v.ordinalSuffix()\n    }\n\n    title () {\n        return this.dayName()\n    }\n\n    subtitle () {\n        return null\n    }\n    \n    note () {\n        return null\n    }\n    \n    nodeTileLink () {\n        // used by UI tile views to browse into next column\n        return null\n    }\n    \n}.initThisClass());\n",
  "Kz5L9vuc1aFL8Irk+Vv6F/1Wpytoh/Ig873Xx00Hc1o=": "\"use strict\";\n\n/*\n\n    BMTimeNode\n    \n    \n\n*/\n        \n(class BMTimeNode extends BMSummaryNode {\n      \n    static availableAsNodePrimitive () {\n        return true\n    }\n\n    initPrototypeSlots () {\n        this.overrideSlot(\"subnodes\").setShouldStoreSlot(false)\n\n        this.newSlot(\"hour\", null).setShouldStoreSlot(true)\n        this.newSlot(\"minute\", null).setShouldStoreSlot(true)\n        this.newSlot(\"timezone\", null).setShouldStoreSlot(true)\n        this.newSlot(\"formatter\", null).setShouldStoreSlot(true)\n    }\n\n    initPrototype () {\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(false)\n        this.setNodeCanReorderSubnodes(false)\n        this.setCanDelete(true)\n\n        this.setTitle(\"Time\")\n\n        this.setNodeCanEditTitle(true)\n        this.setNodeCanEditSubtitle(false)\n    }\n\n    init () {\n        super.init()\n        this.setNoteIconName(\"right-arrow\")\n        this.setFormatter(TimeFormatter.clone())\n        return this\n    }\n\n    hasTime () {\n        return !Type.isNull(this.hour())\n    }\n\n    jsDate () {\n        //new Date(year, month, day, hours, minutes, seconds, milliseconds)\n        if (this.hasTime()) {\n            const d = new Date(0, 0, 0, this.hour(), this.minute(), 0, 0, 0)\n            return d\n        }\n        return null\n    }\n\n    timeString () {\n        if (!this.formatter()) { //tmp hack to deal with bug\n            this.setFormatter(TimeFormatter.clone())\n        }\n\n        return this.formatter().setDate(this.jsDate()).formattedValue()\n    }\n\n    subtitle () {\n        if (this.hasTime()) {\n            return this.timeString()\n        }\n\n        return \"No time selected\"\n    }\n\n    prepareToSyncToView () {\n        // called after clicked\n        if (!this.hasSubnodes()) {\n            this.setupHourNodes()\n        }\n    }\n\n    setupHourNodes () {\n        for (let i = 0; i < 23; i++) {\n            const hour = BMHourNode.clone().setValue(i)\n            this.addSubnode(hour)\n        }\n    }\n\n    onTapOfDecendantNode (aNode) {\n        if (aNode.type() === \"BMMinuteNode\") {\n            const minuteNode = aNode\n            const hourNode = minuteNode.parentNode()\n            this.setHour(hourNode.value())\n            this.setMinute(minuteNode.value())\n            this.scheduleSyncToView()\n            this.parentNode().postShouldFocusSubnode(this)\n        }\n        return true\n    }\n\n    jsonArchive () {\n        const d = this.jsDate()\n        return d ? d.toString() : null\n    }\n\n}.initThisClass());\n",
  "mwFrYPyKOd+vR5oTBKsE4SJ7IvH1CP5kXrp97S2GFws=": "\"use strict\";\n\n/*\n\n    BMHourNode \n    \n*/\n\n(class BMHourNode extends BaseNode {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"value\", 0).setComment(\"0 to 23\")\n    }\n\n    init () {\n        super.init()\n\n        this.setCanDelete(false)\n        this.setNodeCanInspect(false)\n\n        this.setNodeCanEditTitle(false)\n        this.setNodeCanReorderSubnodes(false)\n\n        this.setNoteIconName(\"right-arrow\")\n    }\n\n    setValue (v) {\n        assert(Number.isInteger(v) && v > -1 && v < 23)\n        this._value = v\n        return this\n    }\n\n    meridiemName () {\n        if (this.value() > 11) {\n            return \"pm\"\n        }\n        return \"am\"\n    }\n\n    hourName () {\n        let v = this.value() % 12\n        if (v === 0) { v = 12 }\n        return v + \"\" + this.meridiemName()\n    }\n\n    title () {\n        return this.hourName()\n    }\n\n    subtitle () {\n        return null\n    }\n    \n    /*\n    nodeTileLink () {\n        return this\n    },    \n    */\n\n    prepareToSyncToView () {\n        // called after clicked\n        if (!this.hasSubnodes()) {\n            for (let i = 0; i < 60; i += 5) {\n                const minute = BMMinuteNode.clone().setValue(i)\n                this.addSubnode(minute)\n            }\n        }\n    }\n    \n}.initThisClass());\n",
  "P2UVBa3VDslLo5n6+Tq4mnBKeEjCyPkkboZqCWL6Tqo=": "\"use strict\";\n\n/*\n\n    BMMinuteNode \n    \n*/\n\n(class BMMinuteNode extends BaseNode {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"value\", 1)\n    }\n\n    init () {\n        super.init()\n        this.setCanDelete(false)\n        this.setNodeCanInspect(false)\n        this.setNodeCanEditTitle(false)\n        this.setNodeCanReorderSubnodes(false)\n    }\n\n    setValue (v) {\n        assert(Number.isInteger(v) && v > -1 && v < 60)\n        this._value = v\n        return this\n    }\n\n    minuteName () {\n        let s = this.value()\n        if (s < 10) { \n            s = \"0\" + s\n        }\n        return s\n    }\n\n    title () {\n        return this.minuteName()\n    }\n\n    subtitle () {\n        return null\n    }\n    \n    note () {\n        return null\n    }\n    \n    nodeTileLink () {\n        // used by UI tile views to browse into next column\n        return null\n    }\n    \n}.initThisClass());\n",
  "3rLf+CUQLrvF+XpIdry62V8vighdrkx8guJ7z+/j7hI=": "\"use strict\";\n\n/*\n\n    BMMeridiemNode \n    \n*/\n\n(class BMMeridiemNode extends BaseNode {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"value\", 1).setComment(\"month value starts with 1\")\n    }\n\n    /*\n    init () {\n        super.init()\n        this.setNoteIconName(\"right-arrow\")\n\n        this.setCanDelete(false)\n        this.setNodeCanInspect(false)\n\n        this.setTitle(\"a month\")\n        this.setNodeCanEditTitle(true)\n\n        //this.setSubnodeProto(BMOptionNode)\n        //this.setNodeCanReorderSubnodes(false)\n\n        //this.setNodeViewClassName(\"BMOptionsNodeView\")\n    }\n\n    setValue (v) {\n        assert(Number.isInteger(v) && v > 0 && v < 13)\n        this._value = v\n        return this\n    }\n\n    year () {\n        const year = this.parentNode().value()\n        return year\n    }\n\n    daysThisMonth () {\n        return new Date(this.year(), this.value() - 1, 0).getDate();\n    }\n\n    monthNames () {\n        return [\"January\", \"February\", \"March\", \"April\", \n            \"May\", \"June\", \"July\", \"August\", \n            \"September\", \"October\", \"November\", \"December\"];\n    }\n\n    monthName () {\n        return this.monthNames()[this.value()-1]\n    }\n\n    title () {\n        return this.monthName()\n    }\n\n    zeroPaddedMonthNumber () {\n        let v = this.value()\n        if (v < 10) { \n            v = \"0\" + v \n        }\n        return v\n    }\n\n    subtitle () {\n        //return this.zeroPaddedMonthNumber()\n        return null\n    }\n    \n    nodeTileLink () {\n        // used by UI tile views to browse into next column\n        return this\n    }\n\n    prepareToSyncToView () {\n        // called after Node is selected\n        if (!this.subnodeCount()) {\n\n            for (let i = 1; i < this.daysThisMonth() + 1; i++) {\n                this.addSubnode(BMDayNode.clone().setValue(i))\n            }\n        }\n    }\n    */\n    \n}.initThisClass());\n",
  "SPsi+4K/7PwIHi4xUpW5Lt5tzLe1O/QEH+c8VnCkULI=": "\"use strict\";\n\n/*\n    \n    BMDataStoreRecord\n    \n    A visible representation of a storage record.\n    \n*/\n\n(class BMDataStoreRecord extends BMFieldSetNode {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"key\", null)\n        this.newSlot(\"store\", null)\n    }\n\n    init () {\n        super.init()\n        this.setCanDelete(false) // too dangerous\n    }\n\n    prepareForFirstAccess () {\n        super.prepareForFirstAccess()\n        const jsonField = BMTextAreaField.clone().setKey(\"recordString\")\n        jsonField.setValueMethod(\"recordString\").setValueIsEditable(false).setIsMono(true)\n        this.addField(jsonField)\n\n        this.referencedRecords().forEach((aRecord) => {\n            const node = BMDataStoreRecord.forRecord(aRecord)\n            this.addSubnode(node)\n        })\n    }\n\n    record () {\n        return this.store().recordForPid(this.key())\n    }\n\n    setRecordString (s) {\n        throw new Error(\"not editable\")\n    }\n\n    recordString () {\n        return JSON.stringify(this.record(), null, 2)\n    }\n\n    referencedRecords () {\n        return this.referencedPidSet().map( pid => this.defaultStore().recordForPid(pid) )\n    }\n\n    referencedPidSet () {\n        return this.defaultStore().refSetForPuuid(this.record().id)\n    }\n\n    /*\n    delete () {\n        super.delete()\n        this.defaultStore().justRemovePid(this.key())\n        return this\n    }\n    */\n\n    static forRecord (aRecord) {\n        const subnode = BMDataStoreRecord.clone()\n        subnode.setTitle(aRecord.type + \" \" + aRecord.id)\n        //subnode.setTitle(aRecord.id)\n        subnode.setKey(aRecord.id)\n        subnode.setStore(this.defaultStore()) //// <-------------------- avoid this?\n        const size = JSON.stringify(aRecord).length\n        subnode.setSubtitle(size.byteSizeDescription())\n        return subnode\n    }\n    \n}.initThisClass());\n\n",
  "7iZ2JhcVFPYsVh3UUpb9lw0kULjzyNJ8GkpR7v08Wsc=": "\n\n.ImageCloseButton {\n\tdisplay: flex;\n\tposition: absolute;\n\t\n\tcolor: rgba(128, 128, 128, 0.5);\n\talign-items: center;\n\tjustify-content: center;\n\n\ttop: 0px;\n\tright: 0px;\n\tmargin: 0px;\n\tpadding: 0px;\t\n\n\tmax-width: 30px;\n\tmin-width: 30px;\n\n\tmin-height: 30px;\n\tmax-height: 30px;\n\n\topacity: 0.3;\n\tz-index: 2;\n\tborder: none;\n\tbox-shadow: none;\n}\n\n.ImageCloseButton:hover {\n\topacity: 1;\n}\n",
  "/dN/4LcHhRDJWAQ8RwzKRJMHG/FP8zRqKY/MYRJYNCU=": "\"use strict\";\n\n/*\n\n    NodeView\n\n*/\n\n(class NodeView extends StyledDomView {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"node\", null) //.setDuplicateOp(\"duplicate\")\n        this.newSlot(\"defaultSubviewProto\", null)\n        this.newSlot(\"overrideSubviewProto\", null)\n        this.newSlot(\"nodeObservation\", null)\n        this.newSlot(\"isInspecting\", false)\n    }\n\n    init () {\n        super.init()\n        //this.setNodeObservation(BMNotificationCenter.shared().newObservation().setName(\"didUpdateNode\").setObserver(this))\n        this.setNodeObservation(BMNotificationCenter.shared().newObservation().setObserver(this)) // observe all posts from node\n        this.updateSubnodeToSubviewMap()\n        return this\n    } //.setDocs(\"init\", \"initializes the object\", \"returns this\"),\n    \n    setNode (aNode) {\n        if (this._node !== aNode) {\n            this.stopWatchingNode()\n            this._node = aNode\n            this.startWatchingNode()\n\n            this.updateElementIdLabel()\n            this.didChangeNode()\n        }\n\t\t\n        return this\n    }\n\n    updateElementIdLabel () {\n        this.element().id = this.debugTypeId()\n        return this\n    }\n    \n    didChangeNode () {\n        if (this.node()) {\n            //this.syncFromNode()\n            this.scheduleSyncFromNode()\n        }\n        return this\n    }\n \n    startWatchingNode () {\n        if (this.node()) {\n            //console.log(\"startWatchingNode \" + this.node() + \" observation count = \" + BMNotificationCenter.shared().observations().length)\n            this.nodeObservation().setSender(this.node()).startWatching()\n            //this.node().onStartObserving()\n        }\n        return this\n    }\n       \n    stopWatchingNode () {\n        if (this.node()) {\n            //console.log(\"stopWatchingNode \" + this.node() + \" observation count = \" + BMNotificationCenter.shared().observations().length)\n            this.nodeObservation().stopWatching()\n            //this.nodeObservation().setSender(null)\n            //this.node().onStopObserving()\n        }\n        return this\n    }\n    \n    willRemove () {\n        super.willRemove()\n        this.stopWatchingNode()\n        return this\n    }\n    \n    subviewProto () {\n        debugger;\n        //console.log(\"looking for subviewProto\")\n        if (this.node()) {\n            const vc = this.node().nodeTileClass()\n            if (vc) { \n                return vc\n            }\n        }\n        return super.subviewProto()\n    }\n\n    // --- syncing ---\n\n    subviewForNode (aNode) {\n        assert(this._subnodeToSubview)\n        return this._subnodeToSubview[aNode]\n    }\n\n    updateSubnodeToSubviewMap () {\n        // TODO: make this more efficient with add/remove hooks\n        const dict = {}\n        this.subviews().forEach(sv => {\n            if (sv.node) { \n                dict.atSlotPut(sv.node(), sv) \n            } \n        })\n        this._subnodeToSubview = dict\n        return this\n    }\n\n    subviewProtoForSubnode (aSubnode) {\n        let proto = this.overrideSubviewProto()\n\t\t\n        if (!proto) {\n\t\t    proto = aSubnode.nodeViewClass()\n        }\n\n        if (!proto) {\n            proto = this.defaultSubviewProto()\n        }\n\t\t\t\t\n        return proto      \n    }\n\n    newSubviewForSubnode (aSubnode) {\n        if (!aSubnode) {\n            throw new Error(\"null aSubnode\")\n        }\n\n        //console.log(this.debugTypeId() + \".newSubviewForSubnode(\" + aSubnode.debugTypeId() + \")\")\n        const proto = this.subviewProtoForSubnode(aSubnode) // this is fast\n\n        if (!proto) {\n            debugger;\n            //aSubnode.nodeViewClass() // used to step into to debug\n            throw new Error(\"no subviewProto for subnode \" + aSubnode.typeId())\n        }\n\n        const instance = proto.clone()\n\n        instance.setNode(aSubnode) // this is fast\n        return instance\n    }\n\n    updateSubviews () {\n        // for subclasses to override\n        return this\n    }\n\n    flattenedSubnodes (depth) {\n        if (Type.isUndefined(depth)) {\n            depth = 0\n        }\n        const subnodes = this.node().subnodes()\n        const flattened = []\n        subnodes.forEach(subnode => {\n            flattened.push(subnode)\n            if (depth > 0) {\n                subnode.subnodes().forEach(sub => flattened.push(sub))\n            }\n        })\n\n        return flattened\n    }\n    \n    visibleSubnodes () {\n        return this.node().subnodes()\n    }\n\n    syncFromNode () {\n        let subnodesDidChange = false\n        // override this method if the view manages it's own subviews\n\n        if (!this.node()) { \n            this.removeAllSubviews();\n            return\n        }\n\n        //console.log(\"> \" + this.debugTypeId() + \" syncFromNode\")\n        \n        this.node().prepareToSyncToView()\n        this.updateSubnodeToSubviewMap() // not ideal - move this to update on subview add/remove\n       \n        const newSubviews = []\n        \n        // only replace subviews if sync requires it,\n        // and reuse subviews for subnodes which are still present \n\n        assert(!this.visibleSubnodes().hasDuplicates())\n        \n        //debugger;\n\n\n        this.visibleSubnodes().forEach((subnode) => {\n            let subview = undefined;\n\n            subview = this.subviewForNode(subnode) // get the current view for the node, if there is one\n\n            if (!subview) {\n                subview = this.newSubviewForSubnode(subnode)\n            }\n\n            if (Type.isNull(subview)) {\n                throw new Error(\"null subview\")\n            }\n            \n            //assert(!newSubviews.contains(subview))\n            newSubviews.push(subview)   \n        })\n\n        /*\n        const oldSubviews = this.subviews().shallowCopy()\n        const removedSubviews = newSubviews.difference(oldSubviews)\n        removedSubviews.forEach(sv => {\n            sv.prepareToRetire()\n        })\n        */\n\n        //debugger;\n        \n        if (!newSubviews.isEqual(this.subviews())) {\n            subnodesDidChange = true\n            //this.removeAllSubviews() \n            this.removeAllSubviews()\n            this.addSubviews(newSubviews)\n            this.updateSubnodeToSubviewMap()\n            // since node's don't hold a view reference, \n            // subviews no longer referenced in subviews list will be collected\n        }\n\n        this.subviews().forEach(subview => subview.syncFromNodeNow())\n\n        return subnodesDidChange\n    }\n\n    flipBorderColor () {\n        const coinFlip = (Math.floor(Math.random() * 10) % 2 === 0)\n        const color = coinFlip ? \"red\" : \"blue\"\n        this.element().style.border = \"1px dashed \" + color \n    }\n    \n    syncToNode () {\n        const node = this.node()\n        if (node) {\n            node.didUpdateNode()\n        }\n        return this\n    }\n\n    didUpdateNode () {\n        //this.debugLog(\" didUpdateNode \" + this.node().type())\n        this.scheduleSyncFromNode()\n    }\n    \n    scheduleSyncToNode () {\n        if (this.hasScheduleSyncFromNode()) {\n            this.hasScheduleSyncFromNode()\n            console.log(\"SKIPPING scheduleSyncToNode because hasScheduleSyncFromNode\")\n            this.unscheduleSyncFromNode()\n            return this\n        }\n        \n        SyncScheduler.shared().scheduleTargetAndMethod(this, \"syncToNode\", 0)\n        return this\n    }\n    \n    hasScheduleSyncToNode () {\n        return SyncScheduler.shared().isSyncingOrScheduledTargetAndMethod(this, \"syncToNode\")\n    }\n\n    hasScheduleSyncFromNode () {\n        return SyncScheduler.shared().isSyncingOrScheduledTargetAndMethod(this, \"syncFromNode\")\n    }\n\n    scheduleSyncFromNode () {\n        assert(!this.hasScheduleSyncToNode())\n        SyncScheduler.shared().scheduleTargetAndMethod(this, \"syncFromNode\", 2) // let posts happen first\n        return this\n    }\n\n    unscheduleSyncFromNode () {\n        SyncScheduler.shared().unscheduleTargetAndMethod(this, \"syncFromNode\")\n    }\n\n    syncFromNodeNow () { // unschedule syncFromNode if scheduled, and call syncFromNode now\n        this.unscheduleSyncFromNode()\n        this.syncFromNode()\n    }\n\n    // logging \n    \n    logName () {\n        return this.type()\n    }\n    \n    log (msg) {\n        const s = \"[\" + this.logName() + \"] \" + msg\n        console.log(s)\n        return this\n    }\n    \n    // visibility\n    \n    onVisibility () {\n\t    super.onVisibility()\n\t    //this.debugLog(\".onVisibility()\")\n\t    const node = this.node()\n\t    if (node && node.nodeBecameVisible) {\n\t        node.nodeBecameVisible()\n\t    }\n\n\t    return this\n    }\n    \n    // value\n    \n    setValue (newValue) {\n        this.setInnerHtml(newValue)\t\t\t\n        return this\n    }\n    \n    value () {\n        return this.innerHtml()\n    }\n\n    // ---\n\n    resyncAllViews () {\n        if (!this.hasScheduleSyncToNode()) {\n            this.scheduleSyncFromNode()\n        }\n        this.subviews().forEach(sv => sv.resyncAllViews())\n        //super.resyncAllViews() // skip this as it calls updateSubviews, but we'll do that in syncFromNode\n        return this\n    }\n\n    // --- debugging ---\n\n    nodeTitle () {\n        const node = this.node()\n        if (node) {\n            return node.title()\n        }\n        return null\n    }\n    \n    // --- helpers ---\n\n    nodeDescription () {\n        const node = this.node()\n        if (node) {\n            return node.debugTypeId()\n        }\n        return null\n    }\n\n    nodeId () {\n        const node = this.node()\n        const nodeId = node ? node.debugTypeId() : \"null\"\n        return nodeId\n    }\n\n    debugTypeId () {\n        //return this.nodeDescription()\n        //return super.debugTypeId() + this.debugTypeIdSpacer() + this.nodeDescription() + \" theme:\" + this.themeClassName()\n\n        let s = \"view:'\" + this.typeId() + \"'\"\n        s += \" node:'\" + this.nodeId() + \"'\"\n        s += \" themeClass:'\" +this.themeClassName() + \"'\"\n        if (this.node()) {\n            s += \" nodeTileClassName:'\" + this.node().nodeTileClassName() + \"'\"\n        }\n        return s\n    }\n\n}.initThisClass());\n",
  "XuoFcwRvJJdSdD7GNq9c3X5wk0cXzNCtcDV6cklML/M=": "\"use strict\";\n\n/*\n\n    ImageWellView\n\n    - designed to contain an ImagineView\n    - can have it's own frame and decoration\n    - supports drag & drop of images\n\n*/\n\n(class ImageWellView extends NodeView {\n    initPrototypeSlots () {\n        this.newSlot(\"imageView\", null)\n        this.newSlot(\"isEditable\", true)\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"flex\")\n        this.setPosition(\"relative\")\n        this.setJustifyContent(\"center\")\n        this.setAlignItems(\"center\")\n        this.setMinHeight(\"10em\")\n        this.setMinWidth(\"10em\")\n        this.setOverflowX(\"hidden\")\n        this.setOverflowY(\"hidden\")\n        this.setBorder(\"1px solid #444\")\n        this.setColor(\"white\")\n        this.setBackgroundColor(\"transparent\")\n\n        this.setIsRegisteredForBrowserDrop(true)\n        this.dragUnhighlight()\n        this.turnOffUserSelect()\n        this.autoFitParentWidth()\n        this.autoFitChildHeight()\n        this.setMinHeightPx(100)\n        this.setPadding(\"0px\")\n        return this\n    }\n\n    syncToNode () {\n        super.syncToNode()\n        this.tellParentViews(\"didUpdateImageWellView\", this)\n        return this\n    }\n    \n    isEditable () {\n        // we need this to override the normal isContentEditable return value\n        return this._isEditable\n    }\n    \n    setIsEditable (aBool) {\n        this._isEditable = aBool\n        if (this.imageView()) {\n            this.imageView().setIsEditable(aBool)\n        }\n        return this\n    }\n    \n    dragHighlight () {\n        this.setBackgroundColor(\"rgba(128, 128, 128, 0.5)\")\n    }\n    \n    dragUnhighlight () {\n        this.setBackgroundColor(\"transparent\")\n    }\n    \n    isFull () {\n        //console.log(\"this.imageView().dataURL()  = \", this.imageView().dataURL() )\n        return this.subviews().length > 0\n    }\n    \n    acceptsDrop (event) {\n        return true\n        //return this.isEditable()        \n    }\n\n    /*\n    onBrowserDrop (event) {\n        return super.onBrowserDrop(event)\n    }\n\n    onBrowserDragOver (event) {\n        const r =  super.onBrowserDragOver(event)\n        //console.log(this.debugTypeId() + \" onBrowserDragOver() -> \" + r)\n        return r\n    }\n    */\n\n    setValue (aValue) {\n        this.setImageDataUrl(aValue)\n        return this\n    }\n\n    value () {\n        return this.imageDataUrl()\n    }\n    \n    setImageDataUrl (dataURL) {\n        assert(!Type.isArray(dataURL)) \n\n        if (dataURL === this.imageDataUrl()) {\n            return this\n        }\n        \n        this.removeAllSubviews()\n\n        if (!Type.isNullOrUndefined(dataURL)) {\n            const v = ImageView.clone()\n            this.setImageView(v)\n            this.addSubview(v)\n\n            v.fetchDataURLFromSrc(dataURL)\n            v.autoFitChildHeight()\n            v.autoFitParentWidth()\n        }\n\n        return this\n    }\n    \n    imageDataUrl () {\n        const v = this.imageView()\n        if (v && v.dataURL()) {\n            return v.dataURL()\n        }\n        return null\n    }\n    \n\n    // need these as method name is constructed from MIME type\n\n    onBrowserDropImageJpeg (dataChunk) {\n        this.droppedImageData(dataChunk)\n    }\n\n    onBrowserDropImageGif (dataChunk) {\n        this.droppedImageData(dataChunk)\n    }\n\n    onBrowserDropImagePng (dataChunk) {\n        this.droppedImageData(dataChunk)\n    }\n\n    // image data chunk\n\n    droppedImageData (dataChunk) {\n        this.setImageDataUrl(dataChunk.dataUrl())\n        this.scheduleSyncToNode() //this.syncToNode()\n        return this        \n    }\n    \n    willRemoveSubview (aSubview) {\n        super.willRemoveSubview(aSubview)\n\n        if (aSubview === this.imageView()) {\n            this.setImageView(null)\n        }\n        return this\n    }\n    \n}.initThisClass());\n",
  "GfRJCOteE6Amfj66svtyze64gVaaKYDB631S03oeZTQ=": "\"use strict\";\n\n/*\n\n    ImageView\n\n*/\n\n(class ImageView extends NodeView {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"imageContainer\", null)\n        this.newSlot(\"rawImageView\", null)\n        this.newSlot(\"closeButtonView\", null)\n        this.newSlot(\"dataURL\", null)\n        this.newSlot(\"isEditable\", false)\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"flex\")\n        this.setPosition(\"relative\")\n        this.setJustifyContent(\"center\")\n        this.setAlignItems(\"center\")\n        this.setOverflow(\"hidden\")\n        this.setWidth(\"auto\")\n        this.setHeight(\"auto\")\n        //this.setIsRegisteredForBrowserDrop(false)\n\n        // image container\n        const ic = this.newImageViewContainer()\n        this.setImageContainer(ic)\n        this.addSubview(ic)\n\n        // close button\n        const cb = this.newCloseButtonView()\n        this.setCloseButtonView(cb)\n        this.addSubview(cb)\n\n        this.setIsEditable(false)\n        this.dragUnhighlight()\n        this.turnOffUserSelect()\n        return this\n    }\n\n    newCloseButtonView () {\n        const v = ButtonView.clone().setElementClassName(\"ImageCloseButton\")\n        v.setDisplay(\"flex\")\n        v.setPosition(\"absolute\")\n        v.setTitleIsVisible(false)\n        v.setTopPx(0)\n        v.setRightPx(0)\n        v.setTarget(this).setAction(\"close\")\n        v.setIconName(\"close\")\n        return v\n    }\n\n    newImageViewContainer () {\n        const v = FlexDomView.clone().setElementClassName(\"ImageViewImageContainer\")\n        v.setDisplay(\"flex\")\n        v.setPosition(\"relative\")\n        v.setJustifyContent(\"center\")\n        v.setAlignItems(\"center\")\n        v.setOverflow(\"hidden\")\n        v.setWidth(\"auto\")\n        v.setHeight(\"auto\")\n        return v\n    }\n\n    setIsRegisteredForBrowserDrop(aBool) {\n        throw new Error(\"shouldn't be called\")\n    }\n\n    // --- editable ---\n    \n    setIsEditable (aBool) {\n        this.closeButtonView().setDisplayIsHidden(!aBool)\n        return this\n    }\n\n    setEditable (aBool) {\n        // to avoid editable content?\n        return this\n    }\n    \n    acceptsDrop () {\n        return false\n    }\n\n    // --- close button ---\n\n    collapse () {\n        this.closeButtonView().setOpacity(0).setTarget(null)\n        this.setOpacity(0)\n\t\t\n        this.setWidth(\"0px\")\n\t\t\n        this.setPaddingLeftPx(0)\n        this.setPaddingRightPx(0)\n\t\t\n        this.setMarginLeft(0)\n        this.setMarginRightPx(0)\n    }\n    \n    close () {\n        const seconds = 0.3\n\t\t\n        this.collapse()\n        \n        this.addTimeout( () => { \n            this.closeButtonView().hideDisplay()\n            const parentView = this.parentView()\n            this.removeFromParentView()\n            parentView.scheduleSyncToNode()\n        }, seconds * 1000)\n    }\n\n    // --- sync ---\n    \n    removeRawImageView () {\n        if (this.rawImageView()) {\n            this.imageContainer().removeSubview(this.rawImageView())\n            this.setRawImageView(null)\n        }\n        return this\n    }\n    \n    fetchDataURLFromSrc (src) {\n        if (src.startsWith(\"data:\")) {\n\t        this.setFromDataURL(src)\n        } else {\n            const img = new Image();\n            img.setDelegate(this)\n            img.loadUrl(src)\n        }\n\t\t\n        return this\n    }\n    \n    didFetchDataUrl (dataURL) {\n        this.setFromDataURL(dataURL)\n        this.scheduleSyncToNode() \n        return this\n    }\n\n    newRawImageViewForImage (image) {\n        const v = FlexDomView.clone().setElement(image).setElementClassName(\"RawImageView\")\n        v.setDisplay(\"flex\")\n        v.setPosition(\"relative\")\n        v.setJustifyContent(\"center\")\n        v.setAlignItems(\"center\")\n        v.setOverflow(\"hidden\")\n        v.makeStandardFlexView()\n        v.setWidth(\"fit-content\")\n        v.setHeight(\"auto\")\n        return v\n    }\n\n    setFromDataURL (dataURL) {\n        //console.log(\"setFromDataURL: \", dataURL)\n        assert(!Type.isNull(dataURL))\n        assert(dataURL.startsWith(\"data:\")) \n\n        this.removeRawImageView()\n        this.setDataURL(dataURL)\n\n        const image = new Image();\n        image.src = dataURL;\n\n        const v = this.newRawImageViewForImage(image)\n        this.setRawImageView(v)\n        this.imageContainer().addSubview(v)\n\t\n        return this\n    }\n    \n}.initThisClass());\n",
  "if3crRdrvgPbOq9SFaxK8pxMj9nMfa1ZaLiHX+tjFh8=": "\n/*\n.BrowserDefaultHeader {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    height: 40px;\n    width: 100%;\n    background-color: #dbdbdb;\n    text-align: right;\n    font-style: bold;\n\tz-index: 1;\n}\n*/\n\n /*  removes scrollbars on Safari and Chrome */\n.BrowserScrollView::-webkit-scrollbar { \n    display: none; \n}\n\n/* \nnotes on Scroll bars theme options\n*/\n::-webkit-scrollbar {  display: none; width: 10px; } \n/*\n::-webkit-scrollbar-button { display: none; }\n*/\n::-webkit-scrollbar-thumb { background-color: #aaa; outline: 1px solid #aaa; } \n::-webkit-scrollbar-thumb:hover { background: #b1b1b1; }\n/*\n::-webkit-scrollbar-track { background: transparent; } \n::-webkit-scrollbar-track-piece { background: transparent; }\n::-webkit-scrollbar-corner { background: transparent; }\n::-webkit-resizer { background: transparent; }\n*/\n\n\n",
  "L1BHbVXLTVia99ZzynAi22Y6auITdmdB0FClZ9yQyvo=": "\"use strict\";\n\n/*\n    \n    StackView\n\n    A view from which of generalized (mixed vertical and horizontal) Miller Column system can be built.\n    \n    Overview of view structure:\n\n        StackView contains:\n            |- navView, which is a NavView and contains:\n                |- scrollView, which is a StackScrollView and contains:\n                    |- tilesView, which is a TilesView contains array of: \n                        |->> Tiles(or subclass), (each of which contains a contentView, so things like slide-to-delete gestures work)\n            |- otherView, which is a FlexDomView whose content is used to display the selected ite, and can be set with setOtherViewContent()\n        \n    \n        There is also a \"direction\" attribute. If it's value is:\n        - \"right\": the navView is on the left, and otherView is on the right, causing navigation to head towards the left\n        - \"down\": the navView is on the top, and otherView is on the bottom, causing navigation to head downwards\n\n        Note: TilesViews will ask their parent StackView about their direction setting to determine the orientation layout of their subviews\n\n        The direction for child StackViews can be set individually, so for example, we could use a \"down\" direction for the \n        topmost StackView or first few levels (so there will be left to right navigation menus at the top level) \n        while children could use the \"right\" direction so navigation under the top level is left to right.\n\n        In this way, we can compose most common hierarchical navigation systems out of this single view type, \n        maximizing code reuse and flexibility. For example:\n        - developer can change layout without code changes\n        - layout could flexibly change with display size \n        - each user could potentially chose a preferred layout\n\n        This also means all the logic around expanding, collapsing, selecting, navigating the views\n        can be reused among all the possible navigation layouts.\n\n    Overview of expand/collapse behavior:\n\n        The StackView will try to collapse and expand levels of navigation to make the best use of the available display area.\n        For example, as one navigates deeper into the hierarchy such that the columns would consume the width of the display,\n        the top most views will start collpasing to allow the deepest views to be displayed. \n\n        The relevant method is:\n        StackView.updateCompactionChain()\n    \n    Drag & Drop:\n\n        When dragging & dropping, hierarchy views for nodes are cached (in nodeToStackCache) in order to make the drag & drop implementation\n        more manageable. For example, the source tilesView needs to remember where the dragged item was when returning to it.\n\n*/\n\n(class StackView extends NodeView {\n\n    initPrototypeSlots () {\n        this.newSlot(\"navView\", null)\n        this.newSlot(\"otherView\", null)\n        this.newSlot(\"direction\", \"down\").setDoesHookSetter(true) // valid values: left, right, up, down\n        this.newSlot(\"lastPathString\", null)\n        this.newSlot(\"onStackViewPathChangeNote\", null)\n        this.newSlot(\"nodeToStackCache\", null)\n    }\n\n    init () {\n        super.init()\n\n        this.setNodeToStackCache(null)\n        \n        this.setDisplay(\"flex\")\n        this.setPosition(\"relative\")\n        this.setWidth(\"100%\")\n        this.setHeight(\"100%\")\n        this.setMinHeight(\"100%\")\n\n        this.setFlexDirection(\"row\")\n        this.setFlexWrap(\"nowrap\")\n        this.setOverflow(\"hidden\")\n\n        this.setupNavView()\n        this.setupOtherView()\n\n        //this.setBorder(\"1px dashed white\")\n\n        this.setFlexBasis(\"fit-content\")\n        this.setFlexBasis(\"auto\")\n        this.setFlexGrow(1)\n        this.setFlexShrink(0)\n\n        // events\n        this.setIsRegisteredForWindowResize(true)\n        //this.addGestureRecognizer(LeftEdgePanGestureRecognizer.clone()) \n        //this.addGestureRecognizer(RightEdgePanGestureRecognizer.clone()) \n        this.setOnStackViewPathChangeNote(this.newNoteNamed(\"onStackViewPathChange\"))\n\n        this.syncOrientation()\n        return this\n    }\n\n    /*\n    didUpdateSlotParentView (oldValue, newValue) { \n        super.didUpdateSlotParentView(oldValue, newValue)\n        console.log(this.typeId() + \".didUpdateSlotParentView(\", oldValue.typeId(), \",\", newValue.typeId(), \")\")\n        return this\n    }\n    */\n\n    setupNavView () {\n        const v = NavView.clone()\n        v.setStackView(this)\n        this.setNavView(v)\n        this.addSubview(v)\n        return this\n    }\n\n    setupOtherView () {\n        const v = FlexDomView.clone()\n        v.setFlexGrow(1)\n        v.setFlexShrink(1)\n        v.setFlexDirection(\"column\")\n        v.setWidth(\"100%\")\n        v.setHeight(\"100%\")\n        this.setOtherView(v)\n        this.addSubview(v)\n        this.clearOtherView()\n        return this\n    }\n\n    // --- direction ---\n\n    didUpdateSlotDirection () {\n        this.syncOrientation()\n    }\n\n    syncOrientation () {\n        const d = this.direction()\n        const nv = this.navView()\n        if (d === \"right\") {\n            this.makeOrientationRight()\n        } else if (d == \"down\") {\n            this.makeOrientationLeft()\n        } else {\n            throw new Error(\"unimplmented direction '\" + d + \"'\")\n        }\n        this.navView().syncOrientation()\n    }\n\n    makeOrientationRight () {\n        this.setFlexDirection(\"row\")\n        return this\n    }\n\n    makeOrientationLeft () {\n        this.setFlexDirection(\"column\")\n        return this\n    }\n\n    /*\n    verifyOrientation () {\n        const d = this.direction()\n        if (d == \"right\")\n    }\n    */\n    \n    /*\n    setFlexDirection (v) {\n        if (this.flexDirection() === \"column\" && v == \"row\") {\n            debugger; // why are we switching back to row?\n        }\n        super.setFlexDirection(v)\n        return this\n    }\n    */\n\n    setNode (aNode) {\n        if (aNode !== this.node()) {\n            if (aNode && this.node() && this.previousStackView() && this.previousStackView().isCaching()) {\n                throw new Error(\"this might invalidate a cache\")\n            }\n            if (aNode) {\n                this._nodePathString = aNode.nodePathString()\n            }\n            super.setNode(aNode)\n        }\n        return this\n    }\n\n    didChangeNode () {\n        super.didChangeNode()\n        this.navView().setNode(this.node())\n        return this\n    }\n\n    syncFromNode () {\n        this.setDirection(this.node().nodeOrientation())\n\n        this.syncOrientation()\n        //this.navView().syncFromNodeNow()\n        this.syncFromNavSelection()\n\n        //this.setupColumnGroupColors()\n        //this.fitColumns()\n        return this\n    }\n\n    onWindowResize (event) {\n        /*\n        if (this.isRootStackView()) {\n            this.safeUpdateCompactionChain()\n        }\n        */\n        // TODO: change so only top stack view registers for resize\n        this.updateCompaction()\n        return this\n    }\n\n    setOtherViewContent (v) {\n        const ov = this.otherView()\n        ov.setFlexBasis(null)\n        ov.setFlexGrow(1)\n        ov.setFlexShrink(1)\n        \n        /*\n        if (ov.subviews().length) {\n            const names = ov.subviews().map(ov => ov.typeId())\n            //console.log(\"removing subviews: \", names)\n            debugger;\n        }\n        */\n        \n        ov.removeAllSubviews().addSubview(v)\n        return this\n    }\n\n    clearOtherView () {\n        const ov = this.otherView()\n        ov.setFlexBasis(\"0px\")\n        ov.setFlexGrow(0)\n        ov.setFlexShrink(0)\n\n        /*\n        if (ov.subviews().length) {\n            const names = ov.subviews().map(ov => ov.typeId())\n            //console.log(\"removing subviews: \", names)\n            //debugger;\n        }\n        */\n        \n        ov.removeAllSubviews()\n        return this\n    }\n\n    otherViewContent () {\n        return this.nextStackView()\n    }\n\n    // notifications\n    \n    tilesView () {\n        return this.navView().tilesView()\n    }\n\n    selectNodePathArray (nodePathArray) {  \n        if (nodePathArray.length === 0) { \n            //console.log(\"- only one node in pathArray and it is ours, so unselecting all subtiles and we're done!\")\n            // no selections left so unselect next\n            this.tilesView().unselectAllTiles()\n            this.syncFromNavSelection()\n            return true\n        }\n\n        nodePathArray = nodePathArray.shallowCopy()\n        // the path should start with the node *after* this one\n        \n        //const p = nodePathArray.map(n => n.title()).join(\"/\")\n        //console.log(\"--- selectNodePathArray ---\")\n        //console.log(this.type() + \" \" + this.node().nodePathString() + \" selectNodePathArray(\" + nodePathArray.map(node => \"'\" + node.title() + \"'\").join(\", \") + \")\")\n        const node = nodePathArray.shift() // pop the first node off (it should be us) and select the next one from our tiles, then pass remaining paths to the tile's stackview\n        //console.warn(\"- popped '\" + node.title() + \"'\")\n\n        //this.syncFromNodeNow()\n        assert(node !== this.node())\n\n        /*\n        console.log(\"1 this.tilesView().node().subnodes(): \", this.tilesView().node().subnodes())\n        this.tilesView().syncFromNodeNow() //test\n        console.log(\"2 this.tilesView().subviews(): \", this.tilesView().subviews())\n        */\n\n        let selectedTile = this.tilesView().selectTileWithNode(node)\n\n        if (!selectedTile) {\n            // if we didn't find the tile but the node is a subnode, sync the tilesView and look again\n            if (this.tilesView().node().subnodes().contains(node)) {\n                //console.warn(\"- the tilesView node's subnodes contain the path node, but there's no matching view!\")\n               // console.log(\"- so syncFromNodeNow and see if we can find it\")\n                this.tilesView().syncFromNodeNow()\n                selectedTile = this.tilesView().selectTileWithNode(node)\n                assert(selectedTile)\n            }\n        }\n\n        if (!selectedTile) { // INVALID PATH ERROR\n            console.log(\"- invalid path - can't find tile for node: \" + node.title())\n\n            console.log(\"debug info:\")\n            console.log(\"  looking for node: \", node.debugTypeId())\n            const subnodeIds = this.tilesView().node().subnodes().map(node => node.debugTypeId())\n            console.log(\"  subnodes:\" + JSON.stringify(subnodeIds) )\n\n            debugger;\n            return false\n        }\n\n        //this.syncFromNavSelection()\n        //console.log(\"- selectedTile '\" + selectedTile.node().title() + \"'\")\n\n        const childStack = this.nextStackView()\n        if (childStack) {\n            childStack.selectNodePathArray(nodePathArray)\n        }\n        return true\n    }\n\n    selectedNodePathArray () {\n        // grab the whole chain of stack view\n        const parts = this.stackViewSubchain().shallowCopy() \n        \n        // last one might not have a node\n        while (parts.last() && Type.isNullOrUndefined(parts.last().node())) {\n            //debugger;\n            parts.removeLast()\n        }\n\n        return parts.map(sv => {\n            if (!sv.node()) {\n                debugger;\n            }\n            return sv.node()\n        })\n    }\n\n    /*\n    selectedNodePathArray () {\n        return this.stackViewSubchain().map(sv => {\n            if (!sv.node()) {\n                debugger;\n            }\n            return sv.node()\n        })\n    }\n    */\n\n    isRootStackView () {\n        return this === this.rootStackView()\n    }\n\n    topDidChangeNavSelection () {\n        // broadcast path change to listeners, like bread crumb view\n        //console.log(\"topDidChangeNavSelection\")\n        //debugger;\n        if (!this.rootStackView()) {\n            debugger;\n            return this\n        }\n\n        const currentPathString = this.selectedPathString()\n        // TODO: change to node matching as path isn't unique and names can change\n        if (this.lastPathString() !== currentPathString) {\n            this.setLastPathString(currentPathString)\n            this.didChangePath()\n        }\n        return this\n    }\n\n    didChangeNavSelection () {\n        this.rootStackView().topDidChangeNavSelection()\n        //this.syncFromNavSelection()\n        this.syncFromNavSelection()\n        //this.scheduleSyncFromNode()\n        return true\n    }\n\n    selectedPathString () {\n        return this.selectedNodePathArray().map(node => {\n            return node.title()\n        }).join(\"/\")\n    }\n\n    pathString () {\n        return this.stackViewSuperChain().reverse().map(sv => sv.node().title()).join(\"/\")\n    }\n\n    // --- selected path changes ---\n\n    didChangePath () {\n        this.onStackViewPathChangeNote().post()\n        return this\n    }\n    \n    // ----------------\n\n    scheduleSyncFromNode () {\n     //   debugger;\n        super.scheduleSyncFromNode()\n    }\n\n    syncFromNavSelection () {\n        // update otherViewContent view to match selected tile\n\n        const tile = this.navView().tilesView().selectedTile() // this may get called before tilesView has synced to current subnodes,\n        //console.log(\"StackView syncFromNavSelection \" + this.node().title() + \" -> \" + (tile ? tile.nodeTitle() : null))\n        //debugger;\n        // in which case, the tile may be about to be removed\n        if (tile && tile.nodeTileLink()) {\n            const oNode = tile.nodeTileLink()\n            const ovc = this.otherViewContent()\n            if (!ovc || (ovc.node() !== oNode)) {\n                const ov = this.otherViewContentForNode(oNode)\n                this.setOtherViewContent(ov)\n            }\n        } else {\n            this.clearOtherView()\n        }\n\n        this.safeUpdateCompactionChain()\n    }\n\n    // stack view chain\n\n    previousStackView () {\n        // this stackView -> otherView -> previousStackView\n        const otherView = this.parentView()\n        if (otherView) {\n            const previousStackView = otherView.parentView()\n            if (previousStackView && previousStackView.previousStackView) {\n                //if (previousStackView.isSubclassOf(StackView)) {\n                return previousStackView\n            }\n        }\n        /*\n        if (p && p.previousStackView) {\n            return p.parentView()\n        }\n        */\n        return null\n    }\n\n    nextStackView () {\n        return this.otherView().subviews().first()\n    }\n\n    rootStackView () {\n        let p = this\n        while (p.previousStackView()) {\n            p = p.previousStackView()\n        }\n        return p\n    }\n\n    // --- compaction (adjusts number of visible stack areas to fit top stack view)\n\n    safeUpdateCompactionChain () {\n        //this.bottomStackView().updateCompactionChain()\n        this.updateCompactionChain()\n    }\n\n    updateCompactionChain () {\n        this.updateCompaction() \n        this.tellParentViews(\"updateCompaction\") \n    }\n\n    updateCompaction () {\n        this.compactNavAsNeeded()\n        return this\n    }\n\n    /*\n    firstParentWithDifferentDirection () {\n        const d = this.direction()\n        let current = this\n        while (current) {\n            const p = current.previousStackView() \n            if (p && p.direction() !== d) {\n                break\n            }\n            current = p\n        }\n        return current\n    }\n    */\n\n    stackViewSuperChain () {\n        // returns list of self and StackViews above\n        const chain = []\n        let current = this\n        while (current) {\n            chain.push(current)\n            const p = current.previousStackView()\n            current = p\n        }\n        return chain\n    }\n\n    stackViewDepth () {\n        return this.stackViewSuperChain().length - 1\n    }\n\n    bottomStackView () {\n        let current = this\n\n        while (current) {\n            const next = current.nextStackView()\n            if (next) {\n                current = next\n            }\n        }\n        return current\n    }\n\n    stackViewSubchain () {\n        // returns self and all StackViews below \n        const chain = []\n        let current = this\n\n        while (current) {\n            chain.push(current)\n            current = current.nextStackView()\n        }\n        return chain\n    }\n\n    navViewSubchain () {\n        return this.stackViewSubchain().map(sv => sv.navView())\n    }\n\n    sumOfNavWidths () { \n        // Returns sum of self and all preceeding vertical nav view widths.\n        // This is used for compacting\n        \n        // NOTES:\n        // - We assume no direct compaction of horizontal nav views (e.g. horizontal menus)\n        //  ** so we need to skip summing widths of horizontal nav views \n        //     as well as compacting them \n        // - Even if vertical and horizontal navs are interleaved, \n        //   we treat all vertical nav view compactions \n        //   as if they are part of the same Miller Column.\n\n        const verticalNavViews = this.navViewSubchain().filter(nv => nv.isVertical())\n        const w = verticalNavViews.sum(nv => nv.targetWidth())\n        return w\n\n        /*\n        let w = 0\n        const views = this.stackViewSubchain()\n        for (let i = 0; i < views.length; i++) { // use loop so we can break\n            const sv = views[i]\n\n            //if (sv.direction() !== this.direction()) {\n            //    break \n            //}\n\n            if (sv.navView().isVertical()) {\n                w += sv.navView().targetWidth()\n            }\n        }\n        return w\n        */\n    }\n\n    topViewWidth () {\n        const view = this.rootStackView()\n        if (view.parentView() === DocumentBody.shared()) {\n            return window.innerWidth // assume it fills the window? what about margins, padding?\n        }\n        return view.size().width() // clientWidth works here, but maybe all cases\n        //return this.rootStackView().calcSize().width()\n    }\n\n    compactNavAsNeeded () {\n        if (this.direction() === \"right\") {\n            //console.log(\"StackView \" + this.node().title() + \" compactNavAsNeeded\")\n\n            const maxWidth = this.topViewWidth()\n            const sum = this.sumOfNavWidths()\n\n            if (sum > maxWidth) {\n                //console.log(\"  \" + this.node().title() + \" sum \" + sum + \" > win \" + maxWidth + \" COLLAPSE\")\n                //debugger;\n                //this.topViewWidth()\n\n                this.navView().collapse()\n            } else {\n                //console.log(\"  \" + this.node().title() + \" sum \" + sum + \" < win \" + maxWidth + \" UNCOLLAPSE\")\n                this.navView().uncollapse()\n            }\n        }\n\n        return false\n    }\n\n    // --- caching during dragging ---\n\n    // dragging events to start/end caching\n\n    onStackChildDragSourceEnter (dragView) {\n        if (!this.isCaching()) {\n            console.log(this.debugTypeId() + \" onStackChildDragSourceEnter\")\n            this.watchOnceForNoteFrom(\"onDragViewClose\", dragView)\n            //this.beginCaching()\n            this.rootStackView().beginCaching()\n        }\n    }\n\n    onDragViewClose (aNote) {\n        console.log(this.debugTypeId() + \" onDragViewClose\")\n        //this.endCaching()\n        this.rootStackView().endCaching()\n    }\n\n    // begin / end caching\n\n    isCaching () {\n        return !Type.isNull(this.nodeToStackCache())\n    }\n\n    beginCaching () {\n        // begins caching on all chained substacks\n        if(!this.isCaching()) {\n            //console.log(this.debugTypeId() + \" beginCaching -----------------\")\n            //debugger;\n            this.setNodeToStackCache(new Map())\n\n            const ov = this.otherViewContent()\n            if (ov && ov.cacheId) {\n                this.cacheView(ov)\n                ov.beginCaching()\n            }\n        }\n        return this\n    }\n\n    endCaching () {\n        // ends caching on all chained substacks\n        if(this.isCaching()) {\n            //console.log(this.debugTypeId() + \" endCaching -----------------\")\n            //this.nodeToStackCache().valuesArray().forEach(sv => this.uncacheView(sv))\n            this.setNodeToStackCache(null)\n\n            const ov = this.otherViewContent()\n            if (ov && ov.cacheId) {\n                //this.uncacheView(ov)\n                ov.endCaching()\n            }\n        }\n        return this\n    }\n\n    // --- node to StackView cache ---\n\n    cacheId () { // used atm in StackView cache\n        return this.node().typeId()\n    }\n\n    hasCache () {\n        return !Type.isNull(this.nodeToStackCache())\n    }\n\n    cacheView (aView) {\n        const cache = this.nodeToStackCache()\n        const k = aView.cacheId()\n        if (!cache.hasKey(k)) {\n            cache.atPut(k, aView)\n        }\n        return this\n    }\n\n    /*\n    uncacheView (stackView) {\n        const cache = this.nodeToStackCache()\n        const k = aView.cacheId()\n        if (cache.hasKey(k)) {\n            cache.removeKey(k)\n        }\n        return this\n    }\n    */\n\n    cachedViewForNode (aNode) {\n        if (this.hasCache() && aNode) {\n            const k = aNode.typeId()\n            return this.nodeToStackCache().at(k, this)\n        }\n        return null\n    }\n\n    otherViewContentForNode (aNode) {\n        let sv = this.cachedViewForNode(aNode)\n\n        if (!sv) {\n            // what if node is null now and set *after* this?\n            // things like a path change can alter node?\n            sv = StackView.clone().setNode(aNode)\n            if (this.isCaching()) {\n                sv.beginCaching()\n            }\n        }\n\n        return sv\n    }\n        \n}.initThisClass());\n",
  "EtndE/8M7mzy9vXPQ3tTQdkur//cnxVbEG6LWwcmuPU=": "\"use strict\";\n\n/*\n    \n    NavView\n    \n*/\n\n(class NavView extends NodeView {\n\n    initPrototypeSlots () {\n        this.newSlot(\"stackView\", null)\n        this.newSlot(\"scrollView\", null) // ScrollView fits NavView size, and contains TilesView which may be larger\n        this.newSlot(\"tilesView\", null) // is inside scrollView\n        this.newSlot(\"isCollapsed\", false)\n        this.newSlot(\"animatesCollapse\", true)\n        this.newSlot(\"beforeEdgePanBorderBottom\", null) // private\n        this.newSlot(\"beforeEdgePanBorderRight\", null) // private\n    }\n\n    targetWidth () {\n        const defaultWidth = 300\n        if (this.node()) {\n            const minWidth = this.node().nodeMinTileWidth()\n            const maxWidth = 600\n            let w = defaultWidth\n            w = Math.max(defaultWidth, minWidth)\n            w = Math.min(w, maxWidth)\n            if (w) {\n                return w\n            }\n        }\n        return defaultWidth\n    }\n\n    targetHeight () {\n        if (this.node()) {\n            const h = this.node().nodeMinTileHeight()\n            if (h) {\n                return h\n            }\n        }\n        return 64\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"block\")\n        this.setPosition(\"relative\")\n        this.setFlexDirection(\"column\")\n        this.setFlexGrow(1)\n        //this.setOpacity(0)\n        this.setOverflow(\"hidden\")\n        this.setUserSelect(\"none\")\n        //this.setTransition(\"opacity 0.5s ease-in-out\")\n        //this.setTransition(\"flex-basis 0.1s\")\n        this.setTransition(\"opacity 0.5s ease-in-out, flex-basis 0s\")\n\n        /*\n        this.setHeaderClass(ColumnGroupHeader)\n        this.setMiddleClass(BrowserScrollView)\n        this.setFooterClass(ColumnGroupFooter)\n        this.setupHeaderMiddleFooterViews()\n        this.footerView().hideDisplay()\n        */\n\n        this.setScrollView(StackScrollView.clone())\n        this.addSubview(this.scrollView())\n\n        this.setTilesView(TilesView.clone())\n        this.scrollView().addSubview(this.tilesView())\n\n        this.addGestureRecognizer(RightEdgePanGestureRecognizer.clone()) // for adjusting width\n        this.addGestureRecognizer(BottomEdgePanGestureRecognizer.clone()) // for adjusting height\n\n        //this.addGestureRecognizer(RightEdgePanGestureRecognizer.clone()) \n        return this\n    }\n\n    isVertical () {\n        return this.stackView().direction() === \"right\"\n    }\n\n    syncOrientation () {\n        if (this.isVertical()) {\n            this.makeOrientationRight()\n        } else {\n            this.makeOrientationDown()\n        }\n        return this\n    }\n\n    // --- border ---\n\n    borderColor () {\n        return \"rgba(255, 255, 255, 0.3)\"\n    }\n\n    hasBorder () {\n        const node = this.node()\n        if (node) {\n            const hint = node.nodeNavBorderHint()\n            if (Type.isBoolean(hint)) {\n                return hint\n            }\n        }\n        return true\n    }\n\n    borderStyle () {\n        if (this.hasBorder()) {\n            return \"0px solid \" + this.borderColor() + \" inset\"\n        }\n        return null\n    }\n\n    // ---\n\n    makeOrientationRight () {\n        this.setFlexDirection(\"column\")\n        this.setFlexBasis(this.targetWidth() + \"px\")\n        this.setFlexGrow(0)\n        this.setFlexShrink(0)\n        this.setBorderBottom(null)\n        this.setBorderRight(this.borderStyle())\n        this.scrollView().setIsVertical(true)\n        //this.setBoxShadow(\"inset -10px 0 20px rgba(0, 0, 0, 0.05)\")\n    }\n\n    makeOrientationDown () {\n        this.setFlexDirection(\"row\")\n        this.setFlexBasis(this.targetHeight() + \"px\")\n        this.setFlexGrow(0)\n        this.setFlexShrink(0)\n        this.setBorderRight(null)\n        this.setBorderBottom(this.borderStyle())\n        this.scrollView().setIsVertical(false)\n        //this.setBoxShadow(\"inset 0 -10px 40px #222\")\n    }\n\n    setNode (aNode) {\n        super.setNode(aNode)\n        this.tilesView().setNode(aNode)\n        return this\n    }\n\n    syncFromNode () {\n        this.syncOrientation()\n        //this.tilesView().syncFromNode()\n        this.applyStyles()\n\n        if (this.isVertical()) {\n            const w = this.node().nodeMinTileWidth()\n            if (w && !Type.isNullOrUndefined(w)) {\n                this.setMinAndMaxWidth(w)\n                /*\n                this.setFlexBasis(w + \"px\")\n                this.setFlexGrow(0)\n                this.setFlexShrink(0)\n                */\n            }\n        } else {\n            const h = this.node().nodeMinTileHeight()\n            if (h && !Type.isNullOrUndefined(h)) {\n                this.setMinAndMaxHeight(h)\n            }\n        }\n\n        return this\n    }\n\n    /*\n    applyStyles () {\n        super.applyStyles()\n        \n        if (this.isVertical()) {\n            this.applyColumnStyle()\n        }\n        return this\n    }\n\n    applyColumnStyle () {\n        this.setBorder(\"\")\n        const themeClass = this.currentThemeClass()\n        if (themeClass) {\n            const columns = themeClass.firstSubnodeWithTitle(\"columns\")\n            //debugger;\n            if (columns) {\n                const colorFields = columns.subnodes().select(sn => sn.thisClass().isSubclassOf(Object.getClassNamed(\"BMStringField\")) || sn.type() === \"BMField\")\n                const count = colorFields.length\n                if (count) {\n                    let i = this.stackView().stackViewDepth()\n                    let ci = i % count\n                    const color = colorFields.at(ci).value()\n                    console.log(\"column \" + i + \" color index \" + ci + \" color \" + color)\n                    this.setBackgroundColor(color)\n                }\n            }\n        }\n    }\n    */\n\n    // --- collpase / uncollapse ---\n\n    collapse () {\n        if (!this.isCollapsed()) {\n            this.hideDisplay()\n            //this.setMinAndMaxWidth(0)\n\n            /*\n            this.setFlexBasis(\"0px\")\n            this.setFlexGrow(0)\n            this.setFlexShrink(0)\n            */\n           this.setIsCollapsed(true)\n        }\n    }\n\n    uncollapse () {\n        if (this.isCollapsed()) {\n            this.unhideDisplay()\n            //this.setMinAndMaxWidth(this.targetWidth() + \"px\")\n            this.syncOrientation()\n            this.setIsCollapsed(false)\n        }\n    }\n\n    // --- right edge gesture ---\n\n    edgeMoveBorderStyle () {\n        return \"1px rgba(255, 255, 255, 0.5) inset\"\n    }\n\n    onRightEdgePanBegin (aGesture) {\n        this.setBeforeEdgePanBorderRight(this.borderRight())\n        this.setBorderRight(this.edgeMoveBorderStyle())\n    }\n\n    onRightEdgePanMove (aGesture) {\n        const p = aGesture.currentPosition() // position in document coords\n        const f = this.frameInDocument()\n        const nw = Math.max(10, p.x() - f.x())\n        //console.log(\"nw = \", nw)\n        this.node().setNodeMinTileWidth(nw)\n        this.scheduleSyncToNode()\n        return this\n    }\n\n    onRightEdgePanComplete (aGesture) {\n        this.onRightEdgePanMove(aGesture)\n        this.setBorderRight(this.beforeEdgePanBorderRight())\n        this.setBeforeEdgePanBorderBottom(null)\n        this.unhideTransition()\n    }\n\n    // --- bottom edge gesture ---\n\n    onBottomEdgePanBegin (aGesture) {\n        this.setBeforeEdgePanBorderBottom(this.borderBottom())\n        this.setBorderBottom(this.edgeMoveBorderStyle())\n        //this.setTransition(\"min-height 0s, max-height 0s\")\n        this.hideTransition()\n    }\n\n    onBottomEdgePanMove (aGesture) {\n        const p = aGesture.currentPosition() // position in document coords\n        const f = this.frameInDocument()\n        const newHeight = Math.max(10, p.y() - f.y())\n        //console.log(\"node \" + this.node().title() + \" newHeight = \", newHeight)\n        this.node().setNodeMinTileHeight(newHeight)\n        this.scheduleSyncToNode()\n        return this\n    }\n\n    onBottomEdgePanComplete (aGesture) {\n        this.onBottomEdgePanMove(aGesture)\n        this.setBorderBottom(this.beforeEdgePanBorderBottom())\n        this.setBeforeEdgePanBorderBottom(null)\n        this.unhideTransition()\n    }\n/*\n    removeAllGestureRecognizers () {\n        //debugger;\n        return super.removeAllGestureRecognizers()\n    }\n    */\n\n}.initThisClass());\n",
  "rWPDrcdvE6cNuWwBLRmiEO3n/hhtYOH1kDleF7NQems=": "\"use strict\";\n\n/*\n\n    StackScrollView\n\n*/\n\n(class StackScrollView extends DomView {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"block\")\n        this.setPosition(\"relative\")\n        this.setTopPx(null)\n        this.makeVertical()\n        this.setMsOverflowStyle(\"none\") // removes scrollbars on IE 10+ \n        this.setOverflow(\"-moz-scrollbars-none\") // removes scrollbars on Firefox \n        this.setBackgroundColor(\"transparent\")\n        //this.setBorder(\"1px solid purple\")\n        return this\n    }\n\n    setIsVertical (aBool) {\n        if (aBool) {\n            this.makeVertical()\n        } else {\n            this.makeHorizontal()\n        }\n        return this\n    }\n\n    makeVertical () {\n        //this.setWidth(\"fit-content\")\n        this.setWidth(\"100%\")\n        this.setHeight(\"100%\")\n        this.setOverflowY(\"scroll\") // has to be scroll, not auto, for touch scroll momentum to work \n        this.setOverflowX(\"hidden\")\n        return this\n    }\n\n    makeHorizontal () {\n        this.setWidth(\"100%\")\n        this.setHeight(\"100%\")\n        //this.setHeight(\"fit-content\")\n        this.setOverflowY(\"hidden\") \n        this.setOverflowX(\"scroll\") // has to be scroll, not auto, for touch scroll momentum to work \n        return this\n    }\n    \n}.initThisClass());\n\n\n",
  "SCN/Ube5vAq6RYSUn0YMYrzxlIqTmZNgHawdK2VeMvw=": "\"use strict\";\n\n/*\n    \n    TilesView\n\n    Contains array of Tile (and Tile decendant class) views.\n    Parent is a StackScrollView, whose parent is a NavView.\n    \n*/\n\n(class TilesView extends NodeView {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"tiles\", null)\n        this.newSlot(\"allowsCursorNavigation\", true)\n        this.newSlot(\"tilePlaceHolder\", null)\n        this.newSlot(\"hasPausedSync\", false)\n        //this.newSlot(\"isColumnInspecting\", false)\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"block\")\n        this.setPosition(\"relative\")\n        //this.setFlexBasis(\"fit-content\")\n        //this.setFlexGrow(0)\n        //this.setFlexShrink(0)\n        this.makeOrientationRight()\n\n        this.setOverflow(\"hidden\")\n        this.setWebkitOverflowScrolling(\"regular\")\n        this.setMsOverflowStyle(\"none\")\n        this.setUserSelect(\"none\")\n\n        this.setIsDebugging(false)\n        this.setIsRegisteredForKeyboard(true)\n        this.setAcceptsFirstResponder(true)\n\n        this.setUserSelect(\"none\")\n        this.addGestureRecognizer(PinchGestureRecognizer.clone()) // for pinch open to add tile\n        this.addGestureRecognizer(TapGestureRecognizer.clone()) // for pinch open to add tile\n\n        this.setIsRegisteredForBrowserDrop(true)\n        \n        //this.setBorder(\"1px dashed red\")\n        this.setDefaultSubviewProto(TitledTile)\n        return this\n    }\n\n    // --- helpers ---\n    // subview path: StackView -> NavView -> ScrollView -> TilesView -> Tiles\n\n    scrollView () {\n        return this.parentView()\n    }\n\n    navView () {\n        return this.scrollView().parentView()\n    }\n\n    stackView () {\n        return this.navView().parentView()\n    }\n\n    /*\n    browser () {\n        return this.stackView()\n    }\n    */\n\n    // --- title ---\n    \n    title () {\n        return this.node() ? this.node().title() : \"\"\n    }\n\n    // --- accessing tiles ---\n    \n    tiles () {\n        return this.subviews()\n    }\n\n    addTile (v) {\n        return this.addSubview(v)\n    }\n\n    removeTile (v) {\n        return this.removeSubview(v)\n    }\n\n    tilesWithNodes (nodeArray) {\n        return nodeArray.map(node => this.tileWithNode(node))\n    }\n\n    tileWithNode (aNode) {\n        return this.tiles().detect(tile => tile.node() === aNode)\n    }\n\n    indexOfTile (aTile) {\n        // we might want this to be based on flex view order instead, \n        // so best to keep it abstract\n        return this.indexOfSubview(aTile)\n    }\n\n    tileAtIndex (anIndex) {\n        return this.subviews().at(anIndex)\n    }\n\n    tileWithNode (aNode) {\n        const tile = this.tiles().detect(tile => tile.node().nodeTileLink() === aNode)\n        return tile\n    }\n\n    maxTileWidth () {\n        if (this.tiles().length === 0) {\n            return 0\n        }\n        \n        const maxWidth = this.tiles().maxValue(tile => tile.desiredWidth())\t\t\t\n        return maxWidth\t\n    }\n\t\n    // --- sync ---\n\n    syncFromNode () {\n        this.syncOrientation()\n        super.syncFromNode() \n\n        /*\n        if (this.node().nodeMinTileHeight()) {\n            this.setMinAndMaxHeight(this.node().nodeMinTileHeight())\n        }\n        */\n\n        /*\n        if (this.selectedTiles().length === 0) {\n            //this.didChangeNavSelection() // TODO: is this right?\n        }\n        */\n        return this\n    }\n\n\n    subviewProtoForSubnode (aSubnode) {\n        let proto = aSubnode.nodeTileClass() // we need this to get tile versions of view\n\t\t\n        if (!proto) {\n            proto = this.defaultSubviewProto()\n        }\n\t\t\t\t\n        return proto      \n    }\n\n    didChangeNode () {\n        super.didChangeNode()\n\n        if (this.node() && this.node().nodeTilesStartAtBottom()) {\n            this.addTimeout(() => { this.scrollToBottom() }, 0)\n            //this.tile().last().scrollIntoView()\n        }\n\n        return this\n    }\n\n    // --- duplicating tiles ---\n\n    duplicateSelectedTile () {\n        const node = this.node()\n        const tile = this.selectedTile()\n        const canAdd = node.canSelfAddSubnode() \n        if (tile && canAdd) {\n            const canCopy = !Type.isNullOrUndefined(tile.node().copy)\n            if (canCopy) { \n                //this.debugLog(\" duplicate selected tile \" + this.selectedTile().node().title())\n                const subnode = tile.node()\n                const newSubnode = subnode.copy()\n                const index = node.indexOfSubnode(subnode)\n                node.addSubnodeAt(newSubnode, index)\n                this.scheduleSyncFromNode()\n            }\n        }\n    }\n\n    duplicateSelectedTiles () {\n        const newNodes = []\n\n        this.selectedTiles().forEach(tile => {\n            const i = this.indexOfSubview(tile)\n            const dupNode = tile.node().duplicate()\n            newNodes.push(dupNode)\n            this.node().addSubnodeAt(dupNode, i+1)\n        })\n        this.unselectAllTiles()\n        this.syncFromNodeNow()\n\n        // TODO: unselect current tiles at browser level\n        newNodes.forEach(newNode => {\n            const newTile = this.tileWithNode(newNode)\n            if (newTile) {\n                newTile.select()\n            }\n        })\n\n        return this\n    }\n\n    // --- inspecting ---\n\n    isInspecting () {\n        /*\n        if (this.isColumnInspecting()) {\n            return true\n        }\n        */\n        // see if the tile that selected this column is being inspected\n        const prev = this.previousItemSet() \n        if (prev) {\n            const tile = prev.selectedTile()\n            if (tile) {\n                return tile.isInspecting()\n            }\n        }\n        return false\n    }\n    \n    /*\n    setIsColumnInspecting (aBool) {\n        if (this._isColumnInspecting !== aBool) {\n            this._isColumnInspecting = aBool\n            this.scheduleSyncFromNode()\n        }\n        return this\n    }\n    */\n\n    // -----------------------------\n\n    columnIndex () {\n        return this.parentViewsOfClass(StackView).length\n    }\n\n    // next column\n    \n    nextColumn () {\n        const nsv = this.stackView().nextStackView()\n        if (nsv) {\n            return nsv.navView().tilesView()\n        }\n        return null\n    }\n\n    // previous column\n\t\n    previousItemSet () {\n        if (this.stackView()) {\n            const ps = this.stackView().previousStackView()\n            if (ps) {\n                return ps.navView().tilesView()\n            }\n        }\n        return null\n    }\n\n    // --- editing ---\n\n    onDoubleClick (event) {\n        //this.debugLog(\".onDoubleClick()\")\n        return true\n    }\n\n    // --- debugging ---\n\n    /*\n    setNode (aNode) {\n        if (this.node() && Type.isNull(aNode)) {\n            console.log(this.debugTypeId() + \" setNode(null)\")\n            //debugger;\n        }\n        super.setNode(aNode)\n        return this\n    }\n    */\n\n    // --- browser drop ---\n\n    onBrowserDropChunk (dataChunk) {\n        const node = this.node()\n\n        if (node && node.onBrowserDropChunk) {\n            node.onBrowserDropChunk(dataChunk)\n        }\n        this.scheduleSyncFromNode()\n    }\n\n    /*\n    scheduleSyncFromNode () {\n        console.warn(this.typeId() + \" scheduleSyncFromNode\")\n        return super.scheduleSyncFromNode()\n    }\n    */\n    \n}.initThisClass());\n",
  "LldDW4vvTWMXP6iw5UsAaucFtJ2jt2Q8bDqHAwrA6fI=": "\"use strict\";\n\n/*\n    \n    TilesView_dragViewProtocol\n    \n*/\n\n(class TilesView_dragViewProtocol extends TilesView {\n    \n    // -- messages sent by DragView to the parent/owner of the view it's dragging ---\n\n    onDragSourceBegin (dragView) {\n        this.setHasPausedSync(true)\n        //ElementDomView.pauseRetires()\n\n        //console.log(this.typeId() + \" onDragSourceBegin\")\n        // ---\n\n\n        /*\n        dragView.items().forEach(sv => {\n            sv.hideForDrag()\n        })\n        */\n\n        // ---\n        const subview = dragView.item()\n        const index = this.indexOfSubview(subview)\n        assert(index !== -1)\n\n        if (dragView.isMoveOp()) {\n            dragView.items().forEach(sv => this.removeSubview(sv))\n        } else if (dragView.isCopyOp()) {\n\n        }\n\n        //this.tiles().forEach(tile => tile.setTransition(\"all 0.3s\"))\n        this.tiles().forEach(tile => tile.setTransition(\"top 0.3s, left 0.3s\"))\n\n        this.newTilePlaceHolder(dragView)\n\n        /*\n        if (dragView.isMoveOp()) {\n            subview.hideForDrag()\n            this.moveSubviewToIndex(this.tilePlaceHolder(), index)\n        }\n        */\n\n        this.moveSubviewToIndex(this.tilePlaceHolder(), index)\n        this.stackTiles()\n        return this\n    }\n\n    onDragSourceCancelled (dragView) {\n        /*\n        dragView.items().forEach(subview => {\n            subview.unhideForDrag()\n        })\n        */\n        this.onDragSourceDropped(dragView)\n        //this.removeTilePlaceHolder()\n    }\n\n\n    onDragSourceEnter (dragView) {\n        this.onDragDestinationHover(dragView)\n        this.stackView().rootStackView().onStackChildDragSourceEnter(dragView)\n    }\n\n    onDragSourceHover (dragView) {\n        this.onDragDestinationHover(dragView)\n        this.indexOfTilePlaceHolder()\n    }\n\n    onDragSourceExit (dragView) {\n        this.onDragDestinationHover(dragView)\n    }\n\n\n    // -- DragView dropping ---\n\n    onDragSourceDropped (dragView) {\n        //console.log(this.debugTypeId() + \" --- onDragSourceDropped ---\")\n        //debugger;\n\n        const insertIndex = this.indexOfTilePlaceHolder()\n\n        let movedNodes = dragView.items().map(item => item.node())\n        if (dragView.isMoveOp()) {\n            // todo\n        } else if (dragView.isCopyOp()) {\n             movedNodes = movedNodes.map(aNode => aNode.duplicate())\n        } else {\n            throw new Error(\"unhandled drag operation\")\n        }\n        //console.log(this.debugTypeId() + \" --- unstacking ---\")\n\n        this.unstackTiles()\n        this.removeTilePlaceHolder()\n    \n        //console.log(\"---\")\n        //this.showNodes(movedNodes)\n        //this.showTiles(this.subviews())\n        const newSubnodesOrder = this.subviews().map(sv => sv.node())\n        //debugger;\n        //this.showNodes(newSubnodesOrder)\n        \n        this.node().removeSubnodes(movedNodes) // is this needed?\n        //assert(!newSubnodesOrder.containsAny(movedNodes))\n\n\n        newSubnodesOrder.atInsertItems(insertIndex, movedNodes)\n        //this.showNodes(newSubnodesOrder)\n\n        this.node().setSubnodes(newSubnodesOrder)\n\n        //console.log(\"new order: \" + this.node().subnodes().map(sn => sn.title()).join(\"-\"))\n        this.setHasPausedSync(false)\n        this.syncFromNodeNow()\n        this.selectAndFocusNodes(movedNodes)\n    }\n\n    onDragDestinationDropped (dragView) {\n        //debugger;\n        \n        const insertIndex = this.indexOfTilePlaceHolder()\n\n        let movedNodes = dragView.items().map(item => item.node())\n        if (dragView.isMoveOp()) {\n            movedNodes.forEach(aNode => aNode.removeFromParentNode())\n        } else if (dragView.isCopyOp()) {\n             movedNodes = movedNodes.map(aNode => aNode.duplicate())\n        } else {\n            throw new Error(\"unhandled drag operation\")\n        }\n\n        this.unstackTiles()\n        this.removeTilePlaceHolder()\n\n        const newSubnodesOrder = this.subviews().map(sv => sv.node())\n        assert(!newSubnodesOrder.containsAny(movedNodes))\n        newSubnodesOrder.atInsertItems(insertIndex, movedNodes)\n        this.node().setSubnodes(newSubnodesOrder)\n\n        this.setHasPausedSync(false)\n        this.syncFromNodeNow()\n        this.selectAndFocusNodes(movedNodes)\n    }\n\n    onDragSourceEnd (dragView) {\n        this.endDropMode()\n        //ElementDomView.unpauseRetires()\n    }\n\n    // -- messages sent by DragView to the potential drop view, if not the source ---\n\n    acceptsDropHover (dragView) {\n        //return true \n\n        const node = this.node()\n        if (node) {\n            const dropNode = dragView.item().node()\n\n            if (dropNode === this.node()) {\n                return false\n            }\n            \n            const acceptsNode = node.acceptsAddingSubnode(dropNode)\n            const canReorder = this.canReorderTiles()\n            //console.log(node.title() + \" acceptsNode \" + dropNode.title() + \" \" + acceptsNode)\n            //console.log(\"parentNode \" + node.parentNode().title())\n            const result = acceptsNode && canReorder\n            return result\n        }\n        return false\n    }\n\n    /// --- tile place holder ---\n\n    newTilePlaceHolder (dragView) {\n        //this.debugLog(\"newTilePlaceHolder\")\n        if (!this.tilePlaceHolder()) {\n            const ph = DomView.clone().setElementClassName(\"TilePlaceHolder\") // classname not for css rule, just a note for debugging\n            ph.setBackgroundColor(\"black\")\n\n            //ph.setTransition(\"top 0s, left 0s, max-height 1s, min-height 1s\")\n            ph.setTransition(\"top 0s, left 0s\")\n            this.addSubview(ph)\n            this.setTilePlaceHolder(ph)\n            this.syncTilePlaceHolderSize(dragView)\n        }\n        return this.tilePlaceHolder()\n    }\n\n    syncTilePlaceHolderSize (dragView) {\n        const ph = this.tilePlaceHolder()\n        //const period = 0.1\n        if (this.isVertical()) {\n            ph.setMinAndMaxWidth(this.computedWidth())\n            ph.setMinAndMaxHeight(dragView.minHeight())\n            //ph.setMinAndMaxHeight(dragView.maxHeightPx() + 1) // all tiles seem to shrink while dragging, not just place holder\n            //ph.transitions().at(\"top\").updateDuration(0)\n            //ph.transitions().at(\"left\").updateDuration(period)\n        } else {\n            ph.setMinAndMaxWidth(dragView.minWidth())\n            ph.setMinAndMaxHeight(this.computedHeight())\n            //ph.transitions().at(\"top\").updateDuration(period)\n            //ph.transitions().at(\"left\").updateDuration(0)\n        }\n\n        return this\n    }\n\n    indexOfTilePlaceHolder () {\n        const sortMethod = this.isVertical() ? \"topPx\" : \"leftPx\"\n        const orderedTiles = this.tiles().shallowCopy().sortPerform(sortMethod) \n        const insertIndex = orderedTiles.indexOf(this.tilePlaceHolder()) \n        \n        //this.showTiles(orderedTiles)\n        //console.log(\"hover insertIndex: \", insertIndex)\n        \n        return insertIndex\n    }\n\n    // --- drag destination ---\n\n    onDragDestinationEnter (dragView) {\n        this.setHasPausedSync(true)\n\n        // insert place holder view\n        if (!this.tilePlaceHolder()) {\n            this.newTilePlaceHolder(dragView)\n            this.tilePlaceHolder().setMinAndMaxHeight(dragView.computedHeight())\n            this.onDragDestinationHover(dragView)\n        }\n    }\n\n    onDragDestinationHover (dragView) {\n        // move place holder view\n        const ph = this.tilePlaceHolder()\n        if (ph) {\n            this.syncTilePlaceHolderSize(dragView)\n            const vp = this.viewPosForWindowPos(dragView.dropPoint())\n            if (this.isVertical()) {\n                const h = dragView.computedHeight()\n                const y = vp.y() - h/2\n                ph.setTopPx(y)\n            } else {\n                const w = dragView.computedWidth()\n                const x = vp.x() - w/2\n                //console.log(\"w:\" + w + \" x:\" + vp.x())\n                ph.setLeftPx(x)\n            }\n            //console.log(\"ph.top() = \", ph.top())\n            this.stackTiles() // need to use this so we can animate the tile movements\n        }\n    }\n    \n    onDragDestinationExit (dragView) {\n        this.endDropMode()\n    }\n\n    onDragDestinationEnd (aDragView) {\n        this.endDropMode()\n    }\n\n    acceptsDropHoverComplete (aDragView) {\n        return this.acceptsDropHover(aDragView);\n    }\n\n    dropCompleteDocumentFrame () {\n        return this.tilePlaceHolder().frameInDocument()\n    }\n\n\n    removeTilePlaceHolder () {\n        this.debugLog(\"removeTilePlaceHolder\")\n\n        const ph = this.tilePlaceHolder()\n        if (ph) {\n            //console.log(\"removeTilePlaceHolder\")\n            if (this.hasSubview(ph)) {\n                this.removeSubview(ph)\n            }\n            this.setTilePlaceHolder(null)\n        }\n    }\n\n    animateRemoveTilePlaceHolderAndThen (resolve) {\n        this.debugLog(\"animateRemoveTilePlaceHolder\")\n\n        const ph = this.tilePlaceHolder()\n        if (ph) {\n            ph.setMinAndMaxHeight(0)\n            this.addTimeout(() => {\n                this.removeTilePlaceHolder()\n                if (resolve) { resolve() }\n            }, 1*1000)\n        } else {\n            if (resolve) { resolve() }\n        }\n    }\n\n    endDropMode () {\n        this.debugLog(\"endDropMode\")\n        //this.unstackTiles()\n        this.removeTilePlaceHolder()\n        this.unstackTiles()\n        this.setHasPausedSync(false)\n        this.didReorderTiles()\n\n        /*\n        this.animateRemoveTilePlaceHolderAndThen(() => {\n         this.debugLog(\"endDropMode\")\n            this.unstackTiles()\n            this.setHasPausedSync(false)\n            this.didReorderTiles()\n        })\n        */\n\n        return this\n    }\n\n    /*\n    tileIndexForViewportPoint (aPoint) {\n        if (this.tiles().length === 0) {\n            return 0\n        }\n\n        const tile = this.tiles().detect((tile) => {\n            return tile.frameInDocument().containsPoint(aPoint)\n        })\n\n        if (tile) {\n            return this.tiles().indexOf(tile)\n        }\n\n        return this.tiles().length\n    }\n    */\n\n    // Browser drop from desktop\n\n    acceptsDrop () {\n        return true\n    }\n\n\n}.initThisCategory());\n",
  "raabuFsENuxIGvkcLHFwtn8mE9sYc8vShYVnzPGkESg=": "\"use strict\";\n\n/*\n    \n    TilesView_selection\n    \n*/\n\n(class TilesView_selection extends TilesView {\n    \n    // --- column ---\n\n    unselectTilesInNextColumn () {\n        const c = this.nextColumn()\n        if (c) {\n            c.unselectAllTiles()\n        }\n        return this\n    }\n\n    /*\n    didSelectItem (itemView) {\n        console.log(this.typeId() + \" didSelectItem\")\n        this.subviews().forEach(sv => {\n            if (sv === itemView) {\n                //sv.select()\n            } else {\n                sv.unselect()\n            }\n        })\n    \n        return false\n    }\n    */\n\n    lastSelectedTile () {\n        return this.selectedTiles().maxItem(tile => tile.lastSelectionDate().getTime())\n    }\n\n    // -- update isSelected ---\n\t\n    didUpdateSlotIsSelected (oldValue, newValue) {\n        debugger;\n        super.didUpdateSlotIsSelected(oldValue, newValue)\n\n        if (this.isSelected()) {\n            const focusedView = WebBrowserWindow.shared().activeDomView()\n\n            // TODO: need a better solution to this problem\n            if (!focusedView || (focusedView && !this.hasFocusedDecendantView())) {\n                this.focus()    \n            }\n        } else {\n            this.blur()\n        }\n\t\t\n        return this\n    }\n\n    // --- tile tapping ---\n\n    selectNode (aNode) {\n        const sv = this.subviewForSubnode(aNode)\n        if (sv) {\n            this.didTapItem(sv)\n        }\n        return this\n    }\n\n    didTapItem (anItem) {\n        //debugger;\n        // if the item is already selected, this won't trigger a resync, so unselect first?\n        //anItem.unselect()\n        //debugger; \n        anItem.activate() \n        if (!anItem.hasFocusedDecendantView()) {\n            anItem.focus()\n            // anItem seems to already be focused somehow\n        }\n        this.unselectAllTilesExcept(anItem)\n        this.unselectTilesInNextColumn()\n        //this.tilesView().didChangeNavSelection()\n\n        this.didChangeNavSelection() // this may already have been sent - but only if selection bool changed\n    }\n    \n    didShiftTapItem (anItem) {\n        let lastItem = this.lastSelectedTile()\n\n        if (!lastItem) {\n            lastItem = this.tiles().first()\n        }\n\n        if (lastItem) {\n            const r1 = this.indexOfTile(anItem)\n            const r2 = this.indexOfTile(lastItem)\n            assert(r1 !== -1 && r2 !== -1)\n            const i1 = Math.min(r1, r2)\n            const i2 = Math.max(r1, r2)\n            for (let i = i1; i <= i2; i++) {\n                const item = this.tileAtIndex(i)\n                if (!item.isSelected()) {\n                    item.activate()\n                }\n            }\n        }\n\n        return this\n    }\n\n    didMetaTapItem (anItem) {\n        anItem.toggleSelection()\n    }\n\n    // --- unselecting tiles ---\n        \n    unselectAllTilesExcept (selectedTile) {\n        const tiles = this.tiles()\n\n        // unselect all other tiles\n        tiles.forEach(tile => {\n            if (tile !== selectedTile) {\n                if (tile.unselect) {\n                    tile.unselect()\n                } else {\n                    //console.warn(\"=WARNING= \" + this.typeId() + \".unselectAllTilesExcept() tile \" + tile.typeId() + \" missing unselect method\")\n                }\n            }\n        })\n        \n        return this\n    }\n\n    unselectAllTilesExceptTiles (tilesToSelect) {\n        const tiles = this.tiles()\n\n        // unselect all other tiles\n        tiles.forEach(tile => {\n            if (tilesToSelect.contains(tile)) {\n                tile.performIfResponding(\"select\") \n            } else {\n                tile.performIfResponding(\"unselect\") \n            }\n        })\n        \n        return this\n    }\n\n    // --- selection ---\n\n    /*\n    didSelectTile (aTile) {\n        this.didChangeNavSelection()\n    }\n\n    didUnselectTile (aTile) {\n        this.didChangeNavSelection()\n\n    }\n    */\n\n    hasMultipleSelections () {\n        return this.selectedTiles().length > 0\n    }\n\n    // --- selected tiles ---\n\n    selectedTiles () {\n        let tiles = this.tiles().filter(tile => tile.thisClass().isSubclassOf(Tile))\n        const selected = tiles.filter(tile => tile.isSelected())\n        return selected\n    }\n\n    selectedTile () {\n        const sr = this.selectedTiles()\n        if (sr.length === 1) {\n            return sr.first()\n        }\n        return null\n    }\n\n    // --- selected nodes ---\n\n    selectedNodes () {\n        return this.selectedTiles().map(tile => tile.node())\n    }\n\n    selectedNode () {\n        const r = this.selectedTile()\n        return r ? r.node() : null\n    }\n    \n    selectedTileIndex () { \n        // returns -1 if no tiles selected\n        return this.tiles().indexOf(this.selectedTile())\n    }\n\n    // --- selecting tiles ---\n    \n    setSelectedTileIndex (index) {\n        const oldIndex = this.selectedTileIndex()\n        //console.log(\"this.setSelectedTileIndex(\" + index + \") oldIndex=\", oldIndex)\n        if (index !== oldIndex) {\n            const tiles = this.tiles()\n            if (index >= 0 && index < tiles.length) {\n                const tile = tiles[index]\n                this.didTapItem(tile)\n            }\n        }\n        return this\n    }\n  \n    indexOfTileWithNode (aNode) {\n        return this.tiles().detectIndex(tile => tile.node() === aNode)\n    }\n\n    selectAllTiles () {\n        this.tiles().forEachPerformIfResponds(\"select\")\n        return this\n    }\n\n    unselectAllTiles () {\n        this.tiles().forEachPerformIfResponds(\"unselect\")\n        return this\n    }\n\n    selectTileWithNode (aNode) {\n        //console.log(\">>> column \" + this.node().title() + \" select tile \" + aNode.title())\n        const selectedTile = this.tileWithNode(aNode)\n\t\t\n        if (selectedTile) {\n            selectedTile.setIsSelected(true)\n\t\t\t\n            this.tiles().forEach((aTile) => {\n                if (aTile !== selectedTile) {\n                    aTile.unselect()\n                }\n            })\n        }\n\n        return selectedTile\n    }\n    \n    selectedTileTitle () {\n        const tile = this.selectedTile()\n        if (tile) { \n            return tile.title().innerHtml() \n        }\n        return null\n    }\n\n    showSelected () {\n        /*\n        TODO: add check if visible\n        if (this.selectedTile()) {\n            this.selectedTile().scrollIntoView()\n        }\n        */\n        //this.didChangeNavSelection()\n        return this\t    \n    }\n\n     // nextTile\n\n     nextTile () {\n        const si = this.selectedTileIndex()\n        if (si !== -1 && si < this.tiles().length) {\n            const nextTile = this.tiles()[si +1]\n            return nextTile\n        }\n        return null\n    }\n    \n    selectFirstTile () {\n        this.setSelectedTileIndex(0)\n        return this\n    }\n\n    firstTile () {\n        if (this.tiles().length > 0) {\n            return this.tiles()[0]\n        }\n        return null\n    }\n\n    selectNextTile () {\n        const si = this.selectedTileIndex()\n        if (si === -1) {\n            this.setSelectedTileIndex(0)\n        } else {\n            this.setSelectedTileIndex(si + 1)\n        }\n        return this\n    }\n    \n    selectPreviousTile () {\n        const si = this.selectedTileIndex()\n        if (si === -1) {\n            this.setSelectedTileIndex(0)\n        } else {\n            this.setSelectedTileIndex(si - 1)\n        }\n        return this\n    }\n\n    // --- focus / selection ---\n    \n    isInBrowser () {\n        return !Type.isNull(this.parentView())\n    }\n\n    shouldFocusAndExpandSubnode (aNote) { // focus & expand tile - can be activated by note from node\n        if (!this.isInBrowser()) {\n            return this\n        }\n\n\t    const subnode = aNote.info()\n\t    let subview = this.subviewForNode(subnode)\n\t    \n        if (!subview) {\n            this.syncFromNodeNow()\n\t        subview = this.subviewForNode(subnode)\n        } \n\n        if (subview) {\n            this.selectTileWithNode(subnode)\n            subview.scrollIntoView()\n            subview.justTap()\n            //this.didChangeNavSelection()\n\t\t    //subview.dynamicScrollIntoView()\n        } else {\n            console.warn(this.type() + \" for node \" + this.node().typeId() + \" has no matching subview for shouldSelectSubnode \" + subnode.typeId())\n\t    }\n\n\t    return this \n    }\n\n    shouldFocusSubnode (aNote) { //  focus but don't expand tile\n\t    const subnode = aNote.info()\n\n\t    let subview = this.subviewForNode(subnode)\n\t    \n        if (!subview) {\n            this.syncFromNodeNow()\n\t        subview = this.subviewForNode(subnode)\n        } \n\n        if (subview) {\n            this.selectTileWithNode(subnode)\n            subview.scrollIntoView()\n\n            // just focus the tile without expanding it\n            /*\n            if (this.previousItemSet()) {\n                this.previousItemSet().didChangeNavSelection()\n            }\n            */\n\n            this.didChangeNavSelection()\n\t\t    //subview.dynamicScrollIntoView()\n        } else {\n            console.warn(this.type() + \" for node \" + this.node().typeId() + \" has no matching subview for shouldFocusSubnode \" + subnode.typeId())\n            //console.log(\"tile nodes = \", this.tiles().map(tile => tile.node().typeId()) )\n\t    }\n\n\t    return this \n    }\n\n    didChangeNavSelection () {\n        const sv = this.stackView()\n        if (sv) {\n            sv.didChangeNavSelection()\n        }\n        return this\n    }\n\t\n    // --- scrolling ---\n\n    scrollToSubnode (aSubnode) {\n\t    //this.debugLog(\".scrollToSubnode\")\n\t    const subview = this.subviewForNode(aSubnode)\n\t    assert(subview)\n\t    this.navView().scrollView().setScrollTop(subview.offsetTop())\n\t    return this \t    \n    }\n    \n    scrollToBottom () {\n        const last = this.tiles().last()\n\n        if (last) { \n            last.scrollIntoView()\n        }\n\n        return this\n    }\n\n    // --------------\n\n    /*\n    focus () {\n        super.focus()\n\t\t\n\t    if (this.selectedTileIndex() === -1) {\n            const sr = this.tiles().first()\n            if (sr) {\n                sr.setShouldShowFlash(true)\n            }\n            this.setSelectedTileIndex(0)\n        }\n\n        //this.debugLog(\" focus\")\n        return this\n    }\n    */\n    \n    selectNextColumn () {\n        const nextColumn = this.nextColumn()\n        if (nextColumn) {\n            this.blur()\n            //console.log(\"nextColumn.focus()\")\n            /*\n            const sr = nextColumn.selectedTile()\n            if (sr) {\n                sr.setShouldShowFlash(true)\n            }\n            */\n            nextColumn.focus()\n            nextColumn.selectFirstTile()\n        }\n        return this\n    }\n\n    selectPreviousColumn () {\n        //this.log(\"selectPreviousColumn this.columnIndex() = \" + this.columnIndex())\n        const prevColumn = this.previousItemSet()\n        if (prevColumn) {\n            this.blur()\n            prevColumn.focus()\n            //this.didChangeNavSelection()\n        }\n        return this\n    }\n\n    // --- select nodes ---\n\n    selectAndFocusNodes (nodes) {\n        const selectTiles = this.tilesWithNodes(nodes)\n        this.unselectAllTilesExceptTiles(selectTiles)\n        if (nodes.length === 1) {\n            const focusNode = nodes.first()\n            focusNode.parentNode().postShouldFocusAndExpandSubnode(focusNode)\n        }\n        return this\n    }\n\n    // --- key views ---\n    \n    selectNextKeyView () {\n        const nextTile = this.nextTile()\n        if (nextTile) {\n            this.selectNextTile()\n            nextTile.becomeKeyView()\n        } else {\n            const firstTile = this.firstTile()\n            if (firstTile) {\n                this.selectFirstTile()\n                firstTile.becomeKeyView()\n            }\n        }\n        return this\n    }\n\n}.initThisCategory());\n",
  "/JrS5CH7i2U4HWp+DNlNoH51kGf/aRkifcJ2SRsKOkk=": "\"use strict\";\n\n/*\n    \n    TilesView_orientation\n    \n*/\n\n(class TilesView_orientation extends TilesView {\n    \n    // --- orientation ---\n\n    syncOrientation () {\n        if (this.isVertical()) {\n            this.makeOrientationRight()\n        } else {\n            this.makeOrientationDown() \n        }\n        return this\n    }\n\n    makeOrientationRight () { // left to right columns, top to bottom items?\n        //this.setFlexDirection(\"column\")\n        this.setMinAndMaxWidth(\"100%\")\n        this.setMinHeight(\"100%\")\n        //this.setMaxHeight(\"fit-content\")\n        //this.setFlexBasis(\"300px\")\n        //this.setMinAndMaxWidth(\"300px\")\n        //this.setMinAndMaxHeight(null)\n        \n        this.debugLog(\"makeOrientationRight on \", this.node() ? this.node().title() : null)\n    }\n\n    makeOrientationDown () { // top to bottom columns, left to right items?\n        //this.setFlexDirection(\"row\")\n        //this.setMinAndMaxWidth(\"fit-content\")\n        this.setMinAndMaxWidth(\"100%\")\n        this.setMinAndMaxHeight(\"100%\")\n        //this.setMinAndMaxWidth(null)\n        //this.setMinAndMaxHeight(\"50px\")   \n        //this.setFlexBasis(\"300px\")\n\n        this.debugLog(\"makeOrientationDown on \", this.node() ? this.node().title() : null)\n\n        this.tiles().forEach(item => {\n            //item.setWidth(\"fit-content\")\n            item.setHeight(\"fit-content\")\n            //item.setHeight(this.desiredHeight()) // this could cause reflow, so let's avoid if we can\n            //console.log(\"    prepare for down orientation on subview \", item.node().title())\n        })\n    }\n\n    // --- get orientation ---\n\n    isVertical () {\n        return this.stackView().direction() === \"right\"\n    }\n\n    // --- stacking general ---\n\n    stackTiles () {\n        //this.assertTilesHaveParent()\n\n        if (this.isVertical()) {\n            this.stackTilesVertically()\n        } else {\n            this.stackTilesHorizontally()\n        }\n        return this\n    }\n\n    unstackTiles () {\n        //this.assertTilesHaveParent()\n\n        if (this.isVertical()) {\n            this.unstackTilesVertically()\n        } else {\n            this.unstackTilesHorizontally()\n        }\n        return this\n    }\n\n    // --- stacking vertical ---\n\n    stackTilesVertically () {\n        // we don't need to order tiles for 1st call of stackTiles, \n        // but we do when calling stackTiles while moving a drop view around,\n        // so just always do it as top is null, and tiles are already ordered the 1st time\n\n        const orderedTiles = this.tiles().shallowCopy().sortPerform(\"topPx\")\n        const displayedTiles = orderedTiles.filter(r => !r.isDisplayHidden())\n        let y = 0\n        \n\n        const offsets = displayedTiles.map(tile => tile.offsetTop())\n        //console.log(\"---\")\n\n        // NOTE: having issues getting absolute positions to match relative ones\n        // Why is getBoundingClientRect on tile always returning same top value as offsetParent.getBoundingClientRect ???\n\n        displayedTiles.forEachKV((i, tile) => {\n            //const oy = offsets[i]\n            /*\n            const dy = i === 0 ? 0 : offsets[i] - offsets[i-1]\n            const parentRect = tile.element().offsetParent.getBoundingClientRect()\n            const rect = tile.boundingClientRect()\n            let h = parentRect.top - rect.top\n            */\n\n            let h = tile.computedHeight() \n            //let h = tile.offsetHeight()\n\n            //console.log(\"h: \" + h + \" dy:\" + dy)\n            //console.log(\"y: \" + y + \" oy:\" + offsets[i])\n\n            if (tile.position() !== \"absolute\") { \n                // they are all not absolute when first dragging in\n                // and stay absolute until unstack gets called at end of drag\n                tile.makeAbsolutePositionAndSize()\n                tile.setLeftPx(0)\n                tile.setOrder(null)\n            } \n\n            /*\n            console.log(\"i:\" + i)\n            console.log(\"   computedHeight:\" + tile.computedHeight())\n            console.log(\"     offsetHeight:\" + tile.offsetHeight())\n            console.log(\"           offset:\" + oy)\n            console.log(\"                y:\" + y)\n            */\n\n            tile.setTopPx(y)\n            y += h + 2\n        })\n        //console.log(\"---\")\n\n        return this\n    }\n\n    unstackTilesVertically  () {\n        const orderedTiles = this.tiles().shallowCopy().sortPerform(\"topPx\")\n        \n        orderedTiles.forEach(tile => assert(tile.hasElement()) ) // todo: temp test\n        orderedTiles.forEach(tile => tile.makeRelativePositionAndSize())\n\n        this.removeAllSubviews()\n        this.addSubviews(orderedTiles)\n        return this\n    }\n\n    // --- stacking horizontal ---\n\n    stackTilesHorizontally () {\n        const orderedTiles = this.tiles().shallowCopy().sortPerform(\"leftPx\") \n        const displayedTiles = orderedTiles.filter(r => !r.isDisplayHidden())\n        let x = 0\n\n        /*\n        let names = []\n        this.tiles().forEach((tile) => { \n            if (tile.node) { \n                names.push(tile.node().title() + \" \" + tile.leftPx() + \"px\")\n            }\n        })\n        console.log(\"horizontal: \", names.join(\", \"))\n        */\n        \n        displayedTiles.forEach((tile) => {\n            let w = tile.computedWidth() \n            if (tile.position() !== \"absolute\") {\n                tile.makeAbsolutePositionAndSize()\n                tile.setTopPx(0)\n                tile.setOrder(null)\n            }\n            tile.setLeftPx(x)\n            x += w\n        })\n\n        return this\n    }\n\n    unstackTilesHorizontally () {\n        const orderedTiles = this.tiles().shallowCopy().sortPerform(\"leftPx\")\n        orderedTiles.forEachPerform(\"makeRelativePositionAndSize\")\n        this.removeAllSubviews()\n        this.addSubviews(orderedTiles)\n        return this\n    }\n\n\n}.initThisCategory());\n",
  "55WtMjE6Usr6akqlNL1u73hfDAiEl+icdRI0hliLJJE=": "\"use strict\";\n\n/*\n    \n    TilesView_keyboard\n    \n*/\n\n(class TilesView_keyboard extends TilesView {\n    \n    // --- keyboard controls, arrow navigation ---\n\n    canNavigate () {\n        return this.allowsCursorNavigation() \n        //return this.allowsCursorNavigation() && this.isActiveElement()\n    }\n\n    // --- controls ---\n\n    onMetaKeyDown (event) {\n        console.log(\"new folder\")\n        event.stopPropagation()\n        event.preventDefault();\n    }\n\n    onMeta_m_KeyDown (event) {\n        console.log(\"new folder\")\n        event.stopPropagation()\n        event.preventDefault()\n    }\n\n    onMeta_d_KeyDown (event) {\n        console.log(\"duplicate selection down\")\n        this.duplicateSelectedTiles()\n        event.stopPropagation()\n        event.preventDefault();\n    }\n\n    onMeta_d_KeyUp (event) {\n        console.log(\"duplicate selection up\")\n        this.selectedTiles().forEach()\n        event.stopPropagation()\n        event.preventDefault();\n    }\n\n    onShiftBackspaceKeyUp (event) {\n        this.debugLog(this.type() + \" for \" + this.node().title() + \" onShiftBackspaceKeyUp\")\n        if (this.selectedTile()) { \n            this.selectedTile().delete()\n        }\n        event.stopPropagation()\n    }\n\n    onShiftPlusKeyUp (event) {\n        this.debugLog(this.type() + \" for \" + this.node().title() + \" onShiftPlusKeyUp\")\n        this.addIfPossible()\n        event.stopPropagation()\n    }\n\n    addIfPossible () {\n        const node = this.node()\n\n        if (node.canSelfAddSubnode()) {\n            const newNode = node.add()\n            if (newNode) {\n                this.syncFromNode()\n                const newSubview = this.subviewForNode(newNode)\n                newSubview.justTap()\n            }\n        }\n    }\n\n    // --- duplicate ---\n\n    onAlternate_d_KeyUp (event) {\n        //this.debugLog(\" onMetaLeft_d_KeyUp\")\n        this.duplicateSelectedTile()\n        return false // stop propogation\n    }\n\n    // select all\n\n    onMeta_a_KeyDown (event) {\n        this.selectAllTiles()\n        event.stopPropagation()\n        return false // stop propogation\n    }\n\n\n    onControl_c_KeyUp (event) {\n        // copy?\n    }\n\n    onControl_p_KeyUp (event) {\n        // paste?\n    }\n\n    // --- shift arrow keys ---\n\n    /*\n    activateSelectedTile () {\n        const tile = this.selectedTile()\n        if (tile && tile.activate) {\n            tile.activate()\n        }\n        return this\n    }\n\n    onShiftUpArrowKeyDown (event) {\n        const result = this.onUpArrowKeyDown(event)\n        this.activateSelectedTile()\n        return result \n    }\n\n    onShiftDownArrowKeyDown (event) {\n        const result =  this.onDownArrowKeyDown(event)\n        this.activateSelectedTile()\n        return result\n    }\n    */\n\n    // --- arrow keys ---\n\n    onUpArrowKeyDown (event) { // why down and not up?\n        if (!this.canNavigate()) { \n            return \n        }\n\n        if (this.isVertical()) {\n            this.moveDown()\n        } else {\n            this.moveLeft()\n        }\n        return false\n    }\n\t\n    onDownArrowKeyDown (event) { // why down and not up?\n        if (!this.canNavigate()) { \n            return \n        }\n\n        if (this.isVertical()) {\n            this.moveUp()\n        } else {\n            this.moveRight()\n        }\n        return false\n    }\n\t\n    onLeftArrowKeyUp (event) {\n        if (!this.canNavigate()) { \n            return this\n        }\t\n        if (this.isVertical()) {\n            this.moveLeft()\n        } else {\n            this.moveDown()\n        }\n    }\n\t\n    onRightArrowKeyUp (event) {\n        if (!this.canNavigate()) { \n            return this\n        }\t\n\n        if (this.isVertical()) {\n            this.moveRight()\n        } else {\n            this.moveUp()\n        }\n    }\n\n    // --- arrow moves ---\n\n    moveLeft () {\n        const pc = this.previousItemSet()\t\n        if (pc) {\n            if (this.selectedTile()) { \n                this.selectedTile().unselect() \n            }\n\t\t\t\n            const newSelectedTile = pc.selectedTile()\n            newSelectedTile.setShouldShowFlash(true).updateSubviews()\n            pc.didTapItem(newSelectedTile)\n        \tthis.selectPreviousColumn()\n\n            //debugger;\n            pc.didChangeNavSelection()\n        }\n        return this\n    }\n\n    moveRight () {\n        this.selectNextColumn()\n        return this\n    }\n\n    moveUp () {\n        this.selectNextTile()\n        this.showSelected()\n        return this\n    }\n\n    moveDown () {\n        this.selectPreviousTile()\n        this.showSelected()\n        return this\n    }\n\n    // --- escape ---\n\n    onEscapeKeyDown (event) {\n        //this.setIsColumnInspecting(false)\n\n        if (!this.canNavigate()) { \n            return this\n        }\t\n\n        this.moveLeft()\n        //return true\n    }\n\t\n    // --- enter key begins tile editing ---\n\t\n    onEnterKeyUp (event) {        \n        if (!this.canNavigate()) { \n            return this\n        }\n\t\n        // carefull - if Tile is registered fro keyboard,\n        // this may cause onEnterKeyUp to be sent twice\n        const tile = this.selectedTile()\n        if (tile) { \n\t\t    tile.onEnterKeyUp(event)\n        }\n\n        return false\n    }\n\n    // --- keyboard controls, add and delete actions ---\n\n    /*\n    deleteTile (aTile) {\n        let sNode = aTile.node()\n        if (sNode && sNode.canDelete()) { \n\t\t\tsNode.performAction(\"delete\") \n\t\t}\n        return this\n    }\n\n    deleteSelectedTiles () {\n        this.selectedTiles().forEach(r => this.deleteTile(r))\n\n        if (this.tiles().length === 0) {\n            this.selectPreviousColumn()\n        }\n    }\n    */\n\n    onShiftDeleteKeyUp (event) {\n        if (!this.canNavigate()) { \n            return \n        }\n\n        //this.deleteSelectedTiles()\n        return false\n    }\n\t\n    onPlusKeyUp (event) {\n        if (!this.canNavigate()) { \n            return \n        }\t\t\n\n        const sNode = this.selectedNode()\n        if (sNode && sNode.hasAction(\"add\")) { \n            const newNode = sNode.performAction(\"add\") \n            this.selectNextColumn()\n            if (this.nextColumn()) {\n                this.nextColumn().selectTileWithNode(newNode)\n            }\n        }\n        return false\t\t\n    }\n\t\n\n}.initThisCategory());\n",
  "HDp56h+spYaxnDT0L2rTSgyPA5SFd7p1W+hrTpHa+hk=": "\"use strict\";\n\n/*\n    \n    TilesView_gestures\n    \n*/\n\n(class TilesView_gestures extends TilesView {\n    \n    // --- tap ---\n\n    onTapComplete (aGesture) {\n        //console.log(this.typeId() + \" \" + this.node().title() + \" .onTapComplete() shouldRequestActivation: \", aGesture.shouldRequestActivation())\n        \n        if (this.node()) {\n\n            // add a subnode if tapping on empty area\n            const p = aGesture.downPosition() // there may not be an up position on windows?\n            //this.debugLog(\".onTapComplete() \", aGesture.upEvent())\n            if (p.event().target === this.element()) {\n                const keyModifiers = BMKeyboard.shared().modifierNamesForEvent(aGesture.upEvent());\n                const isAltTap = keyModifiers.contains(\"Alternate\");\n                if (isAltTap) {\n                    // inspect parent node\n                    //this.setIsColumnInspecting(true)\n                    return this\n                } else {\n                    this.addIfPossible()\n                }\n            }\n        }\n        return true\n    }\n\n    // --- reorder ---\n\n    canReorderTiles () {\n        return this.node().nodeTileLink().nodeCanReorderSubnodes()\n    }\n\n    didReorderTiles () { \n        if (!this.node() || !this.isInBrowser()) {\n            return this\n        }\n        // TODO: make a more scaleable API\n        const subnodes = this.tiles().map(tile => tile.node())\n        this.node().nodeTileLink().nodeReorderSudnodesTo(subnodes)\n        //this.node().nodeReorderSudnodesTo(subnodes)\n        return this\n    }\n\n    // --- pinch apart to create a tile ---\n\n    tileContainingPoint (aPoint) {\n        // potentially faster:\n        //const topElement = document.elementFromPoint(aPoint.x(), aPoint.y())\n        // now see if topElement has this.element() as an ancestor\n\n        return this.tiles().detect((tile) => {\n            return tile.frameInDocument().containsPoint(aPoint)\n        })\n    }\n\n    onPinchBegin (aGesture) { // pinch apart to insert a new tile\n        // TODO: move tile specific code to Tile\n\n        //this.debugLog(\".onPinchBegin()\")\n\n        // - calc insert index\n        const p = aGesture.beginCenterPosition()\n        const tile = this.tileContainingPoint(p)\n        if (!tile) {\n            // don't allow pinch if it's bellow all the tiles\n            // use a tap gesture to create a tile there instead?\n            return this\n        }\n\n        const insertIndex = this.tiles().indexOf(tile)\n\n        //console.log(\"insertIndex: \", insertIndex)\n\n        if (this.node().hasAction(\"add\")) {\n            // create new subnode at index\n            const newSubnode = this.node().addAt(insertIndex)\n\n            // reference it with _temporaryPinchSubnode so we\n            // can delete it if pinch doesn't complete with enough height\n            this._temporaryPinchSubnode = newSubnode\n\n            // sync with node to add tile view for it\n            this.syncFromNodeNow()\n\n            // find new tile and prepare it\n            const newTile = this.subviewForNode(newSubnode)\n            newTile.setMinAndMaxHeight(0)\n            newTile.contentView().setMinAndMaxHeight(64)\n            newTile.setTransition(\"all 0.3s\")\n            newTile.contentView().setTransition(\"all 0s\")\n            newTile.setBackgroundColor(\"black\")\n\n            // set new tile view height to zero and \n            const minHeight = Tile.defaultHeight()\n            const cv = newTile.contentView()\n            cv.setBackgroundColor(this.navView().backgroundColor())\n            cv.setMinAndMaxHeight(minHeight)\n            //newTile.scheduleSyncFromNode()\n            //this._temporaryPinchSubnode.didUpdateNode()\n        } else {\n            //this.debugLog(\".onPinchBegin() cancelling due to no add action\")\n\n            aGesture.cancel()\n        }        \n    }\n    \n    onPinchMove (aGesture) {\n        if (this._temporaryPinchSubnode) {\n            let s = Math.floor(aGesture.spreadY())\n            if (s < 0) {\n                s = 0\n            }\n            //this.debugLog(\".onPinchMove() s = \", s)\n            const minHeight = Tile.defaultHeight()\n            const newTile = this.subviewForNode(this._temporaryPinchSubnode)\n            //newTile.setBackgroundColor(\"black\")\n            newTile.setMinAndMaxHeight(s)\n            const t = Math.floor(s/2 - minHeight/2);\n            newTile.contentView().setTopPx(t)\n\n            const h = Tile.defaultHeight()\n\n            if (s < h) {\n                const f = s/h;\n                const rot = Math.floor((1 - f) * 90);\n                newTile.setPerspective(1000)\n                newTile.setTransformOrigin(0)\n                //newTile.contentView().setTransformOriginPercentage(0)\n                newTile.contentView().setTransform(\"rotateX(\" + rot + \"deg)\")\n                const z = -100 * f;\n                //newTile.contentView().setTransform(\"translateZ(\" + z + \"dg)\")\n            } else {\n                newTile.setPerspective(null)\n                newTile.contentView().setTransform(null)                \n            }\n        } else {\n            console.warn(this.typeId() + \".onPinchMove() missing this._temporaryPinchSubnode\")\n        }\n        // do we need to restack views?\n    }\n\n    onPinchComplete (aGesture) {\n        //this.debugLog(\".onPinchCompleted()\")\n        // if pinch is tall enough, keep new tile\n\n        if (this._temporaryPinchSubnode) {\n            const newTile = this.subviewForNode(this._temporaryPinchSubnode)\n            const minHeight = Tile.defaultHeight()\n            if (newTile.clientHeight() < minHeight) {\n                this.removeTile(newTile)\n            } else {\n                //newTile.setTransition(\"all 0.3s, height 0s\")\n                this.addTimeout(() => { \n                    newTile.contentView().setTopPx(0)\n                    newTile.setMinAndMaxHeight(minHeight) \n                }, 0)\n            }\n\n            this._temporaryPinchSubnode = null\n        }\n    }\n\n    onPinchCancelled (aGesture) {\n        //this.debugLog(\".onPinchCancelled()\")\n        if (this._temporaryPinchSubnode) {\n            this.node().removeSubnode(this._temporaryPinchSubnode)\n            this._temporaryPinchSubnode = null\n        }\n    }\n\n}.initThisCategory());\n",
  "Da8bvMUAAcHIZgRHYnxRTD4h3o5uyysUO0Ay6oiQCDc=": "\"use strict\";\n\n/*\n    \n    TilesView_helpers\n    \n*/\n\n(class TilesView_helpers extends TilesView {\n    \n    // --- reordering support ---\n\n    /*\n    absolutePositionTiles () {\n        const ys = []\n        this.tiles().forEach((tile) => {\n            const y = tile.relativePos().y()\n            ys.append(y)\n        })\n\n        let i = 0\n        this.tiles().forEach((tile) => {\n            const y = ys[i]\n            i ++\n            tile.unhideDisplay()\n            tile.setPosition(\"absolute\")\n            tile.setTopPx(y)\n            tile.setLeftPx(0)\n            tile.setRightPx(null)\n            tile.setBottomPx(null)\n            tile.setWidthPercentage(100)\n            //console.log(\"i\" + i + \" : y\" + y)\n        })\n        \n        return this\n    }\n    */\n\n\n    /*\n    orderTiles () {\n        const orderedTiles = this.tiles().shallowCopy().sortPerform(\"topPx\")\n\n        this.tiles().forEach((tile) => {\n            tile.setPosition(\"absolute\")\n            tile.unhideDisplay()\n        })\n\n        this.removeAllSubviews()\n        this.addSubviews(orderedTiles)\n        return this\n    }\n    */\n\n    // -- stacking tiles ---\n\n    /*\n    Tile methods:\n\n    makeAbsolutePositionAndSize () {\n        const f = this.frameInParentView()\n        this.setFrameInParent(f)\n        return this \n    }\n\n    makeRelativePositionAndSize () {\n        this.setPosition(\"relative\")\n\n        this.setTopPx(null)\n        this.setLeftPx(null)\n        this.setRightPx(null)\n        this.setBottomPx(null)\n\n        this.setMinAndMaxWidth(null)\n        this.setMinAndMaxHeight(null)  \n        return this \n    }\n\n    flexDirectionLength () {\n        const fd = this.parentView().flexDirection() \n        // tile is left to right\n        if (Type.isNull(fd)) {\n            fd = \"row\"\n        }\n        assert(fd)\n        const wfunc = () => { return this.computedWidth() }\n        const hfunc = () => { return this.computedHeight() }\n        const d = {\n            \"row\" : () => hfunc,\n            \"row-reverse\" : hfunc,\n            \"column\" : () => wfunc,\n            \"column-reverse\" : wfunc,\n        }\n        return d[fd]()\n    }\n\n    flexDirectionBreadth () {\n        const fd = this.parentView().flexDirection()\n        if (fd)\n        assert(fd)\n        const wfunc = () => { return this.computedWidth() }\n        const hfunc = () => { return this.computedHeight() }\n        const d = {\n            \"row\" : wfunc,\n            \"row-reverse\" : wfunc,\n            \"column\" : () => hfunc,\n            \"column-reverse\" : hfunc,\n        }\n        return d[fd]()\n    }\n    flexDirectionStartPosition\n\n    */\n\n    // --- debugging ---\n\n    showTiles (tiles) {\n        console.log(\"tiles: \", tiles.map(r => {\n            if (r.node) {\n                return r.node().title() + (r.display() !== \"block\" ? (\"-\" + r.display()) : \"\")\n            }\n            return r.type() \n        }).join(\", \"))\n        return this\n    }\n\n    showNodes (nodes) {\n        console.log(\"nodes: \", nodes.map(node => {\n            return node.title()\n        }).join(\", \"))\n        return this\n    }\n\n    // --- helpers ---\n/*\n    debugTypeId () {\n        const comment = \" '\" + (this.node() ? this.node().title() : \"untitled node\") + \"'\"\n        return super.debugTypeId() + comment\n    }\n*/\n\n    // paths\n\n    /*\n    logName () {\n        return this.browserPathString()\n    }\n    */\n\n}.initThisCategory());\n",
  "XnooyEqXkPoRAAr6EC/A6dPHypJ8YMHszcVCZA0GrPo=": "\"use strict\";\n\n/*\n    \n    Tile\n\n    Base tile view. This is a sort of empty canvas for subclasses to put subviews in.\n    It's important that subviews are put within the contentView, as this is used\n    to support features like slide-to-delete.\n\n    Tile supports tile features such as:\n    \n        - selection\n        - applying styles to match state\n        - slide-to-delete gesture\n        - long-press + pan-to-reorder gesture\n        - dragging\n        - close/delete button on right side\n    \n    NOTES\n    \n    Tile styles lookup order:\n\n        node -> (fallback to) -> tile -> (fallback to) -> column\n\n    See lookedUpStyles method.\n\n*/\n\n(class Tile extends NodeView {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"isSelectable\", true) //.setDuplicateOp(\"copyValue\")\n        this.newSlot(\"closeButtonView\", null)\n        this.newSlot(\"defaultHeight\", 30)\n        this.newSlot(\"restCloseButtonOpacity\", 0.4)\n        this.newSlot(\"transitionStyle\", \"all 0s\")\n        this.newSlot(\"selectedFlashColor\", \"#ccc\")\n        this.newSlot(\"shouldShowFlash\", false)\n        this.newSlot(\"shouldCenterCloseButton\", true)\n\n        this.newSlot(\"contentView\", null)\n    \n        this.newSlot(\"slideDeleteOffset\", 0)\n        this.newSlot(\"dragDeleteButtonView\", null)\n        this.newSlot(\"isDeleting\", false)\n        this.newSlot(\"lastTapDate\", null)\n        this.newSlot(\"lastSelectionDate\", null)\n    }\n\n    applyStyles () {\n        // we default to using the current theme, but \n        // we need to give view a chance to override style\n        // also, NodeView should override this method to give node a chance to override style\n\n        const state = this.currentThemeState()\n        if (state) {\n            /*\n            if (this.thisClass() === BreadCrumbsTile) {\n                debugger;\n            }\n            */\n            state.applyBorderStylesToView(this) // apply only border styles\n            state.applyNonBorderStylesToView(this.contentView()) // apply non border styles\n        }\n        return this\n    }\n\n    /*\n    setDisplay (v) {\n        if (v === \"block\") {\n            console.log(this.typeId() + \" setDisplay \" + v)\n        }\n        return super.setDisplay(v)\n    }\n    */\n\n    init () {\n        super.init()\n\n        this.setThemeClassName(\"Tile\")\n\n        this.setDisplay(\"inline-block\")\n        this.setPosition(\"relative\") // so absolute position on close button works\n        //this.setFlexGrow(0)\n        //this.setFlexShrink(0)\n        this.makeOrientationRight()\n\n        this.setWidth(\"100%\")\n        this.setHeight(\"fit-content\")\n        this.setWhiteSpace(\"no-wrap\")\n        //this.setHeight(\"auto\")\n\n        //this.setMinHeight(\"4em\")\n        //this.setColor(\"rbga(255, 255, 255, 0.5)\")\n        this.setTransition(\"all 0s\")\n        this.setOverflow(\"hidden\")\n        this.setWhiteSpace(\"nowrap\")\n        //this.setTransitionStyle(\"all 0.0s ease, width 0s, max-width 0s, min-width 0s\")\n        \n        /*\n        this.setBorderStyle(\"solid\")\n        this.setBorderColor(\"transparent\")\n        this.setBorderLeft(\"0px\")\n        this.setBorderRight(\"0px\")\n        this.setBorderTop(\"1px\")\n        this.setBorderBottom(\"1px\")\n        this.setTextAlign(\"left\")\n        */\n\n        this.setWebkitOverflowScrolling(\"touch\")\n\n        this.turnOffUserSelect()\n        this.setAcceptsFirstResponder(false)\n        this.setupTileContentView()\n\n        if (TouchScreen.shared().isSupported() || true) { // testing \n            //\n        } else {\n            //this.addCloseButton()\n        }\n\n        this.setTransition(this.transitionStyle())\n\n        //this.animateOpen()\n        \n        this.addGestureRecognizer(LongPressGestureRecognizer.clone()) // for long press & pan reordering\n        this.addGestureRecognizer(SlideGestureRecognizer.clone()) // for slide delete\n        //this.addGestureRecognizer(TapGestureRecognizer.clone()) // for selection, and tap-longpress\n        this.addDefaultTapGesture()\n        //this.defaultTapGesture().setShouldRequestActivation(true) // test to avoid tapping button within tile and row\n\n        //this.addGestureRecognizer(RightEdgePanGestureRecognizer.clone()) // for adjusting width?\n        //this.addGestureRecognizer(BottomEdgePanGestureRecognizer.clone()) // for adjusting height?\n\n        this.setIsRegisteredForKeyboard(true)\n        this.setIsDebugging(false)\n        return this\n    }\n\n    /*\n    setNode (aNode) {\n        super.setNode(aNode)\n        return this\n    }\n    */\n\n    duplicate () {\n        const dup = super.duplicate()\n        dup.setNode(this.node().duplicate())\n        return dup\n    }\n\n    // -- contentView -- \n    // a special subview within the Tile for it's content\n    // we route style methods to it\n\n    setupTileContentView () {\n        const cv = FlexDomView.clone().setElementClassName(\"TileContentView\")\n        cv.setDisplay(\"flex\")\n        cv.setHeight(\"auto\")\n        cv.setMinHeightPx(60)\n        cv.setWidthPercentage(100)\n        cv.setHeightPercentage(100) \n        cv.setPosition(\"relative\")\n        cv.setFloat(\"left\")\n\n        //cv.autoFitParentWidth().autoFitParentHeight() // can't do this since we need to float left for sliding\n\n        //cv.setTransition(\"all 0.2s ease, transform 0s, left 0s, right 0s, width 0s, min-width 0s, max-width 0s\")\n        cv.setTransition(\"all 0s\")\n        cv.setZIndex(2) // so it will be above other views like the slide delete button \n        this.setZIndex(1)\n        this.setContentView(cv)\n        this.addSubview(cv)\n\n        return this\n    }\n\n    desiredWidth () {\n        return this.calcWidth()\n    }\n\n    /*\n    setMinAndMaxWidth (w) {\n        super.setMinAndMaxWidth(w)\n        this.contentView().setMinAndMaxWidth(w)\n        return this\n    }\n\n    setMinAndMaxHeight (h) {\n        super.setMinAndMaxHeight(h)\n        this.contentView().setMinAndMaxHeight(h)\n        return this\n    }\n    */\n\n    addContentSubview (aView) {\n        return this.contentView().addSubview(aView)\n    }\n\n    removeContentSubview (aView) {\n        return this.contentView().removeSubview(aView)\n    }\n\n\n    // --- helpers --------\n    \n    browser () {\n        return this.column().browser()\n    }\n\n    column () {\n        return this.parentView()\n    }\n    \n    navView () {\n        return this.column().navView()\n    }\n\n    // ----\n\n    didUpdateSlotIsInspecting (oldValue, newValue) {\n        //super.didUpdateSlotIsSelected (oldValue, newValue)\n        this.tilesView().didChangeNavSelection()\n        //this.updateSubviews()\n    }\n\n    didUpdateSlotIsSelected (oldValue, newValue) {\n        super.didUpdateSlotIsSelected (oldValue, newValue)\n\n        if (this.isSelected()) {\n            this.setLastSelectionDate(Date.clone())\n        } else {\n            this.setShouldShowFlash(true)\n            this.setLastSelectionDate(null)\n        }\n\n        this.tilesView().didChangeNavSelection()\n        this.updateSubviews()\n    }\n    \n    // update\n     \n    updateSubviews () {   \n        if (this.closeButtonView()) {\n            const node = this.node()\n\n            if (node) {\n                this.closeButtonView().setColor(this.currentColor()) // needed?\n            }\n\t\t\t\n            if (this.canDelete()) {\n                this.closeButtonView().setOpacity(this.restCloseButtonOpacity())\n            } else {\n                this.closeButtonView().setOpacity(0)\n            }\n\n            if (node) {\n                const h = node.nodeMinTileHeight()\n                if (h) {\n                    this.setMinAndMaxHeight(h) \n                    this.contentView().autoFitParentHeight()\n                }\n            }\n        }\n\n        /*\n        // take up full height if node asks for it\n        const node = this.node()\n        if (node && node.nodeMinTileHeight()) {\n            const e = this.element()\n            if (node.nodeMinTileHeight() === -1) {\n                this.setHeight(\"auto\")                \n                this.setPaddingBottom(\"calc(100% - 20px)\")\n            } else {\n                this.setHeight(this.pxNumberToString(node.nodeMinTileHeight()))\n            }\n        }\n        */\n        \n        this.applyStyles()\n\n        return this\n    }\n    \n    // -------------\n    \n    onDidEdit (aView) {\n        this.scheduleSyncToNode() \n        return true // stop propogation\n    }\n    \n    // --- sync ---\n\t\n    syncFromNode () {\n        // is this ever called?\n        this.updateSubviews()\n        this.syncOrientation()\n        return this\n    }\n\n    tilesView () {\n        return this.parentView()\n    }\n\n    stackView () {\n        const scrollView = this.tilesView().parentView()\n        const navView = scrollView.parentView()\n        const stackView = navView.parentView()\n        return stackView\n        //return this.firstParentViewWithAncestorClass(StackView)\n    }\n\n    syncOrientation () {\n        if (!this.parentView()) {\n            return this\n        }\n\n        const d = this.stackView().direction()\n\n        if (d === \"right\") {\n            this.makeOrientationRight()\n        } else if (d === \"down\") {\n            this.makeOrientationDown()\n        }\n        return this\n    }\n\n    makeOrientationRight () {  //stackview is right (other view is on the right and nav is top to bottom)\n        //this.debugLog(\"makeOrientationRight\")\n\n        this.setDisplay(\"inline-block\")  \n        this.setWidth(\"100%\")\n        //this.setWidth(\"fit-content\")\n        //this.setHeight(\"fit-content\")\n        //this.setHeight(this.parentView().desiredHeight())\n        //this.setBorderBottom(\"1px solid rgba(255, 255, 255, 0.3)\")\n\n        //this.setBorderRight(\"1px solid rgba(255, 0, 0, 1)\")\n        this.setMinAndMaxHeight(null)\n        //this.setBoxShadow(\"inset -10px 0 20px rgba(0, 0, 0, 0.05)\")\n    }\n\n    makeOrientationDown () { \n        //this.debugLog(\"makeOrientationDown\")\n\n        this.setDisplay(\"inline-block\")\n        //this.setWidth(\"fit-content\")\n        //this.setWidth(\"170px\")\n        this.setWidth(null)\n        this.setMinAndMaxWidth(170)\n        //this.setWidth(\"100%\") // want 100% if single item, like breadcrumb\n        // otherwise, the stack view should figure out the widths using one of\n        // several policy options?\n        //this.setHeight(\"fit-content\")\n        //this.setHeight(\"100%\")\n        //this.setBorderRight(\"1px solid rgba(255, 255, 255, 0.3)\")\n        //this.setBoxShadow(\"inset -10px 0 20px rgba(0, 0, 0, 0.05)\")\n\n        \n        if (this.stackView()) {\n            // apply node height hint\n            const node = this.stackView().node()\n            if (node) {\n                const h = node.nodeMinTileHeight()\n                //console.log(\"node \" + this.node().title() + \" height \" + h)\n                if (h) {\n                    this.setMinAndMaxHeight(h)\n                    this.contentView().setMinAndMaxHeight(h)\n                }\n            }\n        }\n    }\n    \n    // close button\n    \n    addCloseButton () {\n        if (this.closeButtonView() === null) {\n            const cb = SvgIconView.clone().setIconName(\"close\")\n            cb.setStrokeColor(\"white\")\n            cb.setFillColor(\"white\")\n            this.setCloseButtonView(cb)\n            this.contentView().addSubview(cb) \n            cb.setMinAndMaxWidthAndHeight(8)\n            cb.setAction(\"delete\")\n            cb.setOpacity(0).setTransition(this.transitionStyle())\n        }\n        return this\n    }\n    \n    removeCloseButton () {\n        if (this.closeButtonView() !== null) {\n            this.contentView().removeSubview(this.closeButtonView()) \n            this.setCloseButtonView(null)\n        }\n    }\n    \n    // ---\n\n    passFirstResponderToColumn () {\n        if (this.isFirstResponder()) {\n            if (this.column()) {\n                this.column().becomeFirstResponder()\n            }\n        }\n        return this\n    }\n\n    // --- delete ---\n\n    canDelete () {\n        if (this.node()) {\n            return this.node().canDelete()\n        }\n        return false\n    }\n\n    delete () {\n        //console.log(\"delete\")\n        if (this.canDelete()) {\n            this.removeFromParentView()\n            this.node().delete()\n        }\n    }\n\n    /*\n\tanimateOpen () {\n\t\tthis.setTransition(this.transitionStyle())\n\t\tthis.setOpacity(0)\n\t\tthis.setMinAndMaxHeight(0)\n\t\tthis.addTimeout(() => {\n\t\t\tthis.setOpacity(1)\n\t\t\tthis.setMinAndMaxHeight(this.defaultHeight())\n\t\t}, 0)\t\t\n\t},\n\t*/\n  \n\n    // -------------------\n\n    /*\n    unselectNextColumnTiles () {\n        const c = this.column().nextColumn()\n        if (c) {\n            c.unselectAllTiles()\n        }\n        return this\n    }\n    */\n    \n    decendantReleasedFocus (aView) {\n        this.focus() // this doesn't seem right \n        return true\n    }\n\n    // --- selecting ---\n\t\n    willAcceptFirstResponder () {\n        super.willAcceptFirstResponder()\n\t    //this.debugLog(\".willAcceptFirstResponder()\")\n        return this\n    }\n\n    // -------------------------\n    \n    nodeTileLink () {\n        //this.debugLog(\".visibleSubnodes() isInspecting:\" + this.isInspecting())\n        if (this.isInspecting()) {\n            return  this.node().nodeInspector()\n        }\n\n        return this.node().nodeTileLink()\n    }\n\n}.initThisClass());\n",
  "aSI1IMXVVaxYgw2IhLdubsQ/AYLLHgtBAblu+tzXzwk=": "\"use strict\";\n\n/*\n    \n    Tile_dragging\n\n*/\n\n(class Tile_dragging extends Tile {\n    \n\n    // --- dragging source protocol ---\n\n    hideForDrag () {\n        //this.setVisibility(\"hidden\")\n        this.hideDisplay()\n    }\n\n    unhideForDrag () {\n        //this.setVisibility(\"visible\")\n        this.unhideDisplay()\n    }\n\n    /*\n    onDragItemBegin (aDragView) {\n    }\n\n    onDragItemCancelled (aDragView) {\n    }\n\n    onDragItemDropped (aDragView) {\n    }\n    */\n\n    onDragRequestRemove () {\n        //assert(this.hasParentView()) //\n        if (this.hasParentView()) {\n            this.removeFromParentView()\n        }\n        assert(!this.hasParentView()) //\n\n        this.node().removeFromParentNode()\n        assert(!this.node().parentNode())\n\n        //this.delete() // we don't want to delete it, we want to move it\n        return true\n    }\n\n    // --- dropping destination protocol implemented to handle selecting/expanding tile ---\n\n    acceptsDropHover (dragView) {\n        return this.canDropSelect() || this.acceptsDropHoverComplete(dragView)\n    }\n\n    onDragDestinationEnter (dragView) {\n        if (this.canDropSelect()) {\n            this.setupDropHoverTimeout()\n        }\n    }\n\n    onDragDestinationHover (dragView) {\n        //console.log(this.typeId() + \" onDragDestinationHover\")\n    }\n\n    onDragDestinationExit (dragView) {\n        this.cancelDropHoverTimeout()\n        //this.unselect()\n        //this.column().unselectAllTilesExcept(anItem)\n    }\n\n    // --- dropping on tile - usefull for LinkNode? ---\n\n    acceptsDropHoverComplete (dragView) {\n        const node = this.node()\n        if (node && node.nodeAcceptsDrop) {\n            return node.nodeAcceptsDrop(dragView.item().node())\n        }\n    }\n\n    onDragDestinationDropped (dragView) {\n        console.log(this.typeId() + \" onDragDestinationDropped\")\n\n        const itemNode = dragView.item().node()\n\n        const node = this.node()\n        if (itemNode && node && node.nodeDropped) {\n            return node.nodeDropped(itemNode)\n        }\n    }\n\n    dropCompleteDocumentFrame () {\n        return this.frameInDocument()\n    }\n\n    // ----\n\n    dropHoverDidTimeoutSeconds () {\n        return 0.3\n    }\n\n    canDropSelect () {\n        // only want to prevent this for non-navigation nodes\n        return true\n        //return this.node().hasSubnodes() || this.node().nodeCanReorderSubnodes()\n    }\n\n    // -----------------\n\n    dropHoverEnterTimeoutName () {\n        return \"dropHoverEnter\"\n    }\n\n    setupDropHoverTimeout () {\n        const ms = this.dropHoverDidTimeoutSeconds() * 1000\n        this.addTimeout(() => this.dropHoverDidTimeout(), ms, this.dropHoverEnterTimeoutName())\n    }\n\n    cancelDropHoverTimeout () {\n        this.clearTimeoutNamed(this.dropHoverEnterTimeoutName())\n        return this\n    }\n\n    dropHoverDidTimeout () {\n        this.justTap()\n    }\n\n    // Browser style drag\n\n    onBrowserDragStart (event) {  \n        let dKey = BMKeyboard.shared().keyForName(\"d\")\n        if (!dKey.isDown()) {\n            return false\n        }\n\n        const node = this.node()\n        if (node && node.getBMDataUrl) {\n            const bdd = node.getBMDataUrl()\n            if (bdd) {\n                event.dataTransfer.setData(bdd.transferMimeType(), bdd.dataUrlString())\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n}.initThisCategory());\n",
  "BMKxDi8Is1QnRmzNqUaZ2Hsocc8OaQLJXpqoMRNtRUk=": "\"use strict\";\n\n/*\n    \n    Tile_keyboard\n\n*/\n\n(class Tile_keyboard extends Tile {\n    \n    // --- keyboard controls ---\n\n    onEnterKeyUp () {\n        //this.debugLog(this.type() + \" for \" + this.node().title() + \" onEnterKeyUp\")\n        this.justTap()\n        return false // stop propogation\n    }\n\n    onShiftBackspaceKeyUp (event) {\n        this.debugLog(this.type() + \" for \" + this.node().title() + \" onBackspaceKeyUp\")\n        this.delete()\n        return false // stop propogation\n    }\n\n    // --- dragging key ---\n\n    onMeta_a_KeyDown (event) {\n        // only select subnodes if this tile can have them,\n        // otherwise, like the column handle this event\n        const c = this.column().nextColumn()\n        if (c) {\n            c.selectAllTiles()\n        }\n        event.stopPropagation()\n        return false \n    }\n\n    on_d_KeyDown (event) {\n        this.debugLog(\" on_d_KeyDown \", event._id)\n        this.setIsRegisteredForBrowserDrag(true)\n        return true\n    }\n\n    on_d_KeyUp (event) {\n        this.debugLog(\" on_d_KeyUp \", event._id)\n        this.setIsRegisteredForBrowserDrag(false)\n        return true\n    }\n\n    /*\n    onEscapeKeyDown (event) {\n        console.log(\" onEscapeKeyDown \", event._id)\n        this.column().onLeftArrowKeyUp()\n        return true\n    }\n    */\n\n}.initThisCategory());\n",
  "Q3sfqbV5IfuCIW5t88VtS2Oq77CewEbEtHUsqiKqqKw=": "\"use strict\";\n\n/*\n    \n    Tile_gestures\n\n*/\n\n(class Tile_gestures extends Tile {\n    \n    // --- tap gesture -------- \n\n    acceptsTapBegin (aGesture) {\n        return true\n    }\n\n    onTapComplete (aGesture) {\n        //console.log(this.debugTypeId() + \" onTapComplete\")\n        this.setLastTapDate(new Date())\n        const keyModifiers = BMKeyboard.shared().modifierNamesForEvent(aGesture.upEvent());\n        ///const hasThreeFingersDown = aGesture.numberOfFingersDown() === 3;\n        //const isAltTap = keyModifiers.contains(\"Alternate\");\n\n        //if (keyModifiers.length) {\n            // TODO: abstract this to DomView or GestureRecognizer?\n            const methodName = \"just\" + keyModifiers.join(\"\") + \"Tap\"\n            //this.debugLog(\" tap method \" + methodName)\n            if (this[methodName]) {\n                this[methodName].apply(this)\n                return this\n            }\n        //} \n        \n        /*\n        if (hasThreeFingersDown || isAltTap) {\n            this.justInspect()\n        } else {\n            this.setIsInspecting(false)\n            this.justTap()\n        }\n        */\n\n        return this\n    }\n\n    // -- just taps ---\n\n    justTap () {\n        this.setIsInspecting(false)\n        this.column().didTapItem(this)\n\n        //console.log(this.debugTypeId() + \" justTap\")\n        if (this.isSelectable()) {\n            const node = this.node()\n            if (node) {\n                node.onTapOfNode()\n                node.onRequestSelectionOfNode(this)\n            }\n\n            /*\n            if (this.isFocused() && node.nodeUrlLink) {\n                // TODO: move to specialized view (something like UrlLinkTile?) \n                if (!BMKeyboard.shared().hasKeysDown()) {\n                    const url = node.nodeUrlLink()\n                    window.open(url, \"_blank\")\n                }\n            }\n            */\n        }\n    }\n\n    justShiftTap () {\n        this.setIsInspecting(false)\n        this.column().didShiftTapItem(this)\n    }\n\n    justAlternateTap () {\n        this.debugLog(\".justInspect()\")\n        if (this.node().nodeCanInspect()) { \n            this.setIsInspecting(true) // will call didUpdateSlotIsInspecting and update nav\n            this.column().didTapItem(this)\n        }\n    }\n\n    justMetaTap () {\n        this.setIsInspecting(false)\n        this.toggleSelection()\n    }\n\n    // --- tap hold ---\n    // TODO: move to GestureRecognizer or DomView?\n\n    acceptsLongPress () {\n        if (!this.column()) {\n            console.log(\"missing parent view on: \" + this.typeId())\n        }\n\n        if (this.column()) {\n            return this.column().canReorderTiles()\n        }\n        return false\n    }\n    \n    onLongPressBegin (aGesture) {\n        if (this.isRegisteredForBrowserDrag()) {\n            aGesture.cancel() // don't allow in-browser drag when we're doing a drag outside\n        }\n    }\n\n    onLongPressCancelled (aGesture) {\n    }\n\n    isTapLongPress () {\n        // ok, now we need to figure out if this is a tap-hold or tap-tap-hold\n        const maxDt = 0.7 // between tap time + long tap hold time before complete is triggered\n        let isTapTapHold = false\n        const t1 = this.lastTapDate()\n        const t2 = new Date()\n        if (t1) {\n            const dtSeconds = (t2.getTime() - t1.getTime())/1000\n            //console.log(\"dtSeconds = \" + dtSeconds)\n            \n            if (dtSeconds < maxDt) {\n                isTapTapHold = true\n            }\n        }\n        return isTapTapHold\n    }\n\n    onLongPressComplete (longPressGesture) {\n        longPressGesture.deactivate() // needed?\n\n        const isTapLongPress = this.isTapLongPress() // is tap-hold\n\n        if (!this.isSelected()) {\n            this.column().unselectAllTilesExcept(this)\n        }\n\n        this.activate()\n        const dv = DragView.clone().setItems(this.column().selectedTiles()).setSource(this.column())\n\n        if (isTapLongPress) {\n            dv.setDragOperation(\"copy\")\n        } else { // otherwise, it's just a normal long press\n            dv.setDragOperation(\"move\")\n        }\n        \n        dv.openWithEvent(longPressGesture.currentEvent())\n    }\n\n    // --- handle pan gesture ---\n\n    acceptsPan () {\n        return this._isReordering\n    }\n\n\n    // --- bottom edge pan ---\n\n    acceptsBottomEdgePan () {\n        if (this.node().nodeCanEditTileHeight) {\n            if (this.node().nodeCanEditTileHeight()) {\n                return true\n            }\n        }\n        return false\n    }\n\n    onBottomEdgePanBegin (aGesture) {\n        this._beforeEdgePanBorderBottom = this.borderBottom()\n        this.setBorderBottom(\"1px dashed red\")\n        this.setTransition(\"min-height 0s, max-height 0s\")\n    }\n\n    onBottomEdgePanMove (aGesture) {\n        const p = aGesture.currentPosition() // position in document coords\n        const f = this.frameInDocument()\n        const newHeight = p.y() - f.y()\n        const minHeight = this.node() ? this.node().nodeMinTileHeight() : 10;\n        if (newHeight < 10) {\n            newHeight = 10;\n        }\n        this.node().setNodeMinTileHeight(newHeight)\n        this.updateSubviews()\n\n        /*\n            this.node().setNodeMinTileHeight(h)\n            this.updateSubviews()\n            //this.setMinAndMaxHeight(newHeight) // what about contentView?\n            //this.contentView().autoFitParentHeight()\n        */\n\n        return this\n    }\n\n    onBottomEdgePanComplete (aGesture) {\n        this.setBorderBottom(this._beforeEdgePanBorderBottom)\n    }\n\n}.initThisCategory());\n",
  "6LzvPfv/q86oKN1jFYiV8+GlBQkwbS9oON01VmCNUdg=": "\"use strict\";\n\n/*\n    \n    Tile_slideGesture\n\n*/\n\n(class Tile_slideGesture extends Tile {\n\n\n    // -- slide gesture ---\n\n    acceptsSlide () {\n        return this.canDelete()\n    }\n\n    onSlideBegin () {\n        //this.debugLog(\".onSlideBegin()\")\n        this.setSlideDeleteOffset(this.clientWidth() * 0.5);\n        this.contentView().setTransition(\"all 0s\") \n        this.setupSlide() \n        return this\n    }\n\n    underContentViewColor () {\n        return \"black\"\n    }\n\n    setupSlide () {\n        if (!this.dragDeleteButtonView()) {\n            const h = this.clientHeight()\n\n            // need to do this because we re-route setBackgroundColor\n            this.element().style.backgroundColor = this.underContentViewColor()\n            const cb = CloseButton.clone().setOpacity(0).setTransition(\"opacity 0.1s\").setPosition(\"absolute\")\n            this.addSubview(cb)\n            //cb.setBorder(\"1px dashed white\")\n\n            const size = 10\n            cb.setMinAndMaxWidthAndHeight(size)\n            cb.verticallyAlignAbsoluteNow()\n            cb.setRightPx(size * 2)\n            cb.setZIndex(0)\n            this.setDragDeleteButtonView(cb)\n        }\n        return this\n    }\n\n    cleanupSlide () {\n        if (this.dragDeleteButtonView()) {\n            this.dragDeleteButtonView().removeFromParentView()\n            this.setDragDeleteButtonView(null)\n        }\n        this.setTouchRight(null)\n    }\n\t\n    onSlideMove (slideGesture) {\n        const d = slideGesture.distance()\n        const isReadyToDelete = d >= this._slideDeleteOffset\n\n        this.setTouchRight(d)\n\n        if (this._dragDeleteButtonView) {\n            this._dragDeleteButtonView.setOpacity(isReadyToDelete ? 1 : 0.2)\n        }\n    }\n\n    setTouchRight (v) {\n        //this.setTransform(\"translateX(\" + (v) + \"px)\");\n        //this.setLeftPx(-v)\n        //this.setRightPx(v)\n        this.contentView().setRightPx(v)\n    }\n\t\n    onSlideComplete (slideGesture) {\n        //console.log(\">>> \" + this.type() + \" onSlideComplete\")\n        const d = slideGesture.distance()\n        const isReadyToDelete  = d >= this._slideDeleteOffset\n\n        this.element().style.backgroundColor = \"transparent\"\n\n        if (isReadyToDelete) {\n            this.finishSlideAndDelete()\n        } else {\n            this.slideBack()\n        }\n    }\n\n    onSlideCancelled (aGesture) {\n        this.slideBack()\n    }\n\n    finishSlideAndDelete () {\n        this.setIsDeleting(true)\n        const dt = 0.08 // seconds\n        this.contentView().setTransition(\"right \" + dt + \"s\")\n        this.setTransition(this.transitionStyle())\n        //this.contentView().animationListener().setDelegate(this).setMethodSuffix().setIsListening(true)\n\n        this.addTimeout(() => {\n            this.setTouchRight(this.clientWidth())\n            this.addTimeout(() => {\n                this.cleanupSlide()\n                this.delete()\n            }, dt * 1000)\n        }, 0)\n    }\n\n    /*\n    onAnimationStart (event) {\n        console.log(this.debugTypeId() + \" onAnimationStart\")\n    }\n\n    onAnimationEnd (event) {\n        console.log(this.debugTypeId() + \" onAnimationEnd\")\n        this.contentView().animationListener().setIsListening(false)\n    }\n    */\n\n    slideBack () {\n        this.disableTilesViewUntilTimeout(400)\n\n        this.contentView().setTransition(\"left 0.2s ease, right 0.2s ease\")\n\n        this.addTimeout(() => {\n            this.setTouchRight(0)\n            this.contentView().setTransition(this.transitionStyle())\n        })\n\n        this.addTimeout(() => {\n            this.didCompleteSlide()\n        }, 300)\n    }\n\n    \n    disableTilesViewUntilTimeout (ms) {\n        this.navView().disablePointerEventsUntilTimeout(ms) \n        this.setPointerEvents(\"none\")\n    }\n\n    didCompleteSlide () {\n        this.cleanupSlide()\n    }\n    \n    hasCloseButton () {\n        return this.closeButtonView() && this.closeButtonView().target() != null\n    }\n\n}.initThisCategory());\n",
  "K9HC0JmLvNtdrAlhRfg7ZRd/Z3HS1ntfZofnntPMtTA=": "\"use strict\";\n\n/*\n    \n    Tile_styling\n\n*/\n\n(class Tile_styling extends Tile {\n    \n    \n    didUpdateSlotParentView (oldValue, newValue) {\n        super.didUpdateSlotParentView(oldValue, newValue)\n        //this.scheduleMethod(\"applyStyles\")\n        this.applyStyles()\n        return this\n    }\n\n    // --- css pass-through to contentView ---\n\n    setBackgroundColor (s) {\n        this.contentView().setBackgroundColor(s)\n        return this\n    }\n\n    setColor (s) {\n        this.contentView().setColor(s)\n        return this\n    }\n\n    setOpacity (v) {\n        this.contentView().setOpacity(v)\n        return this\n    }\n\n    // --- styles ---\n\n    /*\n    applyStyles () {\n        super.applyStyles()\n\n        // flash\n        \n        if (this.shouldShowFlash() && this.selectedFlashColor()) {\n            this.setBackgroundColor(this.selectedFlashColor())\n            this.setTransition(\"background-color 0.3s\")\n            //this.addTimeout(() => { this.setBackgroundColor(this.currentBgColor()) }, 100)\n            this.addTimeout(() => { super.applyStyles() }, 100)\n            this.setShouldShowFlash(false)\n        }\n        \n        return this\n    }\n    */\n    \n    \n}.initThisCategory());\n",
  "3mA9sRnnbhkE0CnUifFj9js0OoMJfhX9YYGeWlZEOGw=": "\"use strict\";\n\n/*\n    \n    TitledTile\n\n    Adds a few subviews for typical tile functionality:\n\n        - titleView\n        - subtitleView\n        - noteView\n        - noteIconView\n        - thumbnailView\n\n    Most of these can easily be disabled, if not needed.\n    \n*/\n\n(class TitledTile extends Tile {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"titleView\", null)\n        this.newSlot(\"subtitleView\", null)\n        this.newSlot(\"noteView\", null)\n        this.newSlot(\"noteIconView\", null) // created lazily\n        this.newSlot(\"thumbnailView\", null)\n    }\n\n    static titleLeftPadding () {\n        return \"30px\"\n    }\n\n    topContentArea () {\n        let lv = this.contentView().subviews().at(0)\n        return lv\n    }\n\n    bottomContentArea () {\n        let lv = this.contentView().subviews().at(1)\n        return lv\n    }\n\n    init () {\n        super.init()\n\n        this.contentView().setMinHeight(\"5em\")\n        this.contentView().flexSplitIntoColumns(2)\n        let lv = this.topContentArea()\n\n        lv.setPaddingTop(\"0.7em\")\n        lv.setPaddingBottom(\"0.7em\")\n        lv.setPaddingLeft(this.thisClass().titleLeftPadding())\n        lv.setPaddingRight(\"1em\")\n\n        lv.setDisplay(\"flex\")\n        lv.setFlex(\"10\")\n        lv.setAlignItems(\"flex-start\") // alignment in direction of flex\n        lv.setJustifyContent(\"center\") // alignment perpendicutal to flex\n        lv.setFlexDirection(\"column\")\n\n        const tv = TileTitleView.clone()\n        lv.addSubview(tv)\n        this.setTitleView(tv)\n        tv.setThemeClassName(\"TileTitle\")\n        tv.setUsesDoubleTapToEdit(true)\n        tv.setOverflow(\"visible\")\n        tv.setPaddingLeft(\"0em\")\n\n        const st = TileSubtitleView.clone()\n        lv.addSubview(st)\n        this.setSubtitleView(st)\n        st.setThemeClassName(\"TileSubtitle\")\n        st.setPaddingLeft(\"0em\")\n        st.setPaddingTop(\"0em\")\n        st.setOpacity(0.6)\n\n\n        const rv = this.bottomContentArea()\n        rv.setDisplay(\"flex\")\n        rv.setAlignItems(\"center\")\n        this.setNoteView(rv.addSubview(TileNoteView.clone()))\n        rv.setMinWidth(\"3em\")\n        rv.setJustifyContent(\"center\")\n\n        const icon = SvgIconView.clone()\n        //icon.setElementClassName(\"NoteIconView\")\n        icon.setMinAndMaxWidth(12)\n        icon.setMinAndMaxHeight(15)\n        //icon.setFillColor(\"white\")\n        icon.setStrokeColor(\"white\") // use currentColor?\n        icon.setOpacity(0.2)\n        this.setNoteIconView(rv.addSubview(icon))\n        \n        this.updateSubviews()\n        this.setIsSelectable(true)\n        return this\n    }\n\n    setupThumbnailViewIfAbsent () {\n        if (!this.thumbnailView()) {\n            const tv = DomView.clone().setElementClassName(\"TileThumbnailView\")\n            tv.setDisplay(\"block\")\n            tv.setLeftPx(10)\n            tv.setTopPx(5)\n            tv.setMinHeight(\"40px\")\n            tv.setMinWidth(\"40px\")\n            tv.setBorderRadiusPx(7)\n            tv.setBackgroundColor(\"transparent\")\n            tv.setBorder(\"0px solid #aaa\")\n\n    \t\ttv.makeBackgroundNoRepeat()\n            tv.makeBackgroundCentered()\n            //tv.makeBackgroundContain()\n            tv.setBackgroundSizeWH(50, 50)\n\n            this.setThumbnailView(tv)\n            this.addSubview(tv)\n            \n            // TODO: make this dynamic with subview for title & subtitle\n            const offset = 60\n            this.titleView().setLeftPx(offset)\n            this.subtitleView().setLeftPx(offset)\n        }\n        return this\n    }\n    \n    hasSubtitle () {\n        const node = this.node()\n\n        if (node) {\n            if (node.subtitle() !== null && node.subtitle() !== \"\") {\n                return true\n            }\n\n            if (node.nodeCanEditSubtitle()) {\n                return true\n            }\n        }\n\n        return false\n    }\n\n    syncStylesToSubviews () {\n        const b = this.isSelected()\n        this.titleView().syncStateFrom(this)\n        this.subtitleView().syncStateFrom(this)\n        this.noteView().syncStateFrom(this)\n        /*\n        this.titleView().setIsSelected(b)\n        this.subtitleView().setIsSelected(b)\n        this.noteView().setIsSelected(b)\n        */\n        return this\n    }\n\n    updateSubviews () {\n        super.updateSubviews()\n\t\n        const node = this.node()\n\n        if (node) {\n            this.titleView().setIsEditable(node.nodeCanEditTitle())\n            this.subtitleView().setIsEditable(node.nodeCanEditSubtitle())\n            this.subtitleView().setDisplayIsHidden(!this.hasSubtitle())\n    \n            if (node) {\n                const imageUrl = node.nodeThumbnailUrl()\n                if (imageUrl) {\n                    this.setupThumbnailViewIfAbsent()\n                    this.thumbnailView().setBackgroundImageUrlPath(imageUrl)\n                }\n            } \n\n            if (node.noteIconName()) {\n                this.hideNoteView()\n                this.showNoteIconView()\n            } else {\n                this.showNoteView()\n                this.hideNoteIconView()\n            }\n        } else {\n            this.titleView().setIsEditable(false)\n            this.subtitleView().setIsEditable(false)\n            this.subtitleView().setDisplayIsHidden(true) \n        }\n\n        this.syncStylesToSubviews()\n        this.applyStyles()\n\n        /*\n        const state = this.currentThemeState()\n        if (state) {\n            state.applyToView(this.titleView())\n            state.applyToView(this.subtitleView())\n        }\n        */\n\n        return this\n    }\n\n    // noteView\n\n    showNoteView () {\n        this.noteView().unhideDisplay()   \n        this.noteView().setString(this.node().note())\n    }\n\n    hideNoteView () {\n        this.noteView().hideDisplay()     \n    }\n\n    // noteIconView\n\n    showNoteIconView () {\n        const v = this.noteIconView()\n        if (v.iconName() != this.node().noteIconName()) {\n            v.unhideDisplay()    \n            v.setIconName(this.node().noteIconName())\n            //v.setDoesMatchParentColor(true)\n\n        }\n        //const color = this.currentColor()\n        const color = this.getComputedCssProperty(\"color\")\n\n        v.setColor(color)\n        v.setFillColor(color)\n        v.setOpacity(0.95)\n        //console.log( this.node().title() + \" - \" + color)\n        //v.updateAppearance()\n    }\n\n    hideNoteIconView () {\n        this.noteIconView().hideDisplay()  \n    }\n\n    // ---\n\n    desiredWidth () {\n        /*\n        const tw = this.titleView().calcWidth()\n        const sw = this.subtitleView().calcWidth()\n        let w = Math.max(sw, tw)\n        //console.log(\"calcCssWidth of tile title '\" + this.node().title() + \"' = \" + w)\n        return w + 50\n        */\n        return this.calcWidth()\n    }\n\n    // --- edit ---\n\n    didInput () {\n        this.scheduleSyncToNode()\n    }\n\n    onDidEdit (aView) {\n        super.onDidEdit() \n    }\n\n    // --- sync ---\n\n    syncToNode () {   \n        //console.log(\"syncToNode\")\n        const node = this.node()\n        node.setTitle(this.titleView().innerText())\n        node.setSubtitle(this.subtitleView().innerText())\n        return this\n    }\n\n    syncFromNode () {\n        super.syncFromNode()\n        const node = this.node()\n        this.titleView().setString(node.title())\n        this.subtitleView().setString(node.subtitle())\n        //this.noteView().setString(this.node().note())\n        this.updateSubviews()\n        return this\n    }\n    \n    // arrow\n    \n    makeNoteRightArrow () {\n        debugger;\n        const nv = this.noteView()\n        \n        nv.setBackgroundImageUrlPath(this.pathForIconName(\"right-gray\"))        \n        nv.setBackgroundSizeWH(10, 10)\n        \n        nv.setMinAndMaxWidth(10)\n        nv.setMinAndMaxHeight(10)\n        return this\t\t\n    }\n\n    onEnterKeyUp (event) {\n        //this.debugLog(\".onEnterKeyUp()\")\n\n        if (this.titleView().isEditable()) {\n            this.titleView().activate()\n            event.stopPropagation()\n        } else if (this.subtitleView().isEditable()) {\n            this.subtitleView().activate()\n            event.stopPropagation()\n        } else {\n            super.onEnterKeyUp(event)\n        }        \n    }\n\n    /*\n    removeAllGestureRecognizers () {\n        debugger;\n        return super.removeAllGestureRecognizers()\n    }\n    */\n    \n}.initThisClass());\n",
  "AqCIWrIr//A9fFiEwSWBDeANo9iF/GxTa+A7VT81ivU=": "\"use strict\";\n\n/*\n    \n    BMTextNodeTile\n    \n*/\n\n(class BMTextNodeTile extends Tile {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"textView\", null)\n    }\n\n    init () {\n        super.init()\n\n        const cv = this.contentView()\n        cv.setMinHeight(\"1em\")\n        cv.setPadding(\"1em\")\n\n        const tv = TextField.clone()\n        this.setTextView(tv)\n        this.contentView().addSubview(tv)\n\n        tv.setDisplay(\"flex\")\n        //tv.setFlex(\"10\")\n        tv.setAlignItems(\"flex-start\") // alignment in direction of flex\n        tv.setJustifyContent(\"center\") // alignment perpendicutal to flex\n        tv.setFlexDirection(\"column\")\n        tv.setWidth(\"100%\")\n        tv.setMinHeight(\"1em\")\n        tv.setPadding(\"1em\")\n        tv.setIsEditable(true)\n\n        tv.setUsesDoubleTapToEdit(true)\n        tv.setOverflow(\"visible\")\n        tv.setPaddingLeft(\"0em\")\n\n        this.updateSubviews()\n        this.setIsSelectable(true)\n        return this\n    }\n\n    /*\n    updateSubviews () {\n        super.updateSubviews()\n        return this\n    }\n    */\n    \n    // ---\n\n    desiredWidth () {\n        return this.calcWidth()\n    }\n\n    // --- edit ---\n\n    didInput () {\n        this.scheduleSyncToNode()\n    }\n\n    onDidEdit (aView) {\n        super.onDidEdit() \n        return true // stop propogation\n    }\n\n    // --- sync ---\n\n    syncToNode () {   \n        //console.log(\"syncToNode\")\n        const node = this.node()\n        node.setValue(this.textView().innerText())\n        return this\n    }\n    \n    syncFromNode () {\n        const node = this.node()\n        if (!node) {\n            return \n        }\n        \n        this.textView().setString(node.value())\n\n        this.applyStyles()\n        return this\n    }\n\n    // --- theme ---\n\n    themeClassName () {\n        // search up the nodes to find a theme class name\n        const node = this.node()\n        if (node && node.themeClassName) {\n            return node.themeClassName()\n        }\n        return super.themeClassName()\n    }\n\n    applyStyles () {\n        // TODO: add method on View to grab these values \n        // - maybe with optional prefix for item class/name?\n\n        /*\n        const state = this.currentThemeState()\n        if (state) {\n            state.applyToView(this.textView())\n        }\n        */\n\n        \n        const theme = (key) => this.themeValueForAttribute(key);\n        const tv = this.textView();\n\n        tv.setColor(theme(\"color\"))\n        tv.setBackgroundColor(theme(\"backgroundColor\"))\n\n        tv.setFontSize(theme(\"fontSize\"))\n        tv.setFontFamily(theme(\"fontFamily\"))\n        tv.setFontWeight(theme(\"fontWeight\"))\n\n        tv.setLetterSpacing(theme(\"letterSpacing\"))\n        tv.setLineHeight(theme(\"lineHeight\"))\n        tv.setTextTransform(theme(\"textTransform\"))\n\n        tv.setPaddingLeft(theme(\"paddingLeft\"))\n        tv.setPaddingRight(theme(\"paddingRight\"))\n        tv.setPaddingTop(theme(\"paddingTop\"))\n        tv.setPaddingBottom(theme(\"paddingBottom\"))\n    }\n    \n}.initThisClass());\n",
  "ZCa8eLc0mR77PjOVHLAcVOYbcmI7RPQAiU+pMfn+O3Q=": "\"use strict\";\n\n/*\n    \n    BreadCrumbsTile\n\n    View for a typical bread crumbs path e.g.:\n\n        a / b / c / d\n\n    Supports compacting path to fit in view size (using back arrow) as needed.\n\n    Registers for onStackViewPathChange notifications (sent by top StackView) to auto update path.\n    TODO: register *only* for our own top stack view.\n    \n*/\n\n(class BreadCrumbsTile extends Tile {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"path\", null)\n        this.newSlot(\"separatorString\", \"/\")\n        this.newSlot(\"onStackViewPathChangeObs\", null)\n    }\n\n    init () {\n        super.init()\n        this.setThemeClassName(\"BreadCrumbsTile\")\n        this.setOnStackViewPathChangeObs(BMNotificationCenter.shared().newObservation().setName(\"onStackViewPathChange\").setObserver(this))\n        this.contentView().setPaddingLeft(\"1.5em\") // TitledTile.titleLeftPadding()\n        this.setWidth(\"100%\")\n        //this.updateSubviews()\n        this.setIsSelectable(true)\n        this.setIsRegisteredForWindowResize(true)\n        return this\n    }\n\n    makeOrientationDown () { // this is a special case where the item is full width\n        super.makeOrientationDown()\n        this.setMinAndMaxWidth(null)\n        this.setWidth(\"100%\")\n        return this\n    }\n\n    rootStackView () { // move to Tile class?\n        return this.parentView() ? this.parentView().stackView().rootStackView() : null\n    }\n\n    targetStackView () {\n        const nc = this.column().nextColumn()\n        if (nc) {\n            //debugger;\n            const sv = nc.stackView()\n            return sv\n        }\n        return null\n    }\n\n    watchRootStackView () {\n        const obs = this.onStackViewPathChangeObs()\n        if (!obs.isWatching()) {\n            const target = this.rootStackView()\n            if (target) {\n                obs.setSender(target)\n                obs.startWatching()\n            } else {\n                //debugger;\n                obs.stopWatching() // needed?\n            }\n        }\n    }\n  \n    pathNodes () {\n        if (this.targetStackView()) {\n            const nodes = this.targetStackView().selectedNodePathArray()\n            return nodes\n        }\n        return []\n    }\n\n    syncPathToStack () {\n        this.scheduleMethod(\"setupPathViews\")\n    }\n\n    setHeight (v) {\n        if (v === \"100%\") {\n            debugger;\n        }\n        return super.setHeight(v)\n    }\n\n    // --- events ---\n\n    /*\n    onMouseDown (event) {\n        const result = super.onMouseDown(event)\n        const t = this.targetStackView()\n        t.selectNodePathArray([])\n        this.setupPathViews() // needed or does the StackView send a note?\n        return result\n    }\n    */\n\n    didUpdateSlotParentView (oldValue, newValue) {  // hook this to do the initial setup\n        super.didUpdateSlotParentView(oldValue, newValue)\n        if (this.parentView()) {\n            this.watchRootStackView()\n            this.syncPathToStack()\n        }\n        return this\n    }\n\n    onStackViewPathChange (aNote) {\n        //debugger;\n        this.syncPathToStack()\n    }\n\n    onClickPathComponent (aPathComponentView) {\n        const nodePathArray = aPathComponentView.info()\n        if (nodePathArray.length === 0) {\n            debugger;\n        }\n        console.log(\"select path: \" + nodePathArray.map(n => n.title()).join(\"/\"))\n        //const ourPath = this.node().nodePath()\n        //console.log(\"our path: \" + ourPath.map(n => n.title()).join(\"/\"))\n        //debugger;\n\n        const t = this.targetStackView()\n        t.selectNodePathArray(nodePathArray)\n    //    debugger;\n        this.setupPathViews() // needed or does the StackView send a note?\n        return this\n    }\n\n    onWindowResize (event) {\n        this.updateCompaction()\n        return this\n    }\n\n    onClickBackButton (backButton) {\n        //const crumb = this.lastHiddenCrumb()\n        const crumb = this.previousCrumb()\n        if (crumb) {\n            //console.log(\"select crumb: \", crumb.title())\n            crumb.sendActionToTarget()\n        }\n    }\n\n    // crumb buttons\n\n    previousCrumb () {\n        const crumbs = this.crumbs().select(crumb => crumb.title() !== \"/\") // previous crumb\n        if (crumbs.length > 1) {\n            return crumbs[crumbs.length - 2]\n        }\n        return null\n    }\n\n    crumbs () {\n        return this.subviews().first().subviews()\n    }\n\n    hiddenCrumbs () {\n        return this.crumbs().detect(sv => sv._isCrumb && sv.isDisplayHidden())\n    }\n\n    lastHiddenCrumb () {\n        return this.hiddenCrumbs().last()\n    }\n    \n    // --- path component views --- \n\n    newUnpaddedButton () {\n        const v = ButtonView.clone()\n        v.setDisplay(\"inline-block\")\n        v.titleView().setOverflow(\"visible\")\n        v.setHeightPercentage(100)\n        v.setWidth(\"fit-content\")\n        v.setPaddingLeft(\"0em\")\n        v.setPaddingRight(\"0em\")\n        v.titleView().setPaddingLeft(\"0em\")\n        v.titleView().setPaddingRight(\"0em\")\n        //v.debugTypeId = function () { return \"crumbView\" }\n        return v\n\n    }\n\n    buttonForName (aName) {\n        const v = this.newUnpaddedButton()\n        v.setTitle(aName)\n        v.setTarget(this)\n        v.setAction(\"onClickPathComponent\")\n        v._isCrumb = true\n        return v\n    }\n\n    newBackButton () {\n        const v = this.newUnpaddedButton()\n        //v.setTitle(\"&lt;\")\n        v.setTitle(\"\")\n        //v.setTitle(\"&#8592;\")\n        v.titleView().setPaddingLeft(\"0em\")\n        v.titleView().setPaddingRight(\"0.5em\")\n        v.setTarget(this)\n        v.setAction(\"onClickBackButton\")\n        return v\n    }\n\n    newSeparatorView () {\n        const v = this.newUnpaddedButton()\n        v.titleView().setPaddingLeft(\"0.5em\")\n        v.titleView().setPaddingRight(\"0.5em\")\n        v.setTitle(this.separatorString())\n        return v\n    }\n\n    crumbViewForNode (node, i, pathNodes) {\n        const name = node.title()\n        const crumb = this.buttonForName(name)\n        // not efficient to get pathNodes\n        // just get the path to the crumb node itself\n        //console.log(\"pathNodes: \" + pathNodes.map(n => n.title()).join(\"/\"))\n        const crumbNodePath = pathNodes.slice(0, i+1) // we WANT our own crumbview node to be the first in this path\n        //console.log(\"crumbNodePath [\" + i + \"]: \" + crumbNodePath.map(n => n.title()).join(\"/\"))\n\n        //debugger;\n        crumb.setInfo(crumbNodePath)\n        return crumb\n    }\n\n    newPathComponentViews () {\n        const pathNodes = this.pathNodes()\n        pathNodes.shift() // remove self from list\n        const views = pathNodes.map((node, i, pathNodes) => this.crumbViewForNode(node, i, pathNodes))\n        return views\n    }\n\n    setupPathViews () {\n        const views = this.newPathComponentViews()\n        const separatedViews = views.joinWithFunc((view, index) => this.newSeparatorView())\n        separatedViews.unshift(this.newSeparatorView())\n        separatedViews.unshift(this.newBackButton())\n        this.contentView().removeAllSubviews()\n        this.contentView().addSubviews(separatedViews)\n        this.updateCompaction()\n        return this\n    }\n\n    widthOfViews (views) {\n        return views.sum(v => v.calcWidth())\n    }\n\n    // --- \n\n    crumbViews () {\n        return this.contentView().subviews()\n    }\n\n    sumOfPathWidths () { // private - IMPORTANT: uses cachedSize\n        const rightMargin = 15\n        return this.crumbViews().sum(view => { \n            //const w = view.calcWidth()\n            const w = view.cachedSize().width()\n            if (Type.isNaN(w)) { \n                debugger; \n                throw new Error(\"invalid width value\")\n            }\n            return w + rightMargin\n        })\n    }\n\n    updateCompaction () {\n        const padding = 20\n        //const maxWidth =  this.calcSize().width() //this.frameInDocument().width()\n        const maxWidth = this.frameInDocument().width()\n        //console.log(\"maxWidth: \", maxWidth)\n        const views = this.crumbViews()\n        views.forEach(view => view.unhideDisplay())\n        views.forEach(view => view.cacheClientSize())\n\n        let didHide = false // to track if we need back button\n        for (let i = 1; i < views.length -1; i++) {\n            const view = views[i]\n            const sum = this.sumOfPathWidths() + padding\n            //console.log(\"sum: \", this.sumOfPathWidths())\n            const isSeparator = view.title() === \"/\"\n            if (isSeparator && views[i-1].isDisplayHidden()) {\n                view.hideDisplay()\n            }\n            if (sum > maxWidth) {\n                view.hideDisplay()\n                didHide = true\n            } else {\n                break;\n            }\n        }\n\n        if (!didHide) {\n            // if we hid anything, we need a back button\n            const backButton = views.first()\n            backButton.hideDisplay()\n        }\n    }\n\n    // ---\n\n    desiredWidth () {\n        return Number.MAX_VALUE\n    }\n\n}.initThisClass());\n",
  "4b7eoaq7ZtfxAX3FuQKH8eRAIYAIAjqPIPt/muX4l3w=": "\"use strict\";\n\n/*\n    \n    HeaderTile\n    \n*/\n\n(class HeaderTile extends TitledTile {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        //this.contentView().setPaddingLeft(\"1.5em\") // TitledTile.titleLeftPadding()\n        this.setIsSelectable(true)\n        this.setThemeClassName(\"HeaderTile\")\n\n        return this\n    }\n\n    makeOrientationDown () {\n        super.makeOrientationDown()\n        this.setMinAndMaxWidth(null)\n        this.setWidth(\"100%\")\n        return this\n    }\n\n}.initThisClass());\n",
  "u8LOi6Pm2v8m9xKjI/6eIyEKEAeBgt3pFR7BJm32Itw=": "\"use strict\";\n\n/*\n    \n    TileNoteView\n    \n*/\n\n(class TileNoteView extends TextField {\n\n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        this.setFontSize(\"80%\")\n        this.setFontWeight(\"normal\")\n        this.setWhiteSpace(\"nowrap\")\n        this.setTextAlign(\"right\")\n        this.setTextOverflow(\"ellipsis\")\n        return this\n    } \n    \n    setBackgroundColor (s) {\n        super.setBackgroundColor(\"tranparent\")\n        return this\n    }\n\n    setTransition (s) {\n        //debugger;\n        return super.setTransition(s)\n    }\n\n}.initThisClass());\n",
  "8DH1E24FuYkmDzqINsvLXP7BG/SGi7dovsVPpn/0Azw=": "\"use strict\";\n\n/*\n    \n    TileSubtitleView\n    \n*/\n\n(class TileSubtitleView extends TextField {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"block\")\n        this.setMarginTop(\"3px\")\n        this.setMarginLeft(\"0px\")\n        this.setMarginBottom(\"3px\")\n        this.setFontSize(\"80%\")\n        this.setFontWeight(\"normal\")\n        this.setTextAlign(\"left\")\n        this.setOverflow(\"visible\")\n        this.setWordWrap(\"break-word\")\n        return this\n    }\n\n}.initThisClass());\n\n\n",
  "e/SNi85xuE2hih4OpjCsGgPX1Z8UY2dqY7yzNG5YL5Q=": "\"use strict\";\n\n/*\n    TileTitleView\n\n    A title element in a Tile. \n\n    Reasons not to just use setElementClassName() on a TextField instead:\n    - to automatically get the full class hierarchy in the div name\n    - a place to (potentially) override interaction behaviors\n\n*/\n\n(class TileTitleView extends TextField {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"block\")\n        this.setPosition(\"relative\")\n        this.setMarginTop(\"0em\")\n        this.setMarginLeft(\"0em\")\n        this.setMinWidth(\"20px\")\n        this.setPaddingTop(\"2px\")\n        this.setPaddingBottom(\"2px\")\n        this.setTextAlign(\"left\")\n        this.setWhiteSpace(\"nowrap\")\n        this.setOverflow(\"hidden\")\n        this.setWordWrap(\"normal\")\n        return this\n    }\n\n    /*\n    tile () {\n        return this.parentView().parentView()\n    }\n    */\n\n    selectNextKeyView () {\n        /*\n        this.debugLog(\".selectNextKeyView()\")\n        const tile = this.parentView().parentView();\n        const nextTile = this.row().column().selectNextTile()\n        */\n        return true\n    }\n    \n}.initThisClass());\n",
  "3NLC1goFITS5R9qjF+80dzMJD4rgK8OYTQ8CTCP5Tag=": "\n\n.BMFieldValueView br {\n    display: none;\n}\n\n.BMFieldValueView * {\n    display: inline;\n    white-space: nowrap;\n}\n\n",
  "nvsvSSQGOlZ2bAS9LyOvbz2u/i/LNDm9nkRy9suIqso=": "\"use strict\";\n\n/*\n\n    BMFieldTile\n\n    Field views are tiles that present nodes which have key/value pairs, \n    such as those representing slots, or other named properties.\n\n    The idea is to use the field as the container, and then get\n    a custom value view to present in the value area. \n\n*/\n\n\n(class BMFieldTile extends Tile {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"allowsCursorNavigation\", false)\n        this.newSlot(\"vPadding\",  \"0.1em\")\n\n        this.newSlot(\"kvSection\", null)\n        this.newSlot(\"keyViewContainer\", null)\n        this.newSlot(\"valueViewContainer\", null)\n\n        this.newSlot(\"errorViewContainer\", null)\n        this.newSlot(\"noteViewContainer\", null)\n\n        this.newSlot(\"keyView\", null)\n        this.newSlot(\"valueView\", null)\n        this.newSlot(\"errorView\", null)\n        this.newSlot(\"noteView\", null)\n\n        this.newSlot(\"editableColor\", \"#aaa\")\n        this.newSlot(\"uneditableColor\", \"#888\")\n        this.newSlot(\"errorColor\", \"red\")\n\n        this.newSlot(\"valueEditableBorder\", \"1px solid rgba(255, 255, 255, 0.2)\")\n        //this.newSlot(\"valueEditableBorder\", \"none\")\n        this.newSlot(\"valueUneditableBorder\", \"none\")\n    }\n\n    setupTileContentView () {\n        super.setupTileContentView()\n\n        const cv = this.contentView()\n        cv.setMinHeight(\"5em\")\n        cv.setPaddingTop(\"0.5em\")\n        cv.setPaddingBottom(\"0.5em\")\n        cv.setJustifyContent(\"center\") // alignment perpendicular to flex\n        cv.setFlexDirection(\"column\")\n        return this\n    }\n\n    init () {\n        super.init()\n        this.makeCursorDefault()\n        this.setSpellCheck(false)\n\n        this.setOpacity(1)\n        this.setPosition(\"relative\")\n        this.setHeight(\"auto\")\n        this.setMinHeight(\"5em\")\n        this.setMaxHeight(\"none\")\n        this.setHeight(\"auto\")\n        this.setOverflow(\"visible\")\n        this.setWidth(\"auto\")\n        this.setTransition(\"background-color .3s ease-out\")\n        this.setTextAlign(\"left\")\n\n        {\n            this.setKvSection(this.contentView().newFlexSubview().setElementClassName(\"KvSection\"))\n            this.kvSection().setFlexDirection(\"column\")\n\n            this.setKeyViewContainer(this.kvSection().newFlexSubview().setElementClassName(\"KeyViewContainer\"))\n            this.keyViewContainer().setAlignItems(\"flex-start\")\n            this.setupKeyView()\n\n            this.setValueViewContainer(this.kvSection().newFlexSubview().setElementClassName(\"ValueViewContainer\"))\n            this.valueViewContainer().setAlignItems(\"flex-start\")\n            this.setupValueView()\n\n            this.setNoteViewContainer(this.contentView().newFlexSubview().setElementClassName(\"NoteViewContainer\"))\n            this.setupNoteView()\n\n            this.setErrorViewContainer(this.contentView().newFlexSubview().setElementClassName(\"ErrorViewContainer\"))\n            this.setupErrorView()\n\n            this.contentView().subviews().forEach(subview => {\n                subview.setPaddingLeft(\"1.5em\")\n                subview.setPaddingRight(\"1em\")\n            })\n        }\n\n        return this\n    }\n\n    setupKeyView () {\n        const v = TextField.clone().setElementClassName(\"BMFieldKeyView\")\n        if (!v.themeClassName()) {\n            v.setThemeClassName(\"FieldKey\")\n        }\n        v.setDisplay(\"inline-block\")\n        v.setOverflow(\"hidden\")\n        v.setTextAlign(\"left\")\n        v.setWhiteSpace(\"nowrap\")\n\n        this.setKeyView(v)\n        v.turnOffUserSelect()\n        v.setSpellCheck(false)\n        //v.setPaddingTop(this.vPadding())\n        //v.setPaddingBottom(this.vPadding())\n        v.setMarginTop(this.vPadding())\n        v.setMarginBottom(this.vPadding())\n        v.setPaddingLeft(\"0em\")\n        v.setPaddingRight(\"0em\")\n\n        this.keyViewContainer().addSubview(v)     \n        return v\n    }\n\n    setupValueView () {\n        const v = this.createValueView()\n        if (!v.themeClassName()) {\n            v.setThemeClassName(\"FieldValue\")\n        }\n        v.setUserSelect(\"text\")   // should the value view handle this?\n        v.setSpellCheck(false)   // should the value view handle this?\n        //v.setPaddingTop(this.vPadding())\n        //v.setPaddingBottom(this.vPadding())\n        v.setMarginTop(this.vPadding())\n        v.setMarginBottom(this.vPadding())\n\n        this.setValueView(v)\n        this.valueViewContainer().addSubview(v)  \n        //this.valueSectionView().addSubview(v)  \n        return v\n    }\n\n    setupNoteView () {\n        const v = DomView.clone().setElementClassName(\"BMFieldTileNoteViewView\")\n        v.setDisplay(\"block\")\n        v.setPosition(\"relative\")\n        v.setOverflow(\"hidden\")\n        v.setWidth(\"100%\")\n        v.setFontWeight(\"normal\")\n        v.setColor(\"#aaa\")\n        v.setMarginLeft(\"0em\")\n        v.setMarginRightPx(0)\n        v.setMarginTop(\"0em\")\n        v.setMarginBottom(\"0.2em\")\n        v.setUserSelect(\"text\")\n        this.setNoteView(v)\n        this.noteViewContainer().addSubview(v)\n        return v\n    }\n\n    setupErrorView () {\n        const v = DomView.clone().setElementClassName(\"BMFieldTileErrorView\")\n        v.setUserSelect(\"text\")\n        v.setSpellCheck(false)\n        //v.setInnerHtml(\"error\")\n        v.setColor(\"red\")\n        v.setPaddingBottom(\"0em\")\n        this.setErrorView(v)\n        this.errorViewContainer().addSubview(v)\n        return v \n    }\n\n    createValueView () {\n        const v = TextField.clone().setElementClassName(\"BMFieldValueView\")\n        v.setDisplay(\"flex\")\n        v.setPosition(\"relative\")\n        v.setWidth(\"100%\")\n        v.setMarginTop(\"0.1em\")\n        v.setMarginLeft(\"0em\")\n        v.setMarginRight(\"0em\")\n        v.setMarginBottom(\"0.1em\")\n        v.setTextAlign(\"left\")\n        v.setOverflow(\"hidden\")\n        v.setWhiteSpace(\"nowrap\")\n        v.setPaddingLeft(\"7px\")\n        v.setPaddingRight(\"4px\")\n        v.setPaddingBottom(\"5px\")\n        v.setColor(\"white\")\n        v.setBackgroundColor(\"transparent\")\n        //tf.setSelectAllOnDoubleClick(true)\n        return v\n    }\n\n    // colors\n\n    currentBackgroundCssColor () {\n        const bg = this.navView().computedBackgroundColor()\n        return CssColor.clone().setCssColorString(bg)\n    }\n\n    valueBackgroundCssColor () {\n        return this.currentBackgroundCssColor().contrastComplement(0.2)\n    }\n\n    valueBackgroundColor () {\n        return this.valueBackgroundCssColor().cssColorString()\n    }\n\n    editableColor () {\n        return this.valueBackgroundCssColor().contrastComplement(0.2).cssColorString()\n    }\n\n    keyViewColor () {\n        //console.log(this.node().title() + \" \" + this.typeId() + \".isSelected() = \", this.isSelected())\n        return this.currentColor()\n        //return this.valueBackgroundCssColor().contrastComplement(0.2).cssColorString()\n    }\n\n\t\n    // visible key and value\n    \n    visibleValue () {\n        return this.node().visibleValue()\n    }\n\t\n    visibleKey () {\n        return this.node().key()\n    }\n\n    // sync \n    \n    didUpdateSlotIsSelected (oldValue, newValue) {\n        super.didUpdateSlotIsSelected(oldValue, newValue)\n        this.syncFromNodeNow() // need this to update selection color on fields?\n        return this\n    }\n\n    syncFromNode () {\n        super.syncFromNode()\n        //this.debugLog(\" syncFromNode\")\n\t\t\n        const node = this.node()\n        node.prepareToSyncToView()\n        this.setDisplayIsHidden(!node.isVisible())\n\n        this.syncKeyFromNode()\n        this.syncValueFromNode()\n        this.syncErrorFromNode()\n        this.syncNoteFromNode()\n        return this\n    }\n\n    syncKeyFromNode () {\n        const node = this.node()\n        const keyView = this.keyView()\n\n        keyView.setString(this.visibleKey()) // setString only applies if value changed\n        keyView.setIsVisible(node.keyIsVisible())\n        keyView.setDisplayIsHidden(!node.keyIsVisible())\n        keyView.setIsEditable(node.keyIsEditable())\n        keyView.setColor(this.keyViewColor())\n    }\n\n    syncValueFromNode () {\n        const node = this.node()\n        const valueView = this.valueView()\n\n        const newValue = this.visibleValue()\n        valueView.setValue(newValue)\n        valueView.setIsEditable(node.valueIsEditable())\n        valueView.setDisplayIsHidden(!node.valueIsVisible())\n\n        if (node.valueIsEditable()) {\n            //valueView.setColor(this.editableColor())\n            valueView.setColor(this.currentColor())\n            //valueView.setBorder(\"1px solid #444\")\n            //valueView.setBorder(\"1px solid rgba(255, 255, 255, 0.2)\")\n            valueView.setBorder(this.valueEditableBorder())\n            valueView.setPaddingLeft(\"0.5em\").setPaddingRight(\"0.5em\")\n\n        } else {\n            //console.log(\"fieldview key '\", node.key(), \"' node.valueIsEditable() = \", node.valueIsEditable(), \" setColor \", this.uneditableColor())\n            valueView.setColor(this.uneditableColor())\n            //valueView.setBorder(\"1px solid rgba(255, 255, 255, 0.05)\")\n            valueView.setBorder(this.valueUneditableBorder())\n            valueView.setPaddingLeft(\"0em\").setPaddingRight(\"0em\")\n        }\n    }\n\n    syncErrorFromNode () {\n        const node = this.node()\n        const valueView = this.valueView()\n        const errorView = this.errorView()\n\n        const color = valueView.color()\n        \n        if (node.valueError()) {\n            valueView.setColor(this.errorColor())\n            errorView.setColor(this.errorColor())\n            errorView.setInnerHtml(node.valueError())\n            errorView.fadeInHeightToDisplayBlock()\n            //valueView.setToolTip(node.valueError())\n        } else {\n            valueView.setBackgroundColor(\"transparent\")\n            valueView.setColor(color)\n\n            if (errorView.display() !== \"none\") {\n                errorView.setDisplay(\"none\")\n            }\n            //errorView.fadeOutHeightToDisplayNone()\n            \n            //valueView.setToolTip(\"\")\n        }\n    }\n\n    syncNoteFromNode () {\n        const node = this.node()\n        const noteView = this.noteView()\n        \n        if (this.visibleNote()) {\n            noteView.unhideDisplay()\n            noteView.setInnerHtml(this.visibleNote())\n        } else {\n            noteView.hideDisplay()\n            noteView.setInnerHtml(\"\")\n        }\n    }\n\n\n    // ----------------------\n\n    visibleNote () {\n        return this.node().note()\n    }\n    \n    syncToNode () {\n        const node = this.node()\n\n        if (node.keyIsEditable()) {\n        \tnode.setKey(this.keyView().value())\n        }\n\t\n        if (node.valueIsEditable()) {\n        \tnode.setValue(this.valueView().value())\n        }\n\t\t\n        super.syncToNode()\n        return this\n    }\n    \n    onDidEdit (changedView) {\n        this.scheduleSyncToNode() \n        return true\n    }\n\n    syncStylesToSubviews () {\n        super.syncStylesToSubviews()\n        this.keyView().syncStateFrom(this)\n        this.valueView().syncStateFrom(this)\n        return this\n    }\n\n    updateSubviews () {\n        super.updateSubviews()\n        this.syncStylesToSubviews()\n\n        /*\n        const node = this.node()\n\n        if (node && node.nodeMinTileHeight()) {\n            if (node.nodeMinTileHeight() === -1) {\n                this.setHeight(\"auto\")\n                this.setPaddingBottom(\"calc(100% - 20px)\")\n\n            } else {\n                this.setHeight(this.pxNumberToString(node.nodeMinTileHeight()))\n            }\n        }\n        */\n        \n        return this\n    }\n\n    applyStyles () {\n        super.applyStyles()\n        //this.keyView().applyStyles()\n        //this.valueView().applyStyles()\n        return this\n    }\n    \n    onEnterKeyUp (event) {\n        //this.debugLog(\".onEnterKeyUp()\")\n        if (this.valueView().activate) {\n            this.valueView().activate()\n        }\n        return this\n    }\n\n    setBackgroundColor (c) {\n        /*\n        this.debugLog(\".setBackgroundColor \", c)\n        if (c !== \"white\") {\n            console.log(\"not white\")\n        }\n        */\n        super.setBackgroundColor(c)\n        return this\n    }\n\n    becomeKeyView () {\n        this.valueView().becomeKeyView()\n        return this\n    }\n\n    unselect () {\n        super.unselect()\n        this.valueView().blur()\n        this.keyView().blur()\n        return this\n    }\n    \n}.initThisClass());\n",
  "wOi4QXQe779rHlA6hsbeKlVRePQXe2IqtrSPd+msq/g=": "\"use strict\";\n\n/*\n\n    BMActionNodeTile\n\n*/\n\n(class BMActionNodeTile extends Tile {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"buttonView\", null)\n    }\n\n    init () {\n        super.init()\n\n        const cv = this.contentView()\n        cv.flexCenterContent()\n        cv.setPaddingTop(\"0.5em\")\n        cv.setPaddingBottom(\"0.5em\")\n        cv.setPaddingLeft(\"1em\")\n        cv.setPaddingRight(\"1em\")\n\t\t\n        const bv = ButtonView.clone().setElementClassName(\"BMActionNodeView\")\n        this.setButtonView(bv)\n\t    bv.setTarget(this).setAction(\"didClickButton\")\n\t    bv.setBorder(\"1px solid rgba(128, 128, 128, 0.5)\")\n\n        this.addContentSubview(this.buttonView())\n        //this.setMinHeightPx(64)\n        return this\n    }\n\n    updateSubviews () {\t\n        super.updateSubviews()\n\t\t\n        const node = this.node()\n        const bv = this.buttonView()\n        bv.setTitle(node.title())\n        bv.setIsEditable(node.nodeCanEditTitle())\n\n        if (node.isEnabled()) {\n            bv.setOpacity(1)\t\n        } else {\n            bv.setOpacity(0.5)\t\n        }\n\t\t\n        return this\n    }\n    \n    onEnterKeyUp (event) {\n        this.doAction()\n        return false\n    }\n    \n    doAction () {\n        if (this.node().isEnabled()) { // check in node field?\n            this.node().doAction()\n        }\n        return this     \n    }\n    \n    didClickButton () {\n        this.doAction()\n        return this\n    }\n\n    syncToNode () {\n        this.node().setTitle(this.buttonView().title()) \n        super.syncToNode()\n        return this\n    }\n\n    onDidEdit (changedView) {     \n        this.scheduleSyncToNode()\n        //this.node().didUpdateView(this)\n        //this.scheduleSyncFromNode() // needed for validation?\n        return true\n    }\n    \n}.initThisClass());\n",
  "/nIEvPblUlQUvMYJQU/RuKh8HeValGJD78jN+eDIA1c=": "\"use strict\";\n\n/*\n\n    BMBooleanFieldTile\n\n*/\n\n(class BMBooleanFieldTile extends BMFieldTile {\n    \n    /*\n    initPrototypeSlots () {\n    }\n    */\n\n    init () {\n        super.init()\n        \n        this.turnOffUserSelect()\n        this.keyView().setTransition(\"color 0.3s\")\n        this.keyView().setPaddingLeft(\"0.5em\")\n\n        this.valueView().parentView().flexCenterContent()\n        this.valueView().setPaddingBottom(\"0em\")\n\n        //this.contentView().debugBorders()\n        this.kvSection().subviews().at(1).flexCenterContent()\n        //this.contentView().setFlexDirection(\"column\")\n        this.kvSection().setFlexDirection(\"row\").makeSubviewsReverseOrdered()\n        //this.kvSection().subviews().forEach(sv => sv.setAlignItems(\"center\"))\n        this.kvSection().subviews().forEach(sv => sv.flexCenterContent())\n        //this.keyView().parentView().swapSubviews(this.keyView(), this.valueView())\n\n        this.setValueEditableBorder(\"none\")\n        this.setValueUneditableBorder(\"none\")\n\n        return this\n    }\n\n    createValueView () {\n        const bv = BooleanView.clone()\n        return bv\n    }\n\t\n    booleanView () {\n        return this.valueView()\n    }\n\n    syncFromNode () {\n        super.syncFromNode()\n        this.booleanView().updateAppearance()\n        return this\n    }\n    \n}.initThisClass());\n",
  "ubTcYGlOmPAlov/D3gEoMGPKa5eFP5/SzOoV9k2Ed4o=": "\"use strict\";\n\n/*\n\n    BMStringFieldTile\n\n*/\n\n(class BMStringFieldTile extends BMFieldTile {\n    \n    /*\n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n    createValueView () {\n        const v = TextField.clone()\n        v.setDisplay(\"block\")\n        v.setPosition(\"relative\")\n        v.setWordWrap(\"normal\")\n        v.setHeight(\"auto\")\n        v.setWidth(\"-webkit-fill-available\")\n        v.setTextAlign(\"left\")\n        v.setMargin(\"0em\")\n        v.setOverflowX(\"hidden\")\n        v.setBorderRadius(\"0.2em\")\n        return v\n    }\n    \n}.initThisClass());\n",
  "deqHudo/YTBrr8ORNH4mEH/qkpDrNz2e8sUFdnkXaVI=": "\"use strict\";\n\n/*\n\n    BMTextAreaFieldTile\n\n    \n*/\n\n(class BMTextAreaFieldTile extends BMFieldTile {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        this.keyView().hideDisplay()\n        this.setValueUneditableBorder(\"none\")\n        this.setValueEditableBorder(\"none\")\n        return this\n    }\n\n    createValueView () {\n        /* old css:\n        .BMTextAreaFieldValueView {\n            display: flex;\n            position: relative;\n            padding: 0;\n            margin: 0;\n            width: auto;\n            min-height: auto;\n\n            word-break: break-all;\n            unicode-bidi: embed;\n            white-space: pre-wrap;\n\n            font-weight: normal;\n            text-align: left;\n        }\n        */\n\n        const v = TextField.clone().setElementClassName(\"BMTextAreaFieldValueView\")\n        v.setDisplay(\"block\")\n        v.setPosition(\"relative\")\n        v.setWordWrap(\"normal\")\n        v.setHeight(\"auto\")\n        v.setWidth(\"-webkit-fill-available\")\n        v.setTextAlign(\"left\")\n        v.setMargin(\"0em\")\n        v.setOverflowX(\"hidden\")\n        v.setOverflowY(\"scroll\")\n        //v.setFontFamily(\"Mono\")\n        //v.setDoesHoldFocusOnReturn(true)\n        v.setDoesInput(false)\n        return v\n    }\n    \n    /*\n    updateSubviews () {   \n        super.updateSubviews()\n\n        return this\n    }\n    */\n\n    /*\n\t\n    fillBottomOfColumnIfAvailable () {\n        if (this.column().tiles().last() === this) {\n            //this.debugLog(\" update height\")\n            this.setMinAndMaxHeightPercentage(100)\n            this.setFlexGrow(100)\n            this.setBorderBottom(\"0em\")\n\n            this.valueView().setHeight(\"100%\")\n        } else {\n            this.setFlexGrow(1)\n            this.setBorderBottom(\"1px solid rgba(125, 125, 125, 0.5)\")\n        }\n        return this\n    }\n    */\n    \n}.initThisClass());\n",
  "t5ftR6raLlELUxGmTgtFs0RBXw8+pJXuLYUEawwWtTE=": "\"use strict\";\n\n/*\n\n    BMImageWellFieldTile\n\n*/\n\n(class BMImageWellFieldTile extends BMFieldTile {\n    \n    canOpenMimeType (mimeType) {\n        // TODO: add checks for browser supported image types?\n        return mimeType.startsWith(\"image/\")\n    }\n\n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.valueViewContainer().flexCenterContent()\n        this.valueViewContainer().setPaddingTop(\"0px\").setPaddingBottom(\"0px\")\n        this.valueView().setPaddingTop(\"0px\").setPaddingBottom(\"0px\")\n\n        //this.keyView().setElementClassName(\"BMImageWellKeyField\")\n        //this.valueView().setIsEditable(false)\n        this.turnOffUserSelect()\n        this.keyView().setTransition(\"color 0.3s\")\n        //this.valueViewContainer().setPadding(\"0px\")\n        return this\n    }\n\n    createValueView () {\n        const imageWellView = ImageWellView.clone()\n        //imageWellView.setWidth(\"100%\").setHeight(\"fit-content\")\n        return imageWellView\n    }\n\t\n    imageWellView () {\n        return this.valueView()\n    }\n\n    syncFromNode () {\n        super.syncFromNode()\n\n        const field = this.node()\n        this.setMaxWidth(\"100em\") // get this from node instead?\n        \n        this.applyStyles() // normally this would happen in updateSubviews\n        this.imageWellView().setImageDataUrl(field.value())\n\n        return this\n    }\n\n    syncToNode () {\n        const field = this.node()\n\t\t\t\t\n        //this.updateKeyView()\n        \n        field.setKey(this.keyView().value())\n\n        if (field.valueIsEditable()) {\n            const data = this.imageWellView().imageDataUrl()\n            //console.log(\"data = \" + (data ? data.slice(0, 40) + \"...\" : \"null\"))\n        \tfield.setValue(data)\n        }\n        \n        //super.suncToNode()\n        return this\n    }\n\n    dataUrl () {\n        return this.imageWellView().imageDataUrl()\n    }\n\n    isEmpty () {\n        return Type.isNull(this.dataUrl())\n    }\n    \n    didUpdateImageWellView (anImageWell) {\n        //this.debugLog(\".didUpdateImageWellView()\")\n        this.scheduleSyncToNode() \n        return this\n    }\n    \n}.initThisClass());\n",
  "T75gMPVhyx39+D13hrhbmkEfVaiF/wPCiTGgfhbbkh0=": "\"use strict\";\n\n/*\n\n    BMOptionsNodeTile \n\n    View for BMOptionsNode\n\n    BMOptionsNode -> BMOptionsNodeTile\n        BMOption -> BMSingleOptionTile\n        BMMultiOption -> BMMultiOptionTile\n\n*/\n\n\n(class BMOptionsNodeTile extends TitledTile {\n    \n    /*\n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n    */\n\t\n}.initThisClass());\n",
  "gSSugKqI4MJ/u1h06BNUp2mk/vwD92DHaoCnU5SRG24=": "\"use strict\";\n\n/*\n\n    BMOptionNodeTile \n\n \n*/\n\n(class BMOptionNodeTile extends TitledTile {\n    \n    /*\n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        //this.setHasSubtitle(true)\n        return this\n    }\n    */\n\n    /*\n    activate () {\n        super.activate()\n        this.toggle()\n        return this\n    }\n    */\n\n    toggle () {\n        //debugger\n        this.node().toggle()\n        return this\n    }\n\n    onEnterKeyUp (event) {\n        //debugger;\n        super.onEnterKeyUp(event)\n        this.toggle()\n        event.stopPropagation()\n        return this\n    }\n    \n    onTapComplete (aGesture) {\n        //debugger;\n        super.onTapComplete(aGesture)\n        this.toggle()\n        //event.stopPropagation() // is this correct? this prevents tiles from doing selection?\n        return this\n    }\n\n    /*\n    syncToNode () {\n        super.syncToNode()\n        return this\n    }\n    */\n\t\n}.initThisClass());\n",
  "RbAMohbGEGt94koGgDZpNOHt/lBoI0y0VkG7JtrlIwA=": "\"use strict\";\n\n/*\n\n    BMPointerFieldTile\n\n*/\n\n(class BMPointerFieldTile extends TitledTile {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n\n        this.makeNoteRightArrow()\n\t\t\n        return this\n    }\n\n    updateSubviews () {\t\n        super.updateSubviews()\n\t\t\n        let node = this.node()\n\n        if (this.isSelected()) {\n            this.noteView().setOpacity(1)\t\n        } else {\n            this.noteView().setOpacity(0.4)\t\n        }\n\n        this.applyStyles()\n\t\t\n        return this\n    }\n    \n}.initThisClass());\n",
  "2x3ynU7k/09o6KEuqcFgYc9UaUvWS5sQrc+rtVI4z5w=": "\"use strict\";\n\n/*\n    \n    BrowserView\n\n    A StackView with the 2nd level node used as a horizontal breadcrumb path node.\n\n    To do this, we create a top wrapper node, which has one subnode which is the actual root node.\n    Somehow we will set the root node tile view to display the path selected in the UI...\n    \n\n    AppLauncher - sets up database, may read App object from database or create if db is empty?\n\n\n    Nodes: ---------------> Views:\n\n    browserNode             BrowserView\n      appRootNode             HeaderTile \n        settingsNode (OPTION hidden) \n        topContentNode          BreadCrumbsTile\n            about\n            guide\n               index\n               content\n                 intro\n                   overview\n                   perspectiv\n                   goals\n            tuturial\n            reference\n            binaries\n            source\n            twitter\n            links\n            repl\n            \n\n    Ideas:\n\n        - need way to read/write local changes (with permission) to server\n        \n    Questions:\n\n    - Should headerNode be the AppNode, so we can option click it to inspect it and map app name to header?\n    - Which node should be root node of storage pool?\n    -- does App own the pool, or does pool own the app?\n    -- should there be a RootPoolNode class that helps manage the pool or help expose management and info to the UI? \n\n    Todo:\n\n        Make moveToBase() more generic\n*/\n\n(class BrowserView extends StackView {\n    \n    initPrototypeSlots () {\n        // broswerNode is this view's node()\n        //this.newSlot(\"headerNode\", null) // top header\n        //this.newSlot(\"breadCrumbsNode\", null) // breadcrumbs\n    }\n\n    init () {\n        super.init()\n        //this.setupBrowserNode()\n        //this.setupHeaderNode()\n        return this\n    }\n\n    /*\n    setupBrowserNode () {\n        const node = BaseNode.clone()\n        node.setNodeMinTileHeight(55)\n        node.setTitle(\"browser\")\n        node.setNodeIsVertical(false) // not setting BrowserView to down direction - why?\n        this.setNode(node)\n        return this\n    }\n\n    setupHeaderNode () {\n        const node = BaseNode.clone()\n        node.setNodeTileClassName(\"HeaderTile\")\n        node.setNodeMinTileHeight(55)\n        node.setTitle(\"Header Tile\")\n        node.setNodeIsVertical(false) \n        this.setHeaderNode(node)\n        this.node().addSubnode(node)\n        return this\n    }\n\n    didUpdateSlotBreadCrumbsNode (oldValue, newValue) {\n        //debugger;\n\n        // tell the node to hint to UI to use BreadCrumbsTile view to display itself\n        newValue.setNodeTileClassName(\"BreadCrumbsTile\")\n        newValue.setTitle(\"BreadCrumbsTile\")\n\n        // make sure it's the only thing under the header\n        this.headerNode().removeAllSubnodes()\n        this.headerNode().addSubnode(newValue)\n        //this.headerNode().addSubnode(this.newSettingsNode())\n\n        // this should set up header view (and bread crumb view?)\n        this.syncFromNode()\n        \n        // select the bread crumb tile\n        // this should cause it's child stack view to get rendered (Notes, Settings, Resources)\n        this.scheduleMethod(\"moveToBase\")\n        return this\n    }\n    */\n\n    moveToBase () {\n        //this.selectNodePathArray([this.headerNode(), this.breadCrumbsNode()])\n       // debugger;\n        return this\n    }\n\n}.initThisClass());\n",
  "A0FDOBBUmFK0VOzIYTBfzDONx0rZtHE70G0Ygka1tVk=": "\"use strict\";\n\n/*\n\n    BMBlob\n\n*/\n\n(class BMBlob extends BaseNode {\n\n    initPrototypeSlots () {\n\n        {\n            const slot = this.newSlot(\"name\", null)\n            slot.setSyncsToView(true)\n            slot.setShouldStoreSlot(true)\n            slot.setDoesHookSetter(true)\n        }\n\n        {\n            const slot = this.newSlot(\"valueHash\", null)\n            slot.setSyncsToView(true)\n            slot.setShouldStoreSlot(true)\n            slot.setDoesHookSetter(true)\n        }\n\n        {\n            const slot = this.newSlot(\"valueSize\", null)\n            slot.setSyncsToView(true)\n            slot.setShouldStoreSlot(true)\n            slot.setDoesHookSetter(true)\n        }\n\n        {\n            const slot = this.newSlot(\"lastModifiedTime\", null)\n            slot.setSyncsToView(true)\n            slot.setShouldStoreSlot(true)\n            slot.setDoesHookSetter(true)\n        }\n\n        {\n            const slot = this.newSlot(\"expirationDate\", null)\n            slot.setSyncsToView(true)\n            slot.setShouldStoreSlot(true)\n            slot.setDoesHookSetter(true)\n        }\n\n        {\n            const slot = this.newSlot(\"value\", null)\n            slot.setSyncsToView(true)\n            slot.setShouldStoreSlot(false)\n            slot.setDoesHookSetter(true)\n        }\n    }\n\n    init () {\n        super.init()\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(false)\n        this.setCanDelete(true)\n        return this\n    }\n\n    age () {\n        return new Date().getTime() - this.lastModifiedTime() \n    }\n\n    prepareForFirstAccess () {\n        super.prepareForFirstAccess()\n        this.setupValueField()\n    }\n\n    setupValueField () {\n        const field = BMTextAreaField.clone().setKey(\"value\")\n        field.setValueMethod(\"value\")\n        field.setValueIsEditable(false)\n        field.setIsMono(true)\n        field.setTarget(this)\n        field.getValueFromTarget()\n        this.addSubnode(field)\n\n        this.promiseReadValue().then(() => { this.didReadValue() })\n        this.scheduleSyncToView()\n    }\n\n    didReadValue () {\n    }\n\n    title () {\n        return this.name()\n    }\n\n    subtitle () {\n        const size = this.valueSize()\n        if (size) {\n            return size.byteSizeDescription() \n        }\n        return null\n    }\n\n    // key\n\n    hash () {\n        return this.valueHash() // for subnode lookup\n    }\n\n    didUpdateSlotValue (oldValue, newValue) {\n        if (newValue) {\n            this.setValueSize(newValue.length)\n            this.setLastModifiedTime(new Date().getTime())\n            this.promiseWriteValue()\n        }\n        return this\n    }\n\n    store () {\n        return this.parentNode().store()\n    }\n\n    promiseWriteValue () {\n        // what about number or null values?\n        const v = this.value()\n        assert(Type.isArrayBuffer(v) || Type.isString(v))\n\n        return v.promiseSha256Digest().then((digestBuffer) => {\n            const h = digestBuffer.base64Encoded()\n            return this.promiseWriteValueWithHash(v, h)\n        })\n    }\n\n    promiseWriteValueWithHash (v, h) {\n        this.setValueHash(h)\n        \n        if (Type.isArrayBuffer(value)) {\n            assert(value.byteLength)\n        }\n\n        assert(this.isValid())\n\n        const resolveAtPut = () => {\n            console.log(\"did write hash/value pair: \" + this.description())\n        }\n\n        const rejectAtPut = (error) => {\n            console.log(\"error writing hash/value pair: \" + this.description())\n            debugger\n        }\n\n        return this.store().promiseOpen().then(() => {\n            return this.store().promiseAtPut(h, v).then(resolveAtPut, rejectAtPut)\n        })\n    }\n\n    promiseReadValue () {\n        if (this.value()) {\n            resolve()\n        }\n\n        assert(this.isValid())\n\n        return this.store().promiseAt(this.valueHash()).then((value) => {\n            this._value = value\n            this.didUpdateNode()\n        })\n    }\n\n    isValid () {\n        if (Type.isNull(this.name())) {\n            return false\n        }\n\n        if (Type.isNull(this.valueHash())) {\n            return false\n        }\n\n        if (Type.isNull(this.valueSize())) {\n            return false\n        }\n\n        if (Type.isNull(this.lastModifiedTime()) || this.lastModifiedTime() === 0) {\n            return false\n        }\n\n        return true\n    }\n\n    description () {\n        const slotNames = [\"name\", \"valueHash\", \"valueSize\", \"lastModifiedTime\"]\n        const parts = [this.typeId()]\n        slotNames.forEach(slotName => {\n            parts.push(slotName + \":\" + this[slotName]())\n        })\n        return parts.join(\", \")\n    }\n\n    /*\n    static testHash () {\n        // code from nodejs\n        // crypto.createHash('sha256').update(Buffer.from(\"abc\", \"utf8\")).digest(\"base64\")\n        const nodejsHash = 'ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0='\n        const enc = new TextEncoder(); // always utf-8\n        const uint8Array = enc.encode(\"abc\");\n        const arrayBuffer = uint8Array.buffer\n        arrayBuffer.promiseSha256Digest((digestBuffer) => {\n            const h = digestBuffer.base64Encoded()\n            assert(h === nodejsHash)\n            console.log(\"hashes match!\")\n            debugger;\n        })\n    }\n    */\n\n}.initThisClass());\n\n\n\n//BMBlob.testHash()",
  "s+MVoYYHZbLzE7hC5VSunsNrW0sGNtfrqkOhg0ZxVoM=": "\"use strict\";\n\n/*\n\n    BMBlobs\n\n    Async storage for larger values.\n\n    Motivation:\n    Due to indexeddb only having an async API, we have to load the app's store \n    entirely into memory in order to be able to synchronously read it. \n    This works as long as the amount of data isn't too big.\n    To help keep the store small, we put large objects, and objects which are ok to load asynchronously \n    (eg app resources like fonts, images) in blobs.\n\n    blobs -> blob subnode (name, valueHash, date, etc) \n\n    A container for existing blobs. \n    A blob is an object that refs an entry in a PersistentAsyncMap (separate from the app's store).\n    The data hash is used as a pointer to a CamRecord\n\n    store a blob:\n\n    const blob = blobs.blobWithName(k)\n    // returns existing blob if there's a match\n\n    NOTES:\n\n    The Blobs object and it's subnodes should be stored in the app's\n    store, so there will need to be a path from the app's root node to\n    the BMBlobs singleton instance. It may be tricky to get this right as\n    creating a BMBlobs before reading it out of the store would create a\n    conflicting instance.\n\n*/\n\n(class BMBlobs extends BMStorableNode {\n    \n    static initClass () {\n        this.setIsSingleton(true)\n\t\treturn this\n    }\n    \n    initPrototypeSlots () {\n        this.newSlot(\"store\", null)\n    }\n\n    init () {\n        super.init()\n        this.setTitle(\"Blobs\")\n        this.setNoteIsSubnodeCount(true)\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(true)\n        this.setNodeCanReorderSubnodes(true)\n        this.setStore(PersistentAsyncMap.clone().setName(\"BlobHashStore\"))\n        return this\n    }\n\n    didInit () {\n        /*\n        this.store().promiseOpen().then(() => {\n            //this.removeAllSubnodes()\n            //this.collectGarbage()\n            //debugger\n            this.postNoteNamed(\"blobsDidOpen\")\n        })\n\n        */\n    }\n\n    promiseOpen () {\n        debugger\n        return this.store().promiseOpen()\n    }\n\n    // --- lookup blob by name ---\n\n    blobWithName (aName) {\n        return this.subnodes().detect(sn => sn.title() === aName)\n        //return this.subnodeWithTitle(aName)\n    }\n\n    hasBlobWithName (aName) {\n        return !Type.isNullOrUndefined(this.blobWithName(aName))\n    }\n\n    // --- lookup blob by hash ---\n\n    hasBlobWithValueHash (h) {\n        return !Type.isNullOrUndefined(this.blobWithValueHash(h))\n    }\n\n    blobWithValueHash (h) {\n        //debugger\n        return this.subnodes().detect(sn => sn.valueHash() === h) /// <------------------------------ TEMPORARY\n        //return this.subnodeWithHash(h)\n    }\n\n    // create blob\n    \n    createBlobWithNameAndValue (aName, aValue) {\n        //debugger\n        const oldBlob = this.blobWithName(aName)\n        if (oldBlob) {\n            oldBlob.setValue(aValue)\n            return oldBlob\n        }\n\n        assert(!this.hasBlobWithName(aName))\n        const blob = BMBlob.clone()\n        blob.setName(aName)\n        blob.setValue(aValue) // this will trigger an async compute of valueHash and store of value\n        this.addSubnode(blob)\n        return blob\n    }\n\n    collectGarbage () {\n        // remove invalid Blob subnodes (thbose with null meta data)\n        this.subnodes().shallowCopy().forEach((blob) => {\n            if (!blob.isValid()) {\n                this.debugLog(\" collecting inValid blob:\", blob.description())\n                blob.delete()\n            }\n        })\n\n        // remove store entries which are not referenced by a Blob subnode valueHash\n        const subnodeHashes = this.subnodes().map(sn => sn.valueHash()).asSet()\n        const store = this.store()\n\n        //store.promiseClear()\n        store.promiseAllKeys().then((storedHashes) => {\n            storedHashes.forEach((h) => {\n                if (!subnodeHashes.has(h)) {\n                    this.debugLog(\"collecting unreferenced blob hash:\", h)\n                    store.promiseRemoveKey(h)\n                }\n            })\n        })\n    }\n\n    static selfTest () {\n        this.addTimeout(() => {\n            const blob = BMBlobs.shared().blobForKey(\"http://test.com/\")\n            blob.setValue(\"test content\")\n            blob.promiseWrite()\n        })\n    }\n\n}.initThisClass());\n",
  "bHS8x/d9NPC5DyVHQZvZw4sabxu3a1go2m4OHjra/uY=": "\"use strict\";\n\n/*\n    App \n    \n    A shared instance that represents the application. \n\n    Handles:\n    - starting up persistence system\n    - setting up user interface, if any\n\n    For your application, create a subclass if needed.\n\n*/\n\n(class App extends BMStorableNode {\n    \n    // --- shared ---\n    // We override sharedContext so all subclasses use the same shared value\n    // and anyone can call App.shared() to access it\n\n    static sharedContext () {\n        return App\n    }\n\n    // --- store ---\n    // we open store from app class since we might want to load app instance from store\n\n    static loadAndRunShared () {\n        this.defaultStore().setName(this.type()) // name of the database\n        //this.defaultStore().promiseOpen().then(() => { this.promiseDeleteDefaultStore() })\n        this.defaultStore().promiseOpen().then(() => { \n            this.onPoolOpenSuccess(this.defaultStore()) \n        }).catch((error) => {\n            console.warn(\"ERROR: \", error)\n            debugger;\n            //ResourceLoaderPanel.shared().setError(errorMessage)\n        })\n    }\n\n    static promiseDeleteDefaultStore () {\n        return this.defaultStore().promiseDeleteAll()\n    }\n\n    static onPoolOpenSuccess (aPool) {\n        this.defaultStore().rootOrIfAbsentFromClosure(() => this.rootNodeProto().clone()) // create the root object\n        //const app = this.defaultStore().rootObject().subnodeWithTitleIfAbsentInsertProto(this.type(), this)\n        const app = this.clone()\n        this.setShared(app)\n        app.run()\n    }\n\n    static rootNodeProto () {\n        return BMStorableNode\n    }\n\n    // ------\n\n    initPrototypeSlots () {\n        this.newSlot(\"name\", \"App\")\n        this.newSlot(\"version\", [0, 0])\n        this.newSlot(\"hasDoneAppInit\", false)\n    }\n\n    init () {\n        super.init()\n        //console.log(ProtoClass.subclassesDescription())\n        this.setIsDebugging(true)\n    }\n\n    title () {\n        return this.name()\n    }\n    \n    // run and setup sequence in order of which methods are called\n    // 1. setup NodeStore\n\n    isBrowserCompatible () {\n        // subclasses can override to do their own checks\n        return true\n    }\n\n    run () {\n        if (!this.isBrowserCompatible()) {\n            ResourceLoaderPanel.shared().setError(\"Sorry, this app only works on<br>Chrome, FireFox, and Brave browsers.\")\n            return this\n        }\n\n       this.setup()\n    }\n\n    /*\n    showBrowserCompatibilityPanel () {\n        console.log(\"showing panel\")\n        const panel = PanelView.clone()\n        this.documentBodyView().addSubview(panel)\n        panel.setTitle(\"Sorry, this app only works on<br>Chrome, FireFox, and Brave browsers.\")\n        panel.orderFront()\n        panel.setZIndex(100)\n        console.log(\"showed panel\")\n    }\n    */\n\n    // 2. setup\n\n    setup () {\n        this.setupDocTheme()\n        return this        \n    }\n\n    appDidInit () {\n        this.showVersion()\n\n        this.setHasDoneAppInit(true)\n        this.postNoteNamed(\"appDidInit\")\n\n        if (this.runTests) {\n\t\t    this.runTests()\n        }\n\n        //Documentation.shared().show()\n        //this.registerServiceWorker() // not working yet\n    }\n\n    // window and document \n\n    mainWindow () {\n        return WebBrowserWindow.shared()\n    }\n\n    documentBodyView () {\n        return this.mainWindow().documentBody()\n    }\n\n    setName (aString) {\n        this._name = aString\n        this.setTitle(aString)\n        this.mainWindow().setTitle(aString)\n        return this\n    }\n    \n    // --- version ---\n\n    versionsString () {\n        return this.version().join(\".\")\n    }\n\n    showVersion () {\n        console.log(\"Application '\" + this.name() + \"' version \" + this.versionsString())\n    }\n\n    // document theme\n\n    setupDocTheme () {\n        //const doc = DocumentBody.shared()\n        const doc = this.documentBodyView()\n        doc.setColor(\"#f4f4ec\")\n        doc.setBackgroundColor(\"rgb(25, 25, 25)\")\n        this.setupNormalTheme()\n    }\n\n    setupNormalDocTheme () {\n        //const doc = DocumentBody.shared()\n        const doc = this.documentBodyView()\n        doc.setBackgroundColor(\"#191919\")\n        doc.setFontFamily(\"Helvetica\")\n        doc.setFontSizeAndLineHeight(\"15px\")\n        doc.setLetterSpacing(\"0.05em\")\n   }\n\n}.initThisClass());\n",
  "c6FEcqjQCwvWPOpiHNzCmnFVN8y70YaIScOEsEYz+SM=": "\"use strict\";\n\n/*\n\n    BMResource\n\n*/\n\n(class BMResource extends BaseNode {\n    \n    // --- supported mime types ---\n\n    static supportedMimeTypes () {\n        throw new Error(\"subclasses should override this method\")\n        return new Set()\n    }\n\n    static canOpenMimeType (mimeType) {\n        return this.supportedMimeTypes().has(mimeType)\n    }\n\n    static openMimeChunk (dataChunk) {\n         throw new Error(\"subclasses should override this method\")\n        //const aNode = this.clone()\n        //setValue(dataChunk)\n        //console.log(dataChunk.mimeType() + \" data.length: \" + dataChunk.decodedData().length)\n        //return aNode\n    }\n\n    // --- supported extension types ---\n\n    static supportedExtensions () {\n        throw new Error(\"subclasses should override this method\")\n        return []\n    }\n\n    static canHandleExtension (extension) {\n        return this.supportedExtensions().contains(extension)\n    }\n\n    // ---\n\n    initPrototypeSlots () {\n        this.newSlot(\"path\", \"\")\n        this.newSlot(\"data\", null)\n        this.newSlot(\"error\", null)\n        this.newSlot(\"loadState\", \"unloaded\") // \"unloaded\", \"loading\", \"decoding\", \"loaded\"\n        this.newSlot(\"loadProgress\", null) // null or a number 0 to 100\n        this.newSlot(\"isLoaded\", false)\n    }\n\n    /*\n    init () {\n        super.init()\n    }\n    */\n\n    title () {\n        return this.name()\n    }\n\n    subtitle () {\n        return this.path().pathExtension()\n    }\n\n    subtitle () {\n        return this.path().pathExtension() + \", \" + this.loadState()\n    }\n\n    name () {\n        return this.path().lastPathComponent().sansExtension()\n    }\n\n    // --- resource file ---\n\n    fileResource () {\n        const rootFolder = BMFileResources.shared().rootFolder()\n        const fileResource = rootFolder.nodeAtSubpathString(this.path())\n        return fileResource\n    }\n\n    promiseLoadFileResource () {\n        this.setTitle(this.path().lastPathComponent().sansExtension())\n        \n        const fileResource = this.fileResource()\n        if (!fileResource) {\n          const error = \"no index for file resource at path '\" + this.path() + \"'\"\n          this.setError(error)\n          throw new Error(error)\n        }\n        return fileResource.promiseLoad().then(() => { this.onFileResourceLoaded(fileResource) })\n    }\n    \n    onFileResourceLoaded (fileResource) {\n        this.setData(fileResource.data())\n        this.postNoteNamed(\"resourceLoaded\")\n        this.setLoadState(\"loaded\")\n        this.didLoad()\n        return this\n    }\n\n    // --- load ---\n\n    loadIfNeeded () {\n        if (this.loadState() === \"unloaded\") {\n            this.load()\n        }\n        return this\n    }\n\n    load () {\n        this.promiseLoadFileResource()\n        return this\n    }\n\n    /*\n    load () {\n        debugger;\n        this.setLoadState(\"loading\")\n        const rq = new XMLHttpRequest();\n        rq.open('GET', this.path(), true);\n        rq.responseType = 'arraybuffer';\n        rq.onload      = (event) => { this.onRequestLoad(event) }\n        rq.onerror     = (event) => { this.onRequestError(event) }\n        rq.onabort     = (event) => { this.onRequestAbort(event) }\n        rq.onloadend   = (event) => { this.onRequestLoadEnd(event) }\n        rq.onloadstart = (event) => { this.onRequestLoadStart(event) }\n        rq.onprogress  = (event) => { this.onRequestProgress(event) }\n        rq.ontimeout   = (event) => { this.onRequestTimeout(event) }\n        rq.send();\n        return this\n    }\n\n    onRequestAbort (event) {\n        this.setLoadState(\"aborted\")\n    }\n\n    onRequestLoadEnd (event) {\n    }\n\n    onRequestLoadStart (event) {\n        this.setLoadState(\"started\")\n    }\n\n    onRequestProgress (event) {\n        if (event.lengthComputable) {\n            const p = Math.floor(100 * (event.loaded / event.total))/100\n            this.setLoadState(p + \"% of \" + event.total.byteSizeDescription())\n        } else {\n            this.setLoadState(\"loading (\" +  event.loaded.byteSizeDescription() + \" so far)\")\n        }\n    }\n\n    onRequestTimeout (event) {\n        this.setLoadState(\"timeout\")\n    }\n\n    onRequestLoad (event) {\n        const request = event.currentTarget;\n        const downloadedBuffer = request.response;  // may be array buffer, blob, or string, depending on request type\n        this.setData(downloadedBuffer)\n        //this.didLoad()\n    }\n\n    onRequestError (event) {\n        console.log(this.type() + \" onLoadError \", error, \" \" + this.path())\n        this.setError(error)\n    }\n    */\n    \n    didLoad () {\n        this.setIsLoaded(true)\n        this.postNoteNamed(\"didLoad\")\n    }\n\n}.initThisClass());\n",
  "i/Bxp6qHDERsLCQ32UWxXHBo5q73BJREXDKuCxCtFeI=": "\"use strict\";\n\n/*\n\n    BMResources\n\n*/\n\n(class BMResources extends BMStorableNode {\n    \n    static initClass () {\n        this.setIsSingleton(true)\n\t\treturn this\n    }\n\n    initPrototypeSlots () {\n        //this.newSlot(\"themes\", null)\n        this.newSlot(\"fonts\", null)\n        this.newSlot(\"sounds\", null)\n        this.newSlot(\"images\", null)\n        this.newSlot(\"icons\", null)\n        this.newSlot(\"json\", null)\n        this.newSlot(\"files\", null)\n    }\n\n    init () {\n        super.init()\n        this.setShouldStore(false)\n        this.setTitle(\"Resources\")\n        this.setSubtitle(\"\")\n        this.setupSubnodes() // don't need to wait for appDidInit?\n        //this.watchOnceForNote(\"appDidInit\")\n    }\n\n    setupSubnodes () {\n        //const themes = this.defaultStore().rootSubnodeWithTitleForProto(\"Themes\", BMThemeResources)\n        //themes.setNodeCanReorderSubnodes(true)\n        //this.addSubnode(themes)\n        //let link = this.addLinkSubnode(themes)\n        //this.setThemes(themes)\n        //console.log(\"themes link = \", link.debugTypeId())\n\n        this.setFiles(BMFileResources.shared())\n        this.addSubnode(this.files())\n\n        this.setFonts(BMFontResources.shared())\n        this.addSubnode(this.fonts())\n\n        this.setSounds(BMSoundResources.shared())\n        this.addSubnode(this.sounds())\n\n        this.setImages(BMImageResources.shared())\n        this.addSubnode(this.images())\n\n        this.setIcons(BMIconResources.shared())\n        this.addSubnode(this.icons())\n\n        this.setJson(BMJsonResources.shared())\n        this.addSubnode(this.json())\n\n        return this\n    }\n\n    /*\n    appDidInit () {\n        this.findResources()\n    }\n\n    findResources () {\n        this.sendRespondingSubnodes(\"findResources\")\n        return this\n    }\n\n    loadResources () {\n        this.sendRespondingSubnodes(\"loadResources\")\n        return this\n    }\n    */\n\n    resourceClassesForFileExtension (extension) {\n        return this.subnodes().forEach(sn => sn.resourceClassesForFileExtension(extension)).flatten()\n    }\n\n    resourceClassForFileExtension (extension) {\n        return this.resourceClassesForFileExtension(extension).first()\n    }\n\n    resourceForPath (aPath) {\n        const rClass = this.resourceClassForFileExtension(aPath.pathExtension())\n        /*\n        if (!rClass) {\n            // do we want this behavior?\n            // What's the typical use case for this method\n            rClass = BMFileResource; \n        }\n        */\n        if (rClass) {\n            const aResource = rClass.clone().setPath(aPath).load()\n            return aResource\n        }\n        return null\n    }\n\n}.initThisClass());\n",
  "DLu5bMGOPDEpCJ/ejrLiHo649D9opclHheUy20NULHI=": "\"use strict\";\n\n/*\n\n    BMResourceGroup\n\n*/\n\n(class BMResourceGroup extends BaseNode {\n    \n    static initClass () {\n        this.setIsSingleton(true)\n\t\treturn this\n    }\n\n    initPrototypeSlots () {\n        this.newSlot(\"resourceClasses\", [])\n    }\n\n    init () {\n        super.init()\n        this.setTitle(this.type())\n        this.setNoteIsSubnodeCount(true)\n        this.setResourceClasses([])\n        this.setup()\n        this.registerForAppDidInit()\n    }\n\n    setup () {\n        // subclasses should override this to set ResourceClasses\n    }\n\n    appDidInit () {\n        this.setupSubnodes()\n        return this\n    }\n\n    extensions () {\n        const exts = this.resourceClasses().map(rClass => rClass.supportedExtensions()).flat().unique()\n        return exts\n    }\n\n    resourcePaths () {\n        return ResourceManager.shared().resourceFilePathsWithExtensions(this.extensions())\n    }\n\n    setupSubnodes () {\n        this.resourcePaths().forEach(path => this.addResourceWithPath(path))\n        return this\n    }\n\n    resourceClassesForFileExtension (extension) {\n        extension = extension.toLowerCase()\n        return this.resourceClasses().select(rClass => rClass.canHandleExtension(extension))\n    }\n\n    resourceClassForFileExtension (extension) {\n        return this.resourceClassesForFileExtension(extension).first()\n    }\n\n    resourceForPath (aPath) {\n        const rClass = this.resourceClassForFileExtension(aPath.pathExtension())\n        const aResource = rClass.clone().setPath(aPath)\n        aResource.load()\n        return aResource\n    }\n\n    addResourceWithPath (aPath) {\n        const aResource = this.resourceForPath(aPath)\n        this.addResource(aResource)\n        return this\n    }\n\n    addResource (aResource) {\n        this.addSubnode(aResource)\n        return this\n    }\n\n    resources () {\n        return this.subnodes()\n    }\n\n    resourceNamed (name) {\n        return this.resources().detect(r => r.name() == name)\n    }\n\n}.initThisClass());\n",
  "SrNKsWfTy5Fg17dZgybcT9zKHPms0KRxqdJ2Y1o3Kjg=": "/*\n\texample use:\n\n\tMimeExtensions.shared().mimeTypeForPathExtension(\".jpg\")\n\n*/\n\n\n(class MimeExtensions extends Base {\n\n\tconstructor () {\n\t\tsuper()\n\t\tthis.setup()\n\t}\n\n\tmimeTypeForPathExtension (ext) {\n\t\tif (ext[0] !== \".\") {\n\t\t\text = \".\" + ext;\n\t\t}\n\n\t\treturn this._fileExtensionToMimeTypeDict[ext]\n\t}\n\n\tpathExtensionsForMimeType (mimeType) {\n\t\tconst allExtensions = Object.keys(this._fileExtensionToMimeTypeDict)\n\t\tconst matchingExtensions = allExtensions.filter(ext => {\n\t\t\treturn mimeType === this._fileExtensionToMimeTypeDict[ext]\n\t\t})\n\t\treturn matchingExtensions.map(ext => ext.slice(1))\n\t}\n\n\tsetup () {\n\t\tthis._fileExtensionToMimeTypeDict = {\n\t\t\t\".123\": \"application/vnd.lotus-1-2-3\",\n\t\t\t\".3dml\": \"text/vnd.in3d.3dml\",\n\t\t\t\".3g2\": \"video/3gpp2\",\n\t\t\t\".3gp\": \"video/3gpp\",\n\t\t\t\".a\": \"application/octet-stream\",\n\t\t\t\".aab\": \"application/x-authorware-bin\",\n\t\t\t\".aac\": \"audio/x-aac\",\n\t\t\t\".aam\": \"application/x-authorware-map\",\n\t\t\t\".aas\": \"application/x-authorware-seg\",\n\t\t\t\".abw\": \"application/x-abiword\",\n\t\t\t\".acc\": \"application/vnd.americandynamics.acc\",\n\t\t\t\".ace\": \"application/x-ace-compressed\",\n\t\t\t\".acu\": \"application/vnd.acucobol\",\n\t\t\t\".acutc\": \"application/vnd.acucorp\",\n\t\t\t\".adp\": \"audio/adpcm\",\n\t\t\t\".aep\": \"application/vnd.audiograph\",\n\t\t\t\".afm\": \"application/x-font-type1\",\n\t\t\t\".afp\": \"application/vnd.ibm.modcap\",\n\t\t\t\".ai\": \"application/postscript\",\n\t\t\t\".aif\": \"audio/x-aiff\",\n\t\t\t\".aifc\": \"audio/x-aiff\",\n\t\t\t\".aiff\": \"audio/x-aiff\",\n\t\t\t\".air\": \"application/vnd.adobe.air-application-installer-package+zip\",\n\t\t\t\".ami\": \"application/vnd.amiga.ami\",\n\t\t\t\".apk\": \"application/vnd.android.package-archive\",\n\t\t\t\".application\": \"application/x-ms-application\",\n\t\t\t\".apr\": \"application/vnd.lotus-approach\",\n\t\t\t\".asc\": \"application/pgp-signature\",\n\t\t\t\".asf\": \"video/x-ms-asf\",\n\t\t\t\".asm\": \"text/x-asm\",\n\t\t\t\".aso\": \"application/vnd.accpac.simply.aso\",\n\t\t\t\".asx\": \"video/x-ms-asf\",\n\t\t\t\".atc\": \"application/vnd.acucorp\",\n\t\t\t\".atom\": \"application/atom+xml\",\n\t\t\t\".atomcat\": \"application/atomcat+xml\",\n\t\t\t\".atomsvc\": \"application/atomsvc+xml\",\n\t\t\t\".atx\": \"application/vnd.antix.game-component\",\n\t\t\t\".au\": \"audio/basic\",\n\t\t\t\".avi\": \"video/x-msvideo\",\n\t\t\t\".aw\": \"application/applixware\",\n\t\t\t\".azf\": \"application/vnd.airzip.filesecure.azf\",\n\t\t\t\".azs\": \"application/vnd.airzip.filesecure.azs\",\n\t\t\t\".azw\": \"application/vnd.amazon.ebook\",\n\t\t\t\".bat\": \"application/x-msdownload\",\n\t\t\t\".bcpio\": \"application/x-bcpio\",\n\t\t\t\".bdf\": \"application/x-font-bdf\",\n\t\t\t\".bdm\": \"application/vnd.syncml.dm+wbxml\",\n\t\t\t\".bh2\": \"application/vnd.fujitsu.oasysprs\",\n\t\t\t\".bin\": \"application/octet-stream\",\n\t\t\t\".bmi\": \"application/vnd.bmi\",\n\t\t\t\".bmp\": \"image/bmp\",\n\t\t\t\".book\": \"application/vnd.framemaker\",\n\t\t\t\".box\": \"application/vnd.previewsystems.box\",\n\t\t\t\".boz\": \"application/x-bzip2\",\n\t\t\t\".bpk\": \"application/octet-stream\",\n\t\t\t\".btif\": \"image/prs.btif\",\n\t\t\t\".bz\": \"application/x-bzip\",\n\t\t\t\".bz2\": \"application/x-bzip2\",\n\t\t\t\".c\": \"text/x-c\",\n\t\t\t\".c4d\": \"application/vnd.clonk.c4group\",\n\t\t\t\".c4f\": \"application/vnd.clonk.c4group\",\n\t\t\t\".c4g\": \"application/vnd.clonk.c4group\",\n\t\t\t\".c4p\": \"application/vnd.clonk.c4group\",\n\t\t\t\".c4u\": \"application/vnd.clonk.c4group\",\n\t\t\t\".cab\": \"application/vnd.ms-cab-compressed\",\n\t\t\t\".car\": \"application/vnd.curl.car\",\n\t\t\t\".cat\": \"application/vnd.ms-pki.seccat\",\n\t\t\t\".cc\": \"text/x-c\",\n\t\t\t\".cct\": \"application/x-director\",\n\t\t\t\".ccxml\": \"application/ccxml+xml\",\n\t\t\t\".cdbcmsg\": \"application/vnd.contact.cmsg\",\n\t\t\t\".cdf\": \"application/x-netcdf\",\n\t\t\t\".cdkey\": \"application/vnd.mediastation.cdkey\",\n\t\t\t\".cdx\": \"chemical/x-cdx\",\n\t\t\t\".cdxml\": \"application/vnd.chemdraw+xml\",\n\t\t\t\".cdy\": \"application/vnd.cinderella\",\n\t\t\t\".cer\": \"application/pkix-cert\",\n\t\t\t\".cgm\": \"image/cgm\",\n\t\t\t\".chat\": \"application/x-chat\",\n\t\t\t\".chm\": \"application/vnd.ms-htmlhelp\",\n\t\t\t\".chrt\": \"application/vnd.kde.kchart\",\n\t\t\t\".cif\": \"chemical/x-cif\",\n\t\t\t\".cii\": \"application/vnd.anser-web-certificate-issue-initiation\",\n\t\t\t\".cil\": \"application/vnd.ms-artgalry\",\n\t\t\t\".cla\": \"application/vnd.claymore\",\n\t\t\t\".class\": \"application/java-vm\",\n\t\t\t\".clkk\": \"application/vnd.crick.clicker.keyboard\",\n\t\t\t\".clkp\": \"application/vnd.crick.clicker.palette\",\n\t\t\t\".clkt\": \"application/vnd.crick.clicker.template\",\n\t\t\t\".clkw\": \"application/vnd.crick.clicker.wordbank\",\n\t\t\t\".clkx\": \"application/vnd.crick.clicker\",\n\t\t\t\".clp\": \"application/x-msclip\",\n\t\t\t\".cmc\": \"application/vnd.cosmocaller\",\n\t\t\t\".cmdf\": \"chemical/x-cmdf\",\n\t\t\t\".cml\": \"chemical/x-cml\",\n\t\t\t\".cmp\": \"application/vnd.yellowriver-custom-menu\",\n\t\t\t\".cmx\": \"image/x-cmx\",\n\t\t\t\".cod\": \"application/vnd.rim.cod\",\n\t\t\t\".com\": \"application/x-msdownload\",\n\t\t\t\".conf\": \"text/plain\",\n\t\t\t\".cpio\": \"application/x-cpio\",\n\t\t\t\".cpp\": \"text/x-c\",\n\t\t\t\".cpt\": \"application/mac-compactpro\",\n\t\t\t\".crd\": \"application/x-mscardfile\",\n\t\t\t\".crl\": \"application/pkix-crl\",\n\t\t\t\".crt\": \"application/x-x509-ca-cert\",\n\t\t\t\".csh\": \"application/x-csh\",\n\t\t\t\".csml\": \"chemical/x-csml\",\n\t\t\t\".csp\": \"application/vnd.commonspace\",\n\t\t\t\".css\": \"text/css\",\n\t\t\t\".cst\": \"application/x-director\",\n\t\t\t\".csv\": \"text/csv\",\n\t\t\t\".cu\": \"application/cu-seeme\",\n\t\t\t\".curl\": \"text/vnd.curl\",\n\t\t\t\".cww\": \"application/prs.cww\",\n\t\t\t\".cxt\": \"application/x-director\",\n\t\t\t\".cxx\": \"text/x-c\",\n\t\t\t\".daf\": \"application/vnd.mobius.daf\",\n\t\t\t\".dataless\": \"application/vnd.fdsn.seed\",\n\t\t\t\".davmount\": \"application/davmount+xml\",\n\t\t\t\".dcr\": \"application/x-director\",\n\t\t\t\".dcurl\": \"text/vnd.curl.dcurl\",\n\t\t\t\".dd2\": \"application/vnd.oma.dd2+xml\",\n\t\t\t\".ddd\": \"application/vnd.fujixerox.ddd\",\n\t\t\t\".deb\": \"application/x-debian-package\",\n\t\t\t\".def\": \"text/plain\",\n\t\t\t\".deploy\": \"application/octet-stream\",\n\t\t\t\".der\": \"application/x-x509-ca-cert\",\n\t\t\t\".dfac\": \"application/vnd.dreamfactory\",\n\t\t\t\".dic\": \"text/x-c\",\n\t\t\t\".diff\": \"text/plain\",\n\t\t\t\".dir\": \"application/x-director\",\n\t\t\t\".dis\": \"application/vnd.mobius.dis\",\n\t\t\t\".dist\": \"application/octet-stream\",\n\t\t\t\".distz\": \"application/octet-stream\",\n\t\t\t\".djv\": \"image/vnd.djvu\",\n\t\t\t\".djvu\": \"image/vnd.djvu\",\n\t\t\t\".dll\": \"application/x-msdownload\",\n\t\t\t\".dmg\": \"application/octet-stream\",\n\t\t\t\".dms\": \"application/octet-stream\",\n\t\t\t\".dna\": \"application/vnd.dna\",\n\t\t\t\".doc\": \"application/msword\",\n\t\t\t\".docm\": \"application/vnd.ms-word.document.macroenabled.12\",\n\t\t\t\".docx\": \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n\t\t\t\".dot\": \"application/msword\",\n\t\t\t\".dotm\": \"application/vnd.ms-word.template.macroenabled.12\",\n\t\t\t\".dotx\": \"application/vnd.openxmlformats-officedocument.wordprocessingml.template\",\n\t\t\t\".dp\": \"application/vnd.osgi.dp\",\n\t\t\t\".dpg\": \"application/vnd.dpgraph\",\n\t\t\t\".dsc\": \"text/prs.lines.tag\",\n\t\t\t\".dtb\": \"application/x-dtbook+xml\",\n\t\t\t\".dtd\": \"application/xml-dtd\",\n\t\t\t\".dts\": \"audio/vnd.dts\",\n\t\t\t\".dtshd\": \"audio/vnd.dts.hd\",\n\t\t\t\".dump\": \"application/octet-stream\",\n\t\t\t\".dvi\": \"application/x-dvi\",\n\t\t\t\".dwf\": \"model/vnd.dwf\",\n\t\t\t\".dwg\": \"image/vnd.dwg\",\n\t\t\t\".dxf\": \"image/vnd.dxf\",\n\t\t\t\".dxp\": \"application/vnd.spotfire.dxp\",\n\t\t\t\".dxr\": \"application/x-director\",\n\t\t\t\".ecelp4800\": \"audio/vnd.nuera.ecelp4800\",\n\t\t\t\".ecelp7470\": \"audio/vnd.nuera.ecelp7470\",\n\t\t\t\".ecelp9600\": \"audio/vnd.nuera.ecelp9600\",\n\t\t\t\".ecma\": \"application/ecmascript\",\n\t\t\t\".edm\": \"application/vnd.novadigm.edm\",\n\t\t\t\".edx\": \"application/vnd.novadigm.edx\",\n\t\t\t\".efif\": \"application/vnd.picsel\",\n\t\t\t\".ei6\": \"application/vnd.pg.osasli\",\n\t\t\t\".elc\": \"application/octet-stream\",\n\t\t\t\".eml\": \"message/rfc822\",\n\t\t\t\".emma\": \"application/emma+xml\",\n\t\t\t\".eol\": \"audio/vnd.digital-winds\",\n\t\t\t\".eot\": \"application/vnd.ms-fontobject\",\n\t\t\t\".eps\": \"application/postscript\",\n\t\t\t\".epub\": \"application/epub+zip\",\n\t\t\t\".es3\": \"application/vnd.eszigno3+xml\",\n\t\t\t\".esf\": \"application/vnd.epson.esf\",\n\t\t\t\".et3\": \"application/vnd.eszigno3+xml\",\n\t\t\t\".etx\": \"text/x-setext\",\n\t\t\t\".exe\": \"application/x-msdownload\",\n\t\t\t\".ext\": \"application/vnd.novadigm.ext\",\n\t\t\t\".ez\": \"application/andrew-inset\",\n\t\t\t\".ez2\": \"application/vnd.ezpix-album\",\n\t\t\t\".ez3\": \"application/vnd.ezpix-package\",\n\t\t\t\".f\": \"text/x-fortran\",\n\t\t\t\".f4v\": \"video/x-f4v\",\n\t\t\t\".f77\": \"text/x-fortran\",\n\t\t\t\".f90\": \"text/x-fortran\",\n\t\t\t\".fbs\": \"image/vnd.fastbidsheet\",\n\t\t\t\".fdf\": \"application/vnd.fdf\",\n\t\t\t\".fe_launch\": \"application/vnd.denovo.fcselayout-link\",\n\t\t\t\".fg5\": \"application/vnd.fujitsu.oasysgp\",\n\t\t\t\".fgd\": \"application/x-director\",\n\t\t\t\".fh\": \"image/x-freehand\",\n\t\t\t\".fh4\": \"image/x-freehand\",\n\t\t\t\".fh5\": \"image/x-freehand\",\n\t\t\t\".fh7\": \"image/x-freehand\",\n\t\t\t\".fhc\": \"image/x-freehand\",\n\t\t\t\".fig\": \"application/x-xfig\",\n\t\t\t\".fli\": \"video/x-fli\",\n\t\t\t\".flo\": \"application/vnd.micrografx.flo\",\n\t\t\t\".flv\": \"video/x-flv\",\n\t\t\t\".flw\": \"application/vnd.kde.kivio\",\n\t\t\t\".flx\": \"text/vnd.fmi.flexstor\",\n\t\t\t\".fly\": \"text/vnd.fly\",\n\t\t\t\".fm\": \"application/vnd.framemaker\",\n\t\t\t\".fnc\": \"application/vnd.frogans.fnc\",\n\t\t\t\".for\": \"text/x-fortran\",\n\t\t\t\".fpx\": \"image/vnd.fpx\",\n\t\t\t\".frame\": \"application/vnd.framemaker\",\n\t\t\t\".fsc\": \"application/vnd.fsc.weblaunch\",\n\t\t\t\".fst\": \"image/vnd.fst\",\n\t\t\t\".ftc\": \"application/vnd.fluxtime.clip\",\n\t\t\t\".fti\": \"application/vnd.anser-web-funds-transfer-initiation\",\n\t\t\t\".fvt\": \"video/vnd.fvt\",\n\t\t\t\".fzs\": \"application/vnd.fuzzysheet\",\n\t\t\t\".g3\": \"image/g3fax\",\n\t\t\t\".gac\": \"application/vnd.groove-account\",\n\t\t\t\".gdl\": \"model/vnd.gdl\",\n\t\t\t\".geo\": \"application/vnd.dynageo\",\n\t\t\t\".gex\": \"application/vnd.geometry-explorer\",\n\t\t\t\".ggb\": \"application/vnd.geogebra.file\",\n\t\t\t\".ggt\": \"application/vnd.geogebra.tool\",\n\t\t\t\".ghf\": \"application/vnd.groove-help\",\n\t\t\t\".gif\": \"image/gif\",\n\t\t\t\".gim\": \"application/vnd.groove-identity-message\",\n\t\t\t\".gmx\": \"application/vnd.gmx\",\n\t\t\t\".gnumeric\": \"application/x-gnumeric\",\n\t\t\t\".gph\": \"application/vnd.flographit\",\n\t\t\t\".gqf\": \"application/vnd.grafeq\",\n\t\t\t\".gqs\": \"application/vnd.grafeq\",\n\t\t\t\".gram\": \"application/srgs\",\n\t\t\t\".gre\": \"application/vnd.geometry-explorer\",\n\t\t\t\".grv\": \"application/vnd.groove-injector\",\n\t\t\t\".grxml\": \"application/srgs+xml\",\n\t\t\t\".gsf\": \"application/x-font-ghostscript\",\n\t\t\t\".gtar\": \"application/x-gtar\",\n\t\t\t\".gtm\": \"application/vnd.groove-tool-message\",\n\t\t\t\".gtw\": \"model/vnd.gtw\",\n\t\t\t\".gv\": \"text/vnd.graphviz\",\n\t\t\t\".gz\": \"application/x-gzip\",\n\t\t\t\".h\": \"text/x-c\",\n\t\t\t\".h261\": \"video/h261\",\n\t\t\t\".h263\": \"video/h263\",\n\t\t\t\".h264\": \"video/h264\",\n\t\t\t\".hbci\": \"application/vnd.hbci\",\n\t\t\t\".hdf\": \"application/x-hdf\",\n\t\t\t\".hh\": \"text/x-c\",\n\t\t\t\".hlp\": \"application/winhlp\",\n\t\t\t\".hpgl\": \"application/vnd.hp-hpgl\",\n\t\t\t\".hpid\": \"application/vnd.hp-hpid\",\n\t\t\t\".hps\": \"application/vnd.hp-hps\",\n\t\t\t\".hqx\": \"application/mac-binhex40\",\n\t\t\t\".htke\": \"application/vnd.kenameaapp\",\n\t\t\t\".htm\": \"text/html\",\n\t\t\t\".html\": \"text/html\",\n\t\t\t\".hvd\": \"application/vnd.yamaha.hv-dic\",\n\t\t\t\".hvp\": \"application/vnd.yamaha.hv-voice\",\n\t\t\t\".hvs\": \"application/vnd.yamaha.hv-script\",\n\t\t\t\".icc\": \"application/vnd.iccprofile\",\n\t\t\t\".ice\": \"x-conference/x-cooltalk\",\n\t\t\t\".icm\": \"application/vnd.iccprofile\",\n\t\t\t\".ico\": \"image/x-icon\",\n\t\t\t\".ics\": \"text/calendar\",\n\t\t\t\".ief\": \"image/ief\",\n\t\t\t\".ifb\": \"text/calendar\",\n\t\t\t\".ifm\": \"application/vnd.shana.informed.formdata\",\n\t\t\t\".iges\": \"model/iges\",\n\t\t\t\".igl\": \"application/vnd.igloader\",\n\t\t\t\".igs\": \"model/iges\",\n\t\t\t\".igx\": \"application/vnd.micrografx.igx\",\n\t\t\t\".iif\": \"application/vnd.shana.informed.interchange\",\n\t\t\t\".imp\": \"application/vnd.accpac.simply.imp\",\n\t\t\t\".ims\": \"application/vnd.ms-ims\",\n\t\t\t\".in\": \"text/plain\",\n\t\t\t\".ipk\": \"application/vnd.shana.informed.package\",\n\t\t\t\".irm\": \"application/vnd.ibm.rights-management\",\n\t\t\t\".irp\": \"application/vnd.irepository.package+xml\",\n\t\t\t\".iso\": \"application/octet-stream\",\n\t\t\t\".itp\": \"application/vnd.shana.informed.formtemplate\",\n\t\t\t\".ivp\": \"application/vnd.immervision-ivp\",\n\t\t\t\".ivu\": \"application/vnd.immervision-ivu\",\n\t\t\t\".jad\": \"text/vnd.sun.j2me.app-descriptor\",\n\t\t\t\".jam\": \"application/vnd.jam\",\n\t\t\t\".jar\": \"application/java-archive\",\n\t\t\t\".java\": \"text/x-java-source\",\n\t\t\t\".jisp\": \"application/vnd.jisp\",\n\t\t\t\".jlt\": \"application/vnd.hp-jlyt\",\n\t\t\t\".jnlp\": \"application/x-java-jnlp-file\",\n\t\t\t\".joda\": \"application/vnd.joost.joda-archive\",\n\t\t\t\".jpe\": \"image/jpeg\",\n\t\t\t\".jpeg\": \"image/jpeg\",\n\t\t\t\".jpg\": \"image/jpeg\",\n\t\t\t\".jpgm\": \"video/jpm\",\n\t\t\t\".jpgv\": \"video/jpeg\",\n\t\t\t\".jpm\": \"video/jpm\",\n\t\t\t\".js\": \"application/javascript\",\n\t\t\t\".json\": \"application/json\",\n\t\t\t\".kar\": \"audio/midi\",\n\t\t\t\".karbon\": \"application/vnd.kde.karbon\",\n\t\t\t\".kfo\": \"application/vnd.kde.kformula\",\n\t\t\t\".kia\": \"application/vnd.kidspiration\",\n\t\t\t\".kil\": \"application/x-killustrator\",\n\t\t\t\".kml\": \"application/vnd.google-earth.kml+xml\",\n\t\t\t\".kmz\": \"application/vnd.google-earth.kmz\",\n\t\t\t\".kne\": \"application/vnd.kinar\",\n\t\t\t\".knp\": \"application/vnd.kinar\",\n\t\t\t\".kon\": \"application/vnd.kde.kontour\",\n\t\t\t\".kpr\": \"application/vnd.kde.kpresenter\",\n\t\t\t\".kpt\": \"application/vnd.kde.kpresenter\",\n\t\t\t\".ksh\": \"text/plain\",\n\t\t\t\".ksp\": \"application/vnd.kde.kspread\",\n\t\t\t\".ktr\": \"application/vnd.kahootz\",\n\t\t\t\".ktz\": \"application/vnd.kahootz\",\n\t\t\t\".kwd\": \"application/vnd.kde.kword\",\n\t\t\t\".kwt\": \"application/vnd.kde.kword\",\n\t\t\t\".latex\": \"application/x-latex\",\n\t\t\t\".lbd\": \"application/vnd.llamagraphics.life-balance.desktop\",\n\t\t\t\".lbe\": \"application/vnd.llamagraphics.life-balance.exchange+xml\",\n\t\t\t\".les\": \"application/vnd.hhe.lesson-player\",\n\t\t\t\".lha\": \"application/octet-stream\",\n\t\t\t\".link66\": \"application/vnd.route66.link66+xml\",\n\t\t\t\".list\": \"text/plain\",\n\t\t\t\".list3820\": \"application/vnd.ibm.modcap\",\n\t\t\t\".listafp\": \"application/vnd.ibm.modcap\",\n\t\t\t\".log\": \"text/plain\",\n\t\t\t\".lostxml\": \"application/lost+xml\",\n\t\t\t\".lrf\": \"application/octet-stream\",\n\t\t\t\".lrm\": \"application/vnd.ms-lrm\",\n\t\t\t\".ltf\": \"application/vnd.frogans.ltf\",\n\t\t\t\".lvp\": \"audio/vnd.lucent.voice\",\n\t\t\t\".lwp\": \"application/vnd.lotus-wordpro\",\n\t\t\t\".lzh\": \"application/octet-stream\",\n\t\t\t\".m13\": \"application/x-msmediaview\",\n\t\t\t\".m14\": \"application/x-msmediaview\",\n\t\t\t\".m1v\": \"video/mpeg\",\n\t\t\t\".m2a\": \"audio/mpeg\",\n\t\t\t\".m2v\": \"video/mpeg\",\n\t\t\t\".m3a\": \"audio/mpeg\",\n\t\t\t\".m3u\": \"audio/x-mpegurl\",\n\t\t\t\".m4u\": \"video/vnd.mpegurl\",\n\t\t\t\".m4v\": \"video/x-m4v\",\n\t\t\t\".ma\": \"application/mathematica\",\n\t\t\t\".mag\": \"application/vnd.ecowin.chart\",\n\t\t\t\".maker\": \"application/vnd.framemaker\",\n\t\t\t\".man\": \"text/troff\",\n\t\t\t\".mathml\": \"application/mathml+xml\",\n\t\t\t\".mb\": \"application/mathematica\",\n\t\t\t\".mbk\": \"application/vnd.mobius.mbk\",\n\t\t\t\".mbox\": \"application/mbox\",\n\t\t\t\".mc1\": \"application/vnd.medcalcdata\",\n\t\t\t\".mcd\": \"application/vnd.mcd\",\n\t\t\t\".mcurl\": \"text/vnd.curl.mcurl\",\n\t\t\t\".mdb\": \"application/x-msaccess\",\n\t\t\t\".mdi\": \"image/vnd.ms-modi\",\n\t\t\t\".me\": \"text/troff\",\n\t\t\t\".mesh\": \"model/mesh\",\n\t\t\t\".mfm\": \"application/vnd.mfmp\",\n\t\t\t\".mgz\": \"application/vnd.proteus.magazine\",\n\t\t\t\".mht\": \"message/rfc822\",\n\t\t\t\".mhtml\": \"message/rfc822\",\n\t\t\t\".mid\": \"audio/midi\",\n\t\t\t\".midi\": \"audio/midi\",\n\t\t\t\".mif\": \"application/vnd.mif\",\n\t\t\t\".mime\": \"message/rfc822\",\n\t\t\t\".mj2\": \"video/mj2\",\n\t\t\t\".mjp2\": \"video/mj2\",\n\t\t\t\".mlp\": \"application/vnd.dolby.mlp\",\n\t\t\t\".mmd\": \"application/vnd.chipnuts.karaoke-mmd\",\n\t\t\t\".mmf\": \"application/vnd.smaf\",\n\t\t\t\".mmr\": \"image/vnd.fujixerox.edmics-mmr\",\n\t\t\t\".mny\": \"application/x-msmoney\",\n\t\t\t\".mobi\": \"application/x-mobipocket-ebook\",\n\t\t\t\".mov\": \"video/quicktime\",\n\t\t\t\".movie\": \"video/x-sgi-movie\",\n\t\t\t\".mp2\": \"audio/mpeg\",\n\t\t\t\".mp2a\": \"audio/mpeg\",\n\t\t\t\".mp3\": \"audio/mpeg\",\n\t\t\t\".mp4\": \"video/mp4\",\n\t\t\t\".mp4a\": \"audio/mp4\",\n\t\t\t\".mp4s\": \"application/mp4\",\n\t\t\t\".mp4v\": \"video/mp4\",\n\t\t\t\".mpa\": \"video/mpeg\",\n\t\t\t\".mpc\": \"application/vnd.mophun.certificate\",\n\t\t\t\".mpe\": \"video/mpeg\",\n\t\t\t\".mpeg\": \"video/mpeg\",\n\t\t\t\".mpg\": \"video/mpeg\",\n\t\t\t\".mpg4\": \"video/mp4\",\n\t\t\t\".mpga\": \"audio/mpeg\",\n\t\t\t\".mpkg\": \"application/vnd.apple.installer+xml\",\n\t\t\t\".mpm\": \"application/vnd.blueice.multipass\",\n\t\t\t\".mpn\": \"application/vnd.mophun.application\",\n\t\t\t\".mpp\": \"application/vnd.ms-project\",\n\t\t\t\".mpt\": \"application/vnd.ms-project\",\n\t\t\t\".mpy\": \"application/vnd.ibm.minipay\",\n\t\t\t\".mqy\": \"application/vnd.mobius.mqy\",\n\t\t\t\".mrc\": \"application/marc\",\n\t\t\t\".ms\": \"text/troff\",\n\t\t\t\".mscml\": \"application/mediaservercontrol+xml\",\n\t\t\t\".mseed\": \"application/vnd.fdsn.mseed\",\n\t\t\t\".mseq\": \"application/vnd.mseq\",\n\t\t\t\".msf\": \"application/vnd.epson.msf\",\n\t\t\t\".msh\": \"model/mesh\",\n\t\t\t\".msi\": \"application/x-msdownload\",\n\t\t\t\".msl\": \"application/vnd.mobius.msl\",\n\t\t\t\".msty\": \"application/vnd.muvee.style\",\n\t\t\t\".mts\": \"model/vnd.mts\",\n\t\t\t\".mus\": \"application/vnd.musician\",\n\t\t\t\".musicxml\": \"application/vnd.recordare.musicxml+xml\",\n\t\t\t\".mvb\": \"application/x-msmediaview\",\n\t\t\t\".mwf\": \"application/vnd.mfer\",\n\t\t\t\".mxf\": \"application/mxf\",\n\t\t\t\".mxl\": \"application/vnd.recordare.musicxml\",\n\t\t\t\".mxml\": \"application/xv+xml\",\n\t\t\t\".mxs\": \"application/vnd.triscape.mxs\",\n\t\t\t\".mxu\": \"video/vnd.mpegurl\",\n\t\t\t\".n-gage\": \"application/vnd.nokia.n-gage.symbian.install\",\n\t\t\t\".nb\": \"application/mathematica\",\n\t\t\t\".nc\": \"application/x-netcdf\",\n\t\t\t\".ncx\": \"application/x-dtbncx+xml\",\n\t\t\t\".ngdat\": \"application/vnd.nokia.n-gage.data\",\n\t\t\t\".nlu\": \"application/vnd.neurolanguage.nlu\",\n\t\t\t\".nml\": \"application/vnd.enliven\",\n\t\t\t\".nnd\": \"application/vnd.noblenet-directory\",\n\t\t\t\".nns\": \"application/vnd.noblenet-sealer\",\n\t\t\t\".nnw\": \"application/vnd.noblenet-web\",\n\t\t\t\".npx\": \"image/vnd.net-fpx\",\n\t\t\t\".nsf\": \"application/vnd.lotus-notes\",\n\t\t\t\".nws\": \"message/rfc822\",\n\t\t\t\".o\": \"application/octet-stream\",\n\t\t\t\".oa2\": \"application/vnd.fujitsu.oasys2\",\n\t\t\t\".oa3\": \"application/vnd.fujitsu.oasys3\",\n\t\t\t\".oas\": \"application/vnd.fujitsu.oasys\",\n\t\t\t\".obd\": \"application/x-msbinder\",\n\t\t\t\".obj\": \"application/octet-stream\",\n\t\t\t\".oda\": \"application/oda\",\n\t\t\t\".odb\": \"application/vnd.oasis.opendocument.database\",\n\t\t\t\".odc\": \"application/vnd.oasis.opendocument.chart\",\n\t\t\t\".odf\": \"application/vnd.oasis.opendocument.formula\",\n\t\t\t\".odft\": \"application/vnd.oasis.opendocument.formula-template\",\n\t\t\t\".odg\": \"application/vnd.oasis.opendocument.graphics\",\n\t\t\t\".odi\": \"application/vnd.oasis.opendocument.image\",\n\t\t\t\".odp\": \"application/vnd.oasis.opendocument.presentation\",\n\t\t\t\".ods\": \"application/vnd.oasis.opendocument.spreadsheet\",\n\t\t\t\".odt\": \"application/vnd.oasis.opendocument.text\",\n\t\t\t\".oga\": \"audio/ogg\",\n\t\t\t\".ogg\": \"audio/ogg\",\n\t\t\t\".ogv\": \"video/ogg\",\n\t\t\t\".ogx\": \"application/ogg\",\n\t\t\t\".onepkg\": \"application/onenote\",\n\t\t\t\".onetmp\": \"application/onenote\",\n\t\t\t\".onetoc\": \"application/onenote\",\n\t\t\t\".onetoc2\": \"application/onenote\",\n\t\t\t\".opf\": \"application/oebps-package+xml\",\n\t\t\t\".oprc\": \"application/vnd.palm\",\n\t\t\t\".org\": \"application/vnd.lotus-organizer\",\n\t\t\t\".osf\": \"application/vnd.yamaha.openscoreformat\",\n\t\t\t\".osfpvg\": \"application/vnd.yamaha.openscoreformat.osfpvg+xml\",\n\t\t\t\".otc\": \"application/vnd.oasis.opendocument.chart-template\",\n\t\t\t\".otf\": \"application/x-font-otf\",\n\t\t\t\".otg\": \"application/vnd.oasis.opendocument.graphics-template\",\n\t\t\t\".oth\": \"application/vnd.oasis.opendocument.text-web\",\n\t\t\t\".oti\": \"application/vnd.oasis.opendocument.image-template\",\n\t\t\t\".otm\": \"application/vnd.oasis.opendocument.text-master\",\n\t\t\t\".otp\": \"application/vnd.oasis.opendocument.presentation-template\",\n\t\t\t\".ots\": \"application/vnd.oasis.opendocument.spreadsheet-template\",\n\t\t\t\".ott\": \"application/vnd.oasis.opendocument.text-template\",\n\t\t\t\".oxt\": \"application/vnd.openofficeorg.extension\",\n\t\t\t\".p\": \"text/x-pascal\",\n\t\t\t\".p10\": \"application/pkcs10\",\n\t\t\t\".p12\": \"application/x-pkcs12\",\n\t\t\t\".p7b\": \"application/x-pkcs7-certificates\",\n\t\t\t\".p7c\": \"application/pkcs7-mime\",\n\t\t\t\".p7m\": \"application/pkcs7-mime\",\n\t\t\t\".p7r\": \"application/x-pkcs7-certreqresp\",\n\t\t\t\".p7s\": \"application/pkcs7-signature\",\n\t\t\t\".pas\": \"text/x-pascal\",\n\t\t\t\".pbd\": \"application/vnd.powerbuilder6\",\n\t\t\t\".pbm\": \"image/x-portable-bitmap\",\n\t\t\t\".pcf\": \"application/x-font-pcf\",\n\t\t\t\".pcl\": \"application/vnd.hp-pcl\",\n\t\t\t\".pclxl\": \"application/vnd.hp-pclxl\",\n\t\t\t\".pct\": \"image/x-pict\",\n\t\t\t\".pcurl\": \"application/vnd.curl.pcurl\",\n\t\t\t\".pcx\": \"image/x-pcx\",\n\t\t\t\".pdb\": \"application/vnd.palm\",\n\t\t\t\".pdf\": \"application/pdf\",\n\t\t\t\".pfa\": \"application/x-font-type1\",\n\t\t\t\".pfb\": \"application/x-font-type1\",\n\t\t\t\".pfm\": \"application/x-font-type1\",\n\t\t\t\".pfr\": \"application/font-tdpfr\",\n\t\t\t\".pfx\": \"application/x-pkcs12\",\n\t\t\t\".pgm\": \"image/x-portable-graymap\",\n\t\t\t\".pgn\": \"application/x-chess-pgn\",\n\t\t\t\".pgp\": \"application/pgp-encrypted\",\n\t\t\t\".pic\": \"image/x-pict\",\n\t\t\t\".pkg\": \"application/octet-stream\",\n\t\t\t\".pki\": \"application/pkixcmp\",\n\t\t\t\".pkipath\": \"application/pkix-pkipath\",\n\t\t\t\".pl\": \"text/plain\",\n\t\t\t\".plb\": \"application/vnd.3gpp.pic-bw-large\",\n\t\t\t\".plc\": \"application/vnd.mobius.plc\",\n\t\t\t\".plf\": \"application/vnd.pocketlearn\",\n\t\t\t\".pls\": \"application/pls+xml\",\n\t\t\t\".pml\": \"application/vnd.ctc-posml\",\n\t\t\t\".png\": \"image/png\",\n\t\t\t\".pnm\": \"image/x-portable-anymap\",\n\t\t\t\".portpkg\": \"application/vnd.macports.portpkg\",\n\t\t\t\".pot\": \"application/vnd.ms-powerpoint\",\n\t\t\t\".potm\": \"application/vnd.ms-powerpoint.template.macroenabled.12\",\n\t\t\t\".potx\": \"application/vnd.openxmlformats-officedocument.presentationml.template\",\n\t\t\t\".ppa\": \"application/vnd.ms-powerpoint\",\n\t\t\t\".ppam\": \"application/vnd.ms-powerpoint.addin.macroenabled.12\",\n\t\t\t\".ppd\": \"application/vnd.cups-ppd\",\n\t\t\t\".ppm\": \"image/x-portable-pixmap\",\n\t\t\t\".pps\": \"application/vnd.ms-powerpoint\",\n\t\t\t\".ppsm\": \"application/vnd.ms-powerpoint.slideshow.macroenabled.12\",\n\t\t\t\".ppsx\": \"application/vnd.openxmlformats-officedocument.presentationml.slideshow\",\n\t\t\t\".ppt\": \"application/vnd.ms-powerpoint\",\n\t\t\t\".pptm\": \"application/vnd.ms-powerpoint.presentation.macroenabled.12\",\n\t\t\t\".pptx\": \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n\t\t\t\".pqa\": \"application/vnd.palm\",\n\t\t\t\".prc\": \"application/x-mobipocket-ebook\",\n\t\t\t\".pre\": \"application/vnd.lotus-freelance\",\n\t\t\t\".prf\": \"application/pics-rules\",\n\t\t\t\".ps\": \"application/postscript\",\n\t\t\t\".psb\": \"application/vnd.3gpp.pic-bw-small\",\n\t\t\t\".psd\": \"image/vnd.adobe.photoshop\",\n\t\t\t\".psf\": \"application/x-font-linux-psf\",\n\t\t\t\".ptid\": \"application/vnd.pvi.ptid1\",\n\t\t\t\".pub\": \"application/x-mspublisher\",\n\t\t\t\".pvb\": \"application/vnd.3gpp.pic-bw-var\",\n\t\t\t\".pwn\": \"application/vnd.3m.post-it-notes\",\n\t\t\t\".pwz\": \"application/vnd.ms-powerpoint\",\n\t\t\t\".py\": \"text/x-python\",\n\t\t\t\".pya\": \"audio/vnd.ms-playready.media.pya\",\n\t\t\t\".pyc\": \"application/x-python-code\",\n\t\t\t\".pyo\": \"application/x-python-code\",\n\t\t\t\".pyv\": \"video/vnd.ms-playready.media.pyv\",\n\t\t\t\".qam\": \"application/vnd.epson.quickanime\",\n\t\t\t\".qbo\": \"application/vnd.intu.qbo\",\n\t\t\t\".qfx\": \"application/vnd.intu.qfx\",\n\t\t\t\".qps\": \"application/vnd.publishare-delta-tree\",\n\t\t\t\".qt\": \"video/quicktime\",\n\t\t\t\".qwd\": \"application/vnd.quark.quarkxpress\",\n\t\t\t\".qwt\": \"application/vnd.quark.quarkxpress\",\n\t\t\t\".qxb\": \"application/vnd.quark.quarkxpress\",\n\t\t\t\".qxd\": \"application/vnd.quark.quarkxpress\",\n\t\t\t\".qxl\": \"application/vnd.quark.quarkxpress\",\n\t\t\t\".qxt\": \"application/vnd.quark.quarkxpress\",\n\t\t\t\".ra\": \"audio/x-pn-realaudio\",\n\t\t\t\".ram\": \"audio/x-pn-realaudio\",\n\t\t\t\".rar\": \"application/x-rar-compressed\",\n\t\t\t\".ras\": \"image/x-cmu-raster\",\n\t\t\t\".rcprofile\": \"application/vnd.ipunplugged.rcprofile\",\n\t\t\t\".rdf\": \"application/rdf+xml\",\n\t\t\t\".rdz\": \"application/vnd.data-vision.rdz\",\n\t\t\t\".rep\": \"application/vnd.businessobjects\",\n\t\t\t\".res\": \"application/x-dtbresource+xml\",\n\t\t\t\".rgb\": \"image/x-rgb\",\n\t\t\t\".rif\": \"application/reginfo+xml\",\n\t\t\t\".rl\": \"application/resource-lists+xml\",\n\t\t\t\".rlc\": \"image/vnd.fujixerox.edmics-rlc\",\n\t\t\t\".rld\": \"application/resource-lists-diff+xml\",\n\t\t\t\".rm\": \"application/vnd.rn-realmedia\",\n\t\t\t\".rmi\": \"audio/midi\",\n\t\t\t\".rmp\": \"audio/x-pn-realaudio-plugin\",\n\t\t\t\".rms\": \"application/vnd.jcp.javame.midlet-rms\",\n\t\t\t\".rnc\": \"application/relax-ng-compact-syntax\",\n\t\t\t\".roff\": \"text/troff\",\n\t\t\t\".rpm\": \"application/x-rpm\",\n\t\t\t\".rpss\": \"application/vnd.nokia.radio-presets\",\n\t\t\t\".rpst\": \"application/vnd.nokia.radio-preset\",\n\t\t\t\".rq\": \"application/sparql-query\",\n\t\t\t\".rs\": \"application/rls-services+xml\",\n\t\t\t\".rsd\": \"application/rsd+xml\",\n\t\t\t\".rss\": \"application/rss+xml\",\n\t\t\t\".rtf\": \"application/rtf\",\n\t\t\t\".rtx\": \"text/richtext\",\n\t\t\t\".s\": \"text/x-asm\",\n\t\t\t\".saf\": \"application/vnd.yamaha.smaf-audio\",\n\t\t\t\".sbml\": \"application/sbml+xml\",\n\t\t\t\".sc\": \"application/vnd.ibm.secure-container\",\n\t\t\t\".scd\": \"application/x-msschedule\",\n\t\t\t\".scm\": \"application/vnd.lotus-screencam\",\n\t\t\t\".scq\": \"application/scvp-cv-request\",\n\t\t\t\".scs\": \"application/scvp-cv-response\",\n\t\t\t\".scurl\": \"text/vnd.curl.scurl\",\n\t\t\t\".sda\": \"application/vnd.stardivision.draw\",\n\t\t\t\".sdc\": \"application/vnd.stardivision.calc\",\n\t\t\t\".sdd\": \"application/vnd.stardivision.impress\",\n\t\t\t\".sdkd\": \"application/vnd.solent.sdkm+xml\",\n\t\t\t\".sdkm\": \"application/vnd.solent.sdkm+xml\",\n\t\t\t\".sdp\": \"application/sdp\",\n\t\t\t\".sdw\": \"application/vnd.stardivision.writer\",\n\t\t\t\".see\": \"application/vnd.seemail\",\n\t\t\t\".seed\": \"application/vnd.fdsn.seed\",\n\t\t\t\".sema\": \"application/vnd.sema\",\n\t\t\t\".semd\": \"application/vnd.semd\",\n\t\t\t\".semf\": \"application/vnd.semf\",\n\t\t\t\".ser\": \"application/java-serialized-object\",\n\t\t\t\".setpay\": \"application/set-payment-initiation\",\n\t\t\t\".setreg\": \"application/set-registration-initiation\",\n\t\t\t\".sfd-hdstx\": \"application/vnd.hydrostatix.sof-data\",\n\t\t\t\".sfs\": \"application/vnd.spotfire.sfs\",\n\t\t\t\".sgl\": \"application/vnd.stardivision.writer-global\",\n\t\t\t\".sgm\": \"text/sgml\",\n\t\t\t\".sgml\": \"text/sgml\",\n\t\t\t\".sh\": \"application/x-sh\",\n\t\t\t\".shar\": \"application/x-shar\",\n\t\t\t\".shf\": \"application/shf+xml\",\n\t\t\t\".si\": \"text/vnd.wap.si\",\n\t\t\t\".sic\": \"application/vnd.wap.sic\",\n\t\t\t\".sig\": \"application/pgp-signature\",\n\t\t\t\".silo\": \"model/mesh\",\n\t\t\t\".sis\": \"application/vnd.symbian.install\",\n\t\t\t\".sisx\": \"application/vnd.symbian.install\",\n\t\t\t\".sit\": \"application/x-stuffit\",\n\t\t\t\".sitx\": \"application/x-stuffitx\",\n\t\t\t\".skd\": \"application/vnd.koan\",\n\t\t\t\".skm\": \"application/vnd.koan\",\n\t\t\t\".skp\": \"application/vnd.koan\",\n\t\t\t\".skt\": \"application/vnd.koan\",\n\t\t\t\".sl\": \"text/vnd.wap.sl\",\n\t\t\t\".slc\": \"application/vnd.wap.slc\",\n\t\t\t\".sldm\": \"application/vnd.ms-powerpoint.slide.macroenabled.12\",\n\t\t\t\".sldx\": \"application/vnd.openxmlformats-officedocument.presentationml.slide\",\n\t\t\t\".slt\": \"application/vnd.epson.salt\",\n\t\t\t\".smf\": \"application/vnd.stardivision.math\",\n\t\t\t\".smi\": \"application/smil+xml\",\n\t\t\t\".smil\": \"application/smil+xml\",\n\t\t\t\".snd\": \"audio/basic\",\n\t\t\t\".snf\": \"application/x-font-snf\",\n\t\t\t\".so\": \"application/octet-stream\",\n\t\t\t\".spc\": \"application/x-pkcs7-certificates\",\n\t\t\t\".spf\": \"application/vnd.yamaha.smaf-phrase\",\n\t\t\t\".spl\": \"application/x-futuresplash\",\n\t\t\t\".spot\": \"text/vnd.in3d.spot\",\n\t\t\t\".spp\": \"application/scvp-vp-response\",\n\t\t\t\".spq\": \"application/scvp-vp-request\",\n\t\t\t\".spx\": \"audio/ogg\",\n\t\t\t\".src\": \"application/x-wais-source\",\n\t\t\t\".srx\": \"application/sparql-results+xml\",\n\t\t\t\".sse\": \"application/vnd.kodak-descriptor\",\n\t\t\t\".ssf\": \"application/vnd.epson.ssf\",\n\t\t\t\".ssml\": \"application/ssml+xml\",\n\t\t\t\".stc\": \"application/vnd.sun.xml.calc.template\",\n\t\t\t\".std\": \"application/vnd.sun.xml.draw.template\",\n\t\t\t\".stf\": \"application/vnd.wt.stf\",\n\t\t\t\".sti\": \"application/vnd.sun.xml.impress.template\",\n\t\t\t\".stk\": \"application/hyperstudio\",\n\t\t\t\".stl\": \"application/vnd.ms-pki.stl\",\n\t\t\t\".str\": \"application/vnd.pg.format\",\n\t\t\t\".stw\": \"application/vnd.sun.xml.writer.template\",\n\t\t\t\".sus\": \"application/vnd.sus-calendar\",\n\t\t\t\".susp\": \"application/vnd.sus-calendar\",\n\t\t\t\".sv4cpio\": \"application/x-sv4cpio\",\n\t\t\t\".sv4crc\": \"application/x-sv4crc\",\n\t\t\t\".svd\": \"application/vnd.svd\",\n\t\t\t\".svg\": \"image/svg+xml\",\n\t\t\t\".svgz\": \"image/svg+xml\",\n\t\t\t\".swa\": \"application/x-director\",\n\t\t\t\".swf\": \"application/x-shockwave-flash\",\n\t\t\t\".swi\": \"application/vnd.arastra.swi\",\n\t\t\t\".sxc\": \"application/vnd.sun.xml.calc\",\n\t\t\t\".sxd\": \"application/vnd.sun.xml.draw\",\n\t\t\t\".sxg\": \"application/vnd.sun.xml.writer.global\",\n\t\t\t\".sxi\": \"application/vnd.sun.xml.impress\",\n\t\t\t\".sxm\": \"application/vnd.sun.xml.math\",\n\t\t\t\".sxw\": \"application/vnd.sun.xml.writer\",\n\t\t\t\".t\": \"text/troff\",\n\t\t\t\".tao\": \"application/vnd.tao.intent-module-archive\",\n\t\t\t\".tar\": \"application/x-tar\",\n\t\t\t\".tcap\": \"application/vnd.3gpp2.tcap\",\n\t\t\t\".tcl\": \"application/x-tcl\",\n\t\t\t\".teacher\": \"application/vnd.smart.teacher\",\n\t\t\t\".tex\": \"application/x-tex\",\n\t\t\t\".texi\": \"application/x-texinfo\",\n\t\t\t\".texinfo\": \"application/x-texinfo\",\n\t\t\t\".text\": \"text/plain\",\n\t\t\t\".tfm\": \"application/x-tex-tfm\",\n\t\t\t\".tgz\": \"application/x-gzip\",\n\t\t\t\".tif\": \"image/tiff\",\n\t\t\t\".tiff\": \"image/tiff\",\n\t\t\t\".tmo\": \"application/vnd.tmobile-livetv\",\n\t\t\t\".torrent\": \"application/x-bittorrent\",\n\t\t\t\".tpl\": \"application/vnd.groove-tool-template\",\n\t\t\t\".tpt\": \"application/vnd.trid.tpt\",\n\t\t\t\".tr\": \"text/troff\",\n\t\t\t\".tra\": \"application/vnd.trueapp\",\n\t\t\t\".trm\": \"application/x-msterminal\",\n\t\t\t\".tsv\": \"text/tab-separated-values\",\n\t\t\t\".ttc\": \"application/x-font-ttf\",\n\t\t\t\".ttf\": \"application/x-font-ttf\",\n\t\t\t\".twd\": \"application/vnd.simtech-mindmapper\",\n\t\t\t\".twds\": \"application/vnd.simtech-mindmapper\",\n\t\t\t\".txd\": \"application/vnd.genomatix.tuxedo\",\n\t\t\t\".txf\": \"application/vnd.mobius.txf\",\n\t\t\t\".txt\": \"text/plain\",\n\t\t\t\".u32\": \"application/x-authorware-bin\",\n\t\t\t\".udeb\": \"application/x-debian-package\",\n\t\t\t\".ufd\": \"application/vnd.ufdl\",\n\t\t\t\".ufdl\": \"application/vnd.ufdl\",\n\t\t\t\".umj\": \"application/vnd.umajin\",\n\t\t\t\".unityweb\": \"application/vnd.unity\",\n\t\t\t\".uoml\": \"application/vnd.uoml+xml\",\n\t\t\t\".uri\": \"text/uri-list\",\n\t\t\t\".uris\": \"text/uri-list\",\n\t\t\t\".urls\": \"text/uri-list\",\n\t\t\t\".ustar\": \"application/x-ustar\",\n\t\t\t\".utz\": \"application/vnd.uiq.theme\",\n\t\t\t\".uu\": \"text/x-uuencode\",\n\t\t\t\".vcd\": \"application/x-cdlink\",\n\t\t\t\".vcf\": \"text/x-vcard\",\n\t\t\t\".vcg\": \"application/vnd.groove-vcard\",\n\t\t\t\".vcs\": \"text/x-vcalendar\",\n\t\t\t\".vcx\": \"application/vnd.vcx\",\n\t\t\t\".vis\": \"application/vnd.visionary\",\n\t\t\t\".viv\": \"video/vnd.vivo\",\n\t\t\t\".vor\": \"application/vnd.stardivision.writer\",\n\t\t\t\".vox\": \"application/x-authorware-bin\",\n\t\t\t\".vrml\": \"model/vrml\",\n\t\t\t\".vsd\": \"application/vnd.visio\",\n\t\t\t\".vsf\": \"application/vnd.vsf\",\n\t\t\t\".vss\": \"application/vnd.visio\",\n\t\t\t\".vst\": \"application/vnd.visio\",\n\t\t\t\".vsw\": \"application/vnd.visio\",\n\t\t\t\".vtu\": \"model/vnd.vtu\",\n\t\t\t\".vxml\": \"application/voicexml+xml\",\n\t\t\t\".w3d\": \"application/x-director\",\n\t\t\t\".wad\": \"application/x-doom\",\n\t\t\t\".wav\": \"audio/x-wav\",\n\t\t\t\".wax\": \"audio/x-ms-wax\",\n\t\t\t\".wbmp\": \"image/vnd.wap.wbmp\",\n\t\t\t\".wbs\": \"application/vnd.criticaltools.wbs+xml\",\n\t\t\t\".wbxml\": \"application/vnd.wap.wbxml\",\n\t\t\t\".wcm\": \"application/vnd.ms-works\",\n\t\t\t\".wdb\": \"application/vnd.ms-works\",\n\t\t\t\".wiz\": \"application/msword\",\n\t\t\t\".wks\": \"application/vnd.ms-works\",\n\t\t\t\".wm\": \"video/x-ms-wm\",\n\t\t\t\".wma\": \"audio/x-ms-wma\",\n\t\t\t\".wmd\": \"application/x-ms-wmd\",\n\t\t\t\".wmf\": \"application/x-msmetafile\",\n\t\t\t\".wml\": \"text/vnd.wap.wml\",\n\t\t\t\".wmlc\": \"application/vnd.wap.wmlc\",\n\t\t\t\".wmls\": \"text/vnd.wap.wmlscript\",\n\t\t\t\".wmlsc\": \"application/vnd.wap.wmlscriptc\",\n\t\t\t\".wmv\": \"video/x-ms-wmv\",\n\t\t\t\".wmx\": \"video/x-ms-wmx\",\n\t\t\t\".wmz\": \"application/x-ms-wmz\",\n\t\t\t\".wpd\": \"application/vnd.wordperfect\",\n\t\t\t\".wpl\": \"application/vnd.ms-wpl\",\n\t\t\t\".wps\": \"application/vnd.ms-works\",\n\t\t\t\".wqd\": \"application/vnd.wqd\",\n\t\t\t\".wri\": \"application/x-mswrite\",\n\t\t\t\".wrl\": \"model/vrml\",\n\t\t\t\".wsdl\": \"application/wsdl+xml\",\n\t\t\t\".wspolicy\": \"application/wspolicy+xml\",\n\t\t\t\".wtb\": \"application/vnd.webturbo\",\n\t\t\t\".wvx\": \"video/x-ms-wvx\",\n\t\t\t\".x32\": \"application/x-authorware-bin\",\n\t\t\t\".x3d\": \"application/vnd.hzn-3d-crossword\",\n\t\t\t\".xap\": \"application/x-silverlight-app\",\n\t\t\t\".xar\": \"application/vnd.xara\",\n\t\t\t\".xbap\": \"application/x-ms-xbap\",\n\t\t\t\".xbd\": \"application/vnd.fujixerox.docuworks.binder\",\n\t\t\t\".xbm\": \"image/x-xbitmap\",\n\t\t\t\".xdm\": \"application/vnd.syncml.dm+xml\",\n\t\t\t\".xdp\": \"application/vnd.adobe.xdp+xml\",\n\t\t\t\".xdw\": \"application/vnd.fujixerox.docuworks\",\n\t\t\t\".xenc\": \"application/xenc+xml\",\n\t\t\t\".xer\": \"application/patch-ops-error+xml\",\n\t\t\t\".xfdf\": \"application/vnd.adobe.xfdf\",\n\t\t\t\".xfdl\": \"application/vnd.xfdl\",\n\t\t\t\".xht\": \"application/xhtml+xml\",\n\t\t\t\".xhtml\": \"application/xhtml+xml\",\n\t\t\t\".xhvml\": \"application/xv+xml\",\n\t\t\t\".xif\": \"image/vnd.xiff\",\n\t\t\t\".xla\": \"application/vnd.ms-excel\",\n\t\t\t\".xlam\": \"application/vnd.ms-excel.addin.macroenabled.12\",\n\t\t\t\".xlb\": \"application/vnd.ms-excel\",\n\t\t\t\".xlc\": \"application/vnd.ms-excel\",\n\t\t\t\".xlm\": \"application/vnd.ms-excel\",\n\t\t\t\".xls\": \"application/vnd.ms-excel\",\n\t\t\t\".xlsb\": \"application/vnd.ms-excel.sheet.binary.macroenabled.12\",\n\t\t\t\".xlsm\": \"application/vnd.ms-excel.sheet.macroenabled.12\",\n\t\t\t\".xlsx\": \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n\t\t\t\".xlt\": \"application/vnd.ms-excel\",\n\t\t\t\".xltm\": \"application/vnd.ms-excel.template.macroenabled.12\",\n\t\t\t\".xltx\": \"application/vnd.openxmlformats-officedocument.spreadsheetml.template\",\n\t\t\t\".xlw\": \"application/vnd.ms-excel\",\n\t\t\t\".xml\": \"application/xml\",\n\t\t\t\".xo\": \"application/vnd.olpc-sugar\",\n\t\t\t\".xop\": \"application/xop+xml\",\n\t\t\t\".xpdl\": \"application/xml\",\n\t\t\t\".xpi\": \"application/x-xpinstall\",\n\t\t\t\".xpm\": \"image/x-xpixmap\",\n\t\t\t\".xpr\": \"application/vnd.is-xpr\",\n\t\t\t\".xps\": \"application/vnd.ms-xpsdocument\",\n\t\t\t\".xpw\": \"application/vnd.intercon.formnet\",\n\t\t\t\".xpx\": \"application/vnd.intercon.formnet\",\n\t\t\t\".xsl\": \"application/xml\",\n\t\t\t\".xslt\": \"application/xslt+xml\",\n\t\t\t\".xsm\": \"application/vnd.syncml+xml\",\n\t\t\t\".xspf\": \"application/xspf+xml\",\n\t\t\t\".xul\": \"application/vnd.mozilla.xul+xml\",\n\t\t\t\".xvm\": \"application/xv+xml\",\n\t\t\t\".xvml\": \"application/xv+xml\",\n\t\t\t\".xwd\": \"image/x-xwindowdump\",\n\t\t\t\".xyz\": \"chemical/x-xyz\",\n\t\t\t\".zaz\": \"application/vnd.zzazz.deck+xml\",\n\t\t\t\".zip\": \"application/zip\",\n\t\t\t\".zir\": \"application/vnd.zul\",\n\t\t\t\".zirz\": \"application/vnd.zul\",\n\t\t\t\".zmm\": \"application/vnd.handheld-entertainment+xml\",\n\n\t\t\t\".woff2\": \"font/woff2\",\n\t\t\t\".woff\": \"font/woff\",\n\t\t}\n\t}\n}.initThisClass());\n",
  "LxKyT3LwBN2kZYWgwMZlFQdSArjgmM3X/iDRJzC++og=": "\"use strict\";\n\n/*\n\n    BMFileResources\n\n*/\n\n(class BMFileResources extends BMResourceGroup {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"rootPath\", \".\")\n        this.newSlot(\"hasSetupSubnodes\", false)\n    }\n\n    init () {\n        super.init()\n        this.setTitle(\"FileResources\")\n        this.setNoteIsSubnodeCount(true)\n        //this.registerForAppDidInit() // BMResourceGroup does this\n        //this.onFinishInit()\n        return this\n    }\n\n    appDidInit () {\n        //this.debugLog(\".appDidInit()\")\n        //this.setupSubnodes()\n        return this\n    }\n\n    /*\n    prepareForFirstAccess () {\n        debugger;\n        this.setupSubnodesIfNeeded()\n        return this\n    }\n    */\n    \n    setupSubnodesIfNeeded () {\n        if (!this.hasSetupSubnodes()) {\n            const rootFolder = BMResourceFolder.clone().setPath(this.rootPath())\n            this.addSubnode(rootFolder)\n\n            const entries = ResourceManager.shared().entries()\n            //const allPaths = ResourceManager.shared().resourceFilePaths()\n            entries.forEach(entry => {\n                const aPath = entry.path\n                const pathArray = aPath.split(\"/\")\n                while (pathArray.first() === \".\") {\n                    pathArray.shift()\n                }\n                const file = rootFolder.addRelativeResourcePathArray(pathArray)\n                file.setResourceHash(entry.hash)\n                file.setResourceSize(entry.size)\n                if (!file) {\n                    throw new Error(\"no file added\")\n                }\n            }) // will find path to last folder and insert resource\n            this.setHasSetupSubnodes(true)\n        }\n        return this\n    }\n\n    rootFolder () {\n        this.setupSubnodesIfNeeded()\n        //debugger\n        return this.subnodes().first()\n    }\n\n\n}.initThisClass());\n",
  "Oi00plsLdQfPDcS4k1uTw/M5oN8yJd5XtQoYCiXPiBQ=": "\"use strict\";\n\n/*\n\n    BMResourceFolder\n\n    An abstraction for an individual file folder.\n\n    BMFileResources will setup all BMResourceFolders.\n\n*/\n\n(class BMResourceFolder extends BaseNode {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"path\", null)\n    }\n\n    init () {\n        super.init()\n        this.setTitle(\"BMFileSystemFolder\")\n        this.setNoteIsSubnodeCount(true)\n        //this.registerForAppDidInit()\n        return this\n    }\n\n    name () {\n        return this.path().lastPathComponent()\n    }\n\n    title () {\n        return this.name()\n    }\n\n    setupSubnodes () {\n        return this\n    }\n\n    isParentOfPath (aPath) {\n        const checkPath = this.path() + \"/\"\n        return (checkPath.indexOf(aPath) === 0)\n    }\n\n    addRelativeResourcePath (aPath) {\n        return this.addRelativeResourcePathArray(aPath.split(\"/\"))\n    }\n\n    addRelativeResourcePathArray (pathArray) {\n        pathArray = pathArray.slice()\n\n        const fullPath = this.path() + \"/\" + pathArray.join(\"/\")\n        //console.log(\"'\" + this.path() + \"' addRelativeResourcePathArray(\", pathArray, \")\")\n\n        if (pathArray.length === 1) { // it's a file\n            const fileName = pathArray.first()\n            const oldFile = this.fileWithName(fileName)\n            if (oldFile) {\n                return oldFile\n            }\n\n            return this.addSubnodeForFileName(fileName) // we assume all paths are to files, not folders\n        } else {\n\n            // must be a folder\n            const subfolderName = pathArray.first()\n            const subfolder = this.addSubnodeForFolderNameCreateIfAbsent(subfolderName)\n            pathArray.shift()\n            const file = subfolder.addRelativeResourcePathArray(pathArray)\n            return file\n        }\n    }\n\n    // subfolders\n\n    hasSubfolderNamed (aName) {\n        const subfolder = this.subfolderWithName(subfolderName)\n        return subfolder !== null\n    }\n\n    addSubnodeForFolderNameCreateIfAbsent (subfolderName) {\n        const subfolder = this.subfolderWithName(subfolderName)\n        if (subfolder) {\n            return subfolder\n        }\n        return this.addSubnodeForFolderName(subfolderName)\n    }\n\n    addSubnodeForFolderName (aName) {\n        if (aName.length === 0) {\n            throw new Error(\"empty folder name\")\n        }\n        if (aName.indexOf(\"/\") !== -1) {\n            throw new Error(\"folder name contains /\")\n        }\n        //console.log(\"'\" + this.path() + \"' addSubnodeForFolderName '\" + aName + \"'\")\n        const fullPath = this.path() + \"/\" + aName\n        const subfolder = BMResourceFolder.clone().setPath(fullPath)\n        this.addSubnode(subfolder)\n        //this.show()\n        return subfolder\n    }\n\n    show () {\n        const subnodeNames = this.subnodes().map(sn => sn.name())\n        console.log(this.type() + \" '\" + this.path() + \"': \" +  JSON.stringify(subnodeNames))\n    }\n\n    folderClassName () {\n        return \"BMResourceFolder\"\n    }\n\n    subfolders () {\n        return this.subnodes().filter(node => node.type() === this.folderClassName())\n    }\n\n    folders () {\n        return this.subfolders()\n    }\n\n    subfolderWithName (aName) {\n        return this.subfolders().detect(subnode => subnode.name() === aName)\n    }\n\n    folderAt (aName) {\n        return this.subfolderWithName(aName)\n    }\n\n    // files\n\n    addSubnodeForFileName (fileName) {\n        const file = BMResourceFile.clone().setPath(this.path() + \"/\" + fileName)\n        this.addSubnode(file)\n        return file\n    }\n\n    fileClassName () {\n        return \"BMResourceFile\"\n    }\n\n    files () {\n        return this.subnodes().filter(node => node.type() === this.fileClassName())\n    }\n\n    fileWithName (aName) {\n        return this.subfolders().detect(subnode => subnode.name() === aName)\n    }\n\n    fileAt (aName) {\n        return this.fileWithName(aName)\n    }\n\n\n}.initThisClass());\n",
  "tbzFXp7mcmh8vF/GZ8SFzDiOMDgmnCAFAQb+qsmRpig=": "\"use strict\";\n\n/*\n\n    BMFileResources\n\n*/\n\n(class BMResourceFile extends BaseNode {\n\n    initPrototypeSlots () {\n        this.newSlot(\"path\", \".\") // path from _index.json entry\n        this.newSlot(\"resourceHash\", null) // hash from _index.json entry\n        this.newSlot(\"resourceSize\", null) // size from _index.json entry\n\n        this.newSlot(\"data\", null)\n        this.newSlot(\"encoding\", \"utf8\")\n        this.newSlot(\"request\", null) // this set back to null after request is successfully completed\n        this.newSlot(\"error\", null) \n        this.newSlot(\"promiseForLoad\", null) // holds promise used for reading from URL request or indexedDB\n\n        // notifications\n        this.newSlot(\"isLoading\", false)\n        this.newSlot(\"isLoaded\", false)\n        this.newSlot(\"loadState\", null) \n        this.newSlot(\"loadNote\", null) \n        this.newSlot(\"loadErrorNote\", null) \n        this.newSlot(\"usesBlobCache\", false)\n    }\n\n    init () {\n        super.init()\n        this.setTitle(\"File\")\n        this.setNoteIsSubnodeCount(true)\n\n        // notifications\n        this.setLoadNote(this.newNoteNamed(\"fileResouceLoaded\"))\n        this.setLoadErrorNote(this.newNoteNamed(\"resourceFileLoadError\"))\n        return this\n    }\n\n    name () {\n        return this.path().lastPathComponent()\n    }\n\n    title () {\n        return this.name()\n    }\n\n    setupSubnodes () {\n        //this.resourcePaths().forEach(path => this.addFontWithPath(path))\n        return this\n    }\n\n    /*\n    asObject () {\n        const sound = BMSoundResources.shared().resources().detect(r => r.path() == this.path())\n        return sound\n    }\n    */\n\n    // move this loading code to parent BMResource?\n\n    hasData () {\n        return this.data() !== null\n    }\n\n    promiseLoad () { \n        if (!this.promiseForLoad()) {\n            this.setPromiseForLoad(new Promise((resolve, reject) => {\n                if (!this.isLoading() && !this.hasData()) {\n                    this.setIsLoading(true)\n                    return this.promiseLoadNow().then(() => { \n                        this.setIsLoading(false) \n                    }).catch((error) => {\n                        this.setIsLoading(false)\n                        throw error\n                    })\n                }\n            }))\n        }\n\n        return this.promiseForLoad()\n    }\n\n    promiseLoadNow () {\n        return new Promise((resolve, reject) => {\n            if (this.hasData()) {\n                this.postLoad()\n                resolve()\n                return this\n            }\n\n            if (this.camData()) {\n                this.loadFromCamData()\n                resolve()\n            } else if (this.usesBlobCache() && this.hasCachedBlob()) {\n                return this.promiseLoadCachedBlob()\n            } else {\n                return this.promiseLoadFromUrl()\n            }\n        })\n    }\n\n    // --- load data from cam ---\n\n    camPath () {\n        return this.path().sansPrefix(\"./\")\n    }\n\n    camData () {\n        return ResourceManager.shared().camValueForPath(this.camPath())\n    }\n\n    loadFromCamData () {\n        this.setData(this.camData())\n        //console.log(\"loaded via cam for path: \", this.camPath())\n        this.postLoad()\n    }\n\n    // --- load data from cached blob ---\n\n    hasCachedBlob () {\n        const h = this.resourceHash()\n        //debugger;\n        const b = h && BMBlobs.shared().hasBlobWithValueHash(h)\n        console.log(\"has cache for \" + this.path() + \":\" + b)\n        return b\n    }\n\n    promiseLoadCachedBlob () {        \n        assert(this.hasCachedBlob())\n        const h = this.resourceHash()\n        const blob = BMBlobs.shared().blobWithValueHash(h)   \n        console.log(\"reading from blob cache... \" + h + \" \" + this.path())\n        return blob.promiseReadValue().then(() => this.onReadCachedBlob(blob), () => this.onErrorReadingCachedBlob(blob))\n    }\n\n    onReadCachedBlob (blob) {\n        console.log(\"success reading blob \" + blob.name() + \" for \" + this.path())\n        //debugger;\n        if (Type.isUndefined(blob.value())) {\n            console.log(\"found undefined reading blob \" + blob.name() + \" for \" + this.path())\n            this.loadFromUrl()\n        } else {\n            this.setData(blob.value())\n            this.postLoad()\n        }\n    }\n\n    onErrorReadingCachedBlob (blob) {\n        console.log(\"error reading blob \" + blob.name() + \" for \" + this.path())\n    }\n\n    // --- load data from url ---\n\n    loadRequestType () {\n        return \"arraybuffer\"\n        //return 'application/json'; // need to change for binary files?\n    }\n\n    promiseLoadFromUrl () {\n        //console.log(\"loading via url fetch for path: \", this.path())\n\n        return new Promise((resolve, reject) => {\n            const path = this.path()\n            const rq = new XMLHttpRequest();\n            rq.open('GET', path, true);\n            if (this.loadRequestType()) {\n                rq.responseType = this.loadRequestType();\n            }\n\n            rq.onload  = (event) => { \n                this.onUrlLoad(event); \n                resolve() \n            }\n\n            rq.onerror = (event) => { \n                this.onRequestError(event); \n                reject() \n            }\n\n            /*        \n            rq.onload      = (event) => { this.onRequestLoad(event) }\n            rq.onabort     = (event) => { this.onRequestAbort(event) }\n            rq.onloadend   = (event) => { this.onRequestLoadEnd(event) }\n            rq.onloadstart = (event) => { this.onRequestLoadStart(event) }\n            */\n\n            rq.onprogress  = (event) => { \n                this.onRequestProgress(event) \n            }\n\n            rq.ontimeout   = (event) => { \n                this.onRequestTimeout(event);\n                reject() \n            }\n\n            this.setRequest(rq)\n            rq.send();\n        })\n    }\n\n    onUrlLoad () {\n        //console.log(\"onUrlLoad \" + this.path())\n        const data = this.request().response\n        this.setData(data)\n        this.postLoad()\n        this.setIsLoading(false)\n        \n        const h = this.resourceHash()\n        if (h && this.usesBlobCache()) {\n            console.log(\"writing to blob cache... \" + h + \" \" + this.path())\n\n            const blob = BMBlobs.shared().createBlobWithNameAndValue(h, this.data())\n\n            /*\n            const buffer = this.data()\n            const str = new TextDecoder().decode(buffer);\n            console.log(\"path: '\" + this.path() + \"'\")\n            console.log(\"size: '\" + buffer.byteLength + \"'\")\n            console.log(\"hash: '\" + h + \"'\")\n            console.log(\"type: '\" + typeof(buffer) + \"'\")\n            console.log(\"slice: '\" + str.slice(0, 6) + \"'\")\n            debugger;\n            */\n\n            blob.setName(this.path())\n            blob.setValueHash(this.resourceHash())\n            blob.setValueSize(this.resourceSize())\n        }\n        return this\n    }\n\n    onRequestError (event) {\n        console.log(\"onRequestError \" + this.path())\n        this.setError(event.error)\n        this.postLoadError()\n        this.setIsLoading(false)\n        return this\n    }\n\n    postLoad () {\n        this.loadNote().post()\n        return this\n    }\n\n    postLoadError () {\n        this.loadErrorNote().post()\n        return this\n    }\n\n    /*\n    onRequestAbort (event) {\n        this.setLoadState(\"aborted\")\n    }\n\n    onRequestLoadEnd (event) {\n    }\n\n    onRequestLoadStart (event) {\n        this.setLoadState(\"started\")\n    }\n    */\n\n    onRequestProgress (event) {\n        if (event.lengthComputable) {\n            const p = Math.floor(100 * (event.loaded / event.total))/100\n            this.setLoadState(p + \"% of \" + event.total.byteSizeDescription())\n        } else {\n            this.setLoadState(\"loading (\" +  event.loaded.byteSizeDescription() + \" so far)\")\n        }\n    }\n\n    onRequestTimeout (event) {\n        this.setLoadState(\"timeout\")\n    }\n\n    /*\n    onRequestLoad (event) {\n        const request = event.currentTarget;\n        const downloadedBuffer = request.response;  // may be array buffer, blob, or string, depending on request type\n        this.setData(downloadedBuffer)\n        //this.didLoad()\n    }\n\n    onRequestError (event) {\n        console.log(this.type() + \" onLoadError \", error, \" \" + this.path())\n        this.setError(error)\n    }\n    \n    didLoad () {\n        this.setIsLoaded(true)\n        this.postNoteNamed(\"didLoad\")\n    }\n    */\n\n}.initThisClass());\n",
  "FqshHSj3tOYiI4+79WA0mcBzbC7QZvi7eGjX1VKBWuk=": "\"use strict\";\n\n/*\n\n    BMFontResources\n\n    BMResources.shared().fonts().newFontOptions()\n\n*/\n\n(class BMFontResources extends BMResourceGroup {\n    \n    static initClass () {\n        this.setIsSingleton(true)\n\t\treturn this\n    }\n    \n    initPrototypeSlots () {\n        //this.newSlot(\"extensions\", [\"ttf\", \"woff\", \"woff2\"])\n    }\n\n    init () {\n        super.init()\n        this.setTitle(\"Fonts\")\n        //this.setExtensions([\"ttf\", \"woff\", \"woff2\"])\n        return this\n    }\n\n    setup () {\n        // subclasses need to use this to set ResourceClasses\n        this.setResourceClasses([BMFont])\n    }\n\n    addResourceWithPath (aPath) {\n        const components = aPath.split(\"/\")\n\n        // verify path is in expected format \n        if (components.first() === \".\") {\n            components.removeFirst()\n        }\n\n        const resources = components.removeFirst()\n        assert(resources === \"resources\")\n\n        const fonts = components.removeFirst()\n        assert(fonts === \"fonts\")\n\n        const familyName = components.removeFirst()\n        const family = this.fontFamilyNamed(familyName) \n        family.addFontWithPath(aPath)\n\n        return this\n    }\n\n    // --- families ---\n\n    addFamily (aFontFamily) {\n        this.addSubnode(aFontFamily)\n        return this\n    }\n\n    families () {\n        return this.subnodes()\n    }\n\n    fontFamilyNamed (aName) {\n        let family = this.families().detect(family => family.name() === aName);\n\n        if (!family) {\n            family = BMFontFamily.clone().setName(aName)\n            this.addFamily(family)\n        }\n\n        return family\n    }\n\n    allFonts () {\n        const fonts = []\n        this.subnodes().forEach(fontFamily => {\n            fontFamily.subnodes().forEach(font => fonts.push(font))\n        })\n        return fonts\n    }\n\n    allFontNames () {\n        return this.allFonts().map(font => font.title())\n    }\n\n    newFontOptions () {\n        const options = BMOptionsNode.clone()\n        this.allFonts().forEach(font => {\n            const name = font.title()\n            const option = BMOptionNode.clone().setLabel(name).setValue(name)\n            options.addSubnode(option)\n        })\n        return options\n    }\n\n}.initThisClass());\n",
  "hb0XegN4i1x1qYOOT0yznQuUQUolvJdYFqNn5G1xggk=": "\"use strict\";\n\n/*\n\n    BMFontFamily\n\n\n*/\n\n(class BMFontFamily extends BaseNode {\n    \n    initPrototypeSlots () {\n        this.newSlot(\"name\", null)\n        this.newSlot(\"fonts\", null)\n    }\n\n    /*\n    init () {\n        super.init()\n    }\n    */\n\n    title () {\n        return this.name()\n    }\n\n    /*\n    subtitle () {\n        return \"font family\"\n    }\n    */\n\n    addFontWithPath (aPath) {\n        const font = BMFont.clone().setPath(aPath)\n        font.load()\n        this.addSubnode(font)\n        return this\n    }\n\n}.initThisClass());\n",
  "tVESpVidQ0pvoxpWgkahvPDbM9i6co9rDZ4dis55v6U=": "\"use strict\";\n\n/*\n\n    BMFont\n\n    Managed by BMFontResources.\n\n*/\n\n(class BMFont extends BMResource {\n    \n    static supportedExtensions () {\n        return [\"ttf\", \"woff\", \"woff2\"]\n    }\n\n    initPrototypeSlots () {\n        this.newSlot(\"name\", null)\n        this.newSlot(\"options\", null)\n        this.newSlot(\"fontFace\", null) // reference to browser FontFace object\n    }\n\n    initPrototype () {\n        this.setIsDebugging(false)\n    }\n\n    init () {\n        super.init()\n        this.setOptions({})  // example options { style: 'normal', weight: 700 }  \n    }\n\n    title () {\n        return this.name()\n    }\n\n    name () {\n        if (this._name) {\n            return this._name\n        }\n\n        return this.path().fileName()\n    }\n\n    // loading \n\n    didLoad () {\n        super.didLoad()\n        this.loadFontFromData()\n        if (this.isDebugging()) {\n            //this.debugLog(\".didLoad('\" + this.name() + \"') '\" + this.path() + \"'\")\n            //debugger;\n            //this.debugLog(\".didLoad('\" + this.name() + \"')\")\n        }\n        return this\n    }\n\n    loadFontFromData () {\n        const aFontFace = new FontFace(this.name(), this.data(), this.options()); \n        this.setFontFace(aFontFace)\n\n        aFontFace.load().then((loadedFace) => {\n            // can probably do this in the background, \n            // but it's nice to know when it's complete\n           // this.didLoad()\n            assert(loadedFace === aFontFace)\n            document.fonts.add(loadedFace)\n            //console.log(\"added font to document: \", this.name())\n        }).catch((error) => {\n            this.onLoadError(error)\n        });\n    }\n\n    onLoadError (error) {\n        if (this.isDebugging()) {\n            this.debugLog(\".onLoadError() \", error)\n        }\n        return this\n    }\n\n}.initThisClass());\n",
  "hOcBw3ahoxvkySyAtxp79ZPv9HYP/ih8NongTQxp80M=": "\"use strict\";\n\n/*\n    \n    BMFontTile\n    \n*/\n\n(class BMFontTile extends TitledTile {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n    \n    updateSubviews () {\n        super.updateSubviews()\n\t\n        const node = this.node()\n\n        if (node) {\n            const name = node.name()\n            this.titleView().setFontFamily(name)\n        }\n\n        return this\n    }\n\n    \n}.initThisClass());\n",
  "tuLwdnsXMCrxy+W07823dgOAsuV5KELBKoPclAB4Krw=": "\"use strict\";\n\n/*\n\n    BMSoundResources\n\n*/\n\n(class BMSoundResources extends BMResourceGroup {\n\n    init () {\n        super.init()\n        this.setTitle(\"Sounds\")\n    }\n\n    setup () {\n        // subclasses need to use this to set ResourceClasses\n        this.setResourceClasses([WASound])\n    }\n\n    addSound (aSound) {\n        this.addResource(aSound)\n        return this\n    }\n\n    sounds () {\n        return this.resources()\n    }\n\n}.initThisClass());\n",
  "i3tjcUjRPvmUf//rmuoYamudgFCVnR6sL5Ihw8GjNIA=": "\"use strict\";\n\n/*\n\n    WASound\n\n   WebAudioSound\n\n*/\n\n(class WASound extends BMResource {\n\n    static supportedExtensions () {\n        return [\"aac\", \"alac\", \"amr\", \"flac\", \"mp3\", \"mp4\", \"3gp\",  \"opus\", \"oga\", \"ogg\", \"ogv\", \"wav\"]\n    }\n\n    // ---\n\n    initPrototypeSlots () {\n        this.newSlot(\"request\", null)\n        //this.newSlot(\"path\", null)\n        this.newSlot(\"decodedBuffer\", null)\n        this.newSlot(\"source\", null)\n        this.newSlot(\"shouldPlayOnLoad\", false)\n        //this.newSlot(\"downloadError\", false)\n        //this.newSlot(\"decodeError\", false)\n\n        // source attributes\n        this.newSlot(\"loop\", false)\n        this.newSlot(\"playbackRate\", 1)\n        //this.newSlot(\"loopStart\", null)\n        //this.newSlot(\"loopEnd\", null)\n    }\n\n    init () {\n        super.init()\n    }\n\n    title () {\n        return this.name() \n    }\n\n    name () {\n        return this.path().lastPathComponent().sansExtension()\n    }\n\n    // --- attributes ---\n\n    duration () {\n        if (this.decodedBuffer()) {\n            return this.decodedBuffer().duration\n        }\n        return 0\n    }\n\n    length () { // sample count\n        if (this.decodedBuffer()) {\n            return this.decodedBuffer().length\n        }\n        return 0\n    }\n\n    numberOfChannels () { // sample count\n        if (this.decodedBuffer()) {\n            return this.decodedBuffer().numberOfChannels\n        }\n        return 0\n    }\n\n    // ---\n\n    audioCtx () {\n        return WAContext.shared().setupIfNeeded().audioContext()\n    }\n\n    /*\n    onLoad (event) {\n        const request = event.currentTarget;\n        const downloadedBuffer = request.response;  // array buffer\n        this.setData(downloadedBuffer)\n    }\n    */\n\n    didLoad () {\n        this.prepareToDecode()\n        return this\n    }\n\n    prepareToDecode () {\n        if (WAContext.shared().isSetup()) {\n            this.decodeBuffer(this.data())\n        } else {\n            Broadcaster.shared().addListenerForName(this, \"didSetupWAContext\")\n            //console.warn(this.typeId() + \" waiting for audio context to decode\")\n        }\n    }\n\n    didSetupWAContext () {\n        //console.warn(this.typeId() + \" \" + this.path() + \" got didSetupWAContext broadcast - can decode now\")\n        Broadcaster.shared().removeListenerForName(this, \"removeListenerForName\")\n        if (this.data()) {\n            this.decodeBuffer(this.data())\n            this.setData(null) // so we only decode once\n        }\n    }\n\n    decodeBuffer (aBuffer) {\n        assert(!Type.isNullOrUndefined(aBuffer))\n        this.audioCtx().decodeAudioData(aBuffer,\n            decodedBuffer => this.onDecode(decodedBuffer),\n            e => this.onDecodeError(e)\n        );\n        this.setLoadState(\"decoding\")\n    }\n\n    // --- decode ---\n\n    onDecode (decodedBuffer) {\n        assert(!Type.isNullOrUndefined(decodedBuffer))\n        this.setDecodedBuffer(decodedBuffer)\n        this.setLoadState(\"loaded\")\n        //console.log(this.type() + \" didDecode \" + this.path())\n        if (this.shouldPlayOnLoad()) {\n            this.play()\n        }\n        //this.didLoad()\n    }\n\n    onDecodeError (e) {\n        console.warn(this.type() + \" onDecodeError \", e.error, \" \" + this.path())\n        this.setError(e.error)\n    }\n\n    // --- audio source ---\n\n    newAudioSource () {\n        const ctx = this.audioCtx()\n        const source = ctx.createBufferSource();\n        source.buffer = this.decodedBuffer();\n        source.connect(ctx.destination);\n        this.syncToSource(source)\n        source.addEventListener(\"ended\", (event) => { this.onEnded(event) })\n        return source\n    }\n\n    onEnded (event) {\n\n    }\n\n    syncToSource (source) {\n        source.playbackRate.value = this.playbackRate();\n        source.loop = this.loop();\n        return this\n    }\n\n    // --- play ---\n\n    play () {\n        const source = this.newAudioSource()\n        source.start();\n        return this\n    }\n\n    pause () {\n        //source.stop()\n    }\n\n    prepareToAccess () {\n        super.prepareToAccess()\n        this.play() // not a good way to do this?\n    }\n\n}.initThisClass());\n",
  "oR2kFswlE4sIPT41n8rE+B4imNxhKUD5waR1MjjoRK4=": "\"use strict\";\n\n/*\n\n    WAContext\n\n   WebAudioContext\n\n*/\n\n(class WAContext extends BaseNode {\n\n    // in JS, do we need user input first to play audio?\n    \n    static initClass () {\n        Broadcaster.shared().addListenerForName(this, \"firstUserEvent\")\n        //this.watchOnceForNote(\"firstUserEvent\")\n        return this\n    }\n\n    static firstUserEvent (anEventListener) {\n        Broadcaster.shared().removeListenerForName(this, \"firstUserEvent\")\n        WAContext.shared().setupIfNeeded() // need user input to do this\n    }\n\n    initPrototypeSlots () {\n        this.newSlot(\"audioContext\", null)\n    }\n\n    init () {\n        super.init()\n    }\n\n    title () {\n        return \"WebAudio Context\"\n    }\n\n    subtitle () {\n        return null\n    }\n\n    isSetup () {\n        return !Type.isNull(this.audioContext())\n    }\n\n    setupIfNeeded () {\n        if (!this.isSetup()) {\n            //debugger;\n            this.setAudioContext(new window.AudioContext())\n            Broadcaster.shared().broadcastNameAndArgument(\"didSetupWAContext\", this)\n            //console.warn(\"can't get audio context until user gesture e.g. tap\")\n        }\n        return this\n    }\n    \n    /*\n    connectSource (webAudioSource) {\n        this.setupIfNeeded()\n        webAudioSource.connect(this.audioContext().destination);\n    }\n\n    disconnectSource (webAudioSource) {\n        \n    }\n    */\n\n    /*\n    prepareToAccess () {\n        super.prepareToAccess()\n    }\n    */\n\n}.initThisClass());\n\n",
  "swOu7Z4ENYtfDs6VJznjbjuvrzKiQ737X8EMWj1Gs6U=": "\"use strict\";\n\n/*\n\n    BMImage\n\n*/\n\n(class BMImage extends BMResource {\n    \n    static supportedExtensions () {\n        return [\"apng\", \"avif\", \"gif\", \"jpg\", \"jpeg\", \"jfif\", \"pjpeg\", \"pjp\", \"png\", \"webp\", /* these aren't well supported -> */ \"tif\", \"tiff\", \"ico\", \"cur\", \"bmp\"]\n    }\n\n    initPrototypeSlots () {\n        //this.newSlot(\"path\", \"\")\n        this.newSlot(\"dataURL\", \"\")\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    title () {\n        return this.path().fileName()\n    }\n\n    subtitle () {\n        return this.path().pathExtension()\n    }\n\n    /*\n    setPath (aPath) {\n        if (this._path !== aPath) {\n            this._path = aPath\n            this.loadDataURL()\n        }\n        return this\n    }\n    */\n\n    /*\n    loadIfNeeded () {\n        this.load()\n        return this\n    }\n    */\n\n    /*\n    load () {\n        if (this.isDebugging()) {\n            this.debugLog(\".loadDataURL() \" + this.path())\n        }\n\n        const request = new XMLHttpRequest();\n        request.open(\"get\", this.path());\n        request.responseType = \"blob\";\n        request.onload = () => { this.loadedRequest(request) };\n        request.send();\n        return this\n    }\n\n    loadedRequest (request) {\n        if (this.isDebugging()) {\n            this.debugLog(\".loadedRequest() \", request)\n        }\n\n        const fileReader = new FileReader();\n\n        fileReader.onload = () => {\n            const dataURL = fileReader.result\n            this.setDataURL(dataURL);\n\n            if (this.isDebugging()) {\n                this.debugLog(\" setDataURL() \", dataURL)\n            }\n\n        };\n\n        fileReader.readAsDataURL(request.response);\n        return this\n    }\n\n    didFetchDataUrl (dataURL) {\n        //<img [src]=\"sanitize('data:image/jpg;base64, ' \" + arrayBuffer.base64Encoded())\">\n\n        this.setDataURL(dataURL);\n        return this\n    }\n    */\n\n    didLoad () {\n        super.didLoad()\n        debugger;\n        this.setDataUrl(this.data())\n        return this\n    }\n\n    /*\n    // this code should be on UI side\n\n    canvasForImage () {\n        // now just to show that passing to a canvas doesn't hold the same results\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = myImage.naturalWidth;\n        canvas.height = myImage.naturalHeight;\n        canvas.getContext(\"2d\").drawImage(myImage, 0, 0);\n    }\n    */\n\n}.initThisClass());\n\n",
  "PAmxL6xmtxDSesV2vtVnc+6Q5T+ZR4Rhgfq6wEIGLcQ=": "\"use strict\";\n\n/*\n\n    BMURLImage\n\n*/\n\n(class BMURLImage extends BMResource {\n    \n    static supportedExtensions () {\n        return [\"apng\", \"avif\", \"gif\", \"jpg\", \"jpeg\", \"jfif\", \"pjpeg\", \"pjp\", \"png\", \"webp\", /* these aren't well supported -> */ \"tif\", \"tiff\", \"ico\", \"cur\", \"bmp\"]\n    }\n\n    initPrototypeSlots () {\n        //this.newSlot(\"path\", \"\")\n        this.newSlot(\"dataURL\", \"\")\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    title () {\n        return this.path().fileName()\n    }\n\n    subtitle () {\n        return this.path().pathExtension()\n    }\n\n    /*\n    setPath (aPath) {\n        if (this._path !== aPath) {\n            this._path = aPath\n            this.loadDataURL()\n        }\n        return this\n    }\n    */\n\n    load () {\n        this.loadDataURL()\n        return this\n    }\n\n    loadDataURL () {\n        if (this.isDebugging()) {\n            this.debugLog(\".loadDataURL() \" + this.path())\n        }\n\n        const request = new XMLHttpRequest();\n        request.open(\"get\", this.path());\n        request.responseType = \"blob\";\n        request.onload = () => { this.loadedRequest(request) };\n        request.send();\n        return this\n    }\n\n    loadedRequest (request) {\n\n        if (this.isDebugging()) {\n            this.debugLog(\".loadedRequest() \", request)\n        }\n\n        const fileReader = new FileReader();\n\n        fileReader.onload = () => {\n            const dataURL = fileReader.result\n            this.setDataURL(dataURL);\n\n            if (this.isDebugging()) {\n                this.debugLog(\" setDataURL() \", dataURL)\n            }\n\n        };\n\n        fileReader.readAsDataURL(request.response); \n        \n        return this\n    }\n\n    didFetchDataUrl (dataURL) {\n        this.setDataURL(dataURL);\n        \n        /*\n        // now just to show that passing to a canvas doesn't hold the same results\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = myImage.naturalWidth;\n        canvas.height = myImage.naturalHeight;\n        canvas.getContext(\"2d\").drawImage(myImage, 0, 0);\n        */\n\n        return this\n    }\n\n}.initThisClass());\n\n//console.log(\"BMURLImage: \", BMURLImage)",
  "bvzDspzPi9k3AVuSbPHivm7jubeO3o03C+TSgIZU0vE=": "\"use strict\";\n\n/*\n\n    BMImageResources\n\n*/\n\n(class BMImageResources extends BMResourceGroup {\n    \n\n    init () {\n        super.init()\n        this.setTitle(\"Images\")\n        this.setSubnodeClasses([BMURLImage])\n        return this\n    }\n\n    setup () {\n        // subclasses need to use this to set ResourceClasses\n        this.setResourceClasses([BMURLImage])\n    }\n\n}.initThisClass());\n",
  "6dlwjZhlEZnFeWWYcxkOHpfbQ4tMfUD/Zf/fml0ajeI=": "\"use strict\";\n\n/*\n    \n    BMImageTile\n    \n*/\n\n(class BMImageTile extends TitledTile {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n    \n    updateSubviews () {\n        super.updateSubviews()\n\t\n        const node = this.node()\n\n        if (node) {\n            const name = node.name()\n            this.titleView() //.setFontFamily(name)\n        }\n\n        return this\n    }\n\n    \n}.initThisClass());\n",
  "lpTqBNcE0SXEOy1apESHafFCaZvVR+GVRb1lDYS3cs4=": "\"use strict\";\n\n/*\n\n    BMThemeResources\n\n    hierarchy:\n\n        BMThemeResources -> Theme -> ThemeClass -> ThemeState -> ThemeAttribute\n\n    example:\n    \n        global           -> \"Dark\" -> \"Field\"   -> \"active\"   -> \"opacity\" : \"0.5\"\n\n    Example use by views:\n\n        BMThemeResources.shared().currentTheme().classNamed(\"x\").attributeNamed(\"y\").value()\n\n    We'd like to implement some form  of inheritance system.\n    Example:\n\n    The ThemeClass \"FieldValue\" has a \"unselected\" ThemeState, but no \"active\" ThemeState, \n    so we default to the \"unselected\" ThemeState.\n\n    Should ThemeClass implement a defaultSubnode() method for failed lookups?\n    Should it ask subnodes isDefault()? \n\n\n*/\n\n(class BMThemeResources extends BMStorableNode {\n    \n    static initClass () {\n        this.setIsSingleton(true)\n\t\treturn this\n    }\n\n    static initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        this.setTitle(\"Themes\")\n\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(true)\n\n        this.setNoteIsSubnodeCount(true)\n        this.addAction(\"add\")\n        this.setSubnodeClasses([BMTheme, BMDefaultTheme])\n        this.setNodeCanReorderSubnodes(true)\n\n        //this.setSubnodes([BMDefaultTheme.clone()]) // hack\n    }\n\n    activeTheme () {\n        return this.subnodes().first()\n    }\n\n    defaultThemeClass () {\n        return this.activeTheme().subnodes().first()\n    }\n    \n}.initThisClass());\n",
  "ked1D3kZ4Vy9y32Q6967IJUFBhcskaShjTVdsQHtga8=": "\"use strict\";\n\n/*\n\n    BMThemeFolder\n\n*/\n\n(class BMThemeFolder extends BMStorableNode {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(true) \n        \n        this.setNodeCanEditTitle(true)\n        this.setTitle(\"Untitled \" + this.thisClass().visibleClassName())\n        this.setCanDelete(true)\n        this.addAction(\"add\")\n        this.setSubnodeClasses([BMThemeFolder, BMThemeClass, BMStringField, BMNumberField])\n        this.setNodeCanReorderSubnodes(true)\n    }\n\n    styleMap () {\n        // this should be the same implementation of styleMap() as BMThemeClass\n        const map = new Map()\n        const title = this.title()\n        this.subnodes().forEach(sn => { \n            sn.styleMap().forEachKV((k, v) => {\n              map.set(title + \".\" + k, v)\n            })\n        })\n        return map\n    }\n\n}.initThisClass());\n",
  "pQVzsesXYd6cozXsO525o1j4NQy5DtS6+Iv1c4aHRRg=": "\"use strict\";\n\n/*\n\n    BMTheme\n\n*/\n\n(class BMTheme extends BMThemeFolder {\n  \n  initPrototypeSlots () {\n  }\n\n  init () {\n    super.init();\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n    this.setNodeCanEditTitle(true);\n    this.setTitle(\"Untitled \" + this.thisClass().visibleClassName());\n    this.setSubtitle(\"theme\")\n    //this.setSubtitle(\"Theme\")\n    this.setCanDelete(true);\n    this.addAction(\"add\");\n    //this.setSubnodeClasses([BMThemeLevel]);\n    this.setSubnodeClasses([BMThemeClass, BMThemeFolder, BMThemeLeveledFolder]);\n    this.setNodeCanReorderSubnodes(true);\n    //this.setupSubnodes()\n  }\n\n  setupAsDefault () {\n    this.setTitle(\"DefaultTheme\");\n    const defaultThemeClass = BMThemeClass.clone().setupAsDefault();\n    this.addSubnode(defaultThemeClass);\n    return this;\n  }\n\n  themeClassNamed (name) {\n    return this.firstSubnodeWithTitle(name)\n  }\n\n}.initThisClass());\n",
  "8wH5vaVKlsUx/8hSxPcwxwSpis6Afsa/gEgMMnVZkSw=": "\"use strict\";\n\n/*\n\n    BMDefaultTheme\n\n*/\n\n(class BMDefaultTheme extends BMTheme {\n    \n    /*\n    initPrototype () {\n        this.setShouldScheduleDidInit(true)\n    }\n    */\n\n    init () {\n        this.setShouldScheduleDidInit(true)\n        super.init()\n        return this\n    }\n\n    didInit () {\n        //debugger;\n        console.log(this.typeId() + \" didInit\")\n\n        super.didInit()\n        this.setupAsDefault() \n    }\n\n    setupAsDefault () {\n        if (this.subnodes().length === 0) {\n            this.setTitle(\"DefaultTheme\")\n            const defaultThemeClass = BMThemeClass.clone().setupAsDefault()\n            this.addSubnode(defaultThemeClass)\n        }\n        return this\n   }\n\n}.initThisClass());\n",
  "GXeEXAQdT82w44pSqw4ifi1q7eevkIPKF7SLiBNujyE=": "\"use strict\";\n\n/*\n\n    BMThemeClass\n\n*/\n\n(class BMThemeClass extends BMThemeFolder {\n  initPrototypeSlots () {\n      this.newSlot(\"standardStateNames\", [\n        \"disabled\",\n        \"unselected\", \n        \"selected\", \n        \"active\"\n      ]);\n  }\n\n  init () {\n    super.init();\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n\n    this.setNodeCanEditTitle(true);\n    this.setTitle(\"Untitled \" + this.thisClass().visibleClassName());\n    this.setSubtitle(\"class\")\n    this.setCanDelete(true);\n    this.addAction(\"add\");\n    this.setSubnodeClasses([BMThemeState, BMThemeFolder]);\n    this.setNodeCanReorderSubnodes(true);\n    this.removeAction(\"add\")\n  }\n\n  /*\n  setSubtitle (s) {\n    if (this.subtitle() && (s === \"\" || s === null)) {\n      debugger;\n    }\n    super.setSubtitle(s)\n    return this\n  }\n  */\n\n  didInit () {\n    super.didInit();\n    this.setSubtitle(\"class\")\n    //this.removeAction(\"add\")\n\n    //console.log(this.typeId() + \" subnodes: \", this.subnodes())\n    this.setupSubnodes();\n  }\n\n  subnodeNames () {\n    return this.standardStateNames();\n  }\n\n  setupSubnodes () {\n    const subnodeClass = this.subnodeClasses().first();\n    this.subnodeNames().forEach((name) => {\n      const subnode = this.subnodeWithTitleIfAbsentInsertProto(\n        name,\n        subnodeClass\n      );\n    });\n  }\n\n  // --- states ---\n\n  activeThemeState () {\n    return this.firstSubnodeWithTitle(\"active\");\n  }\n\n  unselectedThemeState () {\n    return this.firstSubnodeWithTitle(\"unselected\");\n  }\n\n  selectedThemeState () {\n    return this.firstSubnodeWithTitle(\"selected\");\n  }\n\n  disabledThemeState () {\n    return this.firstSubnodeWithTitle(\"disabled\");\n  }\n\n  // --- default ---\n\n  setupAsDefault() {\n    this.setTitle(\"DefaultThemeClass\");\n    this.setupSubnodes();\n    this.subnodes().forEach((sn) => sn.didInit());\n\n    this.setupActiveDefault();\n    this.setupUnselectedDefault();\n    this.setupSelectedDefault();\n    this.setupDisabledDefault();\n\n    //this.setupColumnsDefault()\n    return this;\n  }\n\n  // --- default states ---\n\n  setupActiveDefault () {\n    const state = this.activeThemeState();\n    //state.setColor(\"white\")\n    //state.setBackgroundColor(\"#333\")\n    state.setThemeAttribute(\"color\", \"white\");\n    state.setThemeAttribute(\"backgroundColor\", \"#333\");\n    //state.setThemeAttribute(\"fontWeight\", \"normal\");\n  }\n\n  setupUnselectedDefault () {\n    const state = this.unselectedThemeState();\n    state.setThemeAttribute(\"color\", \"#bbb\");\n    state.setThemeAttribute(\"backgroundColor\", \"transparent\");\n    //state.setThemeAttribute(\"fontWeight\", \"normal\");\n  }\n\n  setupSelectedDefault () {\n    const state = this.selectedThemeState();\n    state.setThemeAttribute(\"color\", \"white\");\n    state.setThemeAttribute(\"backgroundColor\", \"#222\");\n    //state.setThemeAttribute(\"fontWeight\", \"normal\");\n    state.setThemeAttribute(\"opacity\", \"1\");\n  }\n\n  setupDisabledDefault () {\n    const state = this.disabledThemeState();\n    state.setThemeAttribute(\"color\", \"#ccc\");\n    state.setThemeAttribute(\"backgroundColor\", \"transparent\");\n    //state.setThemeAttribute(\"fontWeight\", \"normal\");\n    state.setThemeAttribute(\"opacity\", \"0.5\");\n  }\n\n  setupColumnsDefault () {\n    const columns = BMThemeFolder.clone().setTitle(\"columns\");\n    this.addSubnode(columns);\n\n    const colors = [\n      [60, 60, 60],\n      [48, 48, 48],\n      [32, 32, 32],\n      [26, 26, 26],\n      [16, 16, 16],\n    ];\n\n    colors.forEach((c) => {\n      const cssColorString = \"rgb(\" + c.join(\",\") + \")\";\n      const field = BMStringField.clone()\n        .setKey(\"backgroundColor\")\n        .setValue(cssColorString);\n      columns.addSubnode(field);\n    });\n  }\n\n  // -- heplers ---\n\n  themeAttributeNamed(name) {\n    return this.firstSubnodeWithTitle(name);\n  }\n\n  themeSubclassNamed(name) {\n    return this.firstSubnodeWithTitle(name);\n  }\n\n}.initThisClass());\n",
  "tyNZ2VdCXWL0tt6TooDjuG2mlEexcqIr4KXAA7SemR0=": "\"use strict\";\n\n/*\n\n    BMThemeState\n\n    Replaces BMStyle\n\n*/\n\n(class BMThemeState extends BMThemeFolder {\n    \n    static styleNames () {\n        return [\n            \"color\", // start with [\"#000\", \"#111\", \"#222\", \"#333\", \"#444\", .. to #fff by X\n            \"backgroundColor\", \n            \"opacity\", // 0 to 1 by 0.1\n\n            \"fontFamily\",\n            //\"font-variant\", // normal, small-caps\n            //\"fontStyle\", // normal, italic, oblique\n            \"fontWeight\", // normal, bold, lighter, bolder, 100-900 by 100\n            \"fontSize\", // 3px to 50px by 1px\n\n            \"lineHeight\", // 0.8em to 3em by 0.1em\n            \"letterSpacing\" // 0.1 em to 2em by 0.1em\n\n            /*\n            \"paddingLeft\", // 0px to 100px by 1px\n            \"paddingRight\", \n            \"paddingTop\", \n            \"paddingBottom\",\n\n            // for border we need to support \n            // left, right, top, bottom\n            // border-style\n            // border-width\n            // border-radius\n            \"borderLeft\", // 0px to 100px by 1px \n            \"borderRight\", \n            \"borderTop\", \n            \"borderBottom\",\n            \"borderRadius\"\n            */\n        ];\n    }\n\n    static validLetterSpacingValues () {\n        const values = []\n        for (let i = 0; i < 0.51; i += 0.01) {\n            const s = (i + \"\").slice(0, 4)\n            values.push(s + \"em\")\n        }\n        return values\n    }\n\n    static validLineHeightValues () {\n        const values = []\n        for (let i = 1; i < 3; i += 0.1) {\n            const s = (i + \"\").slice(0, 3)\n            values.push(s + \"em\")\n        }\n        return values\n    }\n\n    static validColors () {\n        return [\"#000\", \"#111\", \"rgb(25, 25, 25)\", \"#222\", \"#333\", \"#444\", \"#555\", \"#666\", \"#777\", \"#888\", \"#999\", \"#aaa\", \"#bbb\", \"#ccc\", \"#ddd\", \"#fff\"]\n    }\n\n    static validPaddingValues () {\n        const values = []\n        for (let i = 0; i < 41; i ++) {\n            values.push(i + \"px\")\n        }\n        return values\n    }\n\n    static validBorderWidthValues () {\n        const values = []\n        for (let i = 0; i < 10; i ++) {\n            values.push(i + \"px\")\n        }\n        return values\n    }\n\n    static validBorderStyleValues () {\n        return [\"none\", \"dotted\", \"dashed\", \"solid\", \"groove\", \"inset\"]\n    }\n\n    static validFontSizes () {\n        const values = []\n        for (let i = 6; i < 41; i ++) {\n            values.push(i + \"px\")\n        }\n        return values\n    }\n\n    initPrototypeSlots () {\n        const styleSlots = []\n        this.newSlot(\"styleSlots\", styleSlots)\n\n        // -----------------\n\n        const addSlot = (name, path, label, values) => {\n            const slot = this.newSlot(name, \"\")\n            slot.setInspectorPath(path)\n            slot.setLabel(label)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"duplicate\")\n            slot.setSlotType(\"String\")\n            slot.setValidValues(values)\n            styleSlots.push(slot)\n        }\n\n        // --- colors ---\n\n        addSlot(\"color\", \"colors\", \"color\", this.thisClass().validColors())\n        addSlot(\"backgroundColor\", \"colors\", \"background\", this.thisClass().validColors())\n        addSlot(\"opacity\", \"colors\", \"opacity\", [\"inherit\", \"0.0\", \"0.1\", \"0.2\", \"0.3\", \"0.4\", \"0.5\", \"0.6\", \"0.7\", \"0.8\", \"0.9\", \"1.0\"])\n\n        // --- font ---\n\n        addSlot(\"fontFamily\", \"font\", \"family\", [])\n        addSlot(\"fontSize\", \"font\", \"size\", this.thisClass().validFontSizes())\n\n        // weight and style don't work with some good fonts like\n        // helvetica as it uses a different font for each,\n        // so hold off on these until we have a UI to manage this stuff\n        //addSlot(\"fontWeight\", \"font\", \"weight\", [\"inherit\", \"normal\", \"bold\"])\n        //addSlot(\"fontStyle\", \"font\", \"style\", [\"inherit\", \"normal\", \"italic\", \"oblique\"])\n\n        addSlot(\"letterSpacing\", \"font\", \"letter spacing\", this.thisClass().validLetterSpacingValues())\n        addSlot(\"lineHeight\", \"font\", \"line height\", this.thisClass().validLineHeightValues())\n\n\n        // --- padding ---\n\n        {\n            const paddings = this.thisClass().validPaddingValues()\n            addSlot(\"paddingLeft\", \"padding\", \"left\", paddings)\n            addSlot(\"paddingRight\", \"padding\", \"right\", paddings)\n            addSlot(\"paddingTop\", \"padding\", \"top\", paddings)\n            addSlot(\"paddingBottom\", \"padding\", \"bottom\", paddings)\n        }\n\n        // --- border ---\n        \n        {\n            const styles = this.thisClass().validBorderStyleValues()\n            addSlot(\"borderLeftStyle\", \"border/left\", \"style\", styles)\n            addSlot(\"borderRightStyle\", \"border/right\", \"style\", styles)\n            addSlot(\"borderTopStyle\", \"border/top\", \"style\", styles)\n            addSlot(\"borderBottomStyle\", \"border/bottom\", \"style\", styles)\n\n            const widths = this.thisClass().validBorderWidthValues()\n            addSlot(\"borderLeftWidth\", \"border/left\", \"width\", widths)\n            addSlot(\"borderRightWidth\", \"border/right\", \"width\", widths)\n            addSlot(\"borderTopWidth\", \"border/top\", \"width\", widths)\n            addSlot(\"borderBottomWidth\", \"border/bottom\", \"width\", widths)\n\n            const colors = this.thisClass().validColors()\n            addSlot(\"borderLeftColor\", \"border/left\", \"color\", colors)\n            addSlot(\"borderRightColor\", \"border/right\", \"color\", colors)\n            addSlot(\"borderTopColor\", \"border/top\", \"color\", colors)\n            addSlot(\"borderBottomColor\", \"border/bottom\", \"color\", colors)\n\n            const radii = this.thisClass().validBorderWidthValues()\n            addSlot(\"borderLeftRadius\", \"border/left\", \"radius\", radii)\n            addSlot(\"borderRightRadius\", \"border/right\", \"radius\", radii)\n            addSlot(\"borderTopRadius\", \"border/top\", \"radius\", radii)\n            addSlot(\"borderBottomRadius\", \"border/bottom\", \"radius\", radii)\n        }\n\n        // ---------------------\n\n        this.newSlot(\"borderStyleSlots\", styleSlots.select(slot => slot.name().beginsWith(\"border\"))); // cached for efficiency\n        this.newSlot(\"nonBorderStyleSlots\", styleSlots.select(slot => !slot.name().beginsWith(\"border\"))); // cached for efficiency\n        this.newSlot(\"styleCacheMap\", null);\n    }\n\n    init () {\n        super.init()\n        this.setStyleCacheMap(null) // null is used to indicate cache needs to be built when accessed\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(false) \n        this.removeAction(\"add\")\n        this.setSubtitle(\"state\")\n        //this.setSubnodeClasses([BMStringField])\n        //this.setupSubnodes()\n        //this._didChangeThemeNote = this.newNoteNamed(\"didChangeTheme\")\n    }\n\n    /*\n    scheduleDidInit () {\n        console.log(this.debugTypeId() + \" scheduleDidInit\")\n        //debugger;\n        super.scheduleDidInit()\n    }\n    */\n\n    didInit () {\n        if (this.hasDoneInit()) {\n            // hack to skip if already called from ThemeClass setupAsDefault \n            console.log(this.typeId() + \" didInit - already called so skipping\")\n            return\n        }\n        //debugger;\n        assert(!this.hasDoneInit())\n        //console.log(this.typeId() + \" didInit setupSubnodes: \", this.subnodes().map(sn => sn.typeId()))\n        super.didInit()\n        this.setupSubnodes()\n    }\n\n    setThemeAttribute (key, value) {\n        this[key.asSetter()].apply(this, [value])\n        //this.firstSubnodeWithTitle(key).setValue(value)\n        return this\n    }\n\n    syncFromViewStyle () {\n        return this\n    }\n\n    // prepareForAccess\n    prepareForFirstAccess () {\n        const fields = this.getFields()\n        if (fields.length) {\n            fields.forEach(field => {\n                if (field.pickSubnodesMatchingValue) {\n                    field.pickSubnodesMatchingValue() \n                }\n            })\n        }\n    }\n\n    getFields () {\n        return this.selectSubnodesRecursively(sn => {\n            return sn.thisClass().isKindOf(BMField)\n        })\n    }\n\n    setupSubnodes () {\n        this.removeAllSubnodes()\n\n        // need this because the fonts typically aren't loaded until after this prototype is initialized\n        this.thisPrototype().slotNamed(\"fontFamily\").setValidValues(BMResources.shared().fonts().allFontNames())    \n\n        this.styleSlots().forEach(slot => {\n            const name = slot.name()\n            const field = slot.newInspectorField()\n            field.setTarget(this)\n            field.setNodeCanEditTitle(false)\n            field.setNodeCanReorderSubnodes(false)\n            //debugger\n            const pathNodes = this.createNodePath(slot.inspectorPath())\n            const node = pathNodes.last()\n            if (node !== this) {\n                node.setNodeSubtitleIsChildrenSummary(true)\n            }\n            field.setSummaryFormat(\"key value\")\n            field.setHasNewlineAferSummary(true)\n            node.addSubnode(field)\n        })\n    }\n\n    // --- style cache ---\n\n    clearStyleCache () {\n        this.setStyleCacheMap(null)\n        console.log(\" clearStyleCache\")\n        return this\n    }\n\n    getCachedStyleValueNamed (name) {\n        return this.getStyleCacheMap().at(name)\n    }\n\n    getStyleCacheMap () {\n        if (!this.styleCacheMap()) {\n            this.setStyleCacheMap(this.computeStyleCacheMap())\n        }\n        return this.styleCacheMap()\n    }\n\n    computeStyleCacheMap () {\n        const map = new Map()\n        this.styleSlots().forEach(slot => { \n            const name = slot.name()\n            const v = this.getStyleValueNamed(name)\n            map.set(name, v)\n        })\n        return map\n    }\n\n    // --- applying styles ---\n\n    themeClass () {\n        return this.parentNode()\n    }\n\n    parentThemeState () {\n        return this.themeClass().subnodeBefore(this)\n    }\n\n    getStyleValueNamed (name) {\n        const getterMethod = this[name]\n\n        let v = null\n\n        if (getterMethod) {\n            v = getterMethod.apply(this)\n            if (v === \"\" || v === \"inherit\") { \n                v = null\n            }\n        } else {\n            const errorMsg = \"missing getter method: \" + this.type() + \".\" + name + \"()\"\n            console.warn(errorMsg)\n            //throw new Error(errorMsg)\n        }\n\n        if (v == null) {\n            const parent = this.parentThemeState()\n            if (parent) {\n                return parent.getStyleValueNamed(name)\n            }\n        }\n        \n        return v\n    }\n\n    // --- apply styles ---\n\n\n    applyStyleSlotsToView (styleSlots, aView) {\n        const lockedSet = aView.lockedStyleAttributeSet ? aView.lockedStyleAttributeSet() : null;\n        \n        styleSlots.forEach(slot => { \n            const name = slot.name()\n            const isLocked = lockedSet ? lockedSet.has(name) : false;\n            if (!isLocked) {\n                const v = this.getCachedStyleValueNamed(name)\n                aView.performIfResponding(aView.setterNameForSlot(name), v)\n            } else {\n                console.log(\"style \" + name + \" locked on view \" + aView.type())\n            }\n        })\n        return this\n    }\n\n    applyToView (aView) {\n        this.applyStyleSlotsToView(this.styleSlots(), aView)\n        return this\n    }\n\n    // --- apply style subsets ---\n\n    applyNonBorderStylesToView (aView) {\n        this.applyStyleSlotsToView(this.nonBorderStyleSlots(), aView)\n        return this\n    }\n\n    applyBorderStylesToView (aView) {\n        this.applyStyleSlotsToView(this.borderStyleSlots(), aView)\n        return this\n    }\n\n    // --- changes ---\n    \n    onDidEdit () {\n        console.log(this.typeId() + \" onDidEdit\")\n        this.setStyleCacheMap(null)\n        debugger;\n        return false\n    }\n\n    didUpdateSlot (aSlot, oldValue, newValue) {\n        if (this.hasDoneInit()) {\n            if (aSlot.name() !== \"styleCacheMap\") { // hack\n                DocumentBody.shared().resyncAllViews() // this will apply any new styles\n                this.scheduleCacheClears()\n            }\n        }\n        return super.didUpdateSlot(aSlot, oldValue, newValue) \n    }\n\n    scheduleCacheClears () {\n        // need to clear our sibling caches as there is inheritance between states,\n        // so our change may invalidate attributes of states that inherit from us\n        this.parentNode().subnodes().forEach(sn => sn.scheduleMethod(\"clearStyleCache\"))\n    }\n    \n    didReorderParentSubnodes () {\n        this.scheduleMethod(\"clearStyleCache\")\n    }\n\n    styleMap () {\n        const map = new Map()\n        const title = this.title()\n        this.styleSlots().forEach(slot => { \n            const name = slot.name()\n            //const v = this.getCachedStyleValueNamed(name)\n            const v = this.getStyleValueNamed(name)\n            map.set(title + \". \" + name, v)\n            // these look like: disabled.backgroundColor: \"black\"\n        })\n        return map\n    }\n\n}.initThisClass());\n\n\n",
  "YyFGctvy3tvUnTPhF6NSLlAaoEkgUneNn1aUQeopG54=": "\"use strict\";\n\n/*\n\n    BMThemeLevelClass\n\n*/\n\n(class BMThemeLevelClass extends BMThemeClass {\n    \n    initPrototypeSlots () {\n\n    }\n\n    /*\n    init () {\n        super.init()\n\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(true) \n        \n        this.setNodeCanEditTitle(true)\n        this.setTitle(\"Untitled \" + this.thisClass().visibleClassName())\n        this.setNodeCanEditTitle(false)\n        this.setCanDelete(true)\n        this.addAction(\"add\")\n        this.setSubnodeClasses([BMThemeFolder, BMThemeClass])\n        this.setNodeCanReorderSubnodes(true)\n    }\n    */\n\n    updateTitle () {\n        const pn = this.parentNode()\n        if (pn) {\n            const index = pn.indexOfSubnode(this)\n            if (index !== -1) {\n                this.setTitle(\"Level \" + index)\n            }\n        }\n    }\n\n    /*\n    didUpdateSlotParentNode (oldValue, newValue) {\n        super.didUpdateSlotParentNode(oldValue, newValue)\n        this.updateTitle()\n        return this\n    }\n\n    didReorderParentSubnodes () {\n        super.didReorderParentSubnodes()\n        this.updateTitle()\n        return this\n    }\n    */\n\n}.initThisClass());\n",
  "Nt3HKFS8DZJkmeW/3qh2wU4ew3gPo+b4cRUcJpRyLfI=": "\"use strict\";\n\n/*\n\n    BMThemeLeveledFolder\n\n*/\n\n(class BMThemeLeveledFolder extends BMThemeFolder {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(true) \n        \n        this.setNodeCanEditTitle(true)\n        this.setTitle(\"Untitled \" + this.thisClass().visibleClassName())\n        this.setNodeCanEditTitle(true)\n        this.setCanDelete(true)\n        this.addAction(\"add\")\n        this.setSubnodeClasses([BMThemeLevelClass])\n        this.setNodeCanReorderSubnodes(true)\n    }\n\n    onDidReorderSubnodes () {\n        this.subnodes().forEach(sn => sn.updateTitle())\n        return this\n    }\n\n}.initThisClass());\n",
  "zbUpaeF+VuVWgbPWlEnXfNGr+WYd7t2U/6OyCqvaEbQ=": "\"use strict\";\r\n\r\n/*\r\n    \r\n\tBMIconResources\r\n\t\r\n\tHack to put SVG files into Javascript strings to avoid cross site loading issues.\r\n    \r\n*/\r\n\r\n(class BMIconResources extends BMResourceGroup {\r\n\r\n\tinit () {\r\n\t\tsuper.init()\r\n\t\tthis.setTitle(\"Icons\")\r\n\t\treturn this\r\n\t}\r\n\r\n\tsetup () {\r\n        // subclasses need to use this to set ResourceClasses\r\n        this.setResourceClasses([SvgIconNode])\r\n    }\r\n\r\n\t// --- old code to add svg directly using a string ---\r\n\r\n    addIcon (aName, svgString) {\r\n\t\tconst node = SvgIconNode.clone().setTitle(aName).setSvgString(svgString)\r\n\t\tthis.addSubnode(node)\r\n        return this\r\n\t}\r\n\t\r\n\ticonWithName (aName) {\r\n\t\tconst node = this.subnodeWithTitle(aName)\r\n\t\tif (node) {\r\n\t\t\treturn node.svgIconView()\r\n\t\t}\r\n\t\treturn null\r\n\t}\r\n\r\n\ticonNames () {\r\n\t\treturn this.subnodes().map(sn => sn.title())\r\n\t}\r\n\r\n}.initThisClass());\r\n\r\n\r\n\r\n",
  "PjfFctReznv9zG/xbFT4Ymfmrfgs6imI+xillyhccfs=": "\"use strict\";\r\n\r\n/*\r\n    \r\n  SvgIconNode\r\n\t\r\n    \r\n*/\r\n\r\n(class SvgIconNode extends BMResource {\r\n\r\n  static supportedExtensions () {\r\n    return [\"svg\"]\r\n  }\r\n\r\n  initPrototypeSlots () {\r\n    {\r\n      const slot = this.newSlot(\"svgString\", null)\r\n      slot.setCanInspect(true)\r\n      slot.setSlotType(\"String\")\r\n      slot.setLabel(\"SVG string\")\r\n    }\r\n  }\r\n\r\n  didLoad () {\r\n    super.didLoad()\r\n    this.setSvgString(this.data())\r\n    return this\r\n  }\r\n\r\n  svgIconView () {\r\n    // TODO: this view stuff probably shouldn't be in the model\r\n    const icon = SvgIconView.clone().setSvgString(this.svgString())\r\n    return icon\r\n  }\r\n\r\n  noteIconName () {\r\n    return this.title()\r\n  }\r\n\r\n}.initThisClass());\r\n\r\n\r\n\r\n",
  "zI6ZLBCB28dXiEIiw02d/rZpieJrj5Dijr/vQYZNkUw=": "\"use strict\";\n\n/*\n\n    BMImage\n\n*/\n\n(class BMJsonResource extends BMResource {\n    \n    static supportedExtensions () {\n        return [\"json\"]\n    }\n\n    initPrototypeSlots () {\n    }\n\n\n}.initThisClass());\n\n",
  "jQCRyHW1rssm9ja5tBY6CuXCt0jBiobIzk5Y+hAV2r4=": "\"use strict\";\n\n/*\n\n    BMJsonResources\n\n*/\n\n(class BMJsonResources extends BMResourceGroup {\n    \n    static initClass () {\n        this.setIsSingleton(true)\n\t\treturn this\n    }\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        this.setTitle(\"Json\")\n        this.setNoteIsSubnodeCount(true)\n        this.setSubnodeClasses([BMJsonResource])\n        return this\n    }\n\n    /*\n    resourcePaths () { //in BMResourceGroup\n        return ResourceManager.shared().resourceFilePathsWithExtensions(this.extensions())\n    }\n    \n    appDidInit () {  //in BMResourceGroup\n        this.setupSubnodes()\n        return this\n    }\n\n    setupSubnodes () {  //in BMResourceGroup\n        this.resourcePaths().forEach(path => this.addResourceWithPath(path))\n        return this\n    }\n\n    addResourceWithPath (aPath) {  //in BMResourceGroup\n        const resource = this.justAdd()\n        resource.setPath(aPath)\n        return this\n    }\n    */\n\n}.initThisClass());\n\n\n",
  "9dLOV96jFP2hbHgTHEsfXSq7+4YFnpO2eTHE7V3/IzY=": "\"use strict\";\n\n/*\n    \n    BMSettingsNode\n\n    Do we want:\n    - a static set of slots whose values are shown as subnodes?\n    - just have some accessors that look up subnodes by title?\n\n    Using slots might allow better use of slot meta data, and \n    we already have inspector for slot meta data...\n\n    slot.setIsSubnodeTitled(title)\n    - on didInit() (after deserialization) we enumerate these slots and:\n    -- foreach slot with subnodeTitle:\n    --- if subnode is present, set slot value to subnode \n    --- else alloc slot via initProto and add then add subnode for it\n\n*/\n\n(class BMSettingsNode extends BMStorableNode {\n    \n    initPrototypeSlots () {\n        // model\n        this.newSlot(\"prototypes\", null).setShouldStoreSlot(false) //.setInitProto(BMNode)\n        this.newSlot(\"resources\", null).setShouldStoreSlot(false)  //.setInitProto(BMDataStore)\n        this.newSlot(\"storage\", null).setShouldStoreSlot(false)  //.setInitProto(BMBlobs)\n        this.newSlot(\"blobs\", null).setShouldStoreSlot(false)  //.setInitProto(BMBlobs)\n    }\n\n    init () {\n        super.init()\n        this.setNodeCanReorderSubnodes(false)\n        this.addAction(\"add\")\n\n        // settings are effectively a global node that references other globals\n        // so we don't need to store it (for now)\n\n        this.setShouldStore(false)\n        this.setShouldStoreSubnodes(false)\n        return this\n    }\n\n    /*\n    didInit () {\n        debugger;\n        this.setResources(this.subnodeWithTitleIfAbsentInsertProto(\"Resources\", BMResources))\n        this.subnodeWithTitleIfAbsentInsertProto(\"Storage\", BMDataStore))\n        this.subnodeWithTitleIfAbsentInsertProto(\"Blobs\", BMBlobs)\n    }\n    */\n\n    didInit () {\n        this.addSettingNameAndClass(\"Resources\", BMResources)\n        this.addSettingNameAndClass(\"Storage\", BMDataStore)\n        this.addSettingNameAndClass(\"Blobs\", BMBlobs)\n    }\n\n    addSettingNameAndClass (aName, aClass) {\n        // like subnodeWithTitleIfAbsentInsertProto but we also set this class's slot aName to the subnode\n        const subnode = this.subnodeWithTitleIfAbsentInsertProto(aName, aClass)\n        this.removeOtherSubnodeWithSameTitle(subnode)\n        const slot = this.thisPrototype().slotNamed(aName.toLowerCase())\n        assert(slot)\n        if (slot) {\n            slot.onInstanceSetValue(this, subnode) \n        }\n        return subnode\n    }\n\n}.initThisClass());",
  "ObK6oO+LlYSbAshLiOanLb/ywGJNHdvbCV9nNyDfNXk=": "\"use strict\";\n\n/*\n    \n    RootContentNode\n\n    Root node to use for app persistent store.\n    The app is responsible for loading this from the store or creating it if it doesn't exist.\n\n    The BrowserView node should be this node.\n    The app header node is a subnode of this one, and the breadcrumbs node would be a subnode of the header.\n    \n    This singleton sets up: \n\n    - themes (inspectable) slot\n    - blobs (inspectable) slot\n    - breadcrumb subnode\n\n    (if not already set up after loading from store)\n\n*/\n\n(class RootContentNode extends BMFolderNode {\n    \n    initPrototypeSlots () {\n\n        {\n            const slot = this.newSlot(\"blobs\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n        }\n\n        {\n            const slot = this.newSlot(\"themes\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n        }        \n        \n        {\n            const slot = this.newSlot(\"prototypes\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n        }\n\n        {\n            const slot = this.newSlot(\"settings\", null)\n            slot.setShouldStoreSlot(false)\n            slot.setCanInspect(true)\n        }\n\n        /*\n        {\n            const slot = this.newSlot(\"settings\", true)\n            slot.setShouldStoreSlot(false)\n            //slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n\n\n        {\n            const slot = this.newSlot(\"breadCrumbs\", true)\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n        }\n        */\n\n        this.newSlot(\"headerNode\", null)\n        this.newSlot(\"breadCrumbsNode\", null)\n\n    }\n\n    // ---\n\n    init () {\n        super.init()\n        this.setTitle(\"Root Content Node\")\n        this.setNodeCanReorderSubnodes(true)\n        //this.addAction(\"add\")\n        this.setNodeMinTileHeight(55)\n        this.setNodeIsVertical(false) // not setting BrowserView to down direction - why?\n        return this\n    }\n\n    didInit () {\n        super.didInit()\n        // This didInit *may not execute before* the didInit of other nodes such as the header and breadcrumbs.\n        //debugger;\n\n        if (!this.blobs()) {\n            this.setBlobs(BMBlobs.shared())\n        }\n\n        if (!this.themes()) {\n            this.setThemes(BMThemeResources.shared())\n        }\n\n        if (!this.prototypes()) {\n            this.setPrototypes(BMPrototypesNode.shared())\n        }        \n\n        // subnodes\n        this.setupHeaderNode()\n        this.setupBreadCrumbsNode()\n        return this\n    }\n\n    // header\n\n    setupHeaderNode () {\n       // this.removeAllSubnodes()\n        //debugger;\n\n        if (this.subnodes().length > 1) {\n            this.removeAllSubnodes()\n        }\n\n        let node = this.subnodes().first()\n\n        if (!node) {\n            node = this.newHeaderNode()\n            this.addSubnode(node)\n        }\n\n        node.setNodeCanEditTitle(true)\n\n        this.setHeaderNode(node)\n    }\n\n    newHeaderNode () {\n        const node = BMFolderNode.clone() // FolderNode?\n        node.setNodeTileClassName(\"HeaderTile\")\n        node.setNodeMinTileHeight(55)\n        node.setTitle(\"my header\")\n        node.setNodeCanEditTitle(true)\n        node.setNodeIsVertical(false) \n        node.setCanDelete(false)\n        return node\n    }\n\n    // bread crumbs\n\n    setupBreadCrumbsNode () {\n        //debugger\n        const root = this.headerNode()\n\n        if (root.subnodes().length > 1) {\n            this.removeAllSubnodes()\n        }\n\n        let node = root.subnodes().first()\n\n        if (!node) {\n            node = this.newBreadCrumbsNode()\n            root.addSubnode(node)\n        }\n        node.setNodeIsVertical(true) \n\n        //debugger;\n        this.setBreadCrumbsNode(node)\n    }\n\n    newBreadCrumbsNode () {\n        const node = BMFolderNode.clone()\n        node.setNodeTileClassName(\"BreadCrumbsTile\")\n        node.setCanDelete(false)\n        return node\n    }\n\n}.initThisClass());",
  "75HZIG0M0QODeuV/O9dRERyziBirpoyzKjDd0WYwbc0=": "\"use strict\";\n\n/*\n    \n    StrvctApp\n\n\n*/\n\n(class StrvctApp extends App {\n    \n    static rootNodeProto () {\n        return RootContentNode\n    }\n\n    initPrototypeSlots () {\n\n        /*\n        {\n            const slot = this.newSlot(\"rootContentNode\", null)\n            slot.setShouldStoreSlot(false)\n            slot.setCanInspect(true)\n        }\n        */\n\n        // for now, we won't store this object in order to avoid some\n        // chicken and egg problems\n\n        this.setShouldStore(false)\n        this.setShouldStoreSubnodes(false)\n\n        // view\n        this.newSlot(\"browser\", null)\n    }\n\n    // ---\n\n    init () {\n        super.init()\n        this.setName(\"StrvctApp\")\n        this.setVersion([0, 0, 0, 0])\n        this.setNodeCanReorderSubnodes(true)\n        this.addAction(\"add\")\n        return this\n    }\n\n    setup () {\n        super.setup()\n        this.setupModel()\n        BMResources.shared()\n        \n        const browser = BrowserView.clone()\n        this.rootNode().setTitle(\"root node\")\n        browser.setNode(this.rootNode())\n        browser.syncFromNode()\n\n        this.setBrowser(browser)\n        this.documentBodyView().addSubview(browser)\n\n        //this.addTimeout( () => this.showClasses(), 1)\n    }\n\n    showClasses () {\n        debugger;\n        const s = ProtoClass.subclassesDescription()\n        console.log(s)\n    }\n\n    // --- setup model ---\n\n    setupModel () {\n        if (false) {\n            BMBlobs.shared().promiseOpen().then(() => this.appDidInit())\n        } else {\n            this.appDidInit()\n        }\n        // settings\n        //const settings = this.rootNode().subnodeWithTitleIfAbsentInsertProto(\"Settings\", BMSettingsNode)\n        //this.setSettings(settings)\n        //debugger;\n        return this\n    }\n\n    // --- setup views ---\n\n    appDidInit () {\n        //this.rootNode().removeFirstSubnodeWithTitle(\"Themes\")\n        super.appDidInit()\n    }\n\n    // themes - temporary, until ThemesResources is ready\n\n    setupDocTheme () {\n        const doc = DocumentBody.shared()\n        doc.setHeight(\"100%\") // trying to fix body not fitting window\n        doc.setColor(\"#f4f4ec\")\n        doc.setBackgroundColor(\"rgb(25, 25, 25)\")\n        this.setupNormalDocTheme()\n        //this.setupVectorTheme()\n        //this.setupBlenderProTheme()\n    }\n\n    setupNormalDocTheme () {\n        const doc = DocumentBody.shared()\n        doc.setBackgroundColor(\"#191919\")\n        //doc.setFontFamily(\"Sans-Serif\")\n        //doc.setFontFamily(\"Electrolize-Regular\")\n        doc.setFontFamily(\"Helvetica\")\n        //doc.setFontWeight(\"bold\")\n        //doc.setFontFamily(\"Helvetica Neue\")\n        //doc.setFontFamily(\"Helvetica LT W01 Condensed\")\n        //doc.setFontFamily(\"San Francisco Display\")\n        //doc.setFontFamily(\"PublicSans Light\")\n        //doc.setFontFamily(\"OpenSans Regular\")\n        doc.setFontSizeAndLineHeight(\"16px\")\n        //doc.setLetterSpacing(\"0.05em\")\n        //doc.setTextTransform(\"uppercase\")\n   }\n\n    /*\n    setupVectorDocTheme () {\n        const doc = DocumentBody.shared()\n        doc.setBackgroundColor(\"#191919\")\n        doc.setFontFamily(\"Hyperspace Bold\")\n        doc.setFontSize(\"15px\")\n        doc.setFontWeight(\"bold\")\n        //doc.setFontSizeAndLineHeight(\"1.1em\")\n        doc.setLetterSpacing(\"0.1em\")\n        doc.setTextShadow(\"0px 0px 1px rgba(255,255,255,1)\")\n        doc.setFontWeight(900)\n        //doc.setTextTransform(\"uppercase\")\n        //DocumentBody.shared().setTextTransform(\"uppercase\")\n    }\n\n    setupBlenderProDocTheme () {\n        const doc = DocumentBody.shared()\n        doc.setFontFamily(\"Blender Pro Book\")\n        doc.setFontSizeAndLineHeight(\"18px\")\n    }\n\n    setupLatoDocTheme () {\n        const doc = DocumentBody.shared()\n        doc.setFontFamily(\"Lato Light\")\n        doc.setFontSizeAndLineHeight(\"16px\")\n        doc.setLetterSpacing(\"0.05em\")\n        doc.setTextShadow(\"0px 0px 0.5px rgba(255,255,255,0.7)\")\n    }\n    */\n\n}.initThisClass());\n\n\n",
  "2+4ji5xbfBCyjqmEdl9oPQ1MHhRJj+9p6nWBtBVdmIU=": "\nconsole.log(\"--- StrvctApp _init.js ---\")\nStrvctApp.loadAndRunShared() \n\n",
  "6YJNcH9GgUI9IcFPVxIc+OzFQWbef8PyLThmBFg8P60=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 37.644 37.644\" style=\"enable-background:new 0 0 37.644 37.644;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path d=\"M37.644,5.957c0,0.829-0.672,1.5-1.5,1.5h-2.118v2.119c0,0.829-0.672,1.5-1.5,1.5s-1.5-0.671-1.5-1.5V7.457h-2.119\r\n\t\tc-0.828,0-1.5-0.671-1.5-1.5c0-0.829,0.672-1.5,1.5-1.5h2.119V2.339c0-0.829,0.672-1.5,1.5-1.5s1.5,0.671,1.5,1.5v2.118h2.118\r\n\t\tC36.972,4.457,37.644,5.129,37.644,5.957z M33.246,28.093l-10.557-3.299c2.28-2.717,3.668-7.024,3.668-11.055\r\n\t\tC26.357,7.64,22.88,3.7,17.502,3.7c-5.38,0-8.857,3.94-8.857,10.039c0,4.03,1.387,8.338,3.669,11.055L1.756,28.093\r\n\t\tC0.711,28.419,0,29.384,0,30.48v3.824c0,1.383,1.119,2.5,2.5,2.5h30.002c1.381,0,2.5-1.117,2.5-2.5V30.48\r\n\t\tC35.002,29.386,34.291,28.42,33.246,28.093z\" />\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "T7gERds4SLhKX/T8PAbsMm6tA5V3D4s0gHs2OnhlvZs=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 401.994 401.994\" style=\"enable-background:new 0 0 401.994 401.994;\" xml:space=\"preserve\">\r\n\t<path d=\"M394,154.175c-5.331-5.33-11.806-7.994-19.417-7.994H255.811V27.406c0-7.611-2.666-14.084-7.994-19.414\r\n\t\tC242.488,2.666,236.02,0,228.398,0h-54.812c-7.612,0-14.084,2.663-19.414,7.993c-5.33,5.33-7.994,11.803-7.994,19.414v118.775\r\n\t\tH27.407c-7.611,0-14.084,2.664-19.414,7.994S0,165.973,0,173.589v54.819c0,7.618,2.662,14.086,7.992,19.411\r\n\t\tc5.33,5.332,11.803,7.994,19.414,7.994h118.771V374.59c0,7.611,2.664,14.089,7.994,19.417c5.33,5.325,11.802,7.987,19.414,7.987\r\n\t\th54.816c7.617,0,14.086-2.662,19.417-7.987c5.332-5.331,7.994-11.806,7.994-19.417V255.813h118.77\r\n\t\tc7.618,0,14.089-2.662,19.417-7.994c5.329-5.325,7.994-11.793,7.994-19.411v-54.819C401.991,165.973,399.332,159.502,394,154.175z\" />\r\n</svg>\r\n",
  "ekFgS5X2gRaqVYXB/4Cj3y6JDCuf9NPAjQHGduljdUA=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 150 150\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path fill=\"#000000\" d=\"M74.997,1.917c-5.786,0-10.495,4.71-10.495,10.5c0,5.789,4.709,10.501,10.495,10.501\r\n\t\tc5.79,0,10.505-4.712,10.505-10.501C85.502,6.626,80.787,1.917,74.997,1.917z\" />\r\n\t\t<path fill=\"#000000\" d=\"M74.998,71.359c-4.135,0-7.498,3.363-7.498,7.5c0,4.137,3.363,7.5,7.498,7.5c4.136,0,7.502-3.363,7.502-7.5\r\n\t\tC82.5,74.722,79.134,71.359,74.998,71.359z\" />\r\n\t\t<path fill=\"#000000\" d=\"M74.998,139.084c-2.479,0-4.496,2.018-4.496,4.5s2.018,4.5,4.496,4.5c2.483,0,4.504-2.018,4.504-4.5\r\n\t\tS77.481,139.084,74.998,139.084z\" />\r\n\t\t<path fill=\"#000000\" d=\"M7.968,71.947c-4.136,0-7.499,3.363-7.499,7.5c0,4.137,3.363,7.5,7.499,7.5c4.138,0,7.501-3.363,7.501-7.5\r\n\t\tC15.469,75.31,12.105,71.947,7.968,71.947z\" />\r\n\t\t<path fill=\"#000000\" d=\"M142.029,71.947c-4.135,0-7.498,3.363-7.498,7.5c0,4.137,3.363,7.5,7.498,7.5s7.502-3.363,7.502-7.5\r\n\t\tC149.531,75.31,146.164,71.947,142.029,71.947z\" />\r\n\t\t<path fill=\"#000000\" d=\"M108.367,37.083c-4.966,0-9.002,4.037-9.002,8.999c0,4.965,4.036,9.001,9.002,9.001\r\n\t\tc4.96,0,8.998-4.036,8.998-9.001C117.365,41.121,113.327,37.083,108.367,37.083z\" />\r\n\t\t<path fill=\"#000000\" d=\"M40.776,37.083c-4.965,0-9.001,4.037-9.001,8.999c0,4.965,4.036,9.001,9.001,9.001\r\n\t\tc4.961,0,8.999-4.036,8.999-9.001C49.775,41.121,45.737,37.083,40.776,37.083z\" />\r\n\t\t<path fill=\"#000000\" d=\"M108.366,107.102c-3.309,0-6.001,2.689-6.001,5.998c0,3.307,2.692,6.002,6.001,6.002\r\n\t\tc3.31,0,5.999-2.695,5.999-6.002C114.365,109.791,111.676,107.102,108.366,107.102z\" />\r\n\t\t<path fill=\"#000000\" d=\"M40.776,107.102c-3.309,0-6.003,2.689-6.003,5.998c0,3.307,2.694,6.002,6.003,6.002\r\n\t\tc3.307,0,5.997-2.695,5.997-6.002C46.773,109.791,44.083,107.102,40.776,107.102z\" />\r\n\t</g>\r\n</svg>\r\n",
  "gP8qW5ViMbxlTuIu10aJps/VG6iORPNGen9voK8yeTM=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 490.2 490.2\" style=\"enable-background:new 0 0 490.2 490.2;\" xml:space=\"preserve\" width=\"100%\" height=\"100%\">\n\t<g>\n\t\t<path d=\"M420.95,61.8C376.25,20.6,320.65,0,254.25,0c-69.8,0-129.3,23.4-178.4,70.3s-73.7,105.2-73.7,175   c0,66.9,23.4,124.4,70.1,172.6c46.9,48.2,109.9,72.3,189.2,72.3c47.8,0,94.7-9.8,140.7-29.5c15-6.4,22.3-23.6,16.2-38.7l0,0   c-6.3-15.6-24.1-22.8-39.6-16.2c-40,17.2-79.2,25.8-117.4,25.8c-60.8,0-107.9-18.5-141.3-55.6c-33.3-37-50-80.5-50-130.4   c0-54.2,17.9-99.4,53.6-135.7c35.6-36.2,79.5-54.4,131.5-54.4c47.9,0,88.4,14.9,121.4,44.7s49.5,67.3,49.5,112.5   c0,30.9-7.6,56.7-22.7,77.2c-15.1,20.6-30.8,30.8-47.1,30.8c-8.8,0-13.2-4.7-13.2-14.2c0-7.7,0.6-16.7,1.7-27.1l18.6-152.1h-64   l-4.1,14.9c-16.3-13.3-34.2-20-53.6-20c-30.8,0-57.2,12.3-79.1,36.8c-22,24.5-32.9,56.1-32.9,94.7c0,37.7,9.7,68.2,29.2,91.3   c19.5,23.2,42.9,34.7,70.3,34.7c24.5,0,45.4-10.3,62.8-30.8c13.1,19.7,32.4,29.5,57.9,29.5c37.5,0,69.9-16.3,97.2-49   c27.3-32.6,41-72,41-118.1C488.05,152.9,465.75,103,420.95,61.8z M273.55,291.9c-11.3,15.2-24.8,22.9-40.5,22.9   c-10.7,0-19.3-5.6-25.8-16.8c-6.6-11.2-9.9-25.1-9.9-41.8c0-20.6,4.6-37.2,13.8-49.8s20.6-19,34.2-19c11.8,0,22.3,4.7,31.5,14.2   s13.8,22.1,13.8,37.9C290.55,259.2,284.85,276.6,273.55,291.9z\" fill=\"#FFFFFF\" />\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "zQq+OSCKvRjlfIaWqZG3zIYV0nwDUQcb9S281elHjM4=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 25.314 25.314\" style=\"enable-background:new 0 0 25.314 25.314;\" xml:space=\"preserve\">\n\t<g>\n\t\t<path d=\"M24.663,20.725c-0.086,0.168-0.258,0.271-0.443,0.271h-8.762c0.171,0.383,0.27,0.803,0.27,1.246   c0,1.697-1.375,3.072-3.07,3.072c-1.694,0-3.07-1.375-3.07-3.072c0-0.443,0.099-0.863,0.271-1.246H1.096   c-0.188,0-0.358-0.104-0.445-0.271c-0.084-0.166-0.069-0.366,0.041-0.521l4.17-5.787V7.798C4.861,3.498,8.359,0,12.659,0   c4.301,0,7.798,3.498,7.798,7.798v6.619l4.171,5.787C24.732,20.358,24.748,20.559,24.663,20.725z\" fill=\"#FFFFFF\" />\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "HbXKAnjOloDeucLWXkGJnSxUozQMnmvYAZpmIZmougQ=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 27.75 27.75\" style=\"enable-background:new 0 0 27.75 27.75;\" xml:space=\"preserve\">\n\t<g>\n\t\t<path d=\"M13.875,27.75l-4.268-7.393H4.273c-2.195,0-3.98-1.618-3.98-3.609V3.61C0.293,1.619,2.079,0,4.273,0h19.204   c2.194,0,3.979,1.619,3.979,3.61v13.138c0,1.991-1.785,3.609-3.979,3.609h-5.334L13.875,27.75z M4.273,2   c-1.091,0-1.98,0.722-1.98,1.61v13.138c0,0.888,0.889,1.609,1.98,1.609h6.486l3.113,5.393l3.112-5.393h6.49   c1.092,0,1.979-0.722,1.979-1.609V3.61c0-0.888-0.89-1.61-1.979-1.61H4.273z\" fill=\"#FFFFFF\" />\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "FRuLDx/lSUQCq/ihFdJuu7GiBpVFkQiHwR40ODLB7gs=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: IcoMoon.io -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\">\n\t<path d=\"M 491.536,108.384l-147.152,148.048l 147.152,147.168c 6.16,6.144, 6.16,16.112,0.00,22.272 l-66.816,66.80c-6.128,6.16-16.096,6.16-22.256,0.00l-146.912-146.912l-146.032,146.912c-6.144,6.16-16.112,6.16-22.272,0.00l-66.80-66.80 c-6.144-6.16-6.144-16.128,0.00-22.272l 146.032-146.912L 20.464,110.672c-6.144-6.144-6.144-16.112,0.00-22.272l 66.80-66.80 c 6.144-6.16, 16.112-6.16, 22.272,0.00l 145.76,145.76l 147.184-148.048c 6.16-6.16, 16.128-6.16, 22.256,0.00l 66.816,66.80 C 497.68,92.272, 497.68,102.24, 491.536,108.384z\">\n\t</path>\n</svg>\n",
  "cCfxfug+8DAuC9LZnM3T4ZbyZI355NmSZlMCK4pRUEg=": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 24 24\">\n\t<path d=\"M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-1.959 17l-4.5-4.319 1.395-1.435 3.08 2.937 7.021-7.183 1.422 1.409-8.418 8.591z\" />\n</svg>\n",
  "QEWr9VW3thd5hGhxMJXA15c1tugfh9gldP6h/s/mBV0=": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 24 24\">\n\t<path d=\"M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm4.597 17.954l-4.591-4.55-4.555 4.596-1.405-1.405 4.547-4.592-4.593-4.552 1.405-1.405 4.588 4.543 4.545-4.589 1.416 1.403-4.546 4.587 4.592 4.548-1.403 1.416z\" />\n</svg>\n",
  "wFWs3Ccg3urcRpOuBzy2l55JA0TI9VrTJlM/+nS7+PU=": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 24 24\">\n\t<path d=\"M10.041 17l-4.5-4.319 1.395-1.435 3.08 2.937 7.021-7.183 1.422 1.409-8.418 8.591zm-5.041-15c-1.654 0-3 1.346-3 3v14c0 1.654 1.346 3 3 3h14c1.654 0 3-1.346 3-3v-14c0-1.654-1.346-3-3-3h-14zm19 3v14c0 2.761-2.238 5-5 5h-14c-2.762 0-5-2.239-5-5v-14c0-2.761 2.238-5 5-5h14c2.762 0 5 2.239 5 5z\" />\n</svg>\n",
  "AtXBTMzNDnnbjQRBUlY7feyQwGECzXLk1TnnruKxBzE=": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 24 24\">\n\t<path d=\"M5 2c-1.654 0-3 1.346-3 3v14c0 1.654 1.346 3 3 3h14c1.654 0 3-1.346 3-3v-14c0-1.654-1.346-3-3-3h-14zm19 3v14c0 2.761-2.238 5-5 5h-14c-2.762 0-5-2.239-5-5v-14c0-2.761 2.238-5 5-5h14c2.762 0 5 2.239 5 5z\" />\n</svg>\n",
  "xp/LIoGZgjCT46DaqcjiDX8pQLqC0qCLXOV2cxIROEE=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: IcoMoon.io -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\">\n\t<path d=\"M 463.968,136.496l-34.144-34.144c-6.304-6.288-16.48-6.288-22.768,0.00L 202.336,307.072 L 104.96,208.992c-6.288-6.288-16.464-6.288-22.768,0.00l-34.144,34.144c-6.288,6.304-6.288,16.48,0.00,22.768l 142.784,143.744 c 6.288,6.288, 16.48,6.288, 22.768,0.00L 463.968,159.264C 470.256,152.992, 470.256,142.784, 463.968,136.496z\">\n\t</path>\n</svg>\n",
  "XoUYzCCSx/NW1Ed8q0Yk/QI0gm1yNQRLohEVxF0kUms=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 23.331 23.331\" style=\"enable-background:new 0 0 23.331 23.331;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path style=\"fill:#010002;\" d=\"M16.043,11.667L22.609,5.1c0.963-0.963,0.963-2.539,0-3.502l-0.875-0.875\r\n\t\tc-0.963-0.964-2.539-0.964-3.502,0L11.666,7.29L5.099,0.723c-0.962-0.963-2.538-0.963-3.501,0L0.722,1.598\r\n\t\tc-0.962,0.963-0.962,2.539,0,3.502l6.566,6.566l-6.566,6.567c-0.962,0.963-0.962,2.539,0,3.501l0.876,0.875\r\n\t\tc0.963,0.963,2.539,0.963,3.501,0l6.567-6.565l6.566,6.565c0.963,0.963,2.539,0.963,3.502,0l0.875-0.875\r\n\t\tc0.963-0.963,0.963-2.539,0-3.501L16.043,11.667z\" />\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "Tg4a2aAuIfmasnxZ/cd1o1L7I0cEJU6/hbV53Btyf7A=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 174.239 174.239\" style=\"enable-background:new 0 0 174.239 174.239;\" xml:space=\"preserve\">\r\n\t<path d=\"M146.537,1.047c-1.396-1.396-3.681-1.396-5.077,0L89.658,52.849c-1.396,1.396-3.681,1.396-5.077,0L32.78,1.047\r\n\tc-1.396-1.396-3.681-1.396-5.077,0L1.047,27.702c-1.396,1.396-1.396,3.681,0,5.077l51.802,51.802c1.396,1.396,1.396,3.681,0,5.077\r\n\tL1.047,141.46c-1.396,1.396-1.396,3.681,0,5.077l26.655,26.655c1.396,1.396,3.681,1.396,5.077,0l51.802-51.802\r\n\tc1.396-1.396,3.681-1.396,5.077,0l51.801,51.801c1.396,1.396,3.681,1.396,5.077,0l26.655-26.655c1.396-1.396,1.396-3.681,0-5.077\r\n\tl-51.801-51.801c-1.396-1.396-1.396-3.681,0-5.077l51.801-51.801c1.396-1.396,1.396-3.681,0-5.077L146.537,1.047z\" />\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "OvobHd6hZALZkJa7ZyZ4WahgNy/uMZVWbAsCwjN+76o=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: IcoMoon.io -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\">\n\t<path d=\"M 192.00,256.00l-32.176,77.44L 256.00,320.00L 192.00,256.00z M 224.00,229.824L 282.192,288.00L 512.00,58.192L 453.808,0.00 L 224.00,229.824z M 64.00,0.00C 32.00,0.00,0.00,32.00,0.00,64.00l0.00,384.00 c0.00,32.00, 32.00,64.00, 64.00,64.00l 384.00,0.00 c 32.00,0.00, 64.00-32.00, 64.00-64.00L 512.00,134.40 L 448.00,172.80L 448.00,384.00 c0.00,32.00-32.00,64.00-64.00,64.00L 128.00,448.00 c-32.00,0.00-64.00-32.00-64.00-64.00L 64.00,128.00 c0.00-32.00, 32.00-64.00, 64.00-64.00l 192.00,0.00 l 64.00-64.00L 64.00,0.00 z\">\n\t</path>\n</svg>\n",
  "ToEiSRDvSnI3D5lvq28KAWQle6zgsFyeGzPvhHNSaGo=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 459 459\" style=\"enable-background:new 0 0 459 459;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<g id=\"delete\">\r\n\t\t\t<path d=\"M76.5,408c0,28.05,22.95,51,51,51h204c28.05,0,51-22.95,51-51V102h-306V408z M408,25.5h-89.25L293.25,0h-127.5l-25.5,25.5\r\n\t\t\tH51v51h357V25.5z\" />\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "mgQPMx6Ry/V65gFY88531cIgKaXfFWIYUb8jR5qIuiE=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: IcoMoon.io -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\">\n\t<path d=\"M 96.00,96.00l-96.00,96.00l 256.00,256.00l 256.00-256.00l-96.00-96.00L 256.00,256.00L 96.00,96.00z\">\n\t</path>\n</svg>\n",
  "yy5Bz98Cdj44asW/ySQ+twRVrI2ncszKxtJw6Sv3QVY=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 27.857 27.857\" style=\"enable-background:new 0 0 27.857 27.857;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<path style=\"fill:#010002;\" d=\"M2.203,5.331l10.034,7.948c0.455,0.36,1.082,0.52,1.691,0.49c0.608,0.03,1.235-0.129,1.69-0.49\r\n\t\t\tl10.034-7.948c0.804-0.633,0.622-1.152-0.398-1.152H13.929H2.604C1.583,4.179,1.401,4.698,2.203,5.331z\" />\r\n\t\t\t<path style=\"fill:#010002;\" d=\"M26.377,7.428l-10.965,8.325c-0.41,0.308-0.947,0.458-1.482,0.451\r\n\t\t\tc-0.536,0.007-1.073-0.144-1.483-0.451L1.48,7.428C0.666,6.811,0,7.142,0,8.163v13.659c0,1.021,0.836,1.857,1.857,1.857h12.071H26\r\n\t\t\tc1.021,0,1.857-0.836,1.857-1.857V8.163C27.857,7.142,27.191,6.811,26.377,7.428z\" />\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "T5Xkjz+OTwP3xh1kUbuHRuziWCU8L6LV47nrPS0W4hE=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 20 20\" style=\"enable-background:new 0 0 20 20;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path style=\"fill:#030104;\" d=\"M19.82,9.43c-0.083-0.119-2.062-2.944-4.793-4.875C13.612,3.552,11.826,3,10,3\r\n\t\tC8.175,3,6.389,3.552,4.97,4.555C2.238,6.486,0.261,9.311,0.179,9.43c-0.238,0.343-0.238,0.798,0,1.141\r\n\t\tc0.083,0.119,2.06,2.944,4.791,4.875C6.389,16.448,8.175,17,10,17c1.826,0,3.612-0.552,5.028-1.555\r\n\t\tc2.731-1.931,4.71-4.756,4.793-4.875C20.059,10.228,20.059,9.772,19.82,9.43z M10,13.5c-1.934,0-3.5-1.57-3.5-3.5\r\n\t\tc0-1.934,1.566-3.5,3.5-3.5c1.93,0,3.5,1.566,3.5,3.5C13.5,11.93,11.93,13.5,10,13.5z\" />\r\n\t\t<g>\r\n\t\t\t<path style=\"fill:#030104;\" d=\"M12,10c0,1.102-0.898,2-2,2c-1.105,0-2-0.898-2-2c0-1.105,0.895-2,2-2C11.102,8,12,8.895,12,10z\" />\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "DOjG174x6FB9F/ZtnO6kTxBWRYGYIXbf6GKo80ZbeMU=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: IcoMoon.io -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 500 500\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\">\n\t<path d=\"M 250.00,30.00L 309.70,198.05L 470.00,198.05L 339.20,296.75L 385.95,470.00L 250.00,366.15L 114.05,470.00L 160.80,296.75L 30.00,198.05L 190.30,198.05 z\">\n\t</path>\n</svg>\n",
  "qDSZJFFZz7IvTnu+TZexv5VwD+fV6f4g5/BpahnxDFw=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 268.765 268.765\" style=\"enable-background:new 0 0 268.765 268.765;\" xml:space=\"preserve\">\r\n\t<g id=\"Settings\">\r\n\t\t<g>\r\n\t\t\t<path style=\"fill-rule:evenodd;clip-rule:evenodd;\" d=\"M267.92,119.461c-0.425-3.778-4.83-6.617-8.639-6.617\r\n\t\t\tc-12.315,0-23.243-7.231-27.826-18.414c-4.682-11.454-1.663-24.812,7.515-33.231c2.889-2.641,3.24-7.062,0.817-10.133\r\n\t\t\tc-6.303-8.004-13.467-15.234-21.289-21.5c-3.063-2.458-7.557-2.116-10.213,0.825c-8.01,8.871-22.398,12.168-33.516,7.529\r\n\t\t\tc-11.57-4.867-18.866-16.591-18.152-29.176c0.235-3.953-2.654-7.39-6.595-7.849c-10.038-1.161-20.164-1.197-30.232-0.08\r\n\t\t\tc-3.896,0.43-6.785,3.786-6.654,7.689c0.438,12.461-6.946,23.98-18.401,28.672c-10.985,4.487-25.272,1.218-33.266-7.574\r\n\t\t\tc-2.642-2.896-7.063-3.252-10.141-0.853c-8.054,6.319-15.379,13.555-21.74,21.493c-2.481,3.086-2.116,7.559,0.802,10.214\r\n\t\t\tc9.353,8.47,12.373,21.944,7.514,33.53c-4.639,11.046-16.109,18.165-29.24,18.165c-4.261-0.137-7.296,2.723-7.762,6.597\r\n\t\t\tc-1.182,10.096-1.196,20.383-0.058,30.561c0.422,3.794,4.961,6.608,8.812,6.608c11.702-0.299,22.937,6.946,27.65,18.415\r\n\t\t\tc4.698,11.454,1.678,24.804-7.514,33.23c-2.875,2.641-3.24,7.055-0.817,10.126c6.244,7.953,13.409,15.19,21.259,21.508\r\n\t\t\tc3.079,2.481,7.559,2.131,10.228-0.81c8.04-8.893,22.427-12.184,33.501-7.536c11.599,4.852,18.895,16.575,18.181,29.167\r\n\t\t\tc-0.233,3.955,2.67,7.398,6.595,7.85c5.135,0.599,10.301,0.898,15.481,0.898c4.917,0,9.835-0.27,14.752-0.817\r\n\t\t\tc3.897-0.43,6.784-3.786,6.653-7.696c-0.451-12.454,6.946-23.973,18.386-28.657c11.059-4.517,25.286-1.211,33.281,7.572\r\n\t\t\tc2.657,2.89,7.047,3.239,10.142,0.848c8.039-6.304,15.349-13.534,21.74-21.494c2.48-3.079,2.13-7.559-0.803-10.213\r\n\t\t\tc-9.353-8.47-12.388-21.946-7.529-33.524c4.568-10.899,15.612-18.217,27.491-18.217l1.662,0.043\r\n\t\t\tc3.853,0.313,7.398-2.655,7.865-6.588C269.044,139.917,269.058,129.639,267.92,119.461z M134.595,179.491\r\n\t\t\tc-24.718,0-44.824-20.106-44.824-44.824c0-24.717,20.106-44.824,44.824-44.824c24.717,0,44.823,20.107,44.823,44.824\r\n\t\t\tC179.418,159.385,159.312,179.491,134.595,179.491z\" />\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "mY/E1jjfwNQUXVSd8j4L1mhO5473MosryyH9B6TydKo=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Layer_1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 512 512\" style=\"enable-background:new 0 0 512 512;\" xml:space=\"preserve\" width=\"100%\" height=\"100%\">\n\t<g>\n\t\t<g>\n\t\t\t<path d=\"M256,151c-57.897,0-105,47.103-105,105c0,57.897,47.103,105,105,105c57.897,0,105-47.103,105-105    C361,198.103,313.897,151,256,151z M256,331c-41.355,0-75-33.645-75-75c0-41.355,33.645-75,75-75s75,33.645,75,75    S297.355,331,256,331z\" fill=\"#FFFFFF\" />\n\t\t</g>\n\t</g>\n\t<g>\n\t\t<g>\n\t\t\t<path d=\"M500.582,211.434l-58.674-14.428c-3.532-11.13-8.068-21.925-13.551-32.249c8.78-14.634,27.343-45.573,27.343-45.573    c3.541-5.902,2.611-13.457-2.256-18.324l-42.426-42.426c-4.867-4.867-12.422-5.797-18.324-2.256    c-0.38,0.228-30.777,18.466-45.626,27.355c-10.269-5.431-20.995-9.927-32.052-13.434c-4.428-17.976-14.451-58.686-14.452-58.686    C298.914,4.711,292.902,0,286,0h-60c-6.903,0-12.915,4.711-14.565,11.414c-4.126,16.76-11.024,44.779-14.45,58.68    c-11.762,3.73-23.143,8.578-34.001,14.482c-6.428-3.856-16.007-9.604-24.869-14.921l-22.462-13.477    c-5.905-3.541-13.457-2.61-18.324,2.256L54.901,100.86c-4.867,4.867-5.797,12.422-2.256,18.324    c0.2,0.335,17.785,29.644,29.271,48.869c-4.712,9.31-8.665,18.986-11.817,28.919c-20.002,4.976-58.223,14.35-58.671,14.46    C4.718,213.077,0,219.092,0,226v60c0,6.909,4.719,12.923,11.429,14.568c0.443,0.109,38.381,9.411,58.687,14.436    c3.565,11.302,8.184,22.273,13.796,32.78l-26.194,43.66c-3.541,5.902-2.611,13.458,2.256,18.324l42.427,42.427    c4.867,4.868,12.421,5.797,18.324,2.256c0.369-0.222,29.463-17.678,43.746-26.227c10.419,5.547,21.313,10.131,32.547,13.692    l14.416,58.66C213.079,507.284,219.093,512,226,512h60c6.904,0,12.917-4.713,14.566-11.418l14.427-58.669    c11.539-3.661,22.671-8.39,33.257-14.128c14.427,8.656,44.444,26.667,44.444,26.667c5.901,3.541,13.457,2.612,18.324-2.256    l42.426-42.427c4.867-4.867,5.797-12.422,2.256-18.324c0,0-18.271-30.452-26.958-44.931c5.308-10.088,9.712-20.634,13.161-31.511    c17.824-4.399,58.19-14.317,58.676-14.436C507.285,298.919,512,292.906,512,286v-60C512,219.095,507.287,213.083,500.582,211.434z     M482,274.24c-17.32,4.257-48.723,11.979-54.72,13.479l-1.131,0.283c-5.231,1.36-9.326,5.43-10.719,10.653    c-3.795,14.229-9.495,27.872-16.942,40.548c-2.779,4.732-2.753,10.605,0.069,15.312c0.78,1.301,16.489,27.483,25.393,42.322    L398.087,422.7c-15.046-9.027-41.716-25.029-41.942-25.165c-4.775-2.866-10.743-2.853-15.501,0.035    c-13,7.885-27.109,13.892-41.938,17.854c-5.177,1.383-9.224,5.422-10.614,10.597c-0.828,3.081-1.644,6.34-1.658,6.397L274.241,482    h-36.479l-10.813-44.042l-2.916-11.664c-1.322-5.292-5.415-9.45-10.686-10.855c-14.533-3.876-28.479-9.747-41.449-17.447    c-4.709-2.797-10.57-2.802-15.285-0.018c-3.23,1.908-27.254,16.313-41.282,24.728l-25.865-25.865l24.661-41.104    c2.841-4.736,2.85-10.65,0.022-15.395c-7.784-13.063-13.685-27.073-17.535-41.643c-1.397-5.286-5.56-9.393-10.863-10.719    c-10.737-2.684-39.564-9.767-55.752-13.741v-36.473c16.342-4.015,45.537-11.199,55.762-13.786    c5.271-1.334,9.408-5.417,10.812-10.671c3.564-13.347,8.822-26.228,15.63-38.286c2.646-4.686,2.578-10.43-0.177-15.053    c-7.25-12.166-20.08-33.577-27.632-46.172l25.865-25.866l12.42,7.452c14.968,8.981,31.98,19.188,32.44,19.463    c4.768,2.85,10.722,2.832,15.472-0.049c13.341-8.088,27.726-14.222,42.756-18.232c5.264-1.404,9.352-5.552,10.68-10.836    c0.282-1.121,9.071-36.815,13.728-55.726h36.49c4.915,19.958,13.621,55.312,13.724,55.722c1.326,5.288,5.417,9.44,10.685,10.845    c14.382,3.836,28.193,9.626,41.05,17.208c4.714,2.781,10.57,2.773,15.276-0.021c4.208-2.498,28.881-17.293,43.106-25.827    l25.864,25.864c-9.037,15.062-25.121,41.869-25.795,42.991c-2.836,4.725-2.853,10.625-0.043,15.367    c7.628,12.872,13.451,26.714,17.308,41.141c1.382,5.167,5.408,9.207,10.57,10.604c3.097,0.839,6.373,1.657,6.428,1.671    L482,237.758V274.24z\" fill=\"#FFFFFF\" />\n\t\t</g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "MLUX1tLgNiMGVDmevSESoOwLITefLy6zkRz2DbCAoeA=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 51.997 51.997\" style=\"enable-background:new 0 0 51.997 51.997;\" xml:space=\"preserve\">\r\n\t<path d=\"M51.911,16.242C51.152,7.888,45.239,1.827,37.839,1.827c-4.93,0-9.444,2.653-11.984,6.905\r\n\tc-2.517-4.307-6.846-6.906-11.697-6.906c-7.399,0-13.313,6.061-14.071,14.415c-0.06,0.369-0.306,2.311,0.442,5.478\r\n\tc1.078,4.568,3.568,8.723,7.199,12.013l18.115,16.439l18.426-16.438c3.631-3.291,6.121-7.445,7.199-12.014\r\n\tC52.216,18.553,51.97,16.611,51.911,16.242z\" />\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "KvfdVXrCilY5NbVUwXs9uGfd5t0RUGOicd1j21sK81A=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 51.997 51.997\" style=\"enable-background:new 0 0 51.997 51.997;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path d=\"M51.911,16.242C51.152,7.888,45.239,1.827,37.839,1.827c-4.93,0-9.444,2.653-11.984,6.905\r\n\t\tc-2.517-4.307-6.846-6.906-11.697-6.906c-7.399,0-13.313,6.061-14.071,14.415c-0.06,0.369-0.306,2.311,0.442,5.478\r\n\t\tc1.078,4.568,3.568,8.723,7.199,12.013l18.115,16.439l18.426-16.438c3.631-3.291,6.121-7.445,7.199-12.014\r\n\t\tC52.216,18.553,51.97,16.611,51.911,16.242z M49.521,21.261c-0.984,4.172-3.265,7.973-6.59,10.985L25.855,47.481L9.072,32.25\r\n\t\tc-3.331-3.018-5.611-6.818-6.596-10.99c-0.708-2.997-0.417-4.69-0.416-4.701l0.015-0.101C2.725,9.139,7.806,3.826,14.158,3.826\r\n\t\tc4.687,0,8.813,2.88,10.771,7.515l0.921,2.183l0.921-2.183c1.927-4.564,6.271-7.514,11.069-7.514\r\n\t\tc6.351,0,11.433,5.313,12.096,12.727C49.938,16.57,50.229,18.264,49.521,21.261z\" />\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "H1TBwTvnGf/BM8oOEamNspvY3ITq/lYk/uG57o9Qz0k=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 50 50\" style=\"enable-background:new 0 0 50 50;\" xml:space=\"preserve\">\r\n\t<path style=\"fill:#D75A4A;\" d=\"M24.85,10.126c2.018-4.783,6.628-8.125,11.99-8.125c7.223,0,12.425,6.179,13.079,13.543\r\n\tc0,0,0.353,1.828-0.424,5.119c-1.058,4.482-3.545,8.464-6.898,11.503L24.85,48L7.402,32.165c-3.353-3.038-5.84-7.021-6.898-11.503\r\n\tc-0.777-3.291-0.424-5.119-0.424-5.119C0.734,8.179,5.936,2,13.159,2C18.522,2,22.832,5.343,24.85,10.126z\" />\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "4xL9bcwwiOGdZbiZA+0Btmjz6gUgkovFyCJUudK/x3s=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 495.398 495.398\" style=\"enable-background:new 0 0 495.398 495.398;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<g>\r\n\t\t\t\t<path d=\"M487.083,225.514l-75.08-75.08V63.704c0-15.682-12.708-28.391-28.413-28.391c-15.669,0-28.377,12.709-28.377,28.391\r\n\t\t\t\tv29.941L299.31,37.74c-27.639-27.624-75.694-27.575-103.27,0.05L8.312,225.514c-11.082,11.104-11.082,29.071,0,40.158\r\n\t\t\t\tc11.087,11.101,29.089,11.101,40.172,0l187.71-187.729c6.115-6.083,16.893-6.083,22.976-0.018l187.742,187.747\r\n\t\t\t\tc5.567,5.551,12.825,8.312,20.081,8.312c7.271,0,14.541-2.764,20.091-8.312C498.17,254.586,498.17,236.619,487.083,225.514z\" />\r\n\t\t\t\t<path d=\"M257.561,131.836c-5.454-5.451-14.285-5.451-19.723,0L72.712,296.913c-2.607,2.606-4.085,6.164-4.085,9.877v120.401\r\n\t\t\t\tc0,28.253,22.908,51.16,51.16,51.16h81.754v-126.61h92.299v126.61h81.755c28.251,0,51.159-22.907,51.159-51.159V306.79\r\n\t\t\t\tc0-3.713-1.465-7.271-4.085-9.877L257.561,131.836z\" />\r\n\t\t\t</g>\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "/LNRqGCRBK6ydHvLRV9YV3yQ00LxkPEDQI7fZcuxREs=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 79.536 79.537\" style=\"enable-background:new 0 0 79.536 79.537;\" xml:space=\"preserve\">\n<g>\n\t<polygon points=\"9.942,74.565 34.795,74.565 34.795,54.681 44.739,54.681 44.739,74.565 69.595,74.565    69.595,44.739 79.536,44.739 39.769,4.971 0,44.739 9.942,44.739  \" fill=\"#FFFFFF\"/>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n</svg>\n",
  "7ZP9d3UHVGVturRrH1lncDQDPNaaFoYcBMYTVhjp7zo=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 510 510\" style=\"enable-background:new 0 0 510 510;\" xml:space=\"preserve\">\n<g>\n\t<g id=\"home\">\n\t\t<polygon points=\"204,471.75 204,318.75 306,318.75 306,471.75 433.5,471.75 433.5,267.75 510,267.75 255,38.25 0,267.75     76.5,267.75 76.5,471.75   \" fill=\"#FFFFFF\"/>\n\t</g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n</svg>\n",
  "CGfh1124j++HzJgPEcMVt860JH+fhKR4bGHHhvf5QJQ=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" style=\"enable-background:new 0 0 512 512;\" xml:space=\"preserve\">\n\t<g>\n\t\t<path d=\"M512,296l-96-96V56h-64v80l-96-96L0,296v16h64v160h160v-96h64v96h160V312h64V296z\" fill=\"#FFFFFF\" />\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "udeWbKT9Is3Mov54VqyftG3t6MDTxfzh6U8XFkAhcIc=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: IcoMoon.io -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\">\n\t<path d=\"M 416.00,416.00l-96.00,96.00L 64.00,256.00L 320.00,0.00l 96.00,96.00L 256.00,256.00L 416.00,416.00z\">\n\t</path>\n</svg>\n",
  "PUOHJ/2kiGO6M2xvtLu3yGuIjuD/Iebxjhxz6Wixp+s=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 398.528 398.528\" style=\"enable-background:new 0 0 398.528 398.528;\" xml:space=\"preserve\" width=\"100%\" height=\"100%\">\n\t<g>\n\t\t<path d=\"M315.232,9.015C311.883,3.276,305.681,0,298.244,0h-91.308c-10.9,0-22.224,7.113-26.93,16.924   L83.17,218.041c-3.162,6.56-2.967,13.518,0.471,19.037c3.463,5.568,9.592,8.811,16.859,8.966l71.662,0.902l-51.877,129.675   c-1.276,3.235-3.959,10.014,0.821,16.981c2.089,3.056,5.674,4.926,9.364,4.926h0.837c6.999,0,11.217-5.308,13.241-7.868   L312.176,180.17c7.153-8.966,4.202-17.013,3.121-19.354c-1.122-2.243-5.625-9.592-17.046-9.592h-53.34l69.8-122.985   C318.37,21.752,318.573,14.729,315.232,9.015z\" fill=\"#FFFFFF\" />\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "qk6VLEA3SEu196CGXwhlwhyoPuriMLzRHD5aNCvDRTo=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Layer_1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 512 512\" style=\"enable-background:new 0 0 512 512;\" xml:space=\"preserve\" width=\"100%\" height=\"100%\">\n\t<g>\n\t\t<g>\n\t\t\t<path d=\"M400.388,175.787c-1.707-3.413-4.267-5.12-7.68-5.12H292.015L391.855,12.8c1.707-2.56,1.707-5.973,0-8.533    S387.588,0,384.175,0H247.642c-3.413,0-5.973,1.707-7.68,4.267l-128,256c-1.707,2.56-1.707,5.973,0,8.533    c1.707,2.56,5.12,4.267,7.68,4.267h87.893l-95.573,227.84c-1.707,3.413,0,7.68,3.413,10.24c0.853,0.853,2.56,0.853,4.267,0.853    c2.56,0,5.12-0.853,6.827-2.56l273.067-324.267C401.242,182.613,402.095,179.2,400.388,175.787z M149.508,454.827l78.507-187.733    c0.853-2.56,0.853-5.12-0.853-7.68c-1.707-1.707-4.267-3.413-6.827-3.413h-87.04L252.762,17.067h116.053L268.122,174.933    c-1.707,2.56-1.707,5.973,0,8.533s4.267,4.267,7.68,4.267h98.987L149.508,454.827z\" fill=\"#FFFFFF\" />\n\t\t</g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "OikLBuTUCMxMzYFpvtODuYIDztGJFhzjKvBGpVuVDhM=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 512 512\" style=\"enable-background:new 0 0 512 512;\" xml:space=\"preserve\" width=\"100%\" height=\"100%\">\n\t<g>\n\t\t<g>\n\t\t\t<g>\n\t\t\t\t<path d=\"M30,92c-8,0-13,0.667-15,2s-2.333,2.833-1,4.5s4.667,4.5,10,8.5c2.667,2,4.667,3.667,6,5l226,172     l226-171l5-5c5.333-4,8.833-6.833,10.5-8.5s1.5-3.333-0.5-5s-7-2.5-15-2.5H241H30z\" fill=\"#FFFFFF\" />\n\t\t\t\t<path d=\"M0,132v254c0,7.333,3,14.833,9,22.5S21,420,27,420h458c6,0,12-3.833,18-11.5s9-15.167,9-22.5V132     L256,328L0,132z\" fill=\"#FFFFFF\" />\n\t\t\t</g>\n\t\t</g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "Gi2ygeOXLpsi6jUuoZVlRXJlZ/4oRK979+KBiKqIYcc=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 24 24\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" enable-background=\"new 0 0 24 24\">\n\t<path d=\"m23,10h-8.5c-0.3,0-0.5-0.2-0.5-0.5v-8.5c0-0.6-0.4-1-1-1h-2c-0.6,0-1,0.4-1,1v8.5c0,0.3-0.2,0.5-0.5,0.5h-8.5c-0.6,0-1,0.4-1,1v2c0,0.6 0.4,1 1,1h8.5c0.3,0 0.5,0.2 0.5,0.5v8.5c0,0.6 0.4,1 1,1h2c0.6,0 1-0.4 1-1v-8.5c0-0.3 0.2-0.5 0.5-0.5h8.5c0.6,0 1-0.4 1-1v-2c0-0.6-0.4-1-1-1z\" />\n</svg>\n",
  "6GsrA1ucxJ3ROgtV+vbMl4pJ5MA2OoA+ZNm2hbVh9Yo=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 384 384\" style=\"enable-background:new 0 0 384 384;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path d=\"M149.333,117.333V32L0,181.333l149.333,149.333V243.2C256,243.2,330.667,277.333,384,352\r\n\t\tC362.667,245.333,298.667,138.667,149.333,117.333z\" />\r\n\t</g>\r\n</svg>\r\n",
  "/JPXVH7ap6Nnn1MFcUUDqbSx0l7h8rvJWcQt5F/OdMA=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 95.561 95.561\" style=\"enable-background:new 0 0 95.561 95.561;\" xml:space=\"preserve\">\n\t<g>\n\t\t<g>\n\t\t\t<path d=\"M95.37,56.591c-0.33-0.701-1.034-1.147-1.81-1.147h-6.955V20.729c0-1.104-0.896-2-2-2H26.677    c-0.776,0-1.482,0.449-1.812,1.152c-0.329,0.703-0.222,1.533,0.275,2.129l7.474,8.963c0.38,0.456,0.943,0.719,1.536,0.719h39.491    v23.75h-6.955c-0.774,0-1.479,0.447-1.81,1.148c-0.33,0.7-0.227,1.528,0.268,2.125l13.437,16.25    c0.381,0.459,0.945,0.727,1.542,0.727c0.598,0,1.162-0.266,1.542-0.727l13.438-16.25C95.597,58.119,95.7,57.291,95.37,56.591z\" fill=\"#FFFFFF\" />\n\t\t\t<path d=\"M62.945,64.587c-0.38-0.455-0.942-0.719-1.536-0.719H21.92v-23.75h6.953c0.008,0,0.014,0,0.021,0c1.104,0,2-0.896,2-2    c0-0.574-0.242-1.091-0.628-1.456l-13.286-16.07c-0.38-0.459-0.945-0.726-1.542-0.726s-1.162,0.266-1.542,0.726L0.459,36.844    C-0.035,37.441-0.14,38.27,0.19,38.97c0.33,0.701,1.035,1.148,1.811,1.148h6.955v34.713c0,1.104,0.896,2,2,2h57.929    c0.775,0,1.481-0.449,1.812-1.152c0.329-0.703,0.223-1.532-0.274-2.129L62.945,64.587z\" fill=\"#FFFFFF\" />\n\t\t</g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "xiImCr9cnkG2Q3oW1io1lcDhw6GUUwTetpYFY7OoB6Q=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 100 100\" style=\"enable-background:new 0 0 100 100;\" xml:space=\"preserve\">\r\n\t<path d=\"M24.9,66V39.9H35L17.5,20L0,39.9h10.1V70c0,5.523,4.476,10,10,10H65L52.195,66H24.9z M89.9,60.1V30\r\n\t\t\tc0-5.523-4.477-10-10-10H35l12.804,14h27.295v26.1H65L82.5,80L100,60.1H89.9z\" />\r\n</svg>\r\n",
  "LAWql+/I2oDA6g4NPAEQGwjRaKRF2oADyGOIKhEuriM=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: IcoMoon.io -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 306 306\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n\t<polygon points=\"94.35,0 58.65,35.7 175.95,153 58.65,270.3 94.35,306 247.35,153\" fill=\"#888\" />\n</svg>\n",
  "5uoYjUmNAayFQvH1raDHOdXWjaozPlzjBI4Hr+waRVw=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 306 306\" style=\"enable-background:new 0 0 306 306;\" xml:space=\"preserve\">\n\t<g>\n\t\t<g id=\"chevron-right\">\n\t\t\t<polygon points=\"94.35,0 58.65,35.7 175.95,153 58.65,270.3 94.35,306 247.35,153   \" fill=\"#888\" />\n\t\t</g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "LqxuSvC7qy12DAXKRQ1lsyNHvbitUI3FnAt/BGNBWKs=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: IcoMoon.io -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\">\n\t<path d=\"M 64.00,416.00l 96.00,96.00l 256.00-256.00L 160.00,0.00L 64.00,96.00l 160.00,160.00L 64.00,416.00z\">\n\t</path>\n</svg>\n",
  "e0fnuhmCNb7Om569CkCw6lcDBiCvZr6XDOa84SaD1qc=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 92.833 92.833\" style=\"enable-background:new 0 0 92.833 92.833;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<path d=\"M89.834,1.75H3c-1.654,0-3,1.346-3,3v13.334c0,1.654,1.346,3,3,3h86.833c1.653,0,3-1.346,3-3V4.75\r\n\t\t\tC92.834,3.096,91.488,1.75,89.834,1.75z\" />\r\n\t\t\t<path d=\"M89.834,36.75H3c-1.654,0-3,1.346-3,3v13.334c0,1.654,1.346,3,3,3h86.833c1.653,0,3-1.346,3-3V39.75\r\n\t\t\tC92.834,38.096,91.488,36.75,89.834,36.75z\" />\r\n\t\t\t<path d=\"M89.834,71.75H3c-1.654,0-3,1.346-3,3v13.334c0,1.654,1.346,3,3,3h86.833c1.653,0,3-1.346,3-3V74.75\r\n\t\t\tC92.834,73.095,91.488,71.75,89.834,71.75z\" />\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "Q05ug8gKz1DVejtOGiOhgzpx0Mmh1GqswLarZtkfbt8=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 410.23 410.23\" style=\"enable-background:new 0 0 410.23 410.23;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path d=\"M401.625,364.092l-107.1-107.1c19.125-26.775,30.6-59.288,30.6-93.713c0-89.888-72.675-162.562-162.562-162.562\r\n\t\tS0,73.392,0,163.279s72.675,162.562,162.562,162.562c34.425,0,66.938-11.475,93.713-30.6l107.1,107.1\r\n\t\tc9.562,9.562,26.775,9.562,38.25,0l0,0C413.1,390.867,413.1,375.566,401.625,364.092z M162.562,287.592\r\n\t\tc-68.85,0-124.312-55.463-124.312-124.312c0-68.85,55.462-124.312,124.312-124.312c68.85,0,124.312,55.462,124.312,124.312\r\n\t\tC286.875,232.129,231.412,287.592,162.562,287.592z\" />\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "7rt7MhkAN/Gg+rYmrT7Ynl68O/rc3rGU4p2MSQGhiK8=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 18.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 334.5 334.5\" style=\"enable-background:new 0 0 334.5 334.5;\" xml:space=\"preserve\">\r\n\t<path d=\"M332.797,13.699c-1.489-1.306-3.608-1.609-5.404-0.776L2.893,163.695c-1.747,0.812-2.872,2.555-2.893,4.481\r\n\ts1.067,3.693,2.797,4.542l91.833,45.068c1.684,0.827,3.692,0.64,5.196-0.484l89.287-66.734l-70.094,72.1\r\n\tc-1,1.029-1.51,2.438-1.4,3.868l6.979,90.889c0.155,2.014,1.505,3.736,3.424,4.367c0.513,0.168,1.04,0.25,1.561,0.25\r\n\tc1.429,0,2.819-0.613,3.786-1.733l48.742-56.482l60.255,28.79c1.308,0.625,2.822,0.651,4.151,0.073\r\n\tc1.329-0.579,2.341-1.705,2.775-3.087L334.27,18.956C334.864,17.066,334.285,15.005,332.797,13.699z\" />\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "Zm1ZR1Egp4yAdzM4xNCxJrJC7A+lbFJnlfzMKswFzes=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" style=\"enable-background:new 0 0 512 512;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<g>\r\n\t\t\t\t<path d=\"M256,192c-35.292,0-64,28.708-64,64s28.708,64,64,64s64-28.708,64-64S291.292,192,256,192z M256,298.667\r\n\t\t\t\tc-23.521,0-42.667-19.135-42.667-42.667s19.146-42.667,42.667-42.667s42.667,19.135,42.667,42.667S279.521,298.667,256,298.667z\" />\r\n\t\t\t\t<path d=\"M256,384c-35.292,0-64,28.708-64,64c0,35.292,28.708,64,64,64s64-28.708,64-64C320,412.708,291.292,384,256,384z\r\n\t\t\t\t M256,490.667c-23.521,0-42.667-19.135-42.667-42.667s19.146-42.667,42.667-42.667s42.667,19.135,42.667,42.667\r\n\t\t\t\tS279.521,490.667,256,490.667z\" />\r\n\t\t\t\t<path d=\"M256,128c35.292,0,64-28.708,64-64S291.292,0,256,0s-64,28.708-64,64S220.708,128,256,128z M256,21.333\r\n\t\t\t\tc23.521,0,42.667,19.135,42.667,42.667S279.521,106.667,256,106.667S213.333,87.531,213.333,64S232.479,21.333,256,21.333z\" />\r\n\t\t\t</g>\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "ykBsmQ5qBYfOlD6oMvWFSCc5YmlrgoT6v4IJ8hg7p+4=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" style=\"enable-background:new 0 0 512 512;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<g>\r\n\t\t\t\t<circle cx=\"256\" cy=\"256\" r=\"64\" />\r\n\t\t\t\t<circle cx=\"256\" cy=\"448\" r=\"64\" />\r\n\t\t\t\t<circle cx=\"256\" cy=\"64\" r=\"64\" />\r\n\t\t\t</g>\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "/dWQCZcWsqUOdn4xlIijasfndzqRwmGgJwILXYQUtGc=": "<?xml version=\"1.0\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 20010904//EN\" \"http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd\">\n<svg version=\"1.0\" xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 64.000000 64.000000\" preserveAspectRatio=\"xMidYMid meet\">\n\t<metadata>\n\t\tCreated by potrace 1.15, written by Peter Selinger 2001-2017\n\t</metadata>\n\t<g transform=\"translate(0.000000,64.000000) scale(0.100000,-0.100000)\" fill=\"#000000\" stroke=\"none\">\n\t\t<path d=\"M101 492 c-54 -27 -93 -83 -99 -141 -7 -72 5 -117 40 -157 54 -61 67\n-64 275 -64 212 0 233 5 286 72 52 66 50 181 -5 244 -54 61 -67 64 -275 64\n-159 0 -193 -3 -222 -18z m170 -55 c93 -62 88 -177 -12 -245 -83 -58 -212 16\n-212 120 0 88 58 148 144 148 31 0 57 -7 80 -23z\" />\n\t</g>\n</svg>\n",
  "KZ5yxZZkEc8jATCf3u/Stpklvq213g1CcrvBJ47QuhI=": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<!-- Creator: CorelDRAW -->\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xml:space=\"preserve\" width=\"100%\" height=\"100%\" style=\"shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd\" viewBox=\"0 0 640 640\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n\t<defs>\r\n\t\t<style type=\"text/css\">\r\n\t\t\t<![CDATA[     .fil0 {fill:black}    ]]>\r\n\t\t</style>\r\n\t</defs>\r\n\t<g id=\"Layer_x0020_1\">\r\n\t\t<metadata id=\"CorelCorpID_0Corel-Layer\" />\r\n\t\t<path class=\"fil0\" d=\"M185.884 128.883l268.232 0c102.226,0 185.884,85.9971 185.884,191.117l0 0c0,105.119 -83.6585,191.117 -185.884,191.117l-268.232 0c-102.226,0 -185.884,-85.9971 -185.884,-191.117l0 0c0,-105.119 83.6585,-191.117 185.884,-191.117zm262.999 40.9493c84.2845,0 152.648,68.3512 152.648,152.636 0,84.2963 -68.363,152.671 -152.648,152.671 -84.2963,0 -152.648,-68.3749 -152.648,-152.671 0,-84.2845 68.3512,-152.636 152.648,-152.636z\" />\r\n\t</g>\r\n</svg>\r\n",
  "TR7BQR5l3d+ykOijtBMChw4cQdtTC2jYiUylS50oSOQ=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: IcoMoon.io -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\">\n\t<path d=\"M 96.00,448.00l-96.00-96.00L 256.00,96.00l 256.00,256.00l-96.00,96.00L 256.00,288.00L 96.00,448.00z\">\n\t</path>\n</svg>\n",
  "YGAbVN5f08Vy7ucASS1O/34AkzhCX5zz13ozrIifpyA=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 45.958 45.958\" style=\"enable-background:new 0 0 45.958 45.958;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<path d=\"M39.287,41.955l-1.626-12.76c-0.556-4.375-4.278-7.61-8.688-7.61H16.985c-4.41,0-8.133,3.235-8.688,7.61L6.67,41.979\r\n\t\t\tc-0.112,0.894,0.163,2.018,0.758,2.692c0.596,0.675,1.453,1.287,2.353,1.287h26.395c0.9,0,1.757-0.624,2.354-1.299\r\n\t\t\tC39.125,43.982,39.4,42.85,39.287,41.955z\" />\r\n\t\t\t<circle cx=\"22.978\" cy=\"9.33\" r=\"9.33\" />\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "rsG1GQj99WN9qlrKmww1KRpBYDCK9tXEeRaHqjIG4aA=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 80.13 80.13\" style=\"enable-background:new 0 0 80.13 80.13;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path d=\"M48.355,17.922c3.705,2.323,6.303,6.254,6.776,10.817c1.511,0.706,3.188,1.112,4.966,1.112\r\n\t\tc6.491,0,11.752-5.261,11.752-11.751c0-6.491-5.261-11.752-11.752-11.752C53.668,6.35,48.453,11.517,48.355,17.922z M40.656,41.984\r\n\t\tc6.491,0,11.752-5.262,11.752-11.752s-5.262-11.751-11.752-11.751c-6.49,0-11.754,5.262-11.754,11.752S34.166,41.984,40.656,41.984\r\n\t\tz M45.641,42.785h-9.972c-8.297,0-15.047,6.751-15.047,15.048v12.195l0.031,0.191l0.84,0.263\r\n\t\tc7.918,2.474,14.797,3.299,20.459,3.299c11.059,0,17.469-3.153,17.864-3.354l0.785-0.397h0.084V57.833\r\n\t\tC60.688,49.536,53.938,42.785,45.641,42.785z M65.084,30.653h-9.895c-0.107,3.959-1.797,7.524-4.47,10.088\r\n\t\tc7.375,2.193,12.771,9.032,12.771,17.11v3.758c9.77-0.358,15.4-3.127,15.771-3.313l0.785-0.398h0.084V45.699\r\n\t\tC80.13,37.403,73.38,30.653,65.084,30.653z M20.035,29.853c2.299,0,4.438-0.671,6.25-1.814c0.576-3.757,2.59-7.04,5.467-9.276\r\n\t\tc0.012-0.22,0.033-0.438,0.033-0.66c0-6.491-5.262-11.752-11.75-11.752c-6.492,0-11.752,5.261-11.752,11.752\r\n\t\tC8.283,24.591,13.543,29.853,20.035,29.853z M30.589,40.741c-2.66-2.551-4.344-6.097-4.467-10.032\r\n\t\tc-0.367-0.027-0.73-0.056-1.104-0.056h-9.971C6.75,30.653,0,37.403,0,45.699v12.197l0.031,0.188l0.84,0.265\r\n\t\tc6.352,1.983,12.021,2.897,16.945,3.185v-3.683C17.818,49.773,23.212,42.936,30.589,40.741z\" />\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "Bg2mkjExPE/WSCEFBNUgqo9jz7/qNPzmAqf7Pn8hN4A=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" style=\"enable-background:new 0 0 512 512;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path d=\"M448,177.14V448c0,35.344-28.656,64-64,64H64c-35.344,0-64-28.656-64-64V128c0-35.344,28.656-64,64-64h270.844l-63.969,64\r\n\t\tH64v320h320V241.156L448,177.14z M398.875,45.25L376.25,67.875l67.875,67.891l22.625-22.625L398.875,45.25z M444.125,0\r\n\t\tL421.5,22.625l67.875,67.891L512,67.875L444.125,0z M150,294.188l67.875,67.875L421.5,158.406l-67.875-67.891L150,294.188z\r\n\t\t M128,384h64l-64-64V384z\" />\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "6xgElmBvS6p2cKnXDynHDtbEkljYJ1wDiTOnvwwI7eU=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 284.936 284.936\" style=\"enable-background:new 0 0 284.936 284.936;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<path d=\"M277.515,135.9L144.464,2.857C142.565,0.955,140.375,0,137.9,0c-2.472,0-4.659,0.955-6.562,2.857l-14.277,14.275\r\n\t\t\tc-1.903,1.903-2.853,4.089-2.853,6.567c0,2.478,0.95,4.664,2.853,6.567l112.207,112.204L117.062,254.677\r\n\t\t\tc-1.903,1.903-2.853,4.093-2.853,6.564c0,2.477,0.95,4.667,2.853,6.57l14.277,14.271c1.902,1.905,4.089,2.854,6.562,2.854\r\n\t\t\tc2.478,0,4.665-0.951,6.563-2.854l133.051-133.044c1.902-1.902,2.851-4.093,2.851-6.567S279.417,137.807,277.515,135.9z\" />\r\n\t\t\t<path d=\"M170.732,142.471c0-2.474-0.947-4.665-2.857-6.571L34.833,2.857C32.931,0.955,30.741,0,28.267,0s-4.665,0.955-6.567,2.857\r\n\t\t\tL7.426,17.133C5.52,19.036,4.57,21.222,4.57,23.7c0,2.478,0.95,4.664,2.856,6.567L119.63,142.471L7.426,254.677\r\n\t\t\tc-1.906,1.903-2.856,4.093-2.856,6.564c0,2.477,0.95,4.667,2.856,6.57l14.273,14.271c1.903,1.905,4.093,2.854,6.567,2.854\r\n\t\t\ts4.664-0.951,6.567-2.854l133.042-133.044C169.785,147.136,170.732,144.945,170.732,142.471z\" />\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "W8R5k23nzbkExNYvtWDzlfyMuRe/dSnFdDEqtAZzGv4=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<rect x=\"7.019\" y=\"15.058\" fill=\"#FFFFFF\" width=\"16.001\" height=\"2\" />\r\n\t\t<rect x=\"7.019\" y=\"21.058\" fill=\"#FFFFFF\" width=\"8.658\" height=\"2\" />\r\n\t\t<polygon fill=\"#FFFFFF\" points=\"30.629,3.414 28.828,1.614 26.128,4.313 23.429,1.614 21.628,3.414 24.328,6.113 21.628,8.813 \r\n\t\t23.429,10.612 26.128,7.913 28.828,10.612 30.629,8.813 27.929,6.113 \t\" />\r\n\t\t<polygon fill=\"#FFFFFF\" points=\"19.508,10.936 17.626,9.057 7.019,9.057 7.019,11.058 19.63,11.058 \t\" />\r\n\t\t<path fill=\"#FFFFFF\" d=\"M26.707,12.734l-0.579-0.579l-0.108,0.108v14.794c0,0.552-0.448,1-1,1H5.019c-0.552,0-1-0.448-1-1V5.057\r\n\t\tc0-0.552,0.448-1,1-1h13.009l-0.643-0.643l1.357-1.357H5.019c-1.657,0-3,1.343-3,3v22.001c0,1.656,1.343,3,3,3H25.02\r\n\t\tc1.656,0,3-1.344,3-3V14.046L26.707,12.734z\" />\r\n\t</g>\r\n</svg>\r\n",
  "baB1jdaWAqaQ/ICKz31jxNltTlZSdyK3YckwbQqobG0=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path fill=\"#FFFFFF\" d=\"M21.02,5.005c2.168,0,4,2.519,4,5.5s-1.832,5.5-4,5.5s-4-2.519-4-5.5S18.852,5.005,21.02,5.005\r\n\t\t M21.02,3.005c-3.313,0-6,3.358-6,7.5c0,4.143,2.687,7.5,6,7.5s6-3.357,6-7.5C27.02,6.363,24.333,3.005,21.02,3.005L21.02,3.005z\" />\r\n\t\t<path fill=\"#FFFFFF\" d=\"M15.927,20.811c-0.356,0.634-0.79,1.192-1.283,1.661c2.406,0.851,4.273,2.495,5.019,4.534H2.375\r\n\t\tc0.745-2.039,2.612-3.684,5.019-4.534C6.9,22.003,6.467,21.444,6.11,20.811c-3.608,1.504-6.092,4.604-6.092,8.195h22\r\n\t\tC22.019,25.415,19.535,22.314,15.927,20.811z\" />\r\n\t\t<g>\r\n\t\t\t<path fill=\"#FFFFFF\" d=\"M29.663,21.005H15.811c-0.487,0.81-1.101,1.492-1.807,2H32.02c0-3.591-2.483-6.69-6.092-8.194\r\n\t\t\tc-0.356,0.633-0.79,1.192-1.283,1.661C27.051,17.321,28.918,18.967,29.663,21.005z\" />\r\n\t\t\t<path fill=\"#FFFFFF\" d=\"M17.019,16.505c0,0.041-0.005,0.08-0.005,0.12c0.128-0.051,0.25-0.108,0.381-0.154\r\n\t\t\tc-0.141-0.134-0.265-0.291-0.396-0.438C17.008,16.19,17.019,16.346,17.019,16.505z\" />\r\n\t\t</g>\r\n\t\t<path fill=\"#FFFFFF\" d=\"M11.019,11.005c2.168,0,4,2.519,4,5.5c0,2.981-1.832,5.5-4,5.5s-4-2.52-4-5.5\r\n\t\tC7.019,13.524,8.851,11.005,11.019,11.005 M11.019,9.005c-3.313,0-6,3.358-6,7.5c0,4.143,2.687,7.5,6,7.5s6-3.357,6-7.5\r\n\t\tC17.019,12.363,14.332,9.005,11.019,9.005L11.019,9.005z\" />\r\n\t</g>\r\n</svg>\r\n",
  "3NySF1M+BlFpdKgiCLUITWDVKchFkR61BhH5wPSQ1jk=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path fill=\"#FFFFFF\" d=\"M26.02,8.008c0.552,0,1,0.449,1,1v14c0,0.552-0.448,1-1,1H6.019c-0.552,0-1-0.448-1-1v-14\r\n\t\tc0-0.551,0.448-1,1-1H26.02 M26.02,6.008H6.019c-1.657,0-3,1.343-3,3v14c0,1.657,1.343,3,3,3H26.02c1.656,0,3-1.343,3-3v-14\r\n\t\tC29.02,7.352,27.676,6.008,26.02,6.008L26.02,6.008z\" />\r\n\t\t<path fill=\"#FFFFFF\" d=\"M16.019,17.008c-0.215,0-0.43-0.069-0.609-0.207l-10.401-8c-0.438-0.336-0.52-0.964-0.184-1.402\r\n\t\tC5.161,6.96,5.789,6.877,6.227,7.215l9.792,7.531l10.214-7.856c0.438-0.337,1.065-0.255,1.402,0.183\r\n\t\tc0.336,0.438,0.255,1.066-0.184,1.402l-10.823,8.325C16.448,16.939,16.233,17.008,16.019,17.008z\" />\r\n\t</g>\r\n</svg>\r\n",
  "ySLntl3dfzYbNgoTBdqy+xs9WSo/jPPnBJ63p1WweMc=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<polygon fill=\"#FFFFFF\" points=\"16.724,21.453 12.094,22.812 13.7,18.262 28.304,4.432 31.326,7.624 \" />\r\n\t<path fill=\"#FFFFFF\" d=\"M24.02,18.675v8.345c0,0.551-0.448,1-1,1H3.019c-0.552,0-1-0.449-1-1v-22c0-0.551,0.448-1,1-1H23.02\r\n\tc0.361,0,0.664,0.203,0.84,0.49l1.466-1.388C24.774,2.454,23.951,2.02,23.02,2.02H3.019c-1.657,0-3,1.343-3,3v22\r\n\tc0,1.656,1.343,3,3,3H23.02c1.656,0,3-1.344,3-3V16.781L24.02,18.675z\" />\r\n\t<g>\r\n\t\t<polygon fill=\"#FFFFFF\" points=\"9.265,21.814 9.545,21.02 5.019,21.02 5.019,23.02 8.839,23.02 \t\" />\r\n\t\t<polygon fill=\"#FFFFFF\" points=\"19.096,9.02 5.019,9.02 5.019,11.02 16.984,11.02 \t\" />\r\n\t\t<polygon fill=\"#FFFFFF\" points=\"11.112,16.581 11.638,16.083 12.761,15.02 5.019,15.02 5.019,17.02 10.957,17.02 \t\" />\r\n\t</g>\r\n</svg>\r\n",
  "pRV/6DXh/b+GeLEkWBax19DQZPTt+K/V8mJzX2bhFrA=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<path fill=\"#FFFFFF\" d=\"M26.02,4.005c0.552,0,1,0.449,1,1v22c0,0.552-0.448,1-1,1H6.019c-0.552,0-1-0.448-1-1v-22\r\n\tc0-0.551,0.448-1,1-1H26.02 M26.02,2.005H6.019c-1.657,0-3,1.343-3,3v22c0,1.657,1.343,3,3,3H26.02c1.656,0,3-1.343,3-3v-22\r\n\tC29.02,3.348,27.676,2.005,26.02,2.005L26.02,2.005z\" />\r\n\t<g>\r\n\t\t<rect x=\"12.019\" y=\"9.005\" fill=\"#FFFFFF\" width=\"12.001\" height=\"2\" />\r\n\t\t<rect x=\"12.019\" y=\"15.005\" fill=\"#FFFFFF\" width=\"12.001\" height=\"2\" />\r\n\t\t<rect x=\"12.019\" y=\"21.006\" fill=\"#FFFFFF\" width=\"12.001\" height=\"2\" />\r\n\t</g>\r\n\t<g>\r\n\t\t<rect x=\"8.019\" y=\"9.005\" fill=\"#FFFFFF\" width=\"2\" height=\"2\" />\r\n\t\t<rect x=\"8.019\" y=\"15.005\" fill=\"#FFFFFF\" width=\"2\" height=\"2\" />\r\n\t\t<rect x=\"8.019\" y=\"21.006\" fill=\"#FFFFFF\" width=\"2\" height=\"2\" />\r\n\t</g>\r\n</svg>\r\n",
  "E8Xuh/aYOqLWlVv+Dwg9Bh7JWeSlZjPnINdz4PB77Tg=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<rect x=\"11.023\" y=\"7.005\" fill=\"#FFFFFF\" width=\"16.001\" height=\"3\" />\r\n\t\t<rect x=\"5.022\" y=\"7.001\" fill=\"#FFFFFF\" width=\"3\" height=\"3\" />\r\n\t\t<rect x=\"11.023\" y=\"14.006\" fill=\"#FFFFFF\" width=\"16.001\" height=\"3\" />\r\n\t\t<rect x=\"5.022\" y=\"14.002\" fill=\"#FFFFFF\" width=\"3\" height=\"3\" />\r\n\t\t<rect x=\"11.023\" y=\"21.006\" fill=\"#FFFFFF\" width=\"16.001\" height=\"3\" />\r\n\t\t<rect x=\"5.022\" y=\"21.002\" fill=\"#FFFFFF\" width=\"3\" height=\"3\" />\r\n\t</g>\r\n</svg>\r\n",
  "MONEwokmzwvC3cVaUZPPsNR5adO6+SFjEDtlI1LEkMU=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<rect x=\"9.016\" y=\"10.003\" fill=\"#FFFFFF\" width=\"14\" height=\"2\" />\r\n\t\t<rect x=\"9.016\" y=\"16.003\" fill=\"#FFFFFF\" width=\"14\" height=\"2\" />\r\n\t\t<path fill=\"#FFFFFF\" d=\"M26.009,4.021h-20c-1.656,0-2.999,1.344-2.999,3v14.001c0,1.656,1.343,3,2.999,3h13.495l6.643,4.981v-4.995\r\n\t\tc1.591-0.074,2.862-1.377,2.862-2.986V7.021C29.009,5.364,27.665,4.021,26.009,4.021z M27.009,21.021c0,0.552-0.448,1-1,1h-1.99\r\n\t\tv0.981v1.019v0.981l-1.309-0.981l0,0l-2.667-2H6.009c-0.551,0-0.999-0.448-0.999-1V7.021c0-0.552,0.448-1,0.999-1h20\r\n\t\tc0.552,0,1,0.448,1,1V21.021z\" />\r\n\t</g>\r\n</svg>\r\n",
  "+heMPb20qCH+9HRzHoZkJvyIHvKoHlsE92mEJUWGcRA=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path fill=\"#FFFFFF\" d=\"M26.02,4.001c0.552,0,1,0.449,1,1v22c0,0.552-0.448,1-1,1H6.019c-0.552,0-1-0.448-1-1v-22\r\n\t\tc0-0.551,0.448-1,1-1H26.02 M26.02,2.001H6.019c-1.657,0-3,1.343-3,3v22c0,1.657,1.343,3,3,3H26.02c1.656,0,3-1.343,3-3v-22\r\n\t\tC29.02,3.344,27.676,2.001,26.02,2.001L26.02,2.001z\" />\r\n\t\t<rect x=\"8.019\" y=\"9.001\" fill=\"#FFFFFF\" width=\"8\" height=\"2\" />\r\n\t\t<rect x=\"8.019\" y=\"15.001\" fill=\"#FFFFFF\" width=\"16.001\" height=\"2\" />\r\n\t\t<rect x=\"8.019\" y=\"21.002\" fill=\"#FFFFFF\" width=\"12\" height=\"2\" />\r\n\t</g>\r\n</svg>\r\n",
  "EUuH2xXJlGXqsCiNZIrN76PfP+EydjXQuC5EEz/LJ4E=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<path fill=\"#FFFFFF\" d=\"M21.837,18.006c-0.33,0.633-0.725,1.202-1.166,1.707c3.516,1.115,6.186,3.444,7.05,6.289H4.317\r\n\tc0.864-2.845,3.534-5.174,7.05-6.289c-0.441-0.505-0.836-1.074-1.166-1.707c-4.825,1.736-8.183,5.554-8.183,9.996H30.02\r\n\tC30.02,23.56,26.661,19.742,21.837,18.006z\" />\r\n\t<path fill=\"#FFFFFF\" d=\"M16.019,6.001c2.711,0,5.001,3.206,5.001,7s-2.29,7-5.001,7c-2.71,0-5-3.206-5-7S13.309,6.001,16.019,6.001\r\n\t M16.019,4.001c-3.865,0-7,4.029-7,9c0,4.971,3.135,9,7,9c3.866,0,7.001-4.029,7.001-9C23.02,8.031,19.885,4.001,16.019,4.001\r\n\tL16.019,4.001z\" />\r\n</svg>\r\n",
  "etFh4I/O9aOZHQ6H1Db3w5Jo9ZDNPlgzdcSNAaJxIN4=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path fill=\"#FFFFFF\" d=\"M16.019,8.201c2.711,0,5.001,3.206,5.001,7c0,3.795-2.29,7-5.001,7c-2.71,0-5-3.205-5-7\r\n\t\tC11.019,11.407,13.309,8.201,16.019,8.201 M16.019,6.201c-3.865,0-7,4.029-7,9s3.135,9,7,9c3.866,0,7.001-4.029,7.001-9\r\n\t\tS19.885,6.201,16.019,6.201L16.019,6.201z\" />\r\n\t</g>\r\n\t<rect x=\"22.013\" y=\"6\" fill=\"#FFFFFF\" width=\"8\" height=\"2\" />\r\n\t<rect x=\"25.013\" y=\"3\" fill=\"#FFFFFF\" width=\"2\" height=\"8\" />\r\n\t<path fill=\"#FFFFFF\" d=\"M21.837,20.205c-0.33,0.633-0.725,1.203-1.166,1.708c3.516,1.114,6.186,3.444,7.05,6.288H4.317\r\n\tc0.864-2.844,3.534-5.174,7.05-6.288c-0.441-0.505-0.836-1.075-1.166-1.708c-4.825,1.736-8.183,5.555-8.183,9.996H30.02\r\n\tC30.02,25.76,26.661,21.941,21.837,20.205z\" />\r\n</svg>\r\n",
  "wQCv9WSePSmQId7vpolJ7L6jyMUGv4YLAeftA/PVQ0E=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<polygon fill=\"#FFFFFF\" points=\"15.723,19.498 11.093,20.857 12.7,16.307 27.303,2.476 30.326,5.668 \t\" />\r\n\t\t<path fill=\"#FFFFFF\" d=\"M26.02,13.878v13.187c0,0.552-0.448,1-1,1H5.019c-0.552,0-1-0.448-1-1V7.063c0-0.552,0.448-1,1-1h14.134\r\n\t\tl2.112-2H5.019c-1.657,0-3,1.343-3,3v20.001c0,1.656,1.343,3,3,3H25.02c1.656,0,3-1.344,3-3V11.983L26.02,13.878z\" />\r\n\t</g>\r\n</svg>\r\n",
  "ceppsRyLhBzNc1PAypgMpzHvDKDvt/VPIK6bR2G8Qus=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path fill=\"#FFFFFF\" d=\"M15.982,4.863c0.013,0,0.024,0,0.036,0s0.023,0,0.035,0c0.036,0.006,0.073,0.01,0.11,0.014\r\n\t\tc3.551,0.318,6.334,4.506,6.348,9.54c-0.04,0.801-0.206,6.158,2.244,8.746c0.521,0.549,1.131,0.946,1.805,1.18v1.577H16.298H15.74\r\n\t\tH5.477v-1.577c0.674-0.233,1.284-0.631,1.805-1.18c2.45-2.588,2.284-7.945,2.244-8.746c0.014-5.034,2.798-9.222,6.349-9.54\r\n\t\tC15.911,4.874,15.947,4.869,15.982,4.863 M16.298,3.346c-0.094,0-0.186,0.014-0.279,0.018c-0.094-0.004-0.185-0.018-0.278-0.018\r\n\t\tv0.037C11.434,3.77,8.025,8.572,8.025,14.455c0,0,0.471,8.635-4.049,8.635v4.33H15.74h0.558h11.763v-4.33\r\n\t\tc-4.52,0-4.049-8.635-4.049-8.635c0-5.883-3.407-10.686-7.714-11.072V3.346L16.298,3.346z\" />\r\n\t\t<circle fill=\"#FFFFFF\" cx=\"15.74\" cy=\"2.629\" r=\"2.629\" />\r\n\t\t<path fill=\"#FFFFFF\" d=\"M20.118,30.75c-2.225,0-4.034-1.81-4.034-4.033h1.5c0,1.396,1.137,2.533,2.534,2.533\r\n\t\ts2.535-1.137,2.535-2.533h1.5C24.153,28.94,22.343,30.75,20.118,30.75z\" />\r\n\t</g>\r\n</svg>\r\n",
  "wsw7fAiZgCrxi4qsVyBRBCKpQXaDj0Rnz6I82YBou7g=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<polygon fill=\"#FFFFFF\" points=\"22.523,12.003 15.522,16.003 22.523,20.003 \" />\r\n\t<path fill=\"#FFFFFF\" d=\"M26.014,4.013c0.552,0,1,0.448,1,1v22.002c0,0.552-0.448,1-1,1h-20c-0.551,0-0.999-0.448-0.999-1V5.013\r\n\tc0-0.552,0.448-1,0.999-1H26.014 M26.014,2.013h-20c-1.656,0-2.999,1.344-2.999,3v22.002c0,1.656,1.343,3,2.999,3h20\r\n\tc1.656,0,3-1.344,3-3V5.013C29.014,3.356,27.67,2.013,26.014,2.013L26.014,2.013z\" />\r\n\t<path fill=\"#FFFFFF\" d=\"M11.791,29.015h-2v-2h2V29.015z M11.791,25.015h-2v-2h2V25.015z M11.791,21.015h-2v-2h2V21.015z\r\n\t M11.791,17.015h-2v-2h2V17.015z M11.791,13.015h-2v-2h2V13.015z M11.791,9.015h-2v-2h2V9.015z M11.791,5.015h-2v-2h2V5.015z\" />\r\n</svg>\r\n",
  "qlhr53STMnYuZOYO4KgCJL1rFJ6VG8AcIFjyQkGgrnM=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<polygon fill=\"#FFFFFF\" points=\"16.519,20.003 23.52,16.003 16.519,12.003 \" />\r\n\t<path fill=\"#FFFFFF\" d=\"M26.009,4.013c0.552,0,1,0.448,1,1v22.002c0,0.552-0.448,1-1,1h-20c-0.551,0-0.999-0.448-0.999-1V5.013\r\n\tc0-0.552,0.448-1,0.999-1H26.009 M26.009,2.013h-20c-1.656,0-2.999,1.344-2.999,3v22.002c0,1.656,1.343,3,2.999,3h20\r\n\tc1.656,0,3-1.344,3-3V5.013C29.009,3.356,27.665,2.013,26.009,2.013L26.009,2.013z\" />\r\n\t<rect x=\"9.786\" y=\"3.015\" fill=\"#FFFFFF\" width=\"2\" height=\"26\" />\r\n</svg>\r\n",
  "9LkL0VWdA0KsoX3MsJoCMsizXCXQ6o4M9NvXunK3tFA=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<g>\r\n\t\t\t\t<path fill=\"#FFFFFF\" d=\"M25.02,22.502c1.379,0,2.5,1.121,2.5,2.5s-1.121,2.5-2.5,2.5s-2.5-1.121-2.5-2.5\r\n\t\t\t\tS23.641,22.502,25.02,22.502 M25.02,21.002c-2.209,0-4,1.791-4,4s1.791,4,4,4s4-1.791,4-4S27.229,21.002,25.02,21.002\r\n\t\t\t\tL25.02,21.002z\" />\r\n\t\t\t</g>\r\n\t\t\t<g>\r\n\t\t\t\t<path fill=\"#FFFFFF\" d=\"M16.019,13.501c1.379,0,2.5,1.122,2.5,2.5c0,1.378-1.121,2.5-2.5,2.5s-2.5-1.122-2.5-2.5\r\n\t\t\t\tC13.519,14.623,14.64,13.501,16.019,13.501 M16.019,12.001c-2.209,0-4,1.791-4,4s1.791,4,4,4s4-1.791,4-4\r\n\t\t\t\tS18.228,12.001,16.019,12.001L16.019,12.001z\" />\r\n\t\t\t</g>\r\n\t\t\t<g>\r\n\t\t\t\t<path fill=\"#FFFFFF\" d=\"M7.018,4.5c1.379,0,2.5,1.122,2.5,2.5s-1.121,2.5-2.5,2.5s-2.5-1.122-2.5-2.5S5.639,4.5,7.018,4.5\r\n\t\t\t\t M7.018,3c-2.209,0-4,1.791-4,4s1.791,4,4,4s4-1.791,4-4S9.227,3,7.018,3L7.018,3z\" />\r\n\t\t\t</g>\r\n\t\t</g>\r\n\t\t<g>\r\n\t\t\t<path fill=\"#FFFFFF\" d=\"M12.019,16.001c0-0.322,0.048-0.631,0.12-0.931H0.017v2h12.165C12.086,16.728,12.019,16.374,12.019,16.001\r\n\t\t\tz\" />\r\n\t\t\t<path fill=\"#FFFFFF\" d=\"M3.018,7c0-0.322,0.048-0.631,0.12-0.931H0.017v2h3.164C3.085,7.728,3.018,7.374,3.018,7z\" />\r\n\t\t\t<path fill=\"#FFFFFF\" d=\"M10.897,6.07c0.072,0.3,0.12,0.609,0.12,0.931c0,0.373-0.067,0.727-0.163,1.069h21.164v-2H10.897z\" />\r\n\t\t\t<path fill=\"#FFFFFF\" d=\"M21.02,25.002c0-0.322,0.048-0.631,0.12-0.931H0.017v2h21.166C21.087,25.729,21.02,25.375,21.02,25.002z\" />\r\n\t\t\t<path fill=\"#FFFFFF\" d=\"M20.019,16.001c0,0.373-0.067,0.727-0.163,1.069h12.163v-2h-12.12\r\n\t\t\tC19.971,15.37,20.019,15.679,20.019,16.001z\" />\r\n\t\t\t<path fill=\"#FFFFFF\" d=\"M29.02,25.002c0,0.373-0.067,0.727-0.163,1.069h3.162v-2h-3.119C28.972,24.371,29.02,24.68,29.02,25.002z\" />\r\n\t\t</g>\r\n\t</g>\r\n</svg>\r\n",
  "ou4RtWKwl4vfjc7ZHjfwbNAjwg+QseDtNjn35J/ww8I=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"  width=\"100%\" height=\"100%\" viewBox=\"0 0 401.994 401.994\">\r\n\t<path d=\"M394,154.175c-5.331-5.33-11.806-7.994-19.417-7.994H255.811V27.406c0-7.611-2.666-14.084-7.994-19.414\r\n\t\tC242.488,2.666,236.02,0,228.398,0h-54.812c-7.612,0-14.084,2.663-19.414,7.993c-5.33,5.33-7.994,11.803-7.994,19.414v118.775\r\n\t\tH27.407c-7.611,0-14.084,2.664-19.414,7.994S0,165.973,0,173.589v54.819c0,7.618,2.662,14.086,7.992,19.411\r\n\t\tc5.33,5.332,11.803,7.994,19.414,7.994h118.771V374.59c0,7.611,2.664,14.089,7.994,19.417c5.33,5.325,11.802,7.987,19.414,7.987\r\n\t\th54.816c7.617,0,14.086-2.662,19.417-7.987c5.332-5.331,7.994-11.806,7.994-19.417V255.813h118.77\r\n\t\tc7.618,0,14.089-2.662,19.417-7.994c5.329-5.325,7.994-11.793,7.994-19.411v-54.819C401.991,165.973,399.332,159.502,394,154.175z\"\r\n\t\t/>\r\n</svg>\r\n",
  "htg5toQYFNrXiHYnUiNiLbEAfwqoLQct3bIobgtBgiM=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 174.239 174.239\" style=\"enable-background:new 0 0 174.239 174.239;\" xml:space=\"preserve\">\r\n\t<path d=\"M146.537,1.047c-1.396-1.396-3.681-1.396-5.077,0L89.658,52.849c-1.396,1.396-3.681,1.396-5.077,0L32.78,1.047\r\n\t\tc-1.396-1.396-3.681-1.396-5.077,0L1.047,27.702c-1.396,1.396-1.396,3.681,0,5.077l51.802,51.802c1.396,1.396,1.396,3.681,0,5.077\r\n\t\tL1.047,141.46c-1.396,1.396-1.396,3.681,0,5.077l26.655,26.655c1.396,1.396,3.681,1.396,5.077,0l51.802-51.802\r\n\t\tc1.396-1.396,3.681-1.396,5.077,0l51.801,51.801c1.396,1.396,3.681,1.396,5.077,0l26.655-26.655c1.396-1.396,1.396-3.681,0-5.077\r\n\t\tl-51.801-51.801c-1.396-1.396-1.396-3.681,0-5.077l51.801-51.801c1.396-1.396,1.396-3.681,0-5.077L146.537,1.047z\" />\r\n</svg>\r\n",
  "Jphu9eYn1YFH99wfkQadp1YZXaISCu+Vq3WfLXj4LLk=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" preserveAspectRatio=\"xMidYMin slice\" viewBox=\"0 0 284.936 284.936\" style=\"enable-background:new 0 0 284.936 284.936;\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<path d=\"M277.515,135.9L144.464,2.857C142.565,0.955,140.375,0,137.9,0c-2.472,0-4.659,0.955-6.562,2.857l-14.277,14.275\r\n\t\t\t\tc-1.903,1.903-2.853,4.089-2.853,6.567c0,2.478,0.95,4.664,2.853,6.567l112.207,112.204L117.062,254.677\r\n\t\t\t\tc-1.903,1.903-2.853,4.093-2.853,6.564c0,2.477,0.95,4.667,2.853,6.57l14.277,14.271c1.902,1.905,4.089,2.854,6.562,2.854\r\n\t\t\t\tc2.478,0,4.665-0.951,6.563-2.854l133.051-133.044c1.902-1.902,2.851-4.093,2.851-6.567S279.417,137.807,277.515,135.9z\" />\r\n\t\t\t<path d=\"M170.732,142.471c0-2.474-0.947-4.665-2.857-6.571L34.833,2.857C32.931,0.955,30.741,0,28.267,0s-4.665,0.955-6.567,2.857\r\n\t\t\t\tL7.426,17.133C5.52,19.036,4.57,21.222,4.57,23.7c0,2.478,0.95,4.664,2.856,6.567L119.63,142.471L7.426,254.677\r\n\t\t\t\tc-1.906,1.903-2.856,4.093-2.856,6.564c0,2.477,0.95,4.667,2.856,6.57l14.273,14.271c1.903,1.905,4.093,2.854,6.567,2.854\r\n\t\t\t\ts4.664-0.951,6.567-2.854l133.042-133.044C169.785,147.136,170.732,144.945,170.732,142.471z\" />\r\n\t\t</g>\r\n\t</g>\r\n</svg>\r\n",
  "gzqCjL2ZPnleYFzmzFrQM4HLYtoLXqvxO5gbD/dZQgA=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"100%\" height=\"100%\" viewBox=\"0 0 51.997 51.997\">\r\n\t<path d=\"M51.911,16.242C51.152,7.888,45.239,1.827,37.839,1.827c-4.93,0-9.444,2.653-11.984,6.905\r\n\t\tc-2.517-4.307-6.846-6.906-11.697-6.906c-7.399,0-13.313,6.061-14.071,14.415c-0.06,0.369-0.306,2.311,0.442,5.478\r\n\t\tc1.078,4.568,3.568,8.723,7.199,12.013l18.115,16.439l18.426-16.438c3.631-3.291,6.121-7.445,7.199-12.014\r\n\t\tC52.216,18.553,51.97,16.611,51.911,16.242z\" />\r\n</svg>\r\n",
  "Y/aWD3bBQXqnTr4SyePk5ITIqc644HmrrWfbdcWFKJ8=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg height='100%' width='100%' viewBox='0 0 16 16' xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n\t<circle stroke-width='1' cx=\"7\" cy=\"7\" r=\"4\" />\r\n</svg>\r\n",
  "y+406ZqF4Qnx/v1TFit7PgfOxGRIP+WjRFYgRDztzN4=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\">\r\n\t<path d=\"M 416.00,416.00l-96.00,96.00L 64.00,256.00L 320.00,0.00l 96.00,96.00L 256.00,256.00L 416.00,416.00z\">\r\n\t</path>\r\n</svg>\r\n",
  "p7guqGDTnmdLbYMqEQkVwWZb1MveUgY/RioNkjxD9yE=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" height='100%' width='100%' viewBox='0 0 16 16'>\r\n\t<circle stroke-width='1' cx=\"7\" cy=\"7\" r=\"6\" />\r\n</svg>\r\n\r\n",
  "847+d+8IOSqpM/X9dlyA2trOF5A++lZmOs7CHAyBjy4=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"100%\" height=\"100%\" viewBox=\"0 0 100 100\">\r\n\t<path d=\"M24.9,66V39.9H35L17.5,20L0,39.9h10.1V70c0,5.523,4.476,10,10,10H65L52.195,66H24.9z M89.9,60.1V30 c0-5.523-4.477-10-10-10H35l12.804,14h27.295v26.1H65L82.5,80L100,60.1H89.9z\" />\r\n</svg>\r\n",
  "lLFn49Y/4Rtb9QRSB5dUihcJOGKeyXsc7XixPjz/0H8=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"100%\" height=\"100%\" viewBox=\"0 0 306 306\">\r\n\t<polygon points=\"94.35,0 58.65,35.7 175.95,153 58.65,270.3 94.35,306 247.35,153\" fill=\"#888\" />\r\n</svg>\r\n",
  "Ss41Nb4mLWs2d2bzqjycl3C5QY9tLOHobhjtIMwROP8=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 284.936 284.936\" style=\"enable-background:new 0 0 284.936 284.936;\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<path d=\"M277.515,135.9L144.464,2.857C142.565,0.955,140.375,0,137.9,0c-2.472,0-4.659,0.955-6.562,2.857l-14.277,14.275\r\n\t\t\t\tc-1.903,1.903-2.853,4.089-2.853,6.567c0,2.478,0.95,4.664,2.853,6.567l112.207,112.204L117.062,254.677\r\n\t\t\t\tc-1.903,1.903-2.853,4.093-2.853,6.564c0,2.477,0.95,4.667,2.853,6.57l14.277,14.271c1.902,1.905,4.089,2.854,6.562,2.854\r\n\t\t\t\tc2.478,0,4.665-0.951,6.563-2.854l133.051-133.044c1.902-1.902,2.851-4.093,2.851-6.567S279.417,137.807,277.515,135.9z\" />\r\n\t\t</g>\r\n\t</g>\r\n</svg>\r\n"
}