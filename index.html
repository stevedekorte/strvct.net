<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="cache-control" content="no-cache">    
    <meta http-equiv="pragma" content="no-cache">      
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=0.1">
    <link rel="manifest" href="/manifest.json">
    <meta name="Description" content="">
    <meta name="theme-color" content="#317EFB"/>
    <link rel="icon" href="resources/favicons/favicon.ico">
    <link rel="apple-touch-icon" href="resources/icons/appicon-black-192x192.png">
    <title>...</title>
    <style>

      
html, body {
    position: absolute;
    overflow: hidden;
    
    overscroll-behavior-x: none;
    overscroll-behavior-y: none;
    
	top: 0px;
	left: 0px;
	
    height: 100%;
    width: 100%;
	
	padding: 0px;
	margin: 0px;
    border: 0px;
    
	background-color: black;
    zoom: 100%;

    font-size: 16px;
    text-size-adjust: 100%; 
    
    -webkit-font-smoothing: antialiased;

    /*
    text-size-adjust: none; 
    -ms-text-size-adjust: none;
    -moz-text-size-adjust: none;
    -webkit-text-size-adjust: none;
    */

    /* text-size-adjust fixes issue with contenteditable fonts being tiny */
    /*
    text-size-adjust: 100%; 
    -ms-text-size-adjust: 100%; 
    -moz-text-size-adjust: 100%; 
    -webkit-text-size-adjust: 100%;
    */

    touch-action: none; /* disable pinch-zoom browser action, but still available to JS */
    -ms-scroll-chaining: none; /* disable left-right paging on windows surface */

}

/* an attempt to deal with tiny fonts on mobile */
html * { 
    min-height: 1px; 
    max-height: 999999px; 
    zoom: 100%;
    /*text-transform: uppercase;*/
}

/* to avoid slow/choppy handling of touchmove events */

html * { 
    touch-action: pan-y; 
}

/* use border-box to make sure padding is included in dom width calculations */

html * { 
    box-sizing: border-box;
}

/* avoid outlines */

html * { 
    outline: none; 
    outline-style: none; 
    -moz-outline-style: none; 
}

html * :focus { 
    outline: none; 
    outline-style: none; 
    -moz-outline-style: none; 
}

html * :active { 
    outline: none; 
    outline-style: none; 
    -moz-outline-style: none; 
}



/*
    IMPORTANT: 
    
        This NEEDS TO BE IN TOP LEVEL FOLDER so the paths are 
        correct when it's css is embedded into index.html.

    NOTES: 
    
        Oher interesting fonts: Blender, Montserrat, MateriaPro, Univ 
*/


/*
@font-face {
    font-family: "AppLight";
    src: url("resources/fonts/Blender Pro/Blender Pro Book.ttf");
}

@font-face {
    font-family: "AppRegular";
    src: url("resources/fonts/Blender Pro/Blender Pro Book.ttf");
}

@font-face {
    font-family: "AppSemiBold";
    src: url("resources/fonts/Blender Pro/Blender Pro Book.ttf");
}

@font-face {
    font-family:"AppExtraBold";
    src: url("resources/fonts/Blender Pro/Blender Pro Book.ttf");
}

@font-face {
	font-family: "AppMono";
    src: url("resources/fonts/Blender Pro/Blender Pro Book.ttf");
    font-display: auto;
}
*/


/* ------------------- */

/*
@font-face {
    font-family: "AppLight";
    src: url("resources/fonts/VectorBattle/VectorBattle.ttf");
    font-display: auto;
}

@font-face {
    font-family: "AppRegular";
    src: url("resources/fonts/VectorBattle/VectorBattle.ttf");
    font-display: auto;
}

@font-face {
    font-family: "AppSemiBold";
    src: url("resources/fonts/VectorBattle/VectorBattle.ttf");
    font-display: auto;
}
*/

/* ------------------- */

/*
@font-face {
    font-family: "AppLight";
    src: url("resources/fonts/Hyperspace/HyperspaceBold.ttf");
    font-display: auto;
}

@font-face {
    font-family: "AppRegular";
    src: url("resources/fonts/Hyperspace/HyperspaceBold.ttf");
    font-display: auto;
}

@font-face {
    font-family: "AppSemiBold";
    src: url("resources/fonts/Hyperspace/HyperspaceBold.ttf");
    font-display: auto;
}
*/

/* ------------------- */

/*
@font-face {
    font-family: "AppLight";
    src: url("resources/fonts/PublicSans/PublicSans Light.woff2");
    font-display: auto;
}

@font-face {
    font-family: "AppRegular";
    src: url("resources/fonts/PublicSans/PublicSans Regular.woff2");
    font-display: auto;
}

@font-face {
    font-family: "AppSemiBold";
    src: url("resources/fonts/PublicSans/PublicSans Semibold.woff2");
    font-display: auto;
}

@font-face {
    font-family:"AppExtraBold";
    src: url("resources/fonts/PublicSans/PublicSans Extra Bold.woff2");
    font-display: auto;
}

@font-face {
	font-family: "AppMono";
    src: url("resources/fonts/PublicSans/PublicSans Regular.woff2");
    font-display: auto;
}

*/ 

/* ---------------------- */


/*
@font-face {
    font-family: "AppLight";
    src: url("resources/fonts/OpenSans/OpenSans Light.ttf");
    font-display: auto;
}

@font-face {
    font-family: "AppRegular";
    src: url("resources/fonts/OpenSans/OpenSans Regular.ttf");
    font-display: auto;
}

@font-face {
    font-family: "AppSemiBold";
    src: url("resources/fonts/OpenSans/OpenSans Semibold.ttf");
    font-display: auto;
}

@font-face {
    font-family:"AppExtraBold";
    src: url("resources/fonts/OpenSans/OpenSans ExtraBold.ttf");
    font-display: auto;
}
*/

/* --- Mono --- */

/*
@font-face {
	font-family: "AppMono";
    src: url("resources/fonts/ShareTechMono/ShareTechMono Regular.ttf");
	unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215;
    font-display: auto;
}
*/

/*
@font-face {
	font-family: "AppMono";
    src: url("resources/fonts/Courier Prime/Courier Prime Code.ttf");
    font-display: auto;
}
*/



.ImageCloseButton {
	display: flex;
	position: absolute;
	
	color: rgba(128, 128, 128, 0.5);
	align-items: center;
	justify-content: center;

	top: 0px;
	right: 0px;
	margin: 0px;
	padding: 0px;	

	max-width: 30px;
	min-width: 30px;

	min-height: 30px;
	max-height: 30px;

	opacity: 0.3;
	z-index: 2;
	border: none;
	box-shadow: none;
}

.ImageCloseButton:hover {
	opacity: 1;
}


.BrowserDefaultHeader {
    position: absolute;
    top: 0px;
    left: 0px;
    height: 40px;
    width: 100%;
    background-color: #dbdbdb;
    text-align: right;
    font-style: bold;
	z-index: 1;
}

.BrowserScrollView::-webkit-scrollbar { 
    display: none;  /*  removes scrollbars on Safari and Chrome */
}

/* 
notes on Scroll bars theme options
::-webkit-scrollbar { width: 10px; } 
::-webkit-scrollbar-track { background: #666; } 
::-webkit-scrollbar-thumb { background-color: #f1f1f1; outline: 1px solid slategrey; } 
::-webkit-scrollbar-thumb:hover { background: #b1b1b1; }
*/




.BMFieldValueView br {
    display: none;
}

.BMFieldValueView * {
    display: inline;
    white-space: nowrap;
}

/*
.BMTextAreaFieldValueView {
    display: flex;
    position: relative;
	padding: 0;
    margin: 0;
    width: auto;
    min-height: auto;

    word-break: break-all;
   	unicode-bidi: embed;
    white-space: pre-wrap;

    font-weight: normal;
    text-align: left;
}
*/


    @font-face{
        font-family:"Helvetica Neue";
        src:url("1489436/89294146-207c-4803-91fe-338f0d0094bd.woff2") format("woff2"),url("1489436/57055fe4-c2d3-4287-bac2-eece43fdcbd3.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica Neue Bold";
        src:url("1489452/7ce0a2f5-eb00-46aa-919c-5b3f3667646c.woff2") format("woff2"),url("1489452/cad22c74-45b4-4c49-9e6a-0cd3768a7bc7.woff") format("woff");
    }
    

    @font-face{
        font-family:"Helvetica";
        src:url("1489436/89294146-207c-4803-91fe-338f0d0094bd.woff2") format("woff2"),url("1489436/57055fe4-c2d3-4287-bac2-eece43fdcbd3.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica Bold";
        src:url("1489452/7ce0a2f5-eb00-46aa-919c-5b3f3667646c.woff2") format("woff2"),url("1489452/cad22c74-45b4-4c49-9e6a-0cd3768a7bc7.woff") format("woff");
    }


    
    
    @font-face{
        font-family:"Helvetica LT W01 Light";
        src:url("1489424/37953885-0443-4c72-a693-9152a9f5a901.woff2") format("woff2"),url("1489424/fcce277c-07e2-4c88-ad8b-a71b484e2cbe.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Light Oblique";
        src:url("1489430/0976eae4-2818-43ff-8f87-70dcbb0f9ea9.woff2") format("woff2"),url("1489430/a26a74ab-9781-4c48-bcfb-e2e63bc068d5.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Roman";
        src:url("1489436/89294146-207c-4803-91fe-338f0d0094bd.woff2") format("woff2"),url("1489436/57055fe4-c2d3-4287-bac2-eece43fdcbd3.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Obliqu1489444";
        src:url("1489444/ac4134ce-b28e-4df9-b88c-a67db965774e.woff2") format("woff2"),url("1489444/6389110a-e983-4d95-8d1f-5a87de018aac.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Bold";
        src:url("1489452/7ce0a2f5-eb00-46aa-919c-5b3f3667646c.woff2") format("woff2"),url("1489452/cad22c74-45b4-4c49-9e6a-0cd3768a7bc7.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Bold O1489460";
        src:url("1489460/3e13f208-91f2-41ec-b1bf-e5b29d486821.woff2") format("woff2"),url("1489460/17d3cf02-3e99-48c3-953a-b26082b28949.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Black";
        src:url("1489468/140cbf94-b441-4980-b031-0a614cdee9a8.woff2") format("woff2"),url("1489468/c13f2d0e-112f-4829-96e7-573d38f83066.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Black Oblique";
        src:url("1489474/471483bd-1422-4548-a1cf-a7fa9fdf5b59.woff2") format("woff2"),url("1489474/07818719-eb0b-475f-ab2b-3cb4ee66e0d9.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Light Cond";
        src:url("1489480/da1e3389-7cb1-4bbe-a8cb-9d8c12bed489.woff2") format("woff2"),url("1489480/a9b0bbff-d4ce-481a-ade4-32c7e112125f.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Light Cn Obl";
        src:url("1489486/ae28463c-ff37-41b4-b03c-4ccb49d556f2.woff2") format("woff2"),url("1489486/a3434dce-e398-47cf-8746-83306c679298.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Condensed";
        src:url("1489492/b2dc2dea-700a-4f4a-8d54-410cab0563eb.woff2") format("woff2"),url("1489492/db750bb2-16e0-4166-a692-163c51ea3190.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Condensed Obl";
        src:url("1489498/836434bb-026b-4b96-9158-34f76cc2cdc6.woff2") format("woff2"),url("1489498/57c443b8-3809-443e-90cb-82c5adee7c79.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Bold Cond";
        src:url("1489504/cc8baf39-7363-4096-9272-744ba5d42550.woff2") format("woff2"),url("1489504/c3e64e07-d679-43dc-982a-6d21239f752e.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Bold Cond Obl";
        src:url("1489510/2bf6c0ba-69c7-4dde-ae8e-80047b60ebc1.woff2") format("woff2"),url("1489510/b659afed-b043-4147-84b5-8ef7fcdbbeef.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Black Cond";
        src:url("1489516/318f10c9-cc4d-47d1-a357-05d8a36bd49c.woff2") format("woff2"),url("1489516/0ec178c4-7cd1-4236-8b55-ad77cb3ceae8.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Black Cn Obl";
        src:url("1489522/2d15f0a2-cc5c-478c-89d0-a5aebc6339ee.woff2") format("woff2"),url("1489522/09e06020-4637-43c8-9783-bf71198454e5.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Compressed";
        src:url("1489528/9a21b599-8254-4b46-af23-7c49a2a127be.woff2") format("woff2"),url("1489528/4464a79b-239b-48ad-88ab-e4518082b9b6.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 X Compressed";
        src:url("1489536/7a971f81-127b-458a-a5ee-02f9290ef997.woff2") format("woff2"),url("1489536/c2db5131-f641-4a27-963c-c1a7435d71da.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Ult Comp";
        src:url("1489544/18bfa02e-fa40-421f-bdf5-ac405949e426.woff2") format("woff2"),url("1489544/cb05eea2-2432-4559-9eb4-83addd62b9e0.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica Inserat LT W01 Rg";
        src:url("1489552/1812bdf9-4db0-46d1-8df8-2d43822ddd1a.woff2") format("woff2"),url("1489552/1311d206-4d5e-4bb7-9eb2-067a37aa10d7.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Narrow";
        src:url("1566264/d9174fff-293c-4d3c-9480-438cfec8ba57.woff2") format("woff2"),url("1566264/3c6ab608-39c8-4a90-849c-c2a32ea0a949.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Narrow Obl";
        src:url("1566270/382794c0-b52b-4279-a296-9c1f37b6cebf.woff2") format("woff2"),url("1566270/8726ba91-3222-4344-878a-87bcb74ac7d3.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Bold Narrow";
        src:url("1566276/94c1b92e-68ab-4029-8e1e-ba7e3e5bcb8b.woff2") format("woff2"),url("1566276/e1f1dbd2-827c-423b-8b9a-660116820c77.woff") format("woff");
    }
    @font-face{
        font-family:"Helvetica LT W01 Bold Nr Obl";
        src:url("1566282/847d8475-4db3-43ce-9bc9-003ce96e1ff6.woff2") format("woff2"),url("1566282/b33db801-fb57-4998-83c2-79868ea9f00b.woff") format("woff");
    }


    </style>
<script>

window.ResourceLoaderIsEmbedded = true

      "use strict"

/*

    ResourceLoaderPanel

    A full page panel that shows load progress.
  
    While running, displays app name, progress bar, and current loading file name.
    On error, displays an error description.
    Used with ResourceLoader.

    Automatically sets up in the document when loading this file via:

        window.ResourceLoaderPanel.shared().startWhenReady()

    When all loading is finished, external code should call:

    		window.ResourceLoaderPanel.shared().stop()  

    Notes:
    This code is a bit ugly because it doesn't have any library dependencies 
    as we need to show it before we load the libraries & need it to tell us about any loading errors.

*/


window.ResourceLoaderPanel = class ResourceLoaderPanel {

    static initThisClass () {
        return this
    }

    static shared () {
        if (!this._shared) {
            this._shared = ResourceLoaderPanel.clone()
        }
        return this._shared
    }

    type() {
        return this.constructor.name
    }

    static clone() {
        const obj = new this()
        obj.init()
        return obj
    }
    
    init() {
        this._error = null;
        this._loadCount = 0
    }
    
    // --- elements ------------------------------------------------

    mainElement () {
        return document.getElementById("ProgressMain")
    }

    iconElement () {
        return document.getElementById("ProgressIcon")
    }

    middleElement () {
        return document.getElementById("ProgressMiddle")
    }

    titleElement () {
        return document.getElementById("ProgressTitle")
    }

    barElement () {
        return document.getElementById("ProgressBar")
    }

    itemElement () {
        return document.getElementById("ProgressItem")
    }

    errorElement () {
        return document.getElementById("ProgressError")
    }

    // --- start ------------------------------------------------

    canStart () {
        const isDefined = window["ResourceLoader"] !== undefined 
        const hasElement = this.mainElement() !== null
        return isDefined && hasElement
    }

    startWhenReady () {
        //console.log("ResourceLoaderPanel.startWhenReady()")
        if (this.canStart()) {
            this.start()
        } else {
            setTimeout(() => { this.startWhenReady() }, 100)
        }
    }

    start () {
        //this.startListeningForErrors()

        //console.log("ResourceLoaderPanel.start()")
        if (!ResourceLoaderClass.shared().isDone()) {
            this.setupHtml()
            this.initTitle()
            this.registerForWindowError()
            this.registerForImports()
        }

        if (ResourceLoaderClass.shared().isDone()) {
            //this.setupHtml()
            this.stop()
        }
        return this
    }

    setupHtml () {
        //console.log("ResourceLoaderPanel.setupHtml()")
        document.body.innerHTML = "<div id='ProgressMain' style='opacity: 0; transition: all 0.3s ease-out; position: absolute; width:100%; height: 100%; background-color: black; z-index: 100000; font-family: AppRegular, Sans-Serif; letter-spacing: 3px; font-size:13px;'> \
<div id='ProgressMiddle' \
style='position: relative; top: 50%; transform: translateY(-50%); height: auto; width: 100%; text-align: center;'> \
<div>\
<div id='ProgressIcon' style='opacity: 0.7; border: 0px dashed yellow; transition: all .6s ease-out; background-position: center; background-repeat: no-repeat; height: 60px; width: 100%; background-size: contain;'></div><br> \
</div>\
<div id='ProgressTitle' style='margin-top: 12px; transition: all .6s ease-out;'></div><br> \
<center><div style='margin-top: 12px; width:170px; height: 4px; border-radius:2px; background-color: #444; text-align: left;'><div id='ProgressBar' style='height:4px; border-radius:2px; background-color:#bbb; transition: all 0s ease-out; letter-spacing: -2.5px;'></div><div></center><br> \
<div id='ProgressItem'  style='color: transparent; transition: all 0.3s ease-out;'></div><br> \
<div id='ProgressError' style='color: red; transition: all .6s ease-out; text-align: center; width: 100%; line-height: 1.7em;'></div> \
</div> \
</div>"
        return this
    }

    initTitle () {
        const title = this.titleElement()
        title.style.color = "#aaa"
        
        if (false) {
            this.iconElement().style.backgroundImage = "url('resources/icons/appicon.svg')";
        } else {
            title.innerHTML = "LOADING"
        }

        if (window.ResourceLoaderIsEmbedded) {
            this.hide()
        }

        setTimeout(() => { this.mainElement().style.opacity = 1 } ,0)

        return this
    }

    hide() {
        this.mainElement().style.visibility = "hidden"
        this.titleElement().style.visibility = "hidden"
    }

    show () {
        this.mainElement().style.visibility = "visible"
        this.titleElement().style.visibility = "visible"
    }

    // --- callabcks ------------------------------------------------

    registerForImports () {
        this._importerUrlCallback = (url, max) => { this.didImportUrl(url, max) }
        ResourceLoaderClass.shared().pushUrlLoadingCallback(this._importerUrlCallback)

        this._importerErrorCallback = (error) => { this.setError(error) }
        ResourceLoaderClass.shared().pushErrorCallback(this._importerErrorCallback)

        return this
    }

    unregisterForImports () {
        ResourceLoaderClass.shared().removeUrlCallback(this._importerUrlCallback)
        ResourceLoaderClass.shared().removeErrorCallback(this._importerErrorCallback)
        return this
    }

    didImportUrl (url, max) {
        this.setCurrentItem(url.split("/").pop())
        //console.log("didImportUrl " + url)
        this.incrementItemCount(max)
        return this
    }

    handleError (errorMsg, url, lineNumber, column, errorObj) {
        if (!this.titleElement()) {
            console.warn("should be unregistered?")
            return false
        }

        //this.titleElement().innerHTML = "ERROR"
        let s = "" + errorMsg

        if (url) {
            s += " in " + url.split("/").pop() + " Line: " + lineNumber;  //+ " Column: "" + column;
        }

        /*
		if (errorObj) {
			s += '<br><br>' +  this.stringForError(errorObj).split("\n").join("<br>")
		}
		*/

        this.setError(s)
        return false;
    }

    registerForWindowError () {
        this._windowErrorCallback = (errorMsg, url, lineNumber, column, errorObj) => {
            return this.handleError(errorMsg, url, lineNumber, column, errorObj)
        }
        window.onerror = this._windowErrorCallback
    }

    unregisterForWindowError () {
        const isRegistered = window.onerror === this._windowErrorCallback
        if (isRegistered) {
            window.onerror = null
        }
    }

    hasLocalStorage () {
        try {
            window.localStorage
            return true
        } catch (e) {
            return false
        }
    }

    maxFileCount () {
        if (!this._maxFileCount) {
            let s = undefined 
            if (this.hasLocalStorage()) {
                s = localStorage.getItem(this.type() + ".maxFileCount");
            }

            if (s) {
                this._maxFileCount = Number(s)
            } else {
                this._maxFileCount = 1
            }
        }
        return this._maxFileCount
    }

    setMaxFileCount (count) {
        this._maxFileCount = count
        if (this.hasLocalStorage()) {
            localStorage.setItem(this.type() + ".maxFileCount", count);
        }
        return this
    }

    incrementItemCount (max) {
        this._loadCount ++
        if (this._loadCount > this.maxFileCount()) {
            this.setMaxFileCount(this._loadCount)
        }

        const e = this.barElement()
        if (e) {
            let p = Math.floor(100 * this._loadCount / this.maxFileCount())
            if (p >= 100) {
                p = 100
                e.style.transition = "all 0.3s"
                e.style.backgroundColor = this._loadCount % 2 ? "#777" : "#ccc"
                e.style.width = this._loadCount % 2 ? "100%" : "95%"
            } else {
                e.style.width = p + "%"
            }
        }
        return this
    }

    setCurrentItem (itemName) {
        const item = this.itemElement()
        this._currentItemName = itemName
        //item.style.opacity = 0
        item.style.color = "#444"
        //item.currentValue = itemName	
        //item.innerHTML = itemName // commented out to make cleaner 
        /*
    	//setTimeout(() => { 
    	    if (item.currentValue === item.innerHTML) {
    	        item.style.opacity = 1
	        }
    	//}, 0)
        */
        return this
    }

    setError (error) {
        const msg = "ERROR: " + this._currentItemName + " : " + error
        console.log(msg)
        this._error = error
        //console.trace()
        this.errorElement().innerHTML = error
        this.show()
        throw new Error(msg)
        return this
    }

    error () {
        return this._error
    }

    removeMainElement () {
        const e = this.mainElement()
        if (e) {
            e.parentNode.removeChild(e)
        }
    }

    stop () {
        this.unregisterForWindowError()

        if (!this.error()) {
            this.fadeOut()
        }
        return this
    }

    fadeOut () {
        const e = this.mainElement()
        if (e) {
            e.style.opacity = 0
        }
        setTimeout(() => { this.close() }, 300)
    }

    /*
    // error listener

    errorListener () {
        if (!this._errorListener) {
            this._errorListener = (error) => {
                this.setError(error.detail)
            }
        }
        return this._errorListener
    }

    startListeningForErrors () {
        window.addEventListener('onLoadError', this.errorListener());
    }

    stopListeningForErrors () {
        window.removeEventListener('onLoadError', this.errorListener());
    }

    postError (detail) {
        const event = new CustomEvent('onLoadError', { detail: detail });
        window.dispatchEvent(event);
    }
    */

    // ---

    close () {
        this.removeMainElement()
        this.unregisterForImports()
        //this.stopListeningForErrors()
        //delete window[this.type()]
    }

}.initThisClass()

window.ResourceLoaderPanel.shared().startWhenReady()


"use strict"

/*

    ResourceLoader

    A simple Javascript importing system.

    Several classes are in this one file to avoid JS loading synchronization issues.
	This runs _import.js which will then reference js and css files and
    _import.js file in it's subfolders.
    
	This makes source reorganizations easier and helps
	keep folder organization aligned with dependency organization
	
	Add an _imports.js file - here's an example. Notice you can reference css files as well.
	
	ResourceLoader.pushRelativePaths([
		"_css.css", 
		"external_libs/_imports.js",
		"resources/data/_imports.js",
		"source/_imports.js",
		"MyApp.js",
	])
	
	The paths in each _imports.js file are relative to the folder it is found within.

	If you need to call some initialization functions after everything is loaded, 
	you can call ResourceLoader.pushDoneCallback() in the related folder's _imports.js

		ResourceLoader.pushDoneCallback( () => {
			sjcl.random.startCollectors();
		})		

    Note: Should probably clean this up with promises.
    
*/

function IsInBrowser() {
	return (typeof document !== 'undefined')
}

Object.defineSlot = function(obj, slotName, slotValue) {
    //if (!Object.hasOwnSlot(obj, slotName, slotValue)) {
    const descriptor = {
        configurable: true,
        enumerable: false,
        value: slotValue,
        writable: true,
    }
    Object.defineProperty(obj, slotName, descriptor)
    //}
}

if (!String.prototype.capitalized) {
    Object.defineSlot(String.prototype, "capitalized", 
        function () {
            return this.replace(/\b[a-z]/g, function (match) {
                return match.toUpperCase();
            });
        }
    )
}

class ResourceLoaderBase {

    static shared() {
        if (!this._shared) {
            this._shared = this.clone()
        }
        return this._shared
    }

    type() {
        return this.constructor.name
    }

    static clone() {
        const obj = new this()
        obj.init()
        return obj
    }
    
    init() {
        // subclasses should override to initialize
    }

    newSlot(slotName, initialValue) {
        if (typeof(slotName) !== "string") {
            throw new Error("slot name must be a string"); 
        }

        if (initialValue === undefined) { 
            initialValue = null 
        };

        const privateName = "_" + slotName;
        this[privateName] = initialValue;

        if (!this[slotName]) {
            this[slotName] = function () {
                return this[privateName];
            }
        }

        const setterName = "set" + slotName.capitalized()

        if (!this[setterName]) {
            this[setterName] = function (newValue) {
                this[privateName] = newValue;
                return this;
            }
        }

        return this;
    }
}

// --- CSSLink ---------------------------------------------------

class CSSLink extends ResourceLoaderBase {
    init() {
        super.init()
        this.newSlot("fullPath", null);
        // subclasses should override to initialize
    }

    run () {
        if (!IsInBrowser()) {
            return
        }

        const styles = document.createElement("link")
        styles.rel = "stylesheet"
        styles.type = "text/css"
        styles.media = "screen"
        styles.href = this.fullPath()
        document.getElementsByTagName("head")[0].appendChild(styles)
    }
}

// --- JSScript ---------------------------------------------------

class JSScript extends ResourceLoaderBase {
    init() {
        super.init()
        this.newSlot("importer", null);
        this.newSlot("fullPath", null);
        this.newSlot("doneCallback", null);
    }

    run () {
        //console.log("JSScript run " + this.fullPath())
        
        if (IsInBrowser()) {
            //this.runUsingImport() // can't use with file:// due to CORS
            this.runInBrowser()
        } else {
            setTimeout(() => { this.runInNode() }, 1)
            //setTimeout(() => { this.runUsingImport() }, 1)
            //this.runInNode()
        }
    }

    runInNode () {
        //const path = __dirname + "/" + this.fullPath()
        //console.log("__dirname = ", __dirname)
        //const path = "../../" + this.fullPath()
        const path = this.fullPath()
        //console.log("runInNode path: ", path)
        //root_require(path)

        try {
            root_require(path)
            this._doneCallback()
        } catch (error) {
            this.importer().setError(error)
            throw new Error(error.essage + " loading url " + path)
        }

        //console.log("required path: ", path)
    }

    runUsingImport () {
        const path = this.fullPath()
        
        console.log("ResourceLoader runInImport " + path)

        import(path).then((module) => {
            this._doneCallback()
        }).catch((error) => {
            this.importer().setError(error)
            throw new Error("missing url " + this.fullPath())
        })
    }

    runInBrowser () {
        const script = document.createElement("script")
        //console.log("JSScript loading: '" + this.fullPath() + "'")

        script.src = this.fullPath()

        script.onload = () => {
            //console.log("loaded script src:'" + script.src + "' type:'" + script.type + "' text:[[[" + script.text + "]]]")
            this._doneCallback()
        }

        script.onerror = (error) => {
            this.importer().setError(error)
            throw new Error("missing url " + this.fullPath())
        }

        const parent = document.getElementsByTagName("head")[0] || document.body
        parent.appendChild(script)
    }

    basePath () {
        const parts = this.fullPath().split("/")
        parts.pop()
        const basePath = parts.join("/")
        return basePath
    }
}

// --- ResourceLoader -----------------------------------------------

class ResourceLoaderClass extends ResourceLoaderBase {

    init() {
        super.init()
        this.newSlot("currentScript", null);
        this.newSlot("urls", []);
        this.newSlot("doneCallbacks", []),
        this.newSlot("urlLoadingCallbacks", []);
        this.newSlot("errorCallbacks", []);
        
        this.newSlot("jsFilesLoaded", []) // these may be embedded in index.html
        this.newSlot("cssFilesLoaded", [])  // these may be embedded in index.html

        //this.newSlot("archive", null)

        this.newSlot("resourceFilePaths", [])
        this._maxUrlCount = 0
    }

    resourceFilePathsWithExtensions(extensions) {
        return this.resourceFilePaths().select(path => extensions.contains(path.pathExtension().toLowerCase()))
    }

    currentScriptPath () {
        if (this.currentScript()) {
            return this.currentScript().basePath()
        }
        return ""
    }

    absolutePathForRelativePath (aPath) {
        const parts = this.currentScriptPath().split("/").concat(aPath.split("/"))
        let rPath = parts.join("/")

        if (rPath[0] === "/"[0]) {
            rPath = "." + rPath
        }

        return rPath
    }

    absolutePathsForRelativePaths (paths) {
        return paths.map((aPath) => { return this.absolutePathForRelativePath(aPath) })
    }

    pushRelativePaths (paths) {
        this.pushFilePaths(this.absolutePathsForRelativePaths(paths))
        return this
    }

    pushFilePaths (paths) {
        this.setUrls(paths.concat(this.urls()))
        this._maxUrlCount += paths.length
        return this
    }

    pushDoneCallback (aCallback) {
        this.doneCallbacks().push(aCallback)
        return this
    }

    pushUrlLoadingCallback (aCallback) {
        this.urlLoadingCallbacks().push(aCallback)
        return this
    }

    pushErrorCallback (aCallback) {
        this.errorCallbacks().push(aCallback)
        return this
    }

    removeErrorCallback (aCallback) {
        this.errorCallbacks().remove(aCallback)
        return this
    }

    removeUrlCallback (aCallback) {
        this.urlLoadingCallbacks().remove(aCallback)
        return this
    }

    // --- run ---

    run () {
        this.loadNext()
    }

    isDone () {
        return this.urls().length === 0
    }

    loadNext () {
        if (!this.isDone()) {
            const url = this.urls().shift()
            this.loadUrl(url)
        } else {
            this.done()
        }
        return this
    }

    loadUrl (url) {
        this.urlLoadingCallbacks().forEach(callback => callback(url, this._maxUrlCount))

        const extension = url.split(".").pop().toLowerCase()
        //const fontExtensions = ["ttf", "woff", "woff2"]
        //const audioExtensions = ["wav", "mp3", "m4a", "mp4", "oga", "ogg"]
        //const imageExtensions = ["png", "jpg", "jpeg", "gif", "tiff", "bmp"]

        if (extension === "js" /*|| extension === "json"*/) {
            this.jsFilesLoaded().push(url)
            const script = JSScript.clone().setImporter(this).setFullPath(url).setDoneCallback(() => { this.loadNext() })
            this.setCurrentScript(script)
            this.currentScript().run()
        } else if (extension === "css") {
            this.cssFilesLoaded().push(url)
            CSSLink.clone().setFullPath(url).run() // move to CSSResources?
            this.loadNext()
        } else {
            this.resourceFilePaths().push(url)
            this.loadNext()
        }

        /*
        } else if (fontExtensions.contains(extension)) {
            this.fontFilePaths().push(url)
            this.loadNext()
        } else if (audioExtensions.contains(extension)) {
            this.audioFilePaths().push(url)
            this.loadNext()
        } else if (imageExtensions.contains(extension)) {
            this.imageFilePaths().push(url)
            this.loadNext()
        } else {
            throw new Error("unrecognized extension on url '" + url + "'")
        }
        */

        return this
    }

    done () {
        //console.log("ResourceLoader.done() -----------------------------")
        this.doneCallbacks().forEach(callback => callback())
        return this
    }

    setError (error) {
        this.errorCallbacks().forEach(callback => callback(error))
        return this
    }
}






window.ResourceLoader = ResourceLoaderClass.shared()

if (window.ResourceLoaderIsEmbedded !== true) {
    ResourceLoader.pushRelativePaths(["_imports.js"]).run()
    //ResourceLoader.pushRelativePaths(["../../_imports.js"]).run()
}

ResourceLoader.pushRelativePaths([
    "_css.css",
    "_fonts.css",
    //"external_libs/_imports.js", // import these from apps that need them
    //"resources/data/_imports.js",
    "source/_imports.js",
    "resources/_imports.js",
]);

"use strict"

ResourceLoader.pushRelativePaths([
    "getGlobalThis.js",
    "library/_imports.js",
    "apps/_imports.js",
])




// A naive attempt at getting the global `this`. Donâ€™t use this!
function getGlobalThis() {
	if (typeof globalThis !== 'undefined') return globalThis;
	if (typeof self !== 'undefined') return self;
	if (typeof window !== 'undefined') {
		window.global = window
		return window;
	}
	if (typeof global !== 'undefined') {
		global.window = global
		return global;
	}
	// Note: this might still return the wrong result!
	if (typeof this !== 'undefined') return this;
	throw new Error('Unable to locate global `this`');
  };
  getGlobalThis().getGlobalThis = getGlobalThis;

"use strict"

ResourceLoader.pushRelativePaths([
    "ideal/_imports.js",
    "notification/_imports.js",
    "storage/_imports.js",
    "view/_imports.js",
    "node/_imports.js",
    "resources/_imports.js",
])

"use strict"

ResourceLoader.pushRelativePaths([
    "categories/_imports.js",
    "Slot.js",
    //"Proto.js",
    "ProtoClass.js",
    "Documentation.js",
    "array/_imports.js",
    "dictionary/_imports.js",
    "StackTrace.js",
    "formatters/_imports.js",
    //"FilePath.js",
    //"proxies/_imports.js",
    "NamespaceSearch.js"
]);



"use strict"

ResourceLoader.pushRelativePaths([
    "Mirror.js",
    "Type-ideal.js",
    "Object-ideal.js",
    //"Object-associations.js",
    "Object-puuid.js",
    "Object-mutation.js",
    "Array-ideal.js",
    "Date-ideal.js",
    "String-ideal.js",
    "Number-ideal.js",
    "Boolean-ideal.js",
    "Set-ideal.js",
    "Error-ideal.js",
    "Function-ideal.js",
    "Image-ideal.js",
    "TypedArray-ideal.js",
]);


/*

	An object wrapper for the Reflect functions

*/

window.Mirror = class Mirror extends Object {
	
	static reflectOn (aTarget) {
		return this.clone().setTarget(aTarget)
	}

    static clone () {
        const obj = new this()
		obj.init()
        return obj
    }
	
	init () {
	}
	
	// target 
	
	setTarget (aTarget) {
		this._target = aTarget
		return this
	}
	
	target () {
		return this._target
	}

	// reflect methods

	defineProperty (propertyKey, attributes) {
		return Reflect.defineProperty(this.target(), propertyKey, attributes)		
	}
	
	deleteProperty (propertyKey) {
		return Reflect.deleteProperty(this.target(), propertyKey)
	}
	
	get (propertyKey, optionalReceiver) {
		return Reflect.get(this.target(), propertyKey, optionalReceiver)
	}

	getOwnPropertyDescriptor (propertyKey) {
		return Reflect.getOwnPropertyDescriptor(this.target(), propertyKey)
	}
	
	getPrototype () {
		return Reflect.getPrototypeOf(this.target())
	}

	has (propertyKey) {
		return Reflect.has(this.target(), propertyKey)
	}

	isExtensible () {
		return Reflect.isExtensible(this.target())
	}

	ownKeys () {
		return Reflect.ownKeys(this.target())
	}

	preventExtensions () {
		return Reflect.preventExtensions(target)
	}

	set (propertyKey, value, optionalReceiver) {
		return Reflect.set(this.target(), propertyKey, value, optionalReceiver)
	}

	setPrototype (prototype) {
		return Reflect.setPrototypeOf(this.target(), prototype)
	}
	
}

"use strict"

/*

    Type-ideal

    Value/reference type related functions.

    Example use:

        if (Type.isNullOrUndefined(value)) { ...}


    Known types:

        Literals:

            null
            undefined
            string
            symbol
            number

        Other types:

            object
            array

            Int8Array
            Uint8Array
            Uint8ClampedArray
            Int16Array
            Uint16Array
            Int32Array
            Uint32Array
            Float32Array
            Float64Array
            BigInt64Array
            BigUint64Array


    More example uses:

        const i8a = new Int8Array(6);   
        console.log("is a Int8Array: ", Type.isInt8Array(i8a))

*/

window.Type = {

    allTypeNames: function() {
        return [
            "Array",
            "Boolean",
            "Map",
            "Null",
            "Number",
            "Set",
            "String",
            "Symbol",
            "Int8Array",
            "Uint8Array",
            "Uint8ClampedArray",
            "Int16Array",
            "Uint16Array",
            "Int32Array",
            "Uint32Array",
            "Float32Array",
            "Float64Array",
            "BigInt64Array",
            "BigUint64Array",
            //"TypedArray",
            "Undefined",
            "Object", // put object last so other types have preference
        ]
    },

    typedArrayTypeNames: function() {
        return [
            "Int8Array",
            "Uint8Array",
            "Uint8ClampedArray",
            "Int16Array",
            "Uint16Array",
            "Int32Array",
            "Uint32Array",
            "Float32Array",
            "Float64Array",
            "BigInt64Array",
            "BigUint64Array",
        ]
    },

    isClass: function(v) {
        const result = typeof(v) === "function"
            && /^class\s/.test(Function.prototype.toString.call(v));

        return result
    },

    isLiteral: function(v) {
        return  Type.isString(v) ||
                Type.isNumber(v) ||
                Type.isBoolean(v) ||
                Type.isNull(v) ||
                Type.isUndefined(v);
    },

    isArray: function(value) {
        return !Type.isNull(value) && 
                Type.isObject(value) && 
                value.__proto__ === ([]).__proto__ &&
                !Type.isUndefined(value.length)
    },

    isSet: function(value) {
        return !Type.isNull(value) && 
            Type.isObject(value) && 
            value.__proto__ === Set.prototype 
    },

    isMap: function(value) {
        return !Type.isNull(value) && 
            Type.isObject(value) && 
            value.__proto__ === Map.prototype 
    },  

    isIterator: function(value) {
        return !Type.isNull(value) && 
                Type.isObject(value) && 
                typeof(value[Symbol.iterator]) === "function";
    },

    isBoolean: function(value) {
        return typeof(value) === "boolean"
    },   

    isFunction: function(value) {
        return typeof(value) === "function"
    },  

    isUndefined: function(value) {
        return value === undefined // safe in modern browsers, even safe in older browsers if undefined is not redefined
    },

    isNull: function(value) {
        return value === null
    },

    isNullOrUndefined: function(value) {
        return this.isUndefined(value) || this.isNull(value)
    },

    isNumber: function(value) {
        return typeof(value) === "number"
    },

    isObject: function(value) { 
        // WARNING: true for array and dictionary too!
        return typeof(value) === "object" 
    },

    isString: function(value) {
        return typeof(value) === "string"
    }, 

    isSymbol: function(value) {
        return typeof(value) === "symbol"
    }, 

    // typed arrays 

    valueHasConstructor: function(v, constructor) {  // private
        return !Type.isNullOrUndefined(v) && (Object.getPrototypeOf(v) === constructor.prototype);
    },

    isInt8Array: function(v) {
        return Type.valueHasConstructor(v, Int8Array);
    },

    isUint8Array: function(v) {
        return Type.valueHasConstructor(v, Uint8Array);
    },

    isUint8ClampedArray: function(v) {
        return Type.valueHasConstructor(v, Uint8ClampedArray);
    },

    isInt16Array: function(v) {
        return Type.valueHasConstructor(v, Int16Array);
    },

    isUint16Array: function(v) {
        return Type.valueHasConstructor(v, Uint16Array);
    },

    isInt32Array: function(v) {
        return Type.valueHasConstructor(v, Int32Array);
    },

    isUint32Array: function(v) {
        return Type.valueHasConstructor(v, Uint32Array);
    },
    
    isFloat32Array: function(v) {
        return Type.valueHasConstructor(v, Float32Array);
    },

    isFloat64Array: function(v) {
        return Type.valueHasConstructor(v, Float64Array);
    },

    isBigInt64Array: function(v) {
        return Type.valueHasConstructor(v, BigInt64Array);
    },

    isBigUint64Array: function(v) {
        return Type.valueHasConstructor(v, BigUint64Array);
    },

    
    isTypedArray: function(v) {
        return Type.valueHasConstructor(v, TypedArray);
    },
    

    // type name

    typeName: function(value) {
        if (value === null) {
            return "Null"
        }

        if (Type.isObject(value)) {
            //return value.type()
            return value.constructor.name
        }

        const typeNames = this.allTypeNames()
        for (let i = 0; i < typeNames.length; i++) {
            const typeName = typeNames[i]
            const methodName = "is" + typeName
            if (this[methodName].apply(this, [value])) {
                return typeName
            }
        }
        throw new Error("unable to identify type for value: ", value)
    },

    typeNamesForValue: function(value) {
        const matches = []
        const typeNames = this.allTypeNames()
        for (let i = 0; i < typeNames.length; i++) {
            const typeName = typeNames[i]
            const methodName = "is" + typeName
            if (this[methodName].apply(this, [value])) {
                matches.push(typeName)
            }
        }
        return matches
    },

    assertValueTypeNames: function(v, validTypeNames) {
        let doesMatch = true
        const foundTypeNames = this.typeNamesForValue(v)
        if (foundTypeNames.length === validTypeNames.length) {
            for (let i = 0; i < foundTypeNames.length; i ++) {
                const name = foundTypeNames[i]
                if (!validTypeNames.includes(name)) {
                    doesMatch = false;
                    break;
                }
            }
        } else {
            doesMatch = false
        }
        if (!doesMatch) {
            throw new Error(JSON.stringify(validTypeNames) + " != " + JSON.stringify(foundTypeNames) )
        }
    },

    test: function() { // private
        this.assertValueTypeNames(null, ["Null", "Object"])
        this.assertValueTypeNames(undefined, ["Undefined"])
        this.assertValueTypeNames("foo", ["String"])
        this.assertValueTypeNames(1, ["Number"])
        this.assertValueTypeNames([], ["Array", "Object"])
        this.assertValueTypeNames({}, ["Object"])
        this.assertValueTypeNames(new Int8Array(), ["Int8Array", "Object"])

        // extras
        //assert(Type.isNullOrUndefined(undefined))
        //assert(Type.isNullOrUndefined(null))
    },

}

//Type.test()
//"use strict"

/*

    Object-ideal
    
    Object isn't a prototype or class, it's more like a namespace to organize
    some functions that take an object as an argument. JS ugliness.

*/


/*
    
    Weird JS things:

    The Array, Set, and Map constructors do not inherit from Object 
    (they and the Object constructor all inherit from constructor named "")
    but their constructor prototypes *do* inherit from Object.prototype.

    To make this consistent (so we can inherit class methods) we do
    the following:

*/

const classesToFix =[Array, Set, Map]
classesToFix.forEach(aClass => aClass.__proto__ = Object)


Object.hasOwnSlot = function(obj, slotName) {
    const descriptor = Object.getOwnPropertyDescriptor(slotName)
    return !Type.isUndefined(descriptor)
}

Object.defineSlot = function(obj, slotName, slotValue) {
    //if (Object.hasOwnSlot(obj, slotName)) {
    if (Object.getOwnPropertyDescriptor(slotName)) {
            this[slotName] = slotValue
    } else {
        const descriptor = {
            configurable: true,
            enumerable: false,
            value: slotValue,
            writable: true,
        }
        Object.defineProperty(obj, slotName, descriptor)
    }
}

/*
window.Test = class Test {
    setup () {
        this._foo = 123
    }
}

Object.defineSlot(Test.prototype, "_foo", "bar")

let test = new Test()
test.setup()

console.log(test)
let d = Reflect.getOwnPropertyDescriptor(test, "_foo")
console.log(d)

if(d.enumerable) {
    console.log("is enumerable")
} else {
    console.log("is not enumberable")
}
*/

Object.defineSlotIfNeeded = function(obj, slotName, slotValue) {
    if (this.hasOwnProperty(slotName)) {
        this[slotName] = slotValue
    } else {
        Object.defineSlot(obj, slotName, slotValue)
    }
}


Object.defineSlots = function(obj, dict) {
    Object.keys(dict).forEach((slotName) => {
        const slotValue = dict[slotName]
        Object.defineSlot(obj, slotName, slotValue)
    })
}

const classSlots = {

    clone: function() {
        const obj = new this()
        obj.init()
        return obj
    },

    type: function() {
        return this.name
    },

    isClass: function() {
        return true
    },

    initThisClass: function () {
        //console.log("Prototype " + this.type() + " initThisClass")
        if (this.prototype.hasOwnProperty("initPrototype")) {
            this.prototype.initPrototype.apply(this.prototype)
        }
        this.addToAllClasses()
        return this
    },

    superClass: function () {
        return this.__proto__
    },

    _allClassesSet: new Set(),


    addToAllClasses: function () {
        const allClassesSet = Object._allClassesSet
        if (allClassesSet.has(this)) {
            throw new Error("attempt to call initThisClass twice on the same class")
        }
        allClassesSet.add(this)
        return this
    },
    
    allSubclasses () {
        return this._allClassesSet.select(aClass => aClass.hasAncestorClass(this))
    },

    hasAncestorClass (aClass) {
        const sc = this.superClass()
        
        if (sc === aClass) {
            return true
        }
        
        if (sc === Object || !sc.hasAncestorClass) {
            return false
        }

        return sc.hasAncestorClass(aClass)
    },

    eachSlot: function (obj, fn) {
        Object.keys(obj).forEach(k => fn(k, obj[k]) )
    },
    
    values: function (obj) {
        const values = [];
        obj.ownForEachKV((k, v) => values.push(v))
        return values;
    },

    asValueKeyDict (obj) {
        const dict = {}
        obj.ownForEachKV((k, v) => dict[v] = k)
        return dict
    },

    isKindOf: function(aClass) {
        //assert(this.isClass())
        //assert(aClass.isClass())
        
        if (this.name === "") {
            // anything touching the root "" class seems to crash Chrome,
            // so let's be carefull to leave it along
            return false
        }

        if (this === aClass) {
            return true 
        }
        
        let proto = this.__proto__
        if (proto && proto.name !== "") {
            return proto.isKindOf.apply(proto, [aClass])
        }

        return false
    },


}

Object.defineSlots(Object, classSlots)

// --- prototype ---

const prototypeSlots = {

    initPrototype: function() {
        Object.defineSlot(this, "_hasDoneInit", false) 
        //Object.defineSlot(this, "_hasRetired", false) 
        Object.defineSlot(this, "_mutationObservers", null) 
        Object.defineSlot(this, "_shouldStore", true)
    },

    clone: function () {
        let obj = new this()
        /*
        let aClass = this.thisClass()
        assert(aClass !== this)
        let obj = aClass.clone()
        */
        return obj
    },

    init: function() {
        this.scheduleDidInit()
    },

    isPrototype: function() {
        return this.constructor.prototype === this 
    },
    
    isInstance: function() {
        return !this.isPrototype()
    },

    isClass: function() {
        return false
    },

    thisClass: function() {
        if (this.isPrototype()) {
            return this.constructor
        }
        return this.__proto__.constructor
    },

    thisPrototype: function() {
        assert(this.isInstance())
        const prototype = this.__proto__
        assert(prototype.isPrototype)
        return prototype
    },

    type: function() {
        return this.constructor.name
    },


    // --- mutation ---
   
    mutatorMethodNamesSet: function () {
        throw new Error("undefined mutatorMethodNamesSet on '" + this.type() + "' class")
    },

    setupMutatorHooks: function() {
        this.mutatorMethodNamesSet().forEach((slotName) => {
            const unhookedName = "unhooked_" + slotName
            const unhookedFunction = this[slotName]

            Object.defineSlot(this, unhookedName, unhookedFunction)

            const hookedFunction = function() {
                this.willMutate(slotName)
                const result = this[unhookedName].apply(this, arguments)
                this.didMutate(slotName)

                /*
                let argsString = []
                for (let i=0; i < arguments.length; i++) {
                    if (i !== 0) { argsString += ", " }
                    argsString += String(arguments[i])
                }
                console.log("hooked Array " + slotName + "(" + argsString + ")") 
                console.log("result = " + result)
                */

                return result
            }

            Object.defineSlot(this, slotName, hookedFunction)
        })
    },

    willMutate: function() {

    },

    didMutate: function() {

    },

    // -------------------

    perform: function(methodName, arg1, arg2, arg3) {
        const f = this[methodName]
        if (f) {
            return f.call(this, arg1, arg2, arg3)
        }
        throw new Error(this.typeId() + " does not repsond to '" + methodName + "'")
    },

    performIfResponding: function(methodName, arg1, arg2, arg3) {
        const f = this[methodName]
        if (f) {
            return f.call(this, arg1, arg2, arg3)
        }
    },


    // -------------------
    
    shallowCopy: function () {
        let copy = Object.assign({}, this);
        return copy
    },

    at (key) {
        return this[key] 
    },

    atPut(key, value) {
        this[key] = value
        return this
    },

    removeAt (key) {
        delete this[key]
        return this
    },

    ownKVMap (fn) {
        return Object.keys(this).map(k => fn(k, this[k]) )
    },

    ownForEachValue: function(fn) {
        Object.keys(this).forEach( k => fn(this[k]) )
        return this
    },

    ownForEachKey: function(fn) {
        Object.keys(this).forEach( k => fn(k) )
        return this
    },
    
    ownForEachKV: function(fn) {    
        Object.keys(this).forEach( k => fn(k, this[k]) )
        return this
    },

    /*
    mapToArrayKV: function(fn) {
        const m = []
        Object.keys(this).forEach((k) => {
            const v = this[k]
            const r = fn(k, v)
            m.push(r)
        }); 
        return m
    },
    */

    isEqual: function(anObject) { 
        // compare like we would two dictionaries
        // only checks enumerable properties
        const keys = Object.keys(this)
        const otherKeys = Object.keys(anObject)
        if (keys.length !== otherKeys.length) {
            return false
        }

        const foundInequality = keys.detect(k => this.getOwnProperty(k) !== anObject.getOwnProperty(k))
        return !foundInequality
    },

    getOwnProperty: function(key) {
        if (this.hasOwnProperty(key)) {
            return this[key]
        }
        return undefined
    },

    /*
    setOwnProperty: function(key, value) {
        Object.defineSlot(this, key, value)
        return this
    },
    */

    isKindOf: function(aClass) {
        //assert(!this.isClass())
        return this.thisClass().isKindOf(aClass)
    },

    // --- didInit ---
    //
    //  we don't want to scheduleSyncToStore while the object is initializing
    // (e.g. while it's being unserialized from a store)
    // so only scheduleSyncToStore if hasDoneInit is true, and set it to true
    // when didInit is called by the ObjectStore after 


    hasDoneInit: function() {
        return this.getOwnProperty("_hasDoneInit") === true
    },

    setHasDoneInit: function(aBool) {
        Object.defineSlot(this, "_hasDoneInit", aBool)
        return this
    },

    didInit: function() {
        assert(!this.hasDoneInit())
        // for subclasses to override if needed
        this.setHasDoneInit(true)
    },

    didLoadFromStore: function() {
    },

    scheduleDidInit: function () {
        //window.SyncScheduler.shared().scheduleTargetAndMethod(this, "didInit")
        this.didInit()
    },

    scheduleDidLoadFromStore: function() {
        //window.SyncScheduler.shared().scheduleTargetAndMethod(this, "didLoadFromStore")
        this.didLoadFromStore()
    },

    didLoadFromStore: function() {
        // for subclasses to override
    },

    prepareToRetire: function() {
        // called by user code when it expect object to stop being used
        // provides opportunity to remove notification observers, event listeners, etc
        this.removeAllNotificationObservations()
        this.removeScheduledActions()
    },

    removeAllNotificationObservations: function() {
        if (window["BMNotificationCenter"]) {
            BMNotificationCenter.shared().removeObserver(this)
        }
    },

    removeScheduledActions: function () {
        if (window["SyncScheduler"]) {
            SyncScheduler.shared().unscheduleTarget(this)
        }
    },
    
    // --- shouldStore ---

    setShouldStore: function(aBool) {
        if (aBool != this._shouldStore) {
            //this.willMutate("shouldStore")
            Object.defineSlot(this, "_shouldStore", aBool)
            //this.didMutate("shouldStore")
        }
        return this
    },

    shouldStore: function() {
        return this._shouldStore
    },

    typeCategory: function() {
        if (this.isInstance()) {
            return "instance"
        } else if (this.isPrototype()) {
            return "prototype" 
        } else if (this.isClass()) {
            return "class" 
        } 
        throw new Error("unable to identify")
    },

    fullTypeName: function() {
        return this.type() + " " + this.typeCategory()
    },

    slotValuePath: function(slotName, entries = []) {
        const entry = [this.fullTypeName(), this.getOwnProperty(slotName)] 
        entries.push(entry)

        const proto = this.__proto__
        if (proto) { // Object.prototype.__proto__ = null
            //proto.constructor.name !== "") {
            return proto.slotValuePath.apply(proto, [slotName, entries])
        }
        
        return entries
    },

    duplicate: function() {
        assert(this.isInstance())
        const instance = this.thisClass().clone().copyFrom(this)
        instance.duplicateSlotValuesFrom(this) // TODO: what about lazy slots?
        /*
        const storeSlots = Object.values(this.allSlots()).filter(slot => slot.shouldStoreSlot())
        storeSlots.forEach((slot) => {
            const v = slot.onInstanceGetValue(this)
            slot.onInstanceSetValue(instance, v)
        })
        */
        return instance
    },

    copy: function() {
        return this.duplicate()
    },

    copyFrom: function(anObject) {
        // WARNING: subclasses will need to customize this
        this.duplicateSlotValuesFrom(anObject) 
        return this
    },

    duplicateSlotValuesFrom: function(otherObject) {
        // TODO: add a type check of some kind?

        this.thisPrototype().allSlots().ownForEachKV((slotName, mySlot) => {
            const otherSlot = otherObject.thisPrototype().ownSlotNamed(slotName)
            const v = otherSlot.onInstanceGetValue(otherObject) // TODO: what about lazzy slots?
            const dop = otherSlot.duplicateOp()

            if (dop === "copyValue") {
                mySlot.onInstanceSetValue(this, v)
            } else if (dop === "duplicate" && v && v.duplicate) {
                const dup = v.duplicate()
                mySlot.onInstanceSetValue(this, dup)
            }
        })
        return this
    },

    copySlotValuesFrom: function(otherObject) {
        this.thisPrototype().allSlots().ownForEachKV((slotName, mySlot) => {
            const otherSlot = otherObject.thisPrototype().ownSlotNamed(slotName)
            const v = otherSlot.onInstanceGetValue(otherObject)
            mySlot.onInstanceSetValue(this, v)
        })
        return this
    },
}


Object.defineSlots(Object.prototype, prototypeSlots)

Object.initThisClass()
"use strict"

Object.defineSlots(Object, {
    /*
    newUuid: function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
            let r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    },
    */

    newUuid: function() { // TODO: move this JS UUID when it's added to JS standard lib
        const uuid_a = Math.floor(Math.random() * Math.pow(10, 17)).toBase64()
        const uuid_b = Math.floor(Math.random() * Math.pow(10, 17)).toBase64()
        return uuid_a + uuid_b
    },

})

Object.defineSlots(Object.prototype, {

    _puuid: undefined,

    puuid: function() {
        if (!this.hasPuuid()) {
            this.setPuuid(Object.newUuid())
        }

        return this["_puuid"]
    },

    hasPuuid: function() {
        return Object.prototype.hasOwnProperty.apply(this, ["_puuid"])
    },

    setPuuid: function(puuid) {
        assert(!Type.isNullOrUndefined(puuid))
        if (this.hasPuuid()) {
            let oldPid = this["_puuid"]
            this.defaultStore().onObjectUpdatePid(this, oldPid, puuid)
        }
        Object.defineSlot(this, "_puuid", puuid) // so _puuid isn't enumerable
        return this
    },

    typePuuid: function() {
        const puuid = this.puuid()
        if (Type.isFunction(this.type)) {
            return this.type() + "_" + puuid
        }
        return Type.typeName(this) + "_" + puuid
    },

    typeId: function() {
        return this.typePuuid()
    },

    debugTypeId: function() {
        const puuid = this.puuid().substr(0,3)

        if (Type.isFunction(this.type)) {
            return this.type() + "_" + puuid
        }
        return Type.typeName(this) + "_" + puuid
    },

    debugTypeIdSpacer: function() {
        return " -> "
    },

})

"use strict"

Object.defineSlots(Object, {


})

Object.defineSlots(Object.prototype, {

    setMutationObservers: function(aSet) {
        if (!this._mutationObservers) {
            Object.defineSlot(this, "_mutationObservers", aSet) 
        }
        return this
    },

    mutationObservers: function() {
        return this._mutationObservers
    },

    addMutationObserver: function(anObserver) {
        if (!this._mutationObservers) {
            this.setMutationObservers(new Set())
        }
        
        this.mutationObservers().add(anObserver)
        return this
    },

    removeMutationObserver: function(anObserver) {
        assert(anObserver)
        this.mutationObservers().delete(anObserver)
        return this
    },


    // --- ---

    willMutate: function() {
        /*
        if (this._mutationObservers) {
            this.mutationObservers().forEach(v => { 
                v.onWillMutateObject(this)
            })
        }
        */
    },

    didMutate: function() {
        if (this._mutationObservers) {
            this.mutationObservers().forEach(v => { 
                v.onDidMutateObject(this)
            })
        }
    },

})

"use strict"

/*

    Array-ideal

    Some extra methods for the Javascript Array primitive.

*/

Object.defineSlots(Array, {

    withArray: function(anArray) {
        return this.clone().copyFrom(anArray)
    },

    fromIterator: function(iterator) {
        const values = []
        let result = iterator.next()
        while (!result.done) {
            values.push(result.value)
            result = iterator.next()
        }
        return values
    },
    
})

// -----------------

Object.defineSlots(Array.prototype, {

    /*
    init: function() {
        Object.prototype.init.apply(this)
    },
    */

    duplicate: function() {
        return this.shallowCopy()
    },

    clear: function() {
        while (this.length) {
            this.pop()
        }
        return this
    },

    copyFrom: function(anArray) {
        this.clear()
        anArray.forEach(v => this.push(v))
        return this
    },

    // --- read operations ---

    // foreach key value (key being the index)

    forEachKV: function(func) {
        let i = 0
        this.forEach((v) => {
            func(i, v)
            i ++
        })
    },

    reverseForEachKV: function(func) {
        let i = 0
        this.forEach((v) => {
            func(i, v)
            i ++
        })
    },
        
    isEmpty: function () {
        return this.length === 0;
    },

    isEqual: function (otherArray) {
        if (this.length !== otherArray.length) { 
            return false; 
        }

        for (let i = 0; i < this.length; i++) {
            if (this[i] !== otherArray[i]) {
            //if (this.at(i) !== otherArray.at(i)) {
                return false;
            }
        }

        return true;
    },

    size: function () {
        return this.length;
    },

    at: function (index) {
        if (index < 0) {
            return this[this.length + index];
        }

        return this[index];
    },

    removeAt (index) {
        // we need to hook this since delete can't be hooked
        const v = this[index]
        this.willMutate("removeAt", v) 
        delete this[index]
        this.didMutate("removeAt", v)
        return this
    },

    atPut: function(index, v) {
        // we need to hook this since []= can't be hooked
        this.willMutate("atPut", v) 
        this[index] = v
        this.didMutate("atPut", v)
        return this
    },

    first: function () {
        return this.at(0)
    },

    second: function () {
        return this.at(1)
    },

    rest: function () {
        return this.slice(1);
    },

    last: function () {
        return this.at(this.length - 1) // returns undefined for negative indexes
    },

    contains: function (element) {
        return this.indexOf(element) !== -1;
    },

    containsAny: function (anArray) {
        const match = anArray.detect(item => this.contains(item))
        return !Type.isNullOrUndefined(match)
    },

    hasPrefix: function (otherArray) {
        if (this.length < otherArray.length) { 
            return false; 
        }

        for (let i = 0; i < this.length; i++) {
            if (this.at(i) !== otherArray.at(i)) {
                return false;
            }
        }

        return true;
    },

    itemAfter: function (v) {
        let i = this.indexOf(v);

        if (i === -1) {
            return null;
        }

        i = i + 1;

        if (i > this.length - 1) {
            return null;
        }

        if (this.at(i) !== undefined) { 
            return this.at(i); 
        }

        return null;
    },

    itemBefore: function (v) {
        let i = this.indexOf(v);

        if (i === -1) {
            return null;
        }

        i = i - 1;

        if (i < 0) {
            return null;
        }

        if (this.at(i)) { 
            return this.at(i) 
        }

        return null;
    },

    shallowCopy: function() {
        return this.slice()
    },

    copy: function (copyDict) {
        // since not every object will implement copy:
        // we need to have a check for it
        return this.slice().map((v) => {
            if (v.copy) {
                return v.copy(copyDict)
            } else {
                return v
            }
        })
    },

    split: function (subArrayCount) {
        const subArrays = [];
        const subArraySize = Math.ceil(this.length / subArrayCount);

        for (let i = 0; i < this.length; i += subArraySize) {
            let subArray = this.slice(i, i + subArraySize);
            if (subArray.length < subArraySize) {
                let lastSubArray = subArrays.pop();
                if (lastSubArray) {
                    subArray = lastSubArray.concat(subArray);
                }
            }
            subArrays.push(subArray);
        }

        return subArrays;
    },

    // --- write operations ---

    atInsert: function (i, e) {
        this.splice(i, 0, e);
        return this
    },

    atInsertItems: function (i, items) {
        let n = i
        items.forEach(item => {
            this.atInsert(n, item) 
            n ++
        })
        return this
    },

    append: function () {
        this.appendItems.call(this, arguments);
        return this;
    },

    appendItems: function (elements) {
        this.push.apply(this, elements);
        return this;
    },

    appendItemsIfAbsent: function (elements) {
        this.appendIfAbsent.apply(this, elements);
        return this;
    },

    moveItemsToIndex: function (movedItems, anIndex) {
        const newArray = this.shallowCopy()
        let insertIndex = anIndex

        movedItems.forEach(item => assert(this.contains(item)) ) // sanity check

        //console.log("start: " + this.map(s => s.title()).join("-") + ".moveItemsToIndex("  + movedItems.map(s => s.title()).join("-") + ", " + anIndex + ")")

        movedItems.forEach(item => {
            const i = this.indexOf(item)
            if (i == -1) {
                throw new Error("this isn't handled yet")
            }

            if (i < insertIndex) {
                insertIndex --
            }
            newArray.remove(item)
        })

        movedItems.reversed().forEach(item => {
            newArray.atInsert(insertIndex, item)
        })

        this.copyFrom(newArray)
        return this
    },

    prepend: function (e) {
        this.unshift(e);
        return this;
    },

    appendIfAbsent: function () {
        this.slice.call(arguments).forEach((value) => {
            if (this.indexOf(value) === -1) {
                this.push(value);
                return true;
            }
        })

        return false;
    },

    removeAll: function() {
        while(this.length) {
            this.pop() // TODO: make more efficient?
        }
        return this
    },

    removeAt: function (i) {
        this.willMutate("removeAt")
        this.splice(i, 1);
        this.didMutate("removeAt")
        return this;
    },

    remove: function (e) {
        const i = this.indexOf(e);
        if (i !== -1) {
            this.removeAt(i);
        }
        return this;
    },

    emptiesRemoved: function () {
        return this.filter(v => !Type.isNullOrUndefined(v) )
    },

    removeFirst: function () {
        // isMutator
        return this.shift();
    },

    removeLast: function () {
        // isMutator
        return this.pop();
    },

    removeItems: function (elements) {
        // isMutator
        elements.forEach(e => this.remove(e));
        return this;
    },

    empty: function () {
        this.splice(0, this.length);
        return this;
    },

    shuffle: function () {
        let i = this.length;

        if (i === 0) {
            return false;
        }

        while (--i) {
            const j = Math.floor(Math.random() * (i + 1));
            const tempi = this.at(i);
            const tempj = this.at(j);
            this.atPut(i, tempj)
            this.atPut(j, tempi)
        }

        return this;
    },

    atRandom: function () {
        const i = Math.floor( Math.random() * this.length )
        return this.at(i);
    },

    // --- enumeration ---

    /*
    forEachCall: function (functionName) {
        const args = this.slice.call(arguments).slice(1);
        args.push(0);
        this.forEach((e, i) => {
            args[args.length - 1] = i;
            if (e) {
                const fn = e[functionName];
                if (fn) {
                    fn.apply(e, args);
                } else {
                    console.warn("Array.forEachCall: No method " + functionName);
                }
            }
        });
        return this;
    },
    */

    forEachPerformIfResponds: function (methodName, arg1, arg2, arg3) {
        this.forEach((item) => {
            if (item) {
                const f = item[methodName]
                if (f) {
                    f.call(item, arg1, arg2, arg3)
                } 
            }
        })
        return this
    },

    forEachPerform: function (methodName, arg1, arg2, arg3) {
        this.forEach((item) => {
            if (item) {
                const f = item[methodName]
                if (f) {
                    f.call(item, arg1, arg2, arg3)
                } else {
                    throw new Error(Type.typeName(item) + " does not respond to '" + methodName + "'")
                }
            }
        })
        return this
    },

    sortPerform: function (functionName) { // WARNING: sorts IN-PLACE
        const args = this.slice.call(arguments).slice(1);
        return this.sort(function (x, y) {
            const xRes = x[functionName].apply(x, args);
            const yRes = y[functionName].apply(y, args);
            if (xRes < yRes) {
                return -1;
            } else if (yRes < xRes) {
                return 1;
            }
            return 0;
        });
    },

    mapProperty: function (propertyName) {
        return this.map(e => e[propertyName]);
    },

    detect: function (callback) {
        for (let i = 0; i < this.length; i++) {
            const v = this.at(i)
            if (callback(v, i)) {
                return v;
            }
        }

        return null; // or should this be undefined?
    },

    detectPerform: function (functionName) {
        const args = this.slice.call(arguments).slice(1);
        return this.detect((value, index) => {
            return value[functionName].apply(value, args);
        });
    },

    detectProperty: function (slotName, slotValue) {
        for (let i = 0; i < this.length; i++) {
            const v = this.at(i)
            if (v[slotName] === slotValue) {
                return v;
            }
        }

        return null;
    },

    detectIndex: function (callback) {
        for (let i = 0; i < this.length; i++) {
            if (callback(this.at(i), i)) {
                return i;
            }
        }

        return null;
    },

    nullsRemoved: function() {
        return this.filter(v => !Type.isNull(v));
    },

    reject: function(callback) {
        return this.filter(v => !callback(v))
    },

    // max 

    maxEntry: function (optionalCallback) { 
        // callback is optional
        const length = this.length;
        const mEntry = [undefined, undefined] 

        for (let i = 0; i < length; i++) {
            let v = this.at(i);
            if (optionalCallback) {
                v = optionalCallback(v);
            }

            if (mEntry[1] === undefined || v > mEntry[1]) {
                mEntry[0] = i
                mEntry[1] = v
            }
        }

        return mEntry;
    },

    maxIndex: function (optionalCallback) {
        return this.maxEntry(optionalCallback)[0];
    },

    maxValue: function (optionalCallback, theDefault) {
        return this.maxEntry(optionalCallback)[1];
    },

    maxItem: function (optionalCallback) {
        return this.at(this.maxIndex(optionalCallback));
    },


    // min

    minEntry: function (optionalCallback) { 
        // callback is optional
        const length = this.length;
        const mEntry = [undefined, undefined] 

        for (let i = 0; i < length; i++) {
            let v = this[i];
            if (optionalCallback) {
                v = optionalCallback(v);
            }

            if (mEntry[1] === undefined || v < mEntry[1]) {
                mEntry[0] = i
                mEntry[1] = v
            }
        }

        return mEntry;
    },

    minIndex: function (optionalCallback) {
        return this.maxEntry(optionalCallback)[0];
    },

    minValue: function (optionalCallback) {
        return this.minEntry(optionalCallback)[1];
    },

    // sum

    sum: function (optionalCallback) {
        let sum = 0;
        const length = this.length;

        for (let i = 0; i < length; i++) {
            let v = this.at(i);
            if (optionalCallback) {
                v = optionalCallback(v);
            }

            sum = sum + v;
        }

        return sum;
    },

    average: function () {
        if (this.length === 0) {
            return 0
        }
        return this.sum() / this.length;
    },

    /*
    flatten: function (maxDepth = 1) {
        const result = [];
        let needsFlatten = true
        let depth = 0
        while (needsFlatten && depth < maxDepth) {
            depth ++
            needsFlatten = false
            this.forEach((item) {
                if (item === this) {
                    throw new Error("attempt to flatten recursive array")
                }
                if (Type.isArray(item)) { // TODO: generalize to enumerables?
                    result.appendItems(array)
                    needsFlatten = true
                } else {
                    result.append(item)
                }
            });
        }
        return result;
    },
    */


    unique: function () {
        return Array.from(new Set(this));
    },

    asSet: function() {
        return new Set(this)
    },

    reversed: function () {
        return this.shallowCopy().reverse();
    },

    asPath: function () {
        if (this.length === 1 && this.first() === "") {
            return "/";
        }
        else {
            return this.join("/");
        }
    },

    isAbsolutePath: function () {
        return this.first() === "";
    },

    isRelativePath: function () {
        return this.first() !== "";
    },

    filterInPlace: function(callback) {
        for (let i = this.length -1; i >= 0; i--) {
            const v = this.at(i);
            if (!callback(v)) {
                this.removeAt(i)
            }
        }
        return this
    },

    select: function (callback) {
        return this.filter(callback)
    },
    
    after: function (v) {
        const index = this.indexOf(v);
    
        if (index === -1) {
            return [];
        }
    
        return this.slice(index + 1);
    },
    
    before: function (v) {
        const index = this.indexOf(v);
    
        if (index === -1) {
            return this.slice();
        }
    
        return this.slice(0, index);
    },
    
    replaceOccurancesOfWith: function (oldValue, newValue) {
        // isMutator
        for (let i = 0; i < this.length; i++) {
            if (this.at(i) === oldValue) {
                this.atPut(i, newValue);
            }
        }
        return this
    },
    
    removeOccurancesOf: function (e) {
        // isMutator
        for (let i = this.length -1; i >= 0; i--) {
            const v = this.at(i);
            if (v === e) {
                this.removeAt(i)
            }
        }
        return this;
    },

    wrap: function (obj) {
        if (obj === null || obj === undefined) {
            return [];
        }
        else if (obj.isArray) {
            return obj;
        }
        else {
            return [obj];
        }
    },

    itemsBefore: function (item) {
        const index = this.indexOf(item);
        if (index !== -1) {
            return this.slice(0, index);
        }
        return this
    },

    /*
    const setDifference = (a, b) => new Set([...a].filter(x => !b.has(x)));
    const setIntersection = (a, b) => new Set([...a].filter(x => b.has(x)));
    const setUnion = (a, b) => new Set([...a, ...b]);
    */
    
    union: function (other) {
        let r = this.concat(other).unique()
        return r;
    },

    intersection: function(other) {
        const thisSet = new Set(this)
        return other.filter((v) => { 
            return thisSet.has(v); 
        });
    },
    
    difference: function (other) {
        const thisSet = new Set(this)
        return other.filter(v => !thisSet.has(v) );
    },

    symmetricDifference: function (other) {
        let all = this.concat(other)
        const thisSet = new Set(this)
        const otherSet = new Set(other)
        return all.filter(v => !thisSet.has(v) || !otherSet.has(v));
    },

    /*
    intersectionWithSelector: function (a, methodName) {
        return this.select((e1) => { 
            return a.detect(e2 => e1[methodName].apply(e1) === e2[methodName].apply(e2)) !== null 
        })
    },
    
    diffWithSelector: function (otherArray, methodName) {
        let thisIdSet = new Set(this.map(v => v[methodName].apply(v)))
        let otherIdSet = new Set(otherArray.map(v => v[methodName].apply(v)))

        return otherArray.select(v => !idSet.has(v.id()) )
    },
    */
    

    // --- equality ---

    equals: function (array /*, visited = new Set()*/) {
        // we want this to work on any object that confroms to the array protocol, 
        // not just objects of the same JS type
        // but how do we test for the [] accessor?
        // also, how do we deal with circular structures?

        /*
        if (visited.has(this)) {
            return true // ?
        }
        visited.add(this)
        */

        if(array.length === undefined) {
            return false;
        }
    
        // compare lengths - can save a lot of time 
        if (this.length !== array.length) {
            return false;
        }
    
        for (let i = 0, l = this.length; i < l; i++) {
            const a = this.at(i)
            const b = array.at(i)
            
            // Check if we have nested arrays
            /*
                if (this.at(i) instanceof Array && array[i] instanceof Array) {
                    // recurse into the nested arrays
                    if (!this.at(i).equals(array[i]))
                        return false;       
                }     
            */
    
            
            if (a.equals && !a.equals(b, visited)) {
                return false;
            } else if (a !== b) {
                // Warning - two different object instances will never be equal: {x:20} !== {x:20}
                return false;
            }
        }
        
        return true;
    },


    containsEquals: function (b) {
        for (let i = 0, l = this.length; i < l; i++) {
            let a = this.at(i)

            if (a.equals) {
                if (!a.equals(b)) {
                    return false;  
                }
            } else if (a !== b) { 
                return false;   
            }
        }    
        return true;
    },
    
    /*
    asImmutable: function() {
        // doesn't raise exception on write - they just fail silently - too dangerous to use
        //const obj = this.shallowCopy()
        //Object.freeze(obj)
        //return obj
    },
    */
});


"use strict"

/*

    Date-ideal

    Some extra methods for the Javascript Date primitive.

*/

Object.defineSlots(Date.prototype, {

    /*
    clone: function () {
        return new Date(this.getTime())
    },
    */

    copy: function() {
        return this.shallowCopy()
    },

    shallowCopy: function() {
        return new Date(this.getTime())
    },

    // ---
   
    monthNames: function() {
        return [ 
            "January", "February", "March", 
            "April", "May", "June", 
            "July", "August", "September", 
            "October", "November", "December" 
        ];
    },

    monthName: function () {
        const monthNumber = this.getMonth() - 1
        return this.monthNames()[monthNumber];
    },

    dateNumberName: function() {
        const dayNumber = this.getDate()
        return dayNumber + dayNumber.ordinalSuffix()
    },

    paddedNumber: function(n) {
        const s = "" + n
        if (s.length === 1) { 
            return "0" + s
        }
        return s
    },

    zeroPaddedHours: function() {
        return this.paddedNumber(this.getHours())
    },

    zeroPaddedMinutes: function() {
        return this.paddedNumber(this.getMinutes())
    },

    zeroPaddedSeconds: function() {
        return this.paddedNumber(this.getSeconds())
    },

    getTwelveHours: function() {
        let h = this.getHours()
        if (h > 12) { h -= 12 }
        if (h === 0) { h = 12 }
        return h
    },

    zeroPaddedUSDate: function() {
        return this.paddedNumber(this.getTwelveHours()) + ":" + this.paddedNumber(this.getMinutes())
    },

});







"use strict"

/*

    String-ideal

    Some extra methods for the Javascript String primitive.

*/

Object.defineSlots(String.prototype, {
    
    shallowCopy: function() {
        return this
    },

    duplicate: function() {
        return this
    },
    
    isEmpty: function () {
        return this.length === 0;
    },

    size: function () {
        return this.length;
    },
    
    beginsWith: function (prefix) {
        if (!prefix || this.length < prefix.length) {
            return false;
        }
        for (let i = 0; i < prefix.length; i ++) {
            if (this.charAt(i) !== prefix.charAt(i)) {
                return false
            }
        } 
        return true
        //return this.substr(0, prefix.length) === prefix // faster that indexOf as it 
        //return this.indexOf(prefix) === 0;
    },

    endsWith: function (suffix) {
        if (!suffix || this.length < suffix.length) {
            return false;
        }
        for (let i = 0; i < suffix.length; i ++) {
            if (this.charAt(this.length - suffix.length + i) !== suffix.charAt(i)) {
                return false
            }
        } 
        return true
        //const index = this.lastIndexOf(suffix);
        //return (index !== -1) && (this.lastIndexOf(suffix) === this.length - suffix.length);
    },

    contains: function (aString) {
        return this.indexOf(aString) !== -1;
    },

    before: function (aString) {
        const index = this.indexOf(aString);
        
        if (index === -1) {
            return this;
        }

        return this.slice(0, index);
    },

    after: function (aString) {
        const index = this.indexOf(aString);

        if (index === -1) {
            return "";
        }
        
        return this.slice(index + aString.length);
    },

    between: function (prefix, suffix) {
        const after = this.after(prefix);
        if (after != null) {
            const before = after.before(suffix);
            if (before != null) {
                return before;
            }
            else {
                return null;
            }
        }
        else {
            return null;
        }
    },

    at: function (i) {
        return this.slice(i, i + 1);
    },

    first: function () {
        return this.slice(0, 1);
    },

    rest: function () {
        return this.slice(1);
    },

    repeated: function (times) {
        let result = "";
        const aString = this;
        times.repeat(function () { result += aString });
        return result
    },

    sansPrefixes: function(aStringList) {
        let result = this
        aStringList.forEach((s) => { result = result.sansPrefix(s) })
        return result
    },

    sansPrefix: function (prefix) {
        return this.substring(this.beginsWith(prefix) ? prefix.length : 0);
    },

    sansSuffixes: function(aStringList) {
        let result = this
        aStringList.forEach((s) => { result = result.sansSuffix(s) })
        return result
    },

    sansSuffix: function (suffix) {
        if (this.endsWith(suffix)) {
            return this.substr(0, this.length - suffix.length);
        }
        else {
            return this;
        }
    },

    stripped: function () {
        return this.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    },

    uncapitalized: function () {
        return this.replace(/\b[A-Z]/g, function (match) {
            return match.toLowerCase();
        });
    },

    asNumber: function () {
        return Number(this);
    },

    //move to libraries?
    humanized: function () //someMethodName -> Some Method Name
    {
        const words = [];
        let start = -1;
        const capitalized = this.capitalized();
        for (let i = 0; i < capitalized.length; i++) {
            if (capitalized.slice(i, i + 1).match(/[A-Z]/)) {
                let word = capitalized.slice(start, i);
                if (word) {
                    words.append(word);
                }
                start = i;
            }
        }
        words.append(capitalized.slice(start, i));
        return words.join(" ");
    },

    titleized: function () {
        return this.split(/\s+/).map(function (s) { return s.capitalized() }).join(" ");
    },

    base64Encoded: function () {
        //return new Buffer(String(this), "utf8").toString("base64");
        return window.btoa(this);
    },

    base64UrlEncoded: function () {
        return this.base64Encoded().replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, ",");
    },

    base64Decoded: function () {
        //return new Buffer(String(this), "base64").toString("utf8");
        return window.atob(this);
    },

    base64UrlDecoded: function () {
        return this.replace(/-/g, "+").replace(/_/g, "/").replace(/,/g, "=").base64Decoded();
    },

    stringCount: function (str) {
        return this.split(str).length - 1;
    },

    lineCount: function () {
        let count = 0
        for (let i = 0; i < this.length; i++) {
            const c = this.charAt(i)
            if (c === "\n") {
                count ++
            }
        }
        return count
    },

    forEachCharacter: function(fn) {
        for (let i = 0; i < this.length; i++) {
            const c = this.charAt(i)
            fn(c)
        }
    },

    forEachKV: function(fn) {
        for (let i = 0; i < this.length; i++) {
            const c = this.charAt(i)
            fn(i, c)
        }
    },

    splitArray: function (splitters) {
        let s = this
        const results = []
        splitters.forEach( (splitter) => {
            if (s.contains(splitter)) {
                const before = s.before(splitter)
                s = s.after(splitter)
                results.push(before)
            } else {
                results.push(null)
            }
        })
        return results
    },

    // --- paths ---

    pathComponents: function () {
        if (this === "/") {
            return [""];
        }
        else if (this === "") {
            return [];
        }
        else {
            return this.split("/");
        }
    },

    sansLastPathComponent: function () {
        const c = this.pathComponents()
        c.removeLast();
        return c.join("/");
    },

    lastPathComponent: function () {
        //return this.pathComponents().last()
        const components = this.pathComponents()
        if (components.length) {
            return this.pathComponents().last();
        }
        return ""
    },

    fileName: function() {
        return this.lastPathComponent().sansExtension()
    },

    sansExtension: function () {
        const parts = this.split(".")
        if (parts.length > 1) {
            parts.pop()
        }
        return parts.join(".")
    },

    pathExtension: function() {
        const extension = this.split(".").last();
        return extension;
    },

    // --- pad / strip -------

    padLeft: function (length, padding) {
        let str = this;
        while (str.length < length) {
            str = padString + str;
        }

        return str.substring(0, length);
    },

    padRight: function (length, padding) {
        let str = this;
        while (str.length < length) {
            str = str + padding;
        }

        return str.substring(0, length);
    },

    strip: function () {
        return String(this).replace(/^\s+|\s+$/g, "");
    },

    asObject: function () {
        return JSON.parse(this);
    },

    capitalized: function () {
        return this.replace(/\b[a-z]/g, function (match) {
            return match.toUpperCase();
        });
    },

    /// String

    asSetter: function () {
        return "set" + this.capitalized();
    },

    firstCharacter: function () {
        return this.slice(0);
    },

    lastCharacter: function () {
        return this.slice(-1);
    },

    capitalizeWords: function () {
        return this.replace(/(?:^|\s)\S/g, function (a) {
            return a.toUpperCase();
        });
    },

    replaceAll: function (target, replacement) {
        return this.split(target).join(replacement);
    },

    loremIpsum: function (minWordCount, maxWordCount) {
        if (!minWordCount) { minWordCount = 10; }
        if (!maxWordCount) { maxWordCount = 40; }

        const loremIpsumWordBank = new Array("lorem", "ipsum", "dolor", "sit", "amet,", "consectetur", "adipisicing", "elit,", "sed", "do", "eiusmod", "tempor", "incididunt", "ut", "labore", "et", "dolore", "magna", "aliqua.", "enim", "ad", "minim", "veniam,", "quis", "nostrud", "exercitation", "ullamco", "laboris", "nisi", "ut", "aliquip", "ex", "ea", "commodo", "consequat.", "duis", "aute", "irure", "dolor", "in", "reprehenderit", "in", "voluptate", "velit", "esse", "cillum", "dolore", "eu", "fugiat", "nulla", "pariatur.", "excepteur", "sint", "occaecat", "cupidatat", "non", "proident,", "sunt", "in", "culpa", "qui", "officia", "deserunt", "mollit", "anim", "id", "est", "laborum.", "sed", "ut", "perspiciatis,", "unde", "omnis", "iste", "natus", "error", "sit", "voluptatem", "accusantium", "doloremque", "laudantium,", "totam", "rem", "aperiam", "eaque", "ipsa,", "quae", "ab", "illo", "inventore", "veritatis", "et", "quasi", "architecto", "beatae", "vitae", "dicta", "sunt,", "explicabo.", "nemo", "enim", "ipsam", "voluptatem,", "quia", "voluptas", "sit,", "aspernatur", "aut", "odit", "aut", "fugit,", "sed", "quia", "consequuntur", "magni", "dolores", "eos,", "qui", "ratione", "voluptatem", "sequi", "nesciunt,", "neque", "porro", "quisquam", "est,", "qui", "dolorem", "ipsum,", "quia", "dolor", "sit,", "amet,", "consectetur,", "adipisci", "velit,", "sed", "quia", "non", "numquam", "eius", "modi", "tempora", "incidunt,", "ut", "labore", "et", "dolore", "magnam", "aliquam", "quaerat", "voluptatem.", "ut", "enim", "ad", "minima", "veniam,", "quis", "nostrum", "exercitationem", "ullam", "corporis", "suscipit", "laboriosam,", "nisi", "ut", "aliquid", "ex", "ea", "commodi", "consequatur?", "quis", "autem", "vel", "eum", "iure", "reprehenderit,", "qui", "in", "ea", "voluptate", "velit", "esse,", "quam", "nihil", "molestiae", "consequatur,", "vel", "illum,", "qui", "dolorem", "eum", "fugiat,", "quo", "voluptas", "nulla", "pariatur?", "at", "vero", "eos", "et", "accusamus", "et", "iusto", "odio", "dignissimos", "ducimus,", "qui", "blanditiis", "praesentium", "voluptatum", "deleniti", "atque", "corrupti,", "quos", "dolores", "et", "quas", "molestias", "excepturi", "sint,", "obcaecati", "cupiditate", "non", "provident,", "similique", "sunt", "in", "culpa,", "qui", "officia", "deserunt", "mollitia", "animi,", "id", "est", "laborum", "et", "dolorum", "fuga.", "harum", "quidem", "rerum", "facilis", "est", "et", "expedita", "distinctio.", "Nam", "libero", "tempore,", "cum", "soluta", "nobis", "est", "eligendi", "optio,", "cumque", "nihil", "impedit,", "quo", "minus", "id,", "quod", "maxime", "placeat,", "facere", "possimus,", "omnis", "voluptas", "assumenda", "est,", "omnis", "dolor", "repellendus.", "temporibus", "autem", "quibusdam", "aut", "officiis", "debitis", "aut", "rerum", "necessitatibus", "saepe", "eveniet,", "ut", "et", "voluptates", "repudiandae", "sint", "molestiae", "non", "recusandae.", "itaque", "earum", "rerum", "hic", "tenetur", "a", "sapiente", "delectus,", "aut", "reiciendis", "voluptatibus", "maiores", "alias", "consequatur", "aut", "perferendis", "doloribus", "asperiores", "repellat");

        const randy = Math.floor(Math.random() * (maxWordCount - minWordCount)) + minWordCount;
        let ret = "";
        let needsCap = true
        for (let i = 0; i < randy; i++) {
            let newTxt = loremIpsumWordBank[Math.floor(Math.random() * (loremIpsumWordBank.length - 1))];

            if (ret.substring(ret.length - 1, ret.length) === "." || ret.substring(ret.length - 1, ret.length) === "?") {
                newTxt = newTxt.substring(0, 1).toUpperCase() + newTxt.substring(1, newTxt.length);
            }

            if (needsCap) {
                newTxt = newTxt.capitalized()
                needsCap = false
            }

            ret += " " + newTxt;
        }

        return ret + "."
    },

    escapeHtml: function () {
        return this.replace(/[&<>"'\/]/g, function (s) {
            const entityMap = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                "\"": "&quot;",
                "'": "&#39;",
                "/": "&#x2F;"
            };
            return entityMap[s];
        });
    },

    GUID: function () {
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1);
        }
        return s4() + s4() + "-" + s4() + "-" + s4() + "-" +
            s4() + "-" + s4() + s4() + s4();
    },

    byteSizeDescription: function() {
        return this.length.byteSizeDescription()
    },

    asyncSha256Digest: async function () {
        // example use let digestHex = await "hello".asyncSha256DigestHex()

        // encode as UTF-8
        const msgBuffer = new TextEncoder('utf-8').encode(this);                    
    
        // hash the message
        const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);

        return hashBuffer
        /*
        // convert ArrayBuffer to Array
        const hashArray = Array.from(new Uint8Array(hashBuffer));
    
        // convert bytes to hex string                  
        const hashHex = hashArray.map(b => ('00' + b.toString(16)).slice(-2)).join('');

        var base64String = btoa(String.fromCharCode.apply(null, new Uint8Array(hashBuffer)));

        return hashHex;
        */
    },

    stripHTML: function () {
        const doc = new DOMParser().parseFromString(this, 'text/html');
        return doc.body.textContent || "";
    },

});

/*
async function test() {
    let text = 'An obscure body in the S-K System, your majesty. The inhabitants refer to it as the planet Earth.';
    let digestHex = await text.sha256Hex()
    console.log(digestHex);
}

test()
*/




"use strict"

/*

    Number-ideal

    Some extra methods for the Javascript Number primitive.

*/


const Base64 = (function () {
    const digitsStr = 
    //   0       8       16      24      32      40      48      56     63
    //   v       v       v       v       v       v       v       v      v
        "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+-";
    let digits = digitsStr.split("");
    let digitsMap = {};
    for (let i = 0; i < digits.length; i++) {
        digitsMap[digits[i]] = i;
    }
    return {
        fromInt: function(int32) {
            let result = "";
            while (true) {
                result = digits[int32 & 0x3f] + result;
                int32 >>>= 6;
                if (int32 === 0)
                    break;
            }
            return result;
        },
        toInt: function(digitsStr) {
            let result = 0;
            const digits = digitsStr.split("");
            for (let i = 0; i < digits.length; i++) {
                result = (result << 6) + digitsMap[digits[i]];
            }
            return result;
        }
    };
})();

Object.defineSlots(Number.prototype, {

    duplicate: function() {
        return this
    },
    
    copy: function() {
        return this
    },

    shallowCopy: function() {
        return this
    },

    repeat: function (callback) {
        for (let i = 0; i < this; i++) {
            if (callback(i) === false) {
                return this;
            }
        }
        return this;
    },

    forEach (func) {
        assert(Number.isInteger(this))
        for (let i = 0; i < this; i++) {
            func(i)
        }
    },

    reverseForEach (func) {
        assert(Number.isInteger(this))
        for (let i = this - 1; i >= 0; i++) {
            func(i)
        }
    },

    map: function () {
        const a = [];
        for (let i = 0; i < this; i++) {
            a.push(i);
        }
        return Array.prototype.map.apply(a, arguments);
    },

    isEven: function () {
        return this % 2 === 0;
    },

    isOdd: function () {
        return this % 2 !== 0;
    },

    ordinalSuffix: function() {
        const i = this
        let j = i % 10
        let k = i % 100
        
        if (j === 1 && k !== 11) {
            return "st";
        }
        if (j === 2 && k !== 12) {
            return "nd";
        }
        if (j === 3 && k !== 13) {
            return "rd";
        }
        return "th";
    },

    toBase64: function() {
        return Base64.fromInt(this)
    },

    fromBase64: function(base64String) {
        // need to call like: 
        // Number.prototype.fromBase64("...")
        return Base64.toInt(base64String)
    },

    byteSizeDescription: function() {
        return ByteFormatter.clone().setValue(this).formattedValue()
    },
    
});

"use strict"

/*

    Boolean-ideal

*/


Object.defineSlots(Boolean.prototype, {

    duplicate: function() {
        return this
    },
 
    // logic

    negate: function() {
        return !this
    },

    and: function(v) {
        return this && v
    },

    or: function(v) {
        return this || v
    },

    xor: function(v) {
        return ( this && !v ) || ( !this && v )
    },

    // control flow

    ifTrue: function(aClosure) { // just a test
        if (this) {
            return aClosure()
        }
        return undefined
    },

});

"use strict"

/*

    Set-ideal

    Some extra methods for the Javascript Set primitive.

*/

Object.defineSlots(Set.prototype, {

    shallowCopy: function() {
        return new Set(this.values())
    },

    keysArray: function() {
        return Array.fromIterator(this.values())
    },

    valuesArray: function() {
        return this.keysArray()
    },

    detect: function(fn) {
        // TODO: optimize?
        return this.valuesArray().detect(fn)
    },

    select: function(fn) {
        // TODO: optimize?
        return this.valuesArray().select(fn)
    },

    isSuperset: function(subset) {
        for (let v of subset) {
            if (!this.has(v)) {
                return false;
            }
        }
        return true;
    },
    
    union: function(setB) {
        let _union = new Set(this);
        for (let v of setB) {
            _union.add(v);
        }
        return _union;
    },
    
    intersection: function(setB) {
        let _intersection = new Set();
        for (let elem of setB) {
            if (this.has(elem)) {
                _intersection.add(elem);
            }
        }
        return _intersection;
    },
    
    symmetricDifference: function(setB) {
        let _difference = new Set(this);
        for (let v of setB) {
            if (_difference.has(v)) {
                _difference.delete(v);
            } else {
                _difference.add(v);
            }
        }
        return _difference;
    },
    
    difference: function(setB) {
        let _difference = new Set(this);
        for (let v of setB) {
            _difference.delete(v);
        }
        return _difference;
    },

    map: function(func) {
        const result = new Set()
        this.forEach((v) => result.add(func(v)))
        return result
    },

    isEmpty: function(func) {
        return this.size == 0        
    },

    
    /*
    //Examples
    let setA = new Set([1, 2, 3, 4])
    let setB = new Set([2, 3])
    let setC = new Set([3, 4, 5, 6])
    
    setA.isSuperset(setB); // => true
    setA.union(setC); // => Set [1, 2, 3, 4, 5, 6]
    setA.intersection(setC); // => Set [3, 4]
    setA.symmetricDifference(setC); // => Set [1, 2, 5, 6]
    setA.difference(setC); // => Set [1, 2]
    */
    
});

"use strict"

/*

    Error-ideal

    Some extra methods for the Javascript Error primitive.

*/

Error.stackTraceLimit = 100 // looks like default on Chrome is 10?

Object.defineSlots(Error, {

    assert: function(v) {
        if(!Boolean(v)) {
            throw new Error("assert failed - false value")
        }
        return v
    },

    assertDefined: function(v) {
        if(v === undefined) {
            throw new Error("assert failed - undefined value")
        }
        return v
    },

    showCurrentStack: function() {
        const e = new Error()
        e.name = "STACK TRACE"
        e.message = ""
        console.log( e.stack );
    },


    assertThrows: function(func) {
        assert(Type.isFunction(func))

        let didThrow = false
        try {
            func()
        } catch(e) {
            didThrow = true
        }

        if (!didThrow) {
            console.log("assertThrows(" + func.toString() + ") failed")
        } else {
            //console.log("assertThrows(" + func.toString() + ") passed")
        }

        assert(didThrow)
    },

    try: function(func) {
        try {
            func()
        } catch (error) {
            this.showError(error)
        }
    },

    callingScriptURL: function() {
        const urls = new Error().stackURLs()
        return urls[1]
    },

})


Object.defineSlots(Error.prototype, {
    
    stackURLs: function(v) {
        let urls = this.stack.split("at")
        urls.removeFirst()
        urls = urls.map(url => {
            
            if (url.contains("(")) {
                url = url.after("(")
            }
    
            url = url.strip()
    
            const parts = url.split(":")
            parts.removeLast()
            parts.removeLast()
            return parts.join(":")
        })
        return urls
    },

    // ------------------------

    description: function() {
        const error = this
        const lines = error.stack.split("\n")
        const firstLine = lines.removeFirst()
        const out = []
        const indent = "    "
		
        lines.forEach(function (line) {
            if (line.contains("at file")) {
                out.push(["....", line.after("at ").split("/").pop()])
            } else {
                line = line.after("at ")
                if (line === "") {
                    return;
                }
                const obj = line.before(".")
                const method = line.after(".").before(" (")
                const path = line.after("(").before(")")
                const filePart = path.split("/").pop()
                let file = filePart.before(":")
                if (file === "") { 
                    file = "???.js:??:?"
                }
                const className = file.before(".js")
                const location = filePart.after(":")
                out.push([className + " " + method + "()      ", file + ":" + location])
            }
        })
		
        let s = firstLine + "\n"
        const m = out.maxValue(function(entry) { return entry[0].length })
        out.forEach(function (entry) {
            s += indent + entry[0] + " ".repeat(m + 1 - entry[0].length) + entry[1] + "\n"
        })
		
        //s = error.message + "\n" + s
        s = s.replaceAll("<br>", "\n")
        return s
    },
	
    show: function() {
        console.warn(this.description())
    },

});

// --- helper functions ---

getGlobalThis().assert = function assert(v) {
    return Error.assert(v)
}

getGlobalThis().assertDefined = function assertDefined(v) {
    return Error.assertDefined(v)
}

getGlobalThis().assertThrows = function assertThrows(func) {
    Error.assertThrows(func)
}

"use strict"

/*

    Function-ideal

    Some extra methods for the Javascript Function primitive.

*/


"use strict"

/*

    Image-ideal

    Some extra methods for the Javascript Image primitive.

    Delegate protocol:

        didFetchDataUrl(data) // sent after load

*/

if (!getGlobalThis().Image) {
    console.log("WARNING: no Image object found - maybe we are not in browser?")
}

Object.defineSlots(Image.prototype, {

    setDelegate: function(anObject) {
        Object.defineSlot(this, "_delegate", anObject)
        return this
    },

    delegate: function() {
        return this._delegate
    },

    loadUrl: function(url) {
        this.crossOrigin = "Anonymous";
        this.onload = () => { this.didLoad() }
        this.src = url;
        return this
    },

    didLoad: function () {
        
        // create a canvas the size of the image
        const canvas = document.createElement("CANVAS");
        canvas.height = this.height;
        canvas.width = this.width;

        // draw image to the canvas
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);

        // get the image data from the canvas
        const data = canvas.toDataURL("image/jpeg");

        // tell the delegate about the loaded data
        if (this._delegate) {
            this._delegate.didFetchDataUrl(data)
        }

        /*
            // test data

            if (img.complete || img.complete === undefined) {
                img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
                img.src = src;
            }
        */
       
        return this
    },

});







"use strict"

Type.typedArrayTypeNames().forEach((name) => {
    const aClass = window[name]

    if (Type.isUndefined(aClass)) {
        console.warn("TypeArray-store error: missing type " + name)
        return
    }

    // add some class methods
    /*
    Object.defineSlots(aClass, {

    })
    */

    // add some object methods

    Object.defineSlots(aClass.prototype, {

        base64Encoded: function(aRecord, aStore) {
            return btoa(String.fromCharCode.apply(null, new Uint8Array(this)));
        },

    })

})

Object.defineSlots(ArrayBuffer.prototype, {

    base64Encoded: function(aRecord, aStore) {
        return btoa(String.fromCharCode.apply(null, new Uint8Array(this)));
    },

})

//console.log("base64Encoded test:", new Uint32Array([1, 2, 3]).base64Encoded())
"use strict"


/*

    Slot

*/

if (!window.ideal) {
    window.ideal = {}
}

window.ideal.Slot = class Slot { 

    static clone () {
        const obj = new this()
        obj.init()
        return obj
    }

    static initThisClass () { // can Object handle this now?
        if (this.prototype.hasOwnProperty("initPrototype")) {
            this.prototype.initPrototype.apply(this.prototype)
        }
        return this
    }

    setShouldStore (aBool) {
        throw new Error("Slot.setShouldStore should not be called")
    }

    shouldStore () {
        throw new Error("Slot.shouldStore should not be called")
    }

    simpleNewSlot (slotName, initialValue) {
        const privateName = "_" + slotName;
        //this[privateName] = initialValue;
        Object.defineSlot(this, privateName, initialValue)


        if (!this[slotName]) {
            const simpleGetter = function () {
                return this[privateName];
            }

            Object.defineSlot(this, slotName, simpleGetter)
        }

        const setterName = "set" + slotName.capitalized()

        if (!this[setterName]) {
            const simpleSetter = function (newValue) {
                this[privateName] = newValue;
                return this;
            }

            Object.defineSlot(this, setterName, simpleSetter)
        }

        this._slotNames.add(slotName)
        
        return this;
    }

    initPrototype () {
        Object.defineSlot(this, "_slotNames", new Set())

        //this._slotNames = new Set()
        
        this.simpleNewSlot("owner", null) // typically a reference to a .prototype
        this.simpleNewSlot("name", false) 
        this.simpleNewSlot("initValue", null) // needed?

        // getter
        this.simpleNewSlot("ownsGetter", true) 
        this.simpleNewSlot("doesHookGetter", false)
        this.simpleNewSlot("hookedGetterIsOneShot", true) 
        this.simpleNewSlot("isInGetterHook", false) 

        // setter
        this.simpleNewSlot("ownsSetter", true) 
        this.simpleNewSlot("doesHookSetter", false) // if shouldStore, then auto post isDirty?
        //this.simpleNewSlot("doesPostSetter", false) // posts a didUpdateSlot<SlotName> note

        // storrage related
        this.simpleNewSlot("isLazy", false) // should hook getter
        this.simpleNewSlot("shouldStoreSlot", false) // should hook setter
        this.simpleNewSlot("initProto", null) // clone this proto on init and set to initial value
        this.simpleNewSlot("valueClass", null) // declare the value should be a kind of valueClass
        this.simpleNewSlot("field", null)

        // slot hook names
        this.simpleNewSlot("willGetSlotName", null)
        //this.simpleNewSlot("willUpdateSlotName", null)
        //this.simpleNewSlot("didUpdateSlotName", null)

        //this.simpleNewSlot("initOp", "copyValue")
        //this.simpleNewSlot("validInitOps", new Set(["null", "lazy", "proto", "nop", "copyValue", "duplicate"])) 

        this.simpleNewSlot("duplicateOp", "nop")
        this.simpleNewSlot("validDuplicateOps", new Set(["nop", "copyValue", "duplicate"])) 
        this.simpleNewSlot("comment", null)
        this.simpleNewSlot("isPrivate", false)

         // a string value, eg: "Boolean", "String", "Number" - can be used to create inspector
         this.simpleNewSlot("slotType", null)
         this.simpleNewSlot("canInspect", false)
         this.simpleNewSlot("canEditInspection", true)
         this.simpleNewSlot("label", null) // visible label on inspector
         this.simpleNewSlot("validValues", null) // used for options field and validation
         this.simpleNewSlot("validValuesClosure", null) 
         this.simpleNewSlot("allowsMultiplePicks", false)

         this.simpleNewSlot("syncsToView", false)

         this.simpleNewSlot("inspectorPath", null) // if non-null, uses to create a path for the slot inspector

         // debugging 

         this.simpleNewSlot("doesBreakInGetter", false) // uses "debugger;"
         this.simpleNewSlot("doesBreakInSetter", false) // uses "debugger;"
    }

    setSyncsToView (aBool) {
        this._syncsToView = aBool
        if (aBool) {
            this.setDoesHookSetter(true)
        }
        return this
    }

    newInspectorField () {
        const slotType = this.slotType() 
        if (slotType && this.canInspect()) {
            let fieldName = "BM" + slotType + "Field"
            if (this.validValues() || this.validValuesClosure()) {
                fieldName = "BMOptionsNode"
            }
            const proto = window[fieldName]
            if (proto) {
                const field = proto.clone()

                field.setKey(this.name())
                field.setKeyIsEditable(false)
                field.setValueMethod(this.name())
                field.setValueIsEditable(this.canEditInspection())
                field.setCanDelete(false)

                if (this.label()) {
                    field.setKey(this.label())
                }

                if (this.validValues()) {
                    field.setValidValues(this.validValues())
                    field.setAllowsMultiplePicks(this.allowsMultiplePicks())
                } else if (this.validValuesClosure()) {
                    const vv = this.validValuesClosure()()
                    field.setValidValues(vv)
                    field.setAllowsMultiplePicks(this.allowsMultiplePicks())
                }
                return field
            }
        }
        return null
    }

    init () {

    }

    validDuplicateOps () {
        return new Set(["nop", "copyValue", "duplicate"])
    }
    
    setDuplicateOp (aString) {
        assert(this.validDuplicateOps().has(aString))
        this._duplicateOp = aString
        return this
    }

    /*
    onInstanceGetDuplicateValue (anInstance) {
        const v = this.onInstanceGetValue(anInstance)
        const dop = this.duplicateOp()

        if (v === null) {
            return null
        } else if (dop === "nop") {
            return v
        } else if (dop === "copyValue") {
            return v
        } else if (dop === "duplicate" && v && v.duplicate) {
            return v.duplicate()
        }

        throw new Error("unable to duplicate")
    }
    */

    setName (aName) {
        this._name = aName
        this.didUpdateSlotName()
        return this
    }

    didUpdateSlotName () {
        const capName = this.name().capitalized()
        this.setWillGetSlotName("willGetSlot" + capName)
        /*
        this.setDidUpdateSlotName("didUpdateSlot" + capName)
        this.setWillUpdateSlotName("willUpdateSlot" + capName)
        */
        return this
    }

    copyFrom (aSlot) {
        this._slotNames.forEach((slotName) => {
            const privateName = "_" + slotName;
            this[privateName] = aSlot[privateName]
            /*
            const setterName = "set" + slotName.capitalized()
            const v = aSlot[slotName].apply(aSlot)
            this[setterName].apply(this, [v])
            */
        })
        return this
    }

    autoSetGetterSetterOwnership () {
        //this.setOwnsGetter(true)
        //this.setOwnsSetter(true)
        
        if (this.alreadyHasGetter()) {
            //console.log(this.owner().type() + "." + this.getterName() + "() exists, so we won't override")
        }
        
        if (this.alreadyHasSetter()) {
            //console.log(this.owner().type() + "." + this.setterName() + "(v) exists, so we won't override")
        }

        this.setOwnsGetter(!this.alreadyHasGetter())
        this.setOwnsSetter(!this.alreadyHasSetter())
        return this
    }

    setDoesHookSetter (aBool) {
        if (this._doesHookSetter !== aBool) {
            this._doesHookSetter = aBool
            if (aBool) {
                if (this.alreadyHasSetter() && !this.ownsSetter()) {
                    const msg = this.owner().type() + "." + this.setterName() + "() exists, so we can't hook it - fix by calling slot.setOwnsSetter(true)"
                    console.log(msg)
                    throw new Error(msg)
                } 
                // this.setOwnsSetter(true)
            }
            this.setupSetter()
        }
        return this 
    }

    setIsLazy (aBool) {
        if (this._isLazy !== aBool) {
            this._isLazy = aBool
            this.setDoesHookSetter(true) 
            this.setHookedGetterIsOneShot(aBool) // TODO: make these the same thing?
            //this.onChangedAttribute()
        }
        return this
    }

    setShouldStoreSlot (aBool) {
        if (this._shouldStoreSlot !== aBool) {
            this._shouldStoreSlot = aBool
            if (aBool) {
                this.setDoesHookSetter(true) // TODO: is there a better way?
            } else {
                this.setIsLazy(false)
            }
            this.onChangedAttribute()
        }
        return this
    }

    onChangedAttribute () {
        this.setupGetter()
        this.setupSetter()
    }

    // setup

    setupInOwner () {
        this.setupValue()
        this.setupGetter()
        this.setupSetter()
        return this
    }

    setupValue () {
        Object.defineSlot(this.owner(), this.privateName(), this.initValue())
        //this.owner()[this.privateName()] = this.initValue()
        return this
    }

    // getter

    alreadyHasGetter () {
        return this.owner().hasOwnProperty(this.getterName())
    }

    setupGetter () {
        if (this.ownsGetter()) {
            if (this.doesHookGetter()) {
                if (this.isLazy()) {
                    this.makeLazyGetter()
                } else if (this.hookedGetterIsOneShot()) {
                    this.makeOneShotHookedGetter()
                } else {
                    this.makeHookedGetter()
                }
            } else {
                this.makeDirectGetter()
            }
        }
        return this
    }

    alreadyHasSetter () {
        return this.owner().hasOwnProperty(this.setterName())
    }

    setupSetter () {
        if (this.ownsSetter()) {

            this.makeHookedSetter()

            /*
            if (this.doesHookSetter()) {
                this.makeHookedSetter()
            } else {
                this.makeDirectSetter()
            }
            */
        }
    }

    privateName () {
        return "_" + this.name()
    }

    // --- getter ---

    getterName () {
        return this.name()
    }

    // direct getter

    makeDirectGetter () {
        Object.defineSlot(this.owner(), this.getterName(), this.directGetter())
        //this.owner()[this.getterName()] = this.directGetter()
        return this
    }

    directGetter () {
        const privateName = this.privateName()
        const func = function () {
            return this[privateName]
        }
        //func.setSlot(this)
        return func
    }

    // hooked getter

    makeHookedGetter () {
        //this.owner()[this.getterName()] = this.hookedGetter()
        Object.defineSlot(this.owner(), this.getterName(), this.safeHookedGetter())
        return this
    }

    makeLazyGetter () {
        assert(this.doesHookGetter())
        //this.owner()[this.getterName()] = this.hookedGetter()
        Object.defineSlot(this.owner(), this.getterName(), this.lazyGetter())
        return this
    }

    makeDirectGetterOnInstance (anInstance) {
        //anInstance[this.getterName()] = this.directGetter()
        Object.defineSlot(anInstance, this.getterName(), this.directGetter())
        return this   
    }

    hookedGetter () {
        const privateName = this.privateName()
        const slotName = this.name()
        const slot = this
        const func = function () {
            this.willGetSlot(slot) // opportunity to replace value before first access
            return this[privateName]
        }
        //func.setSlot(this)
        return func
    }

    safeHookedGetter () {
        const privateName = this.privateName()
        const slotName = this.name()
        // usefull for debugging infinite loops
        const slot = this
        const func = function () {

            if (slot.isInGetterHook()) { 
                throw new Error("hooked getter infinite loop detected")
            }

            slot.setIsInGetterHook(true)
            try {
                this.willGetSlot(slot) 
            } catch(e) {
                slot.setIsInGetterHook(false)
                throw e
            } 
            slot.setIsInGetterHook(false)

            return this[privateName]
        }
        //func.setSlot(this)
        return func
    }

    // one shot hooked getter

    makeOneShotHookedGetter () {
        assert(this.owner().isPrototype())
        console.log(this.owner().type() + "." + this.name() + " setting up one-shot getter in prototype")
        //this.owner()[this.getterName()] = this.oneShotHookedGetter()
        Object.defineSlot(this.owner(), this.getterName(), this.oneShotHookedGetter())
        return this
    }

    oneShotHookedGetter () {
        const privateName = this.privateName()
        const slotName = this.name()
        const slot = this
        const willGetSlotName = this.willGetSlotName()
        const func = function () {
            console.log(this.typeId() + "." + slot.name() + " replacing one-shot getter with direct getter")
            slot.makeDirectGetterOnInstance(this) // now, replace with direct getter after first call
            //this.willGetSlot(slot) // opportunity to replace value before first access
            if (this[willGetSlotName]) {
                this[willGetSlotName].apply(this)
            }
            return this[privateName]
        }
        //func.setSlot(this)
        return func
    }

    lazyGetter () {
        const slot = this
        const privateName = this.privateName()
        const slotName = this.name()
        const willGetSlotName = this.willGetSlotName()
        const func = function () {
            //console.log(this.typeId() + "." + slot.name() + " lazySlotGetter")
            
            slot.makeDirectGetterOnInstance(this) // now, replace with direct getter after first call
            
            slot.onInstanceLoadRef(this)

            if (this[willGetSlotName]) {
                this[willGetSlotName].apply(this)
            }

            return this[privateName]
        }
        //func.setSlot(this)
        return func
    }

    // --- setter ---

    setterName () {
        return "set" + this.name().capitalized()
    }

    directSetterName () {
        return "directSet" + this.name().capitalized()
    }

    makeDirectSetter () {
        //this.owner()[this.setterName()] = this.directSetter()
        Object.defineSlot(this.owner(), this.setterName(), this.directSetter())
        return this
    }

    directSetter () {
        const privateName = this.privateName()
        const slot = this
        const setterName = this.setterName()
        const func = function (newValue) {
            this[privateName] = newValue
            return this
        }
        //func.setSlot(this)
        return func
    }

    // hooked setter

    makeHookedSetter () {
        //this.owner()[this.setterName()] = this.hookedSetter()
        Object.defineSlot(this.owner(), this.setterName(), this.hookedSetter())
        Object.defineSlot(this.owner(), this.directSetterName(), this.directSetter())
        return this
    }

    /*
    updateWithHookOnInstance (anInstance) {
        const slotName = this.name()
        const privateName = this.privateName()
        const didUpdateSlotMethodName = "didUpdateSlot" + slotName.capitalized()
        const oldValue = this[privateName]

        this[privateName] = newValue
        this.didUpdateSlot(slot, oldValue, newValue)
        if (this[didUpdateSlotMethodName]) {
            this[didUpdateSlotMethodName].apply(this, [oldValue, newValue])
        }
    }
    */
    
    hookedSetter () {
        const slot = this
        const slotName = this.name()
        const privateName = this.privateName()
        const didUpdateSlotMethodName = "didUpdateSlot" + slotName.capitalized()
        const func = function (newValue) {
            const oldValue = this[privateName]
            if (oldValue !== newValue) {
                
                this[privateName] = newValue
                this.didUpdateSlot(slot, oldValue, newValue)

                if (this[didUpdateSlotMethodName]) {
                    this[didUpdateSlotMethodName].apply(this, [oldValue, newValue])
                }

                if (slot.syncsToView() && this.scheduleSyncToView) {
                    this.scheduleSyncToView()
                }

            }
            return this
        }
        //func.setSlot(this)
        return func
    }

    /*
    postingSetter () {
        const slotName = this.name()
        const privateName = this.privateName()
        const noteName = "didUpdateSlot" + this.slotName().capitalized()
        const func = function (newValue) {
            const oldValue = this[privateName]
            if (oldValue !== newValue) {
                this[privateName] = newValue
                const didUpdateSlotNote = BMNotificationCenter.shared().newNote().setSender(this).setName(noteName)
                didUpdateSlotNote.post()
            }
            return this
        }
        //func.setSlot(this)
        return func
    }
    */

    
    // call helpers

    onInstanceRawGetValue (anInstance) {
        return anInstance[this.privateName()]
    }

    onInstanceGetValue (anInstance) {
        return anInstance[this.getterName()].apply(anInstance)
    }

    onInstanceSetValue (anInstance, aValue) {
        return anInstance[this.setterName()].apply(anInstance, [aValue])
    }

    // --- StoreRefs for lazy slots ---

    refPrivateName () {
        return "_" + this.name() + "Ref"
    }

    onInstanceSetValueRef (anInstance, aRef) {        
        Object.defineSlot(anInstance, this.refPrivateName(), aRef)
        return this
    }

    onInstanceGetValueRef (anInstance, aRef) {        
        return anInstance[this.refPrivateName()]
    }

    copyValueFromInstanceTo(anInstance, otherInstance) {
        if (this.isLazy()) {
            const valueRef = this.onInstanceGetValueRef(anInstance)
            if (valueRef) {
                this.onInstanceSetValueRef(otherInstance, valueRef)
                return this
            }
        }

        const v = this.onInstanceGetValue(anInstance)
        this.onInstanceSetValue(otherInstance, v)
        return this
    }

    // -----------------------------------------------------

    onInstanceInitSlot (anInstance) {
        const name = this.privateName()
        let defaultValue = anInstance[name]
        // to ensure privateName isn't enumerable
        Object.defineSlot(anInstance, name, defaultValue)

        
        /*
        const op = this.initOp()
        assert(this.validInitOps().contains(op)) // TODO: put on setter instead

        const opMethods = {
            "null" : () => { 
                this.onInstanceSetValue(anInstance, null)
            },

            "lazy" : () => { 
                const obj = this.initProto().clone()
                anInstance[this.privateName()] = obj
            },

            "proto" : () => { 
                const obj = this.initProto().clone()
                this.onInstanceSetValue(anInstance, obj)
            },

            "nop" : () => { 
            },

            "copyValue" : () => { 
                this.onInstanceSetValue(anInstance, defaultValue)
            },
    
            "duplicate" : () => { 
                if (defaultValue) {
                    const obj = defaultValue.duplicate()
                    this.onInstanceSetValue(anInstance, obj)
                }
            },
        }

        opMethods[op].apply(this)
        */


        if (this.isLazy()) {
            const obj = this.initProto().clone()
            anInstance[this.privateName()] = obj
        } else if (this.initProto()) {
            const obj = this.initProto().clone()
            this.onInstanceSetValue(anInstance, obj)
        } else if (this.initValue()) {
            this.onInstanceSetValue(anInstance,this.initValue() )
        }

        if (this.field()) {
            // duplicate the field instance owned by the slot,
            // add it as a subnode to the instance,
            // and sync it to the instance's slot value
            const newField = this.field().duplicate()
            anInstance.addSubnode(newField)
            newField.getValueFromTarget()
        }
    }

    onInstanceLoadRef (anInstance) {
        const storeRef = this.onInstanceGetValueRef(anInstance)
        if (storeRef) {
            
            //console.warn(anInstance.typeId() + "." + this.name() + " [" + anInstance.title() + "] - loading storeRef")
            //console.warn(anInstance.title() + " loading storeRef for " + this.name())
            const obj = storeRef.unref()
            /*
            //console.warn("   loaded: " + obj.type())
            anInstance[this.privateName()] = obj // is this safe? what about initialization?
            //this.onInstanceSetValue(anInstance, obj)
            this.onInstanceSetValueRef(anInstance, null)
            */

            const setter = anInstance[this.setterName()]
            setter.apply(anInstance, [obj])

        } else {
            //console.warn(anInstance.typeId() + " unable to load storeRef - not found")
            //console.warn(anInstance.typeId() + ".shouldStoreSubnodes() = " + anInstance.shouldStoreSubnodes())
            //throw new Error("")
        }
    }

    hasSetterOnInstance (anInstance) {
        return Type.isFunction(anInstance[this.setterName()])
    }

    // --- should store on instance ---

    shouldStoreSlotOnInstancePrivateName() {
        return "_shouldStoreSlot" + this.name().capitalized()
    }

    shouldStoreSlotOnInstance (anInstance) {
        const k = this.shouldStoreSlotOnInstancePrivateName()
        const v = anInstance[k]
        if (Type.isUndefined(v)) {
            return this.shouldStoreSlot()
        }
        return v === true
    }

    setShouldStoreSlotOnInstance (anInstance, aBool) {
        const k = this.shouldStoreSlotOnInstancePrivateName()
        Object.defineSlot(anInstance, k, aBool)
        return aBool
    }
    
}.initThisClass()


// --- slot methods on Function -------------------------------------------------

/*
Object.defineSlots(Function.prototype, {
    slot: function() {
        return this._slot
    },

    setSlot: function(aSlot) {
        this._slot = aSlot
        return this
    },

    super: function() {
        return this
    },

})
*/
"use strict"

/*

    ProtoClass

    Base class to implement some things we're used to in Smalltalk/ObjC,
    as well as Slot related methods.

*/

window.ProtoClass = class ProtoClass extends Object { 

    /*
    static newUniqueInstanceId() {
        const uuid_a = Math.floor(Math.random() * Math.pow(10, 17)).toBase64()
        const uuid_b = Math.floor(Math.random() * Math.pow(10, 17)).toBase64()
        return uuid_a + uuid_b
    }
    */

    static minimalClone () {
        const obj = new this()
        obj.init()
        return obj
   }

   static minimalNewSlot (slotName, slotValue) {
        if (Object.getOwnPropertyDescriptor(slotName)) {
                this[slotName] = slotValue
        } else {
            const descriptor = {
                configurable: true,
                enumerable: false,
                value: slotValue,
                writable: true,
            }
            Object.defineProperty(obj, slotName, descriptor)
        }
        return this
   }

   /* ------------------------------------------------ */

    static clone () {
        if (this.isSingleton() && this.hasShared()) {
            return this.shared()
        }

        const obj = new this()
        obj.init()

        if (this.isSingleton()) {
            this.setShared(obj)
        }

        return obj
    }

    initPrototype () { 
        // subclasses should call this at end of their definition
    }

    // --- class slots and variables ---
    
    static getClassVariable (key, defaultValue) {
        if (!this.hasOwnProperty(key)) {
            if (Type.isFunction(defaultValue)) { 
                defaultValue = defaultValue()
            }
            this[key] = defaultValue
        }
        return this[key]
    }

    static setClassVariable (key, value) {
        Object.defineSlot(this, key, value)
        //this[key] = value
        return this
    }

    // singleton

    static setIsSingleton (aBool) {
        this.setClassVariable("_isSingleton", aBool)
        return this
    }

    static isSingleton () {
        return this.getClassVariable("_isSingleton", false)
    }

    static singleton() {
        assert(this.isSingleton())
        return this.shared()
    }

    // shared

    static hasShared () {
        return !Type.isUndefined(this.getClassVariable("_shared"))
    }

    static shared () {
        if (!this.getClassVariable("_shared")) {
            this.setShared(this.clone())
        }
        return this.getClassVariable("_shared")
    }

    static setShared (anInstance) {
        this.setClassVariable("_shared", anInstance)
        return this
    }

    static allClasses () {
        return this.getClassVariable("_allClasses", [Object])
    }
    
    static defineClassGlobally () {
        if(Type.isUndefined(window[this.type()])) {
            window[this.type()] = this
            //console.log(this.type() + ".initThisClass()")
        } else {
            const msg = "WARNING: Attempt to redefine window['" + this.type() + "']"
            console.warn(msg)
            throw new Error(msg)
        }
    }

    static addChildClass (aClass) {
        this._childClasses.add(aClass)
        return this
    }

    static initThisClass () {
        //console.log(this.type() + " initThisClass")
        
        this.setClassVariable("_childClasses", new Set())
        this.setClassVariable("_ancestorClasses", this.findAncestorClasses())

        const p = this.parentClass()
        if (p && p.addChildClass) {
            p.addChildClass(this)
        }

        if (this.prototype.hasOwnProperty("initPrototype")) {
            // each class inits it's own prototype, so make sure we only call our own initPrototype()
            //this.prototype.initPrototype.apply(this.prototype)
            this.prototype.initPrototype()
        }

        this.defineClassGlobally()
        this.addToAllClasses()

        return this
    }

    static parentClass () {
        const p = this.__proto__

        if (p && p.type) {
            return p
        }

        return null
    }

    static ancestorClassesTypesIncludingSelf () {
        return this.ancestorClassesIncludingSelf().map(c => c.type())
    }

    static ancestorClassesTypes () {
        return this.ancestorClasses().map(c => c.type())
    }

    /*
    static ancestorClassesIncludingSelf (results = []) {
        results.push(this)

        const parent = this.parentClass()
        if (parent && parent.ancestorClasses) {
            //assert(!results.contains(parent))
            parent.ancestorClassesIncludingSelf(results)
        }
        return results
    }
    */

    static isSubclassOf(aClass) {
        return this.ancestorClassesIncludingSelf().contains(aClass)
    }

    static ancestorClassesIncludingSelf() {
        const results = this.ancestorClasses().shallowCopy()
        results.atInsert(0, this)
        return results
    }

    static ancestorClasses() {
        const v = this.getClassVariable("_ancestorClasses")
        assert(v)
        return v
    }

    static findAncestorClasses () {
        const results = []
        let aClass = this.parentClass()
        while (aClass && aClass.parentClass) {
            results.push(aClass)
            aClass = aClass.parentClass()
        }
        return results
    }

    /*
    static ancestorClasses (results = []) {
        const parent = this.parentClass()
        if (parent && parent.ancestorClasses) {
            //assert(!results.contains(parent))
            results.push(parent)
            parent.ancestorClasses(results)
        }
        return results
    }
    */

    static childClasses () {
        // TODO: if needed for performance, 
        // - have each class cache a list of childClasses
        // - use initClass method tell parent about new child class
        return ProtoClass.allClasses().filter(aClass => aClass && aClass.parentClass && aClass.parentClass() === this)
    }

    static descendantClasses (results = []) {
        const children = this.childClasses()
        children.forEach(child => {
            results.push(child)
            child.descendantClasses(results)
        })
        return results
    }

    static superClass () {
        return Object.getPrototypeOf(this)
    }

    superClass () {
        return this.thisClass().superClass()
    }

    superPrototype () {
        return this.superClass().prototype
    }


    /*
    static subclassesDescription (level) {
        if (Type.isUndefined(level)) {
            level = 0
        }
        const spacer = "  ".repeat(level)
        const lines = [spacer + this.type()]
        const subclassLines = this.subclasses().map(subclass => spacer + subclass.subclassesDescription(level + 1))
        lines.appendItems(subclassLines)
        return lines.join("\n")
    }
    */

    static isClass () {
        return true
    }

    static isInstance () {
        return false
    }

    static isPrototype () {
        return false
    }

    // --- instance ---

    thisPrototype () {
        assert(this.isInstance())
        const prototype = this.__proto__
        assert(prototype.isPrototype)
        return prototype
    }

    thisClass () {
        if (this.isPrototype()) {
            return this.constructor
        }

        // it's an instance
        return this.__proto__.constructor
    }

    isPrototype () {
        return this.constructor.prototype === this 
    }
    
    isInstance () {
        return !this.isPrototype()
    }

    isClass () {
        return false
    }

    type () {
        return this.constructor.name
    }

    setType (aString) {
        this.constructor.name = aString
        return this
    }

    // --- slots ---

    ownSlotNamed (slotName) {
        assert(this.isPrototype())

        const slots = this.slots()
        if (slots.hasOwnProperty(slotName)) {
            return slots[slotName]
        }
        
        // why call it "own" if we look in parent?
        const p = this.__proto__ 
        if (p && p.ownSlotNamed) {
            return p.ownSlotNamed(slotName)
        }

        return null
    }

    // slot objects

    slots () {
        if (!this.hasOwnProperty("_slots")) {
            Object.defineSlot(this, "_slots", {})
        }
        return this._slots
    }

    allSlots (allSlots = {}) {
        //assert(this.isPrototype())

        if (this.__proto__ && this.__proto__.allSlots) {
            this.__proto__.allSlots(allSlots)
        }

        Object.assign(allSlots, this.slots()); // do this last so we override ancestor slots

        return allSlots
    }

    // stored slots

    /*
    storedSlots () {
        // TODO: use slot cache?
        const slotsArray = Object.values(this.allSlots())
        return slotsArray.filter(slot => slot.shouldStoreSlot())
    }

    storedSlotNamesSet () { 
        const slotsArray = Object.values(this.allSlots())
        return this.storedSlots().map(slot => slot.name()).asSet()
    }
    */

    // -------------------------------------

    /*
    hasOwnSlotGetter (slotName) {
        return Reflect.ownKeys(this).contains(slotName)
    }

    hasOwnSlotSetter (slotName) {
        return Reflect.ownKeys(this).contains(slotName.asSetter())
    }
    */

    hasOwnSlotObject (slotName) {
        if( !Type.isUndefined(this.allSlots()[slotName]) ) {
            return true
        }
        return false
        //return this.hasOwnSlotGetter(slotName) || this.hasOwnSlotSetter(slotName)
    }
    
    newSlotIfAbsent (slotName, initialValue) {
        const slot = this.allSlots()[slotName]
        if (slot) {
            return slot
        }
        return this.justNewSlot(slotName, initialValue)
    }

    newSlot (slotName, initialValue, allowOnInstance=false) {
        if (Reflect.ownKeys(this).contains(slotName)) {
            //const msg = "WARNING: " + this.type() + "." + slotName + " slot already exists"
            //console.log(msg) 
        }

        if(this.hasOwnSlotObject(slotName)) {
            const msg = this.type() + " newSlot('" + slotName + "') - slot already exists"
            console.log(msg)
            throw new Error(msg)
        }
        return this.justNewSlot(slotName, initialValue, allowOnInstance)
    }

    overrideSlot (slotName, initialValue, allowOnInstance=false) {
        const oldSlot = this.allSlots()[slotName]
        if(Type.isUndefined(oldSlot)) {
            const msg = this.type() + " newSlot('" + slotName + "') - no existing slot to override"
            console.log(msg)
            this.allSlots()
            throw new Error(msg)
        }
        const slot = this.justNewSlot(slotName, initialValue, allowOnInstance)
        slot.copyFrom(oldSlot)
        slot.setInitValue(initialValue)
        slot.setOwner(this)
        return slot
    }

    justNewSlot (slotName, initialValue, allowOnInstance=false) { // private
        if (!allowOnInstance) {
            assert(this.isPrototype())
        }
        assert(Type.isString(slotName))

        /*
        // TODO: we want to create the private slots and initial value on instances
        // but ONLY create method slots on classes, not instances...
        const privateName = "_" + slotName
        this[privateName] = initialValue
        */

        const slot = ideal.Slot.clone().setName(slotName).setInitValue(initialValue)
        slot.setOwner(this)
        slot.autoSetGetterSetterOwnership()
        slot.setupInOwner()
        this.slots().atPut(slotName, slot)
        return slot
    }

    newSlots (slots) {
        assert(this.isPrototype())
        if (Object.keys(slots).length === 0) {
            return this
        }
        let s = this.type() + ":\n"
        Object.eachSlot(slots, (slotName, initialValue) => {
            let initialValueString = initialValue
            if (!Type.isLiteral(initialValueString)) {
                initialValueString = "[insert]"
            } else if (Type.isString(initialValueString)) {
                initialValueString = "\"" + initialValueString + "\""
            }
            const line =  "     this.newSlot(\"" + slotName + "\", " + initialValueString + ")\n"
            //console.log(line)
            s += line
            this.newSlot(slotName, initialValue);
        });

        console.log(s)
        return this;
    }

    willGetSlot (aSlot) {
        // example: if the slot name is "subnodes",
        // this will call this.willGetSlotSubnodes()
        const s = aSlot.willGetSlotName()
        const f = this[s]
        if (f) {
            f.apply(this)
        }
    }

    didUpdateSlot (aSlot, oldValue, newValue) {
        if (aSlot.shouldStoreSlot()) {
            this.didMutate(aSlot.name())
        }
        /*
        // persistence system can hook this
        const methodName = "didUpdateSlot" + aSlot.name().capitalized()
        if (this[methodName]) {
            this[methodName].apply(this, [oldValue, newValue])
        }
        */
    }

    setSlots (slots) {
        Object.eachSlot(slots, (name, initialValue) => {
            this.setSlot(name, initialValue);
        });
        return this;
    }

    setSlot (name, initialValue) {
        this[name] = initialValue
        return this
    }

    init () { 
        super.init()
        // subclasses should override to do initialization
        //assert(this.isInstance())
        const allSlots = this.__proto__.allSlots()
        allSlots.ownForEachKV((slotName, slot) => slot.onInstanceInitSlot(this)) // TODO: use slot cache
    }

    toString () {
        return this.type();
    }

    ownsSlot (name) {
        return this.hasOwnProperty(name);
    }

    argsAsArray (args) {
        return Array.prototype.slice.call(args);
    }

    respondsTo (methodName) {
        const f = this[methodName] 
        return typeof(f) === "function";
    }

    performWithArgList (message, argList) {
        return this[message].apply(this, argList);
    }

    perform (message) { // will apply any extra arguments to call
        if (this[message] && this[message].apply) {
            return this[message].apply(this, this.argsAsArray(arguments).slice(1));
        }

        throw new Error(this, ".perform(" + message + ") missing method")
        return this;
    }

    setterNameMap () {
        return this.thisClass().getClassVariable("_setterNameMap", {})
    }

    setterNameForSlot (name) {
        // cache these as there aren't too many and it will avoid extra string operations
        let setter = this.setterNameMap()[name]
        if (!setter) {
            setter = "set" + name.capitalized()
            this.setterNameMap()[name] = setter
        }
        return setter
    }

    toString () {
        return this.typeId();
    }

    // --- ancestors ---

    firstAncestorWithMatchingPostfixClass (aPostfix) {
        // not a great name but this walks back the ancestors and tries to find an
        // existing class with the same name as the ancestor + the given postfix
        // useful for things like type + "View" or type + "RowView", etc
        //this.debugLog(" firstAncestorWithMatchingPostfixClass(" + aPostfix + ")")
        const match = this.thisClass().ancestorClassesIncludingSelf().detect((obj) => {
            const name = obj.type() + aPostfix
            const proto = window[name]
            return proto
        })
        const result = match ? window[match.type() + aPostfix] : null

        return result
    }

    // debugging

    setIsDebugging (aBool) {
        Object.defineSlot(this, "_isDebugging", aBool)
        return this
    }

    isDebugging () {
        return this._isDebugging
    }

    debugLog (s) {
        if (this.isDebugging()) {
            if (Type.isFunction(s)) {
                s = s()
            }
            if (arguments.length == 1) {
                console.log(this.debugTypeId() + " " + s)
            } else {
                console.log(this.debugTypeId() + " ", arguments[0], arguments[1])
            }
        }
        return this
    }

}.initThisClass() 




"use strict"

/*

    Documentation

    An simple in-memory documentation system.
    
    TODO: Rename to something more unique.

*/

window.Documentation = class Documentation extends ProtoClass {
    initPrototype () {

    }

    init() {
        super.init()
    }

    classes () {
        return ProtoClass.allClasses()
    }

    methodsDocsForClass(aClass) {
        const methods = []
        Object.getOwnPropertyNames(aClass).forEach((methodName) => {
            const v = aClass[methodName]
            //const docs = v._docs
            if (Type.isFunction(v) && methodName !== "constructor") {
                const source = v.toString()
                let argNames = source.after("(").before(")").split(",").map(s => s.trim())
                if (argNames[0] === "") { 
                    argNames = [] 
                }
                methods.push({ name: methodName, argNames: argNames, comments: v.extractComments() })
            }
        })
        return methods
    }

    asJson() {
        const classes = []
        this.classes().forEach((aClass) => {
            const classDict = {}
            classDict.name = aClass.type()
            const superclass = aClass.superClass()
            if (superclass.type) {
                classDict.superClass = superclass.type()
            }
            classes.push(classDict)
            classDict.methods = this.methodsDocsForClass(aClass)
            //classDict.comments = aClass.comments()
        })
        return classes
    }

    show() {
        const classes = this.asJson()
        const lines = []
        classes.forEach((aClass) => {
            lines.push(aClass.name + " : " + aClass.superClass)
            /*
            aClass.methods.forEach((aMethod) => {
                let argsString = ""
                if (aMethod.argNames.length > 0) {
                    argsString = "(" + aMethod.argNames.join(",") + ")"
                }
                lines.push("  - " + aMethod.name + argsString + " " + aMethod.comments)
            })
            */
        })
        /*
        const s = JSON.stringify(this.asJson(), 2, 2)
        */
        console.log("DOCUMENTATION:\n\n", lines.join("\n"))
    }
}.initThisClass()


/*
// --- Object category -------------------------------------

Object.defineSlots(Object.prototype, {

    docs: function() {
        if (!this._docs) {
            this._docs = {}
        }
        return this._docs
    },

    setDocs: function (name, description) {
        const docs = this.docs()
        docs._name = methodName
        docs._description = description
        return this
    },
    
})

// --- Function category -------------------------------------

Object.defineSlots(Function.prototype, {

    docs: function() {
        if (!this._docs) {
            this._docs = {}
        }
        return this._docs
    },

    setDocs: function (name, description, returns) {
        const docs = this.docs()
        docs._name = name
        docs._description = description
        docs._returns = returns 
        return this
    },

    extractComments: function() {
        const commentPattern = new RegExp("(\\/\\*([^*]|[\\r\\n]|(\\*+([^*\/]|[\\r\\n])))*\\*+\/)|(\/\/.*)", "g");
        return this.toString().match(commentPattern)
    },
})

*/
"use strict"

ResourceLoader.pushRelativePaths([
    "HookedArray.js",
    "HookedSet.js",
    "HookedMap.js",

    "IndexedArray.js",
    "SortedArray.js",
]);



"use strict"

/*

    HookedArray

    A subclass of Array that maintains that hooks the base getters and setters.

    For this to work, you need to use method alternative to the non-method
    array operations:
    
        a[i] -> instead use a.at(i) 
        a[i] = b -> instead use a.atPut(i, b)
        delete a[i] -> instead use a.removeAt(i)
    
    
    Example use:


*/

window.HookedArray = class HookedArray extends Array {

    initPrototype () {
        this.setupMutatorHooks()
    }

    // ------------------------------

    /*
    nonMutatorMethodNames () {
        // this doesn't cover operators, such as comparison
        const allNames = Object.getOwnPropertyNames(Array.prototype)
        const mutatorNames = mutatorMethodNames
        const getterNames = allNames.filter(name => !mutatorNames.contains(name))
        return getterNames
    }
    */

    mutatorMethodNamesSet () {
        // we can't hook []= or delete[] but we can hook these
        // and use hooked methods instead of operators for those
        return new Set([
            "copyWithin",
            "pop",
            "push",
            "reverse",
            "shift",
            "sort",
            "splice",
            "unshift"
        ])
    }
 

    asReadOnlyShalowCopy () {
        const obj = this.thisClass().withArray(this)
        obj.willMutate = () => {
            throw new Error("attempt to mutate a read only array")
        }
        return obj
    }

    // ------------------------------

    static selfTest () {
        const a = this.clone()

        let gotWillMutate = false
        let gotDidMutate = false

        a.willMutate = () => {
            gotWillMutate = true
        }
        a.didMutate = () => {
            gotDidMutate = true
        }
        a.push("b")
        assert(gotWillMutate)
        assert(gotDidMutate)

        const b = a.asReadOnlyShalowCopy()

        let caughtReadOnlyMutate = false
        try {
            b.pop()
        } catch (e) {
            caughtReadOnlyMutate = true
        }
        assert(caughtReadOnlyMutate)

        console.log(this.type() + " - passed self test")
        return this
    }

}.initThisClass() //.selfTest()


"use strict"

/*

    HookedSet

    A subclass of Set that maintains that hooks the base mutation methods.

    For this to work, you need to use method alternatives to the non-method
    (operator) operations.

*/

window.HookedSet = class HookedSet extends Set {

    initPrototype () {
        this.setupMutatorHooks()
    }

    // ------------------------------

    mutatorMethodNamesSet () {
        return new Set([
            "add",
            "clear",
            "delete"
        ])
    }

    static selfTest () {
        const a = this.clone()
        
        let gotWillMutate = false
        let gotDidMutate = false

        a.willMutate = () => {
            gotWillMutate = true
        }
        a.didMutate = () => {
            gotDidMutate = true
        }

        a.add("b")
        assert(gotWillMutate)
        assert(gotDidMutate)

        console.log(this.type() + " - passed self test")
        return this
    }

}.initThisClass() //.selfTest()


"use strict"

/*

    HookedMap

    A subclass of Map that maintains that hooks the base mutation methods.

    For this to work, you need to use method alternatives to the non-method
    (operator) operations.

*/

window.HookedMap = class HookedMap extends Map {

    initPrototype () {
        this.setupMutatorHooks()
    }

    mutatorMethodNamesSet () {
        return new Set([
            "clear",
            "delete",
            "set",
        ])
    }


    static selfTest () {
        const a = this.clone()
        
        let gotWillMutate = false
        let gotDidMutate = false

        a.willMutate = () => {
            gotWillMutate = true
        }
        a.didMutate = () => {
            gotDidMutate = true
        }

        a.clear()
        assert(gotWillMutate)
        assert(gotDidMutate)

        console.log(this.type() + " - passed self test")
        return this
    }

}.initThisClass() //.selfTest()


"use strict"

/*

    IndexedArray

    A subclass of Array that maintains an dictionary index of the 
    elements of the list via a index closure. The index closure should return 
    a string. For this to work, you need to avoid using the Array 
    operations which can't be overridden:
    
        a[i] -> instead use a.at(i) 
        a[i] = b -> instead use a.atPut(i, b)
        delete a[i] -> instead use a.removeAt(i)
    
    Efficiency:

        The index is produced lazily, so there's (practically) no cost if it isn't used.
        TODO: This could be improved by removing didMutate method until needed? 
        Mutations to the array will set needsReindex property to true.
        On accessing the index (e.g. calling itemForIndexKey(key)), the 
        index will be updated, if needed.

        This could be optimized by overloading some of the mutation operations
        and adding and removing the index as needed without setting the needsReindex to true.
    
    Example use:

        const ia = IndexedArray.clone()
        ia.setIndexClosure(item => item.hash())
        ia.push(someItem) // this will trigger reindex
        const hasItem = is.itemForIndexKey(someHash) // this is an O(1) operation

*/

window.IndexedArray = class IndexedArray extends HookedArray {

    initPrototype () {
    }

    init () {
        super.init()
        Object.defineSlot(this, "_index", {}) 
        Object.defineSlot(this, "_indexClosure", null) 
        Object.defineSlot(this, "_needsReindex", false) 
    }

    // index

    setIndex (aDict) {
        this._index = aDict
        return this
    }

    index () {
        if (this._needsReindex) {
            this.reindex()
        }
        return this._index
    }

    // index closure

    setIndexClosure (aFunction) {
        if (aFunction !== this._indexClosure) {
            this._indexClosure = aFunction
            this.setNeedsReindex(true)
        }
        return this
    }

    indexClosure () {
        return this._indexClosure
    }

    isIndexed () {
        return Type.isFunction(this._indexClosure)
    }

    // --- lazy reindexing ---

    setNeedsReindex (aBool) {
        this._needsReindex = aBool
        return this
    }

    needsReindex () {
        return this._needsReindex
    }

    reindex () {
        this.setNeedsReindex(false) // do this first to avoid infinite loop
        this.setIndex({})
        this.forEach( v => this.addItemToIndex(v) )
        return this
    }

    hasIndexedItem(anObject) {
        const key = this.indexKeyForItem(anObject)
        return !Type.isUndefined(this.itemForIndexKey(key))
    }

    didMutate (slotName, optionalValue) {
        super.didMutate(slotName, optionalValue)

        if (this._indexClosure && !this._needsReindex && optionalValue) {
            // If we don't already need to reindex, 
            // check if we can avoid it.
            // These cover the common use cases.

            /*
            if (slotName === "push") {
                // need to add a way to handle multiple arguments first
                optionalArguments.forEach(v => this.addItemToIndex(v))
                return
            }
            */

            if (slotName === "atPut") {
                // We can just add it, instead of doing a fill reindex.
                this.addItemToIndex(optionalValue)
                return
            }

            if (slotName === "removeAt") {
                if (!this.contains(optionalValue)) {
                    // No copies of this value in the array, 
                    // so we can just remove it from the index.
                    this.removeItemFromIndex(optionalValue)
                    return
                }
            }
        }

        this.setNeedsReindex(true)
    }

    // accessing index - public

    itemForIndexKey (key) { // public
        //if (this.hasIndexKey(key)) {
        return this.index().at(key)
        //}
    }

    indexHasItem (v) { // public
        assert(this.isIndexed()) 
        const key = this.indexClosure()(v)
        return this.hasIndexKey(key)
    }

    // indexing - private

    hasIndexKey (key) { // private
        return this._index.hasOwnProperty(key)
    }

    indexKeyForItem (v) { // private
        const key = this.indexClosure()(v)
        return key
    }

    addItemToIndex (v) { // private
        const key = this.indexKeyForItem(v)
        assert(Type.isString(key))
        this._index.atPut(key, v)
        return this
    }

    removeItemFromIndex (v) { // private
        const key = this.indexKeyForItem(v)
        this._index.removeAt(key)
        return this
    }

    // --------------------------------

    static selfTest () {
        let ia = IndexedArray.clone()
        ia.setIndexClosure(v => v.toString())
        ia.push(123)
        let result = ia.itemForIndexKey("123")
        assert(result === 123)
        return this
    }

}.initThisClass() //.selfTest()

"use strict"

/*

    SortedArray

    A subclass of IndexedArray that maintains it's items in sorted order. 
    The sort closure should return 
    
    Efficiency:

    Once sorted, a binary insert would be faster.
    TODO: remove didMutate method when sortFunc is not defined?

    
    Example use:

        const sa = SortedArray.clone()
        sa.setSortFunc(function (a, b) { return a.compare(b) })
        sa.push(someItem) // this will trigger resort

*/

window.SortedArray = class SortedArray extends IndexedArray {

    initPrototype () {

    }

    init () {
        super.init()
        Object.defineSlot(this, "_isSorting", false)
        Object.defineSlot(this, "_sortFunc", null)
    }

    doesSort () {
        return !Type.isNull(this._sortFunc)
    }

    setSortFunc (aFunc) {
        if (this._sortFunc !== aFunc) {
            this._sortFunc = aFunc
            this.resort()
        }
        return this
    }

    sortFunc () {
        return this._sortFunc
    }


    // sort

    didChangeSlotSortFunc (oldValue, newValue) {
        this.resort()
    }

    resort () {
        if (this._sortFunc && this.length && !this._isSorting) {
            this._isSorting = true
            this.sort(this._sortFunc)
            this._isSorting = false
        }
        return this
    }

    needsResortOnForSlot (slotName) {
        const nonOrderChangingSlots = ["sort", "pop", "shift", "removeAt", "remove", "removeAll"]
        return !nonOrderChangingSlots.contains(slotName)
    }

    didMutate (slotName, optionalValue) {
        if (this._isSorting) {
            return
        }

        super.didMutate(slotName, optionalValue)

        if (this._sortFunc && this.needsResortOnForSlot(slotName)) {
            this.resort()
        }
    }
    
    // --------------------------------

    static selfTest () {
        let sa = this.clone() 
        sa.setSortFunc((a, b) => { return a - b })
        sa.push(3, 1, 2)
        assert(sa.isEqual([1, 2, 3]))
        return this
    }

}.initThisClass() //.selfTest()

"use strict"

ResourceLoader.pushRelativePaths([
    "Dictionary.js",
    "AtomicDictionary.js",
]);



"use strict"

/*

    Dictionary

    A wrapper for a Javascript dictionary/object.
    We can use this to ensure all dictionary methods are hooked.


*/

window.ideal.Dictionary = class Dictionary extends ProtoClass {
    static withJsDict (jsDict) {
        return this.clone().setJsDict(jsDict)
    }

    initPrototype() {
        // don't call super as it's init was called when it was created
        this.newSlot("jsDict", null)
        this.newSlot("mutateClosure", null)
    }

    init () {
        super.init()
        this.clear();
    }

    clear () {
        this.setJsDict({});
        return this
    }

    setJsDict (anObject) {
        this.willMutate()
        assert(Type.isObject(anObject))
        this._jsDict = anObject
        return this
    }

    keys () {
        return Object.keys(this.jsDict());
    }

    values () {
        const dict = this.jsDict()
        return this.keys().map( k => dict[k] )
    }

    at (k) {
        return this.jsDict().getOwnProperty(k)
    }

    /*
    mapAt (k) {
        const v = this.at(k);
        if (typeof(v) !== "object" || (Object.getPrototypeOf(v) !== Object.prototype)) {
            return v;
        }
        else {
            return this.thisClass().withJsDict(v)
        }
    }
    */

    atPut (k, v) {
        const dict = this.jsDict()
        if (dict[k] !== v) {
            this.willMutate()
            dict[k] = v;
        }
        return this;
    }

    atIfAbsentPut (k, v) {
        if (!this.hasKey(k)) {
            this.atPut(k, v);
        }
        return this;
    }

    /*
    valuesSortedByKeys () {
        return this.keys().sort().map(k =>  this.at(k))
    }
    */

    ownForEachKV (fn) {
        return this.forEach(fn)
    }

    forEach (fn) {
        const jsDict = this.jsDict();
        this.keys().forEach( k => fn(k, jsDict[k]) )
        return this;
    }

    map (fn) {
        const jsDict = this.jsDict();
        return this.keys().map( k => fn(k, jsDict[k]) )
    }

    /*
    filtered (fn) {
        const map = this.thisClass().clone();
        const jsDict = this.jsDict();
        this.keys().forEach(function (k) {
            const v = jsDict[k];
            if (fn(k, v)) {
                map.atPut(k, v);
            }
        });
        return map;
    }
    */

    asJson () {
        return JSON.stringify(this.jsDict(), null, 2);
    }

    isEmpty () {
        return Object.keys(this.jsDict()).length === 0;
    }

    keySet () {
        return this.keys().asSet()
    }

    isEqual (other) {
        assert(other.isKindOf(Dictionary)) // protocol check would be better

        const allKeys = this.keySet().union(other.keySet())
        const nonMatchingKey = allKeys.detect(k => this.at(k) !== other.at(k))
        return Type.isNullOrUndefined(nonMatchingKey)
    }

    /*
    atPath (pathList) {
        return Object.atPath(this.jsDict(), pathList);
    }

    merged (aMap) {
        return this.shallowCopy().merge(aMap);
    }
    */

    shallowCopy () {
        return this.thisClass().withJsDict(Object.assign({}, this.jsDict()));
    }

    merge (other) {
        const jsDict = this.jsDict();
        other.ownForEachKV((k, v) => { this.atPut(k, v) } )
        return this;
    }

    size () {
        return this.keys().size();
    }

    /*
    has(k) {
        return this.jsDict().hasOwnProperty(k);
    }
    */

    hasKey (k) {
        return this.jsDict().hasOwnProperty(k);
    }

    removeAt (k) {
        console.log(this.typeId() + " warning: using removeAt instead of removeKey")
        return this.removeKey(k)
    }

    removeKey (k) {
        this.willMutate()
        delete this.jsDict()[k];
        return this;
    }

    // extra helpers

    totalBytes () {
        let byteCount = 0
        this.jsDict().ownForEachKV((k, v) => {
            byteCount += k.length + v.length
        })
        return byteCount
    }

    willMutate () {
        if (this.mutateClosure()) {
            this.mutateClosure()(this)
        }
    }

}.initThisClass()
"use strict"

/*

    AtomicDictionary

    TODO: map dictionary operators to methods or raise exceptions?

*/

window.ideal.AtomicDictionary = class AtomicDictionary extends ideal.Dictionary {

    initPrototype () {
        this.newSlot("hasBegun", false) // private method
        this.newSlot("oldVersion", null) // private method
        this.newSlot("isOpen", true) // private method
        this.newSlot("keysAndValuesAreStrings", true) // private method
    }

    init () {
        super.init()
    }

    open () {
        this.setIsOpen(true)
        return this
    }

    assertOpen () {
        assert(this.isOpen())
    }

    asyncOpen (callback) {
        this.setIsOpen(true)
        callback()
    }

    close () {
        this.setIsOpen(false)
        return this
    }

    begin () {
        this.assertAccessible()
        this.assertNotInTx()
        let old = this.jsDict().shallowCopy()
        this.setOldVersion(old) // so no one else has a reference to our copy
        this.setHasBegun(true)
        return this
    }

    revert() {
        this.assertInTx()
        // replace dict with old version
        this.setJsDict(this.oldVersion()) 
        this.setOldVersion(null)
        this.setHasBegun(false)
        return this
    }

    commit () {
        this.assertInTx()
        // erase old version
        this.setOldVersion(null) 
        this.setHasBegun(false)
        return this
    }

    /*
        - changeEntries 
        Usefull for sharing changes with a peer or server.
        Note: We may need a 2 phase commit where we hold onto old version
        until remote share acknowledges commit
    */

    changeEntries () {
        // format: ["key", newValueIfNotDelete]
        const entries = []

        const d1 = this.oldVersion()
        const d2 = this.jsDict()

        const k1 = Object.keys(d1).asSet()
        const k2 = Object.keys(d2).asSet()

        const keys = k1.union(k2)

        keys.forEach((k) => {
            const v1 = d1[k]
            const v2 = d2[k]

            if (v1 !== v2) {
                if (Type.isUndefined(v2)) {
                    entries.push([k]) // removeKey(k)
                } else if (Type.isUndefined(v1)) {
                    entries.push([k, v2]) // atPut(k, v2)
                }
            }
        })

        return entries
    }

    commitApplyChangeEntries (entries) {
        this.begin()

        entries.forEach((entry) => {
            const k = entry[0]
            const v = entry[1]

            if (Type.isUndefined(v)) {
                this.removeKey(k)
            } else {
                this.atPut(k, v)
            }
        })

        this.commit()
    }

    // just need to make sure writes happen within a transaction

    assertInTx () { // private
	    assert(this.hasBegun())
    }

    assertNotInTx () { // private
	    assert(!this.hasBegun())
    }

    atPut (k, v) {
        if (this.keysAndValuesAreStrings()) {
            assert(Type.isString(k))
            assert(Type.isString(v))
        }

        this.assertAccessible()
        this.assertInTx()
        return super.atPut(k, v)
    }

    removeKey (k) {        
        if (this.keysAndValuesAreStrings()) {
            assert(Type.isString(k))
        }

        this.assertAccessible()
        this.assertInTx()
        return super.removeKey(k)
    }

    // extras 

    assertAccessible () {
        this.assertOpen()
    }

    keys () {
        this.assertAccessible()
        return Object.keys(this.jsDict());
    }
	
    values () {
        this.assertAccessible()
        return Object.values(this.jsDict());
    }

    size () {
        this.assertAccessible()
        return this.keys().length
    }	

    asJsonString () {
        this.assertAccessible()
        // WARNING: this can be slow for a big store!
        return this.jsDict()
    }

    totalBytes () {
        this.assertAccessible()
        let byteCount = 0
        this.jsDict().ownForEachKV((k, v) => {
            byteCount += k.length + v.length
        })
        return byteCount
    }

    // test

    static selfTest () {
        this.selfTest_changeEntries()
    }

    static selfTest_changeEntries () {
        // changeEntries test
        const ad1 = this.clone()
        const ad2 = this.clone()

        ad1.begin()
        ad1.atPut("foo", "bar")
        ad1.commit()

        ad1.begin()
        ad1.removeAt("foo")
        let entries = ad1.changeEntries()
        ad1.commit()

        ad2.commitApplyChangeEntries(entries)

        assert(ad1.isEqual(ad2))

        return this
    }
}.initThisClass()//.selfTest()


"use strict"

/*
    
    StackTrace
    
    Class that can parse a JS stack trace, into StackFrame objects.


*/

window.StackFrame = class StackFrame extends ProtoClass {
    initPrototype () {
        this.newSlot("functionName", null)
        this.newSlot("url", null)
        this.newSlot("lineNumber", null)
        this.newSlot("characterNumber", null)
    }

    init() {
        super.init()
    }

    fromLine(line) {
        line = line.after("at ")

        if (line.contains("(")) {
            const functionName = line.before("(").strip()
            this.setFunctionName(functionName)
            line = line.between("(", ")").strip()
        }
        
        const parts = line.split(":")
        if (parts.length !== 4) {
            console.log("unexpected stacktrace line format: '" + line + "'")
            return this
        }
        const lineNumber = parts.removeLast()
        this.setLineNumber(Number(lineNumber))

        const characterNumber = parts.removeLast()
        this.setCharacterNumber(Number(characterNumber))

        const url = parts.join(":")
        this.setUrl(url)

        return this
    }

    description() {
        return "  " + this.functionName() + "() line " + this.lineNumber()
    }

    show() {
        console.log(this.description())
    }
}.initThisClass() 


// -----------------------------------------------------------------

window.StackTrace = class StackTrace extends ProtoClass {
    initPrototype () {
        this.newSlot("error", null)
        this.newSlot("stackFrames", [])
    }

    init() {
        super.init()
    }
	
    setError(error) {
        this._error = error

        const lines = error.stack.split("\n")
        const firstLine = lines.removeFirst()
		
        const frames = lines.map((line) => {
            return StackFrame.clone().fromLine(line)
        })
        this.setStackFrames(frames)

        return this
    }

    show() {
        console.log(this.type() + ": '" + this.error().message + "'")
        this.stackFrames().forEach(frame => frame.show())
    }

    test() {
        const f1 = function() {
            try {
                throw(new Error("test error"))
            } catch(e) {
                StackTrace.clone().setError(e).show()
            }
        }
        
        const f2 = function() { f1() }
        const f3 = function() { f2() }
        f3()        
    }

}.initThisClass() 

//StackTrace.clone().test()
//console.log("Currently running script:", Error.callingScriptURL())

"use strict"

ResourceLoader.pushRelativePaths([
    "ByteFormatter.js",
    "TimePeriodFormatter.js",
    "TimeFormatter.js"
]);



"use strict"

/*

    ByteFormatter
    
	ByteFormatter takes a number of bytes and returns a string with the order of magnitude in 
	standard SI decimal ditial information format.

	example use:

	const stringVersion = ByteFormatter.clone().setValue(aNumberOfBytes).formattedValue()

	example output:

	if aNumberOfBytes was 300, stringVersion would be 300 bytes.
	if aNumberOfBytes was 3,000, stringVersion would be 3 kB.
	if aNumberOfBytes was 30,000, stringVersion would be 30 kB.
	if aNumberOfBytes was 300,000, stringVersion would be 300 kB.
	if aNumberOfBytes was 3,000,000, stringVersion would be 3 MB.
	etc.

*/

window.ByteFormatter = class ByteFormatter extends ProtoClass {
    initPrototype () {

        this.newSlot("value", 0)
        this.newSlot("usePostfix", true)
        this.newSlot("useSpace", false)
        this.newSlot("useLongNames", false)
        this.newSlot("orderNamesShort", ["bytes", "k", "M", "G", "T", "P", "E", "Z", "Y"])
        this.newSlot("orderNamesLong", [
            "bytes", 
            "kilobytes", 
            "megabytes", 
            "gigabytes", 
            "terabytes", 
            "petabytes", 
            "exabytes", 
            "zettabytes", 
            "yottabytes"])
    }

    init() {
        super.init()
    }

    formattedValue() {
        const b = Math.floor(this.value());
        let postfix = this.usePostfix() ? "B" : "";
        let space = this.useSpace() ? " " : "";
		
        const orderNames = this.useLongNames() ? this.orderNamesLong() : this.orderNamesShort();
        let order = Math.floor(Math.log10(b)/3)
        order = Math.min(order, orderNames.length - 1)
        const orderName = orderNames[order]

        if (order === 0 || this.useLongNames()) {
            space = " "
            postfix = ""
        }

        const v = Math.floor(b / Math.pow(10, order*3))
		
        // remove plural if v === 1
        if (orderName[orderName.length-1] === "s" && v === 1) {
            orderName = orderName.substring(0, orderName - 2)
        }
		
        return v + space + orderName + postfix
    }
}.initThisClass()

"use strict"

/*
    
TimePeriodFormatter 

    Takes a number of seconds and formats in a compact format.

	Example use:

	const stringVersion = TimePeriodFormatter.clone().setValueInSeconds(seconds).formattedValue()

	Example output:

	if seconds was 10, stringVersion would be 10s.
	if seconds was 60, stringVersion would be 1m.
	if seconds was 3600, stringVersion would be 1h.
	if seconds was 172800, stringVersion would be 2d.
	etc.

*/

window.TimePeriodFormatter = class TimePeriodFormatter extends ProtoClass {
    initPrototype () {
        this.newSlot("valueInSeconds", 0)
    }

    init() {
        super.init()
    }

    formattedValue() {
        const periods = {
            seconds: "s", 
            minutes: "m", 
            hours: "h", 
            days: "d", 
            months: "months", 
            years: "years"
        }

        const seconds = this.valueInSeconds()
        if (seconds === null) {
            return "?"
        }

        if (seconds < 60) {
            return Math.floor(seconds) + periods.seconds
        }
        
        const minutes = Math.floor(seconds/60)
        if (minutes < 60) {
            return minutes + periods.hours
        }

        const hours = Math.floor(minutes/60)
        if (hours < 24) {
            return hours + periods.hours
        }
        
        const days = Math.floor(hours/24)
        return days + periods.days
    }
}.initThisClass()

"use strict"

/*
    
TimeFormatter 

    Takes a javascript Date and can produces a formatted string description
    following the object's format option properties. 

	Example use:

    const formatter = TimeFormatter.clone()
    formatter.setIs24Hour(false)          // this is the default
    formatter.setShowsMeridiem(true)      // this is the default
    formatter.setUppercaseMeridiem(false) // this is the default
    formatter.setAmString("am")           // this is the default
    formatter.setPmString("am")           // this is the default
    formatter.setShowsSeconds(false)      // this is the default
    formatter.setShowsMilliseconds(false) // this is the default
    formatter.setHourMinuteSpacer(":")    // this is the default
    formatter.setDate(new Date())
    const aDateString = formatter.formattedValue()

    example output:

        "10:11am"


*/

window.TimeFormatter = class TimeFormatter extends ProtoClass {
    initPrototype () {
        this.newSlot("is24Hour", false)
        this.newSlot("showsMeridiem", true)
        this.newSlot("uppercaseMeridem", false)
        this.newSlot("amString", "am")
        this.newSlot("pmString", "pm")
        this.newSlot("doesPadHours", false)
        this.newSlot("showsHours", true)
        this.newSlot("hourMinuteSpacer", ":")
        this.newSlot("showsMinutes", true)
        this.newSlot("showsSeconds", false)
        this.newSlot("showsMilliseconds", false)
        this.newSlot("date", null) // a javascript Date object
    }

    init() {
        super.init()
    }

    paddedNumber (n, padLength) {
        if (!padLength) {
            padLength = 2
        }
        const s = "" + n
        if (s.length < padLength) { 
            return "0".repeat(padLength - s.length) + s
        }
        return s
    }

    getTwelveHours () {
        let h = this.date().getHours()
        if (h > 12) { h -= 12 }
        if (h === 0) { h = 12 }
        return h
    }

    zeroPaddedUSDate () {
        return this.paddedNumber(this.getTwelveHours()) + ":" + this.paddedNumber(this.getMinutes())
    }

    hoursString () {
        let h = this.date().getHours()

        if (!this.is24Hour()) {
            h = this.getTwelveHours()
        }
        
        if (this.doesPadHours()) {
            this.paddedNumber(h)
        }

        return "" + h
    }

    minutesString () {
        return this.paddedNumber(this.date().getMinutes())

    }

    secondsString () {
        return this.paddedNumber(this.date().getSeconds())
    }

    millisecondsString () {
        return this.paddedNumber(this.date().getMilliseconds() % 1000)
    }

    meridiemString() {
        let s = ""
        
        if (this.date().getHours() < 12) {
            s = this.amString()
        } else {
            s = this.pmString()
        }
        
        if (this.uppercaseMeridem()) {
            s = s.toUpperCase()
        }

        return s
    }

    formattedValue() {
        assert(this.date())
        let s = ""

        if (this.showsHours()) {
            s += this.hoursString()
        }

        if (this.showsMinutes()) {
            if (s.length) {
                s += this.hourMinuteSpacer()
            }
            s += this.minutesString()
        } 

        if (this.showsMeridiem()) { // correct location wrt seconds?
            s += this.meridiemString()
        } 

        if (this.showsSeconds()) {
            if (s.length) {
                s += this.hourMinuteSpacer()
            }
            s += this.secondsString()
        } 

        if (this.showsMilliseconds()) {
            if (s.length) {
                s += this.hourMinuteSpacer()
            }
            s += this.millisecondsString() 
        } 

        if (true) {
            const h = this.date().getHours()
            const m = this.date().getMinutes()
            if (h === 0 && m === 0) { 
                s = "midnight"
            }

            if (h === 12 && m === 0) { 
                s = "noon"
            }
        }

        return s
    }
}.initThisClass()





"use strict"

/*

    NamespaceSearch
 
    A way to search the Javascript namespace.
    All slots are enumerated and passed through a user defined closure to find matches.

    Example use:

        const search = new NamespaceSearch()
        search.setSlotMatchClosure(function (slotOwner, slotName, slotValue, slotPath) {
            return slotName === "String"
        })
        search.find()
        assert(search.matchingPaths()[0] === "globalThis/String")

*/

class NamespaceSearch extends ProtoClass {

    init () {
        this.newSlot("visited", null)
        this.newSlot("matchingPaths", null)
        this.newSlot("slotMatchClosure", null)
        this.clear()
    }

    clear () {
        this.setVisited(new Set([this])) // to avoid searching this object
        this.setMatchingPaths([])
    }

    find (searchString) {
        this.clear()

        if (searchString) {
            this.setSlotMatchClosure((slotOwner, slotName, slotValue, slotPath) => {
                return slotName === s
            })
        }

        this.findOnObject(globalThis, ["globalThis"])
        return this
    }

    findOnObject (v, path = []) {
        if (Type.isNullOrUndefined(v)) {
            return false
        }

        if (this._visited.has(v)) {
            return false
        } else {
            this._visited.add(v)
        }

        //const joinedPath = path.join("/")

        Object.getOwnPropertyNames(v).forEach((k) => {
            if (this.canAccessSlot(v, k)) {
                this.findOnSlot(v, k, path)
            }
        })
    }

    canAccessSlot (v, k) {
        // to avoid illegal operation errors
        const descriptor = Object.getOwnPropertyDescriptor(v, k)
        const hasCustomGetter = Type.isUndefined(descriptor.get)
        return !hasCustomGetter
    }

    findOnSlot (slotOwner, slotName, path = []) {
        const localPath = path.shallowCopy()
        localPath.push(slotName)
        
        const slotValue = slotOwner[slotName]

        if (this.doesMatchOnSlot(slotOwner, slotName, slotValue, localPath)) {
            this.addMatchingPath(localPath)
        }

        this.findOnObject(slotValue, localPath)
    }

    doesMatchOnSlot (slotOwner, slotName, slotValue, slotPath) {
        return this.slotMatchClosure()(slotOwner, slotName, slotValue, slotPath)
    }

    addMatchingPath (aPath) {
        const stringPath = aPath.join("/")
        if (!this._matchingPaths.contains(stringPath)) {
            this._matchingPaths.push(stringPath)
        }
        return this
    }

    showMatches () {
        console.log("matchingPaths:")
        this._matchingPaths.forEach(p => console.log("  " + p))
    }

    static selfTest () {
        const ns = NamespaceSearch.clone()
        ns.setSlotMatchClosure(function (slotOwner, slotName, slotValue, slotPath) {
            return slotName === "String"
        })
        ns.find()
        assert(ns.matchingPaths()[0] === "globalThis/String")
    }

}

//NamespaceSearch.selfTest()

"use strict"

ResourceLoader.pushRelativePaths([
    "SyncAction.js",
    "SyncScheduler.js",
    "notifications/_imports.js",
    "Broadcaster.js",
])

"use strict"


/*

    SyncAction

    An action managed by the SyncScheduler.

*/

window.SyncAction = class SyncAction extends ProtoClass {

    static ActionKeyForTargetAndMethod (target, method) {
        return target.typeId() + "." + method
    }

    initPrototype () {
        this.newSlot("target", null)
        this.newSlot("method", null)
        this.newSlot("order", 0)
        this.newSlot("args", null)
    }

    init() {
        super.init()
        //this.setIsDebugging(true)
    }
	
    tryToSend () {
        try {
            this.send()
        } catch(error) {
            console.warn(this.typeId() + ".tryToSend(" + this.description() + ") caught exception: ")
            error.show()
            return error
        }
        return null
    }
	
    send () {
        this.debugLog("   <- sending " + this.description())
        const t = this.target()
        const m = this.method()
        const a = this.args()
        t[m].apply(t, a ? a : [])
        return null
    }
	
    actionsKey () {
        return SyncAction.ActionKeyForTargetAndMethod(this.target(), this.method())
    }
	
    equals (anAction) {
        return anAction !== null && 
               (this.target() === anAction.target()) && 
               (this.method() === anAction.method())
    }
	
    description () {
        const t = this.target() ? this.target().typeId() : "null"
        const o = this.order() === 0 ? "" : " order:" + this.order()
        return t + " " + this.method() + "" + o
    }

}.initThisClass()


"use strict"

/*

    SyncScheduler

    Many state changes can cause the need to synchronize a given object 
    with others within a given event loop, but we only want synchronization to 
    happen at the end of an event loop, so a shared SyncScheduler instance is used to
    track which sync actions should be sent at the end of the event loop and only sends each one once. 

    SyncScheduler should be used to replace most cases where setTimeout() would otherwise be used.

       example use:
    
        window.SyncScheduler.shared().scheduleTargetAndMethod(this, "syncToView")

    Automatic sync loop detection

    It will throw an error if a sync action is scheduled while another is being performed,
    which ensures sync loops are avoided.

    Ordering

    Scheduled actions can also be given a priority via an optional 3rd argument:

        window.SyncScheduler.shared().scheduleTargetAndMethod(this, "syncToView", 1)

    Higher orders will be performed *later* than lower ones. 

    Some typical sync methods:

        // node
    	syncToStore
    	syncToView

        // view
    	syncToNode	
        syncFromNode
        
    When to run

        When a UI event is handled, SyncSchedule.fullSyncNow should be called just before
        control is returned to the browser to ensure that another UI event won't occur
        before syncing as that could leave the node and view out of sync.
            For example:
                - edit view #1
                - sync to node
                - node posts didUpdateNode
                - edit view #2
                - view get didUpdateNode and does syncFromNode which overwrites view state #2

    	
*/

window.SyncScheduler = class SyncScheduler extends ProtoClass {
    initPrototype () {
        this.newSlot("actions", ideal.Dictionary.clone())
        //this.newSlot("syncSets", ideal.Dictionary.clone())
        this.newSlot("hasTimeout", false)
        this.newSlot("isProcessing", false)
        this.newSlot("currentAction", null)
    }

    init () {
        super.init()
    }
    
    /*
    syncSet (syncMethod) {
        const sets = this.syncSets()

        if (!sets.at(syncMethod)) {
            sets.atPut(syncMethod, ideal.Dictionary.clone())
        }
        
        return sets.at(syncMethod)
    }
    */

    newActionForTargetAndMethod (target, syncMethod, order) {
        return SyncAction.clone().setTarget(target).setMethod(syncMethod).setOrder(order ? order : 0)
    }
	
    scheduleTargetAndMethod (target, syncMethod, optionalOrder) { // higher order performed last
        if (!this.hasScheduledTargetAndMethod(target, syncMethod)) {
            const newAction = this.newActionForTargetAndMethod(target, syncMethod, optionalOrder)

            this.debugLog(() => "    -> scheduling " + newAction.description())

            /*
            if (this.isProcessing() && this.currentAction().method() !== "processPostQueue") {
                this.debugLog(() => "    - isProcessing " + this.currentAction().description() +  " while scheduling " + newAction.description())
            }
            */
            
            if (syncMethod !== "processPostQueue") {
                if (this.currentAction() && this.currentAction().equals(newAction)) {
                    const error = [
                        this.typeId(), "LOOP DETECTED: ",
                        "  scheduleTargetAndMethod: \n", newAction.description(),
                        "  while processing: ", this.currentAction().description()
                    ]
                    console.log(error.join())
                    throw new Error(error.join())
                }
            }

            this.actions().atIfAbsentPut(newAction.actionsKey(), newAction)
	    	this.setTimeoutIfNeeded()
            return true
        }
		
        return false
    }

    isSyncingOrScheduledTargetAndMethod(target, syncMethod) {
        const sc = this.hasScheduledTargetAndMethod(target, syncMethod) 
        const sy = this.isSyncingTargetAndMethod(target, syncMethod) 
        return sc || sy;
    }

    hasScheduledTargetAndMethod (target, syncMethod) {
        const actionKey = window.SyncAction.ActionKeyForTargetAndMethod(target, syncMethod)
    	return this.actions().hasKey(actionKey)
    }

    isSyncingTargetAndMethod (target, syncMethod) {
        const ca = this.currentAction()
        if (ca) {
            const action = this.newActionForTargetAndMethod(target, syncMethod)
    		return ca.equals(action)
        }
        return false
    }
    
    actionsForTarget (target) {
        return this.actions().values().select(action => action.target() === target)
    }

    unscheduleTarget (target) {
        this.actionsForTarget(target).forEach(action => {
            this.actions().removeKey(action.actionsKey())
        })
        return this
    }

    unscheduleTargetAndMethod (target, syncMethod) {
        this.actions().removeKey(this.newActionForTargetAndMethod(target, syncMethod).actionsKey())
        return this
    }
	
    setTimeoutIfNeeded () {
	    if (!this.hasTimeout()) {
            this.setHasTimeout(true)
	        setTimeout(() => { 
	            this.setHasTimeout(false)
	            this.processSets() 
	        }, 1)
	    }
	    return this
    }
	
    clearActions () {
	    this.setActions(ideal.Dictionary.clone())
	    return this
    }
	
    orderedActions () {
        const sorter = function (a1, a2) { return a1.order() - a2.order() }
        return this.actions().values().sort(sorter)
    }
	
    processSets () {
        if (this.isProcessing()) {
            console.warn("WARNING: SynScheduler attempt to processSets before last set is completed")
            return this
        }
        assert(!this.isProcessing())

        //console.log(" --- SyncScheduler BEGIN ---")
        //this.show()

        this.setIsProcessing(true)
        let error = null

        //this.debugLog(this.description())
        this.debugLog("Sync")
        
        const actions = this.orderedActions()
        this.clearActions()
 
        actions.forEach((action) => {
            this.setCurrentAction(action)
            //const actionError = action.tryToSend()
            const actionError = action.send()
            if (actionError) {
                error = actionError
            }
            this.setCurrentAction(null)
        })
        
        this.setCurrentAction(null)
        this.setIsProcessing(false)
        
        if (error) {
            throw error
        }

        //console.log(" --- SyncScheduler END ---")

        return this
    }

    actionCount () {
        return this.actions().keys().length
    }

    fullSyncNow () {
        if (this.isProcessing()) {
            this.debugLog(() => "fullSyncNow called while isProcessing so SKIPPING")
            return this
        }

        if (this.actionCount()) {
            this.debugLog(" --- fullSyncNow start --- ")
            let count = 0
            const maxCount = 10

            while (this.actionCount()) {
                /*
                this.(() => " --- processSets # " + count + " --- ")
                this.debugLog(() => this.description())
                this.debugLog(() => window.BMNotificationCenter.shared().notesDescription())
                this.debugLog(" --- ")
                */
                this.processSets()
                count ++
                if (count > 6) {
                    this.debugLog("loop?")
                }
                assert (count < maxCount)
            }

            this.debugLog(" --- fullSyncNow end --- ")
        }

        return this
    }

    actionsDescription () {
        return this.orderedActions().map(action => "    " + action.description() ).join("\n")
    }

    show () {
        console.log(this.type() + ":")
        console.log(this.actionsDescription())
    }

}.initThisClass()

Object.defineSlots(ProtoClass.prototype, {

    scheduleMethod: function(methodName, priority) {
        window.SyncScheduler.shared().scheduleTargetAndMethod(this, methodName, priority)
        return this
    }

})

"use strict"

ResourceLoader.pushRelativePaths([
    "BMNotification.js",
    "BMNotificationCenter.js",
    "BMObservation.js",
])

"use strict"

/*

    BMNotification

*/

window.BMNotification = class BMNotification extends ProtoClass {
    initPrototype () {
        this.newSlot("name", null)
        this.newSlot("sender", null)
        this.newSlot("info", null)
        this.newSlot("center", null) // NotificationCenter that owns this
        this.newSlot("senderStack", null)
    }

    init() {
        super.init()
    }

    senderId () {
        return this.sender().typeId()
    }

    setSender (obj) {
        assert(Type.isObject(obj))
        this._sender = obj
        //this._senderId = obj.typeId())
        return this
    }
    
    isEqual (obs) {
        if (this === obs) { 
            return true 
        }
        
        /*
        const sameName = this.name() === obs.name() 
        const sameSenderId = this.senderId() === obs.senderId() 
        // TODO: testing equivalence of info?
        return sameName && sameSenderId
        */
        // not sure if compiler is smart enough to skip 2nd part
        return this.name() === obs.name()  && this.senderId() === obs.senderId() 
    }

    isPosted () {
        return this.center().hasNotification(this)
    }
    
    post () {
        if (true || this.center().isDebugging()) {
            //console.log(typeof(this.senderId()) + "." + this.senderId() + " posting note " + this.name() + " and recording stack for debug")
            const e = new Error()
            e.name = "" //"Notification Post Stack"
            e.message = this.senderId() + " posting note '" + this.name() + "'" 
            this.setSenderStack(e.stack);
        }

        //console.log("   queuing post " + this.senderId() + " '" + this.name() + "'" )
       
        this.center().addNotification(this)
        return this
    }
    
    /*
    schedulePost () {
	     window.SyncScheduler.shared().scheduleTargetAndMethod(this, "post")
    }
    */

    description () {
        const s = this.senderId() ? this.senderId() : "null"
        const n = this.name() ? this.name() : "null"
        return s + " " + n
    }
}.initThisClass()


"use strict"

/* 

    BMNotificationCenter
    
    A notification system that queues notifications and waits for the 
    app to return to the event loop (using a timeout) to post them. 
    It filters out duplicate notifications (posted on the same event loop) 
    and duplicate observations (same object registering the same observation again).
        
    Warning about Weak links: 
    
        As Javascript doesn't support weak links, you'll need to be careful
        about having your observers tell the NotificationCenter when they 
        are done observing, otherwise, it will hold a reference to them that
        will prevent them from being garbage collected and they'll continue
        to receive matching notifications. 
    
    Weak links solution (for target/sender):
    
        Instead of passing an object reference for: 
        
            BMObservation.setTargetId() and 
            BMNotification.setSender()
        
        you can pass a typeId string/number for the object. e.g. the ideal.js 
        assigns each instance a unique typeId.
        
        This should work assuming:
            - notification receiver doesn't already have a reference to the sender
            - observer can remove it's observation appropriately
        

    Example use:
 
        // start watching for "changed" message from target object
        this._obs = BMNotificationCenter.shared().newObservation().setName("changed").setObserver(this).setTarget(target).watch()
    
        // start watching for "changedStoredSlot" message from any target object
        this._obs = BMNotificationCenter.shared().newObservation().setName("changedStoredSlot").setObserver(this).watch()

        // stop watching this observation
        this._obs.stopWatching()
        
        // stop watching all
        BMNotificationCenter.shared().removeObserver(this)
        
        // post a notification
        const note = BMNotificationCenter.shared().newNote().setSender(this).setName("hello").post()

        // repost same notification
        note.post()

    Broadcast notifications:

        For use cases where the overhead of creating post objects would be costly, 
        it's possible to send a direct message to all name listeners without waiting
        until the event loop to end. These will pass the target itself instead of a Notification object.

        // call's changedStoredSlot(target) on all listeners for "changedStoredSlot"
        BMNotificationCenter.shared().broadcastTargetAndName(this, "changedStoredSlot")

*/

window.BMNotificationCenter = class BMNotificationCenter extends ProtoClass {
    initPrototype () {
        this.newSlot("observations", null) // array 
        this.newSlot("notifications", null) // array 
        this.newSlot("debugNoteName", "appDidInit")
        this.newSlot("currentNote", null)
        this.newSlot("isProcessing", false)
        this.newSlot("nameIndex", null) // dict of dicts
    }

    init() {
        super.init()
        this.setObservations([]);
        this.setNotifications([]);
        this.setNameIndex({});
        //this.setIsDebugging(true)
    }

    // --- observations ----
    
    hasObservation (obs) {
        return this.observations().detect(ob => ob.isEqual(obs))
    }
    
    addObservation (obs) {
        if (!this.hasObservation(obs)) {
            this.observations().push(obs)
        }
        return this
    }

    newObservation () {
        return BMObservation.clone().setCenter(this);
    }

    hasObservationsForTargetId (targetId) {
        const obs = this.observations().detect(obs => obs.targetId() === targetId)
        return !Type.isNullOrUndefined(obs)
    }

    countOfObservationsForTargetId (targetId) {
        const matches = this.observations().filter(obs => obs.targetId() === targetId)
        return matches.length
    }
    
    removeObservation (anObservation) {
        if (true) {
            const filtered = this.observations().filter(obs => !obs.isEqual(anObservation))
            this.setObservations(filtered)
        } else {
            // If possible, we want to send onNoObservers listen targets when 
            // their last observer is removed, so track these

            const targetId = anObservation.targetId()
            let removedMatchingTargetId = false
            let stillHasMatchingTargetId = false

            const filtered = this.observations().filter((obs) => {
                if(obs.isEqual(anObservation)) {
                    if (obs.targetId() === targetId) {
                        removedMatchingTargetId = true
                    }
                    return false
                }
                if (obs.targetId() === targetId) {
                    stillHasMatchingTargetId = true
                }
                return true
            })
            this.setObservations(filtered)

            if (removedMatchingTargetId && !stillHasMatchingTargetId) {
                const target = this.targetForTargetId(targetId) // looks through obs listeners 
                if(target && target.onNoObservers) {
                    target.onNoObservers(this)
                }
            }
        }

        return this
    }

    targetForTargetId (targetId) {
        if (Type.isNullOrUndefined(targetId)) {
            return false
        }

        // this only works if there's an observation whose observer is the target
        // which works, for example, if the target is observing onNoObservers

        const matchObservation = this.observations().detect(obs => obs.observerId() === targetId)
        if (matchObservation) {
            const target = matchObservation.observer()
            return target
        }
        return null
    }
    
    removeObserver (anObserver) {        
        const filtered = this.observations().filter(obs => obs.observer() !== anObserver)
        this.setObservations(filtered)
        return this;
    }

    // --- helpers ---

    observersForName (name) {
        return this.nameToObservers()[name] // returns a set
    }

    // --- notifying ----
    
    hasNotification (note) {
        return this.notifications().detect(n => n.isEqual(note))
    }
    
    addNotification (note) {
        if (!this.hasNotification(note)) {
            /*
            if (note.sender().title && note.sender().title === "STRVCTapp") {
                console.log("NotificationCenter '" + note.sender().title() + "' " + note.name())
            }
            */
            this.notifications().push(note)
		    window.SyncScheduler.shared().scheduleTargetAndMethod(this, "processPostQueue", -1)
        }
        return this
    }

    newNote () {
        return BMNotification.clone().setCenter(this)
    }
    
    // --- timeout & posting ---
    
    processPostQueue () {
        // TODO: for performance, we could make an observationName->observations dictionary
        // but only worthwhile if observation list is sufficiently large

        // keep local ref of notifications and set 
        // notifications to empty array in case any are
        // added while we process them

        /*
        console.log(" --- " + this.type() + " processPostQueue BEGIN ---")
        this.show()
        console.log(" ")
        */
        this.setCurrentNote(null)

        if (!this.isProcessing()) {
            this.setIsProcessing(true)
            //console.log("processPostQueue " + this.notifications().length)
            const notes = this.notifications()
            this.setNotifications([])
            notes.forEach(note => this.postNotificationNow(note))
            //notes.forEach(note => this.tryToPostNotificationNow(note))
            this.setIsProcessing(false)
        } else {
            Error.showCurrentStack()
            console.warn("WARNING: attempt to call processPostQueue recursively while on note: ", this._currentNote)
        }

        //console.log(" --- " + this.type() + " processPostQueue END ---")

        return this
    }

    tryToPostNotificationNow (note) {
        try { 
            this.postNotificationNow(note)
            //this.debugLog("   <- posting " + note.description() )
        } catch (error) {
            console.log(this.type() + " caught exception while posting: " + note.description())
            return error
        }
        return null
    }

    shouldDebugNote (note) {
        return this.isDebugging() === true && (this.debugNoteName() === null || this.debugNoteName() === note.name());
    }
    
    postNotificationNow (note) {
        // use a copy of the observations list in 
        // case any are added while we are posting 
        //
        // TODO: add an dictionary index for efficiency

        this.setCurrentNote(note)
        
        const showDebug = this.shouldDebugNote(note)

        if (showDebug) {
            this.debugLog(" senderId " + note.senderId() + " posting " + note.name())
            //this.showObservers()
        }
        
        const observations = this.observations().shallowCopy()  
      
        observations.forEach( (obs) => {
            if (obs.matchesNotification(note)) {
                if (showDebug) {
                    this.debugLog(" " + note.name() + " matches obs ", obs)
                    this.debugLog(" sending ", note.name() + " to obs " + obs.type())
                }
            
                obs.sendNotification(note)    
                //obs.tryToSendNotification(note)   
            }
        })        
        
        this.setCurrentNote(null)
    }

    show () {
        console.log(this.type() + ":")
        console.log("  posting notes:")
        console.log(this.notesDescription())
        console.log("  observations:")
        console.log(this.observersDescription())
    }

    notesDescription() {
        return this.notifications().map(note => "    " + note.description()).join("\n")
    }

    observersDescription() {
        return this.observations() .map(obs => "    " + obs.description()).join("\n") 
    }
    
    showCurrentNoteStack () {
        if (this.currentNote() === null) {
            //console.log("BMNotificationCenter.showCurrentNoteStack() warning - no current post")
        } else {
            console.log("current post sender stack: ", this.currentNote().senderStack())
        }
    }
}.initThisClass()

"use strict"

/*

    BMObservation

    An abstraction for a NotificationCenter observation. 
    Holds references to which notification message a given observer is wants
    notifications for. 

*/

window.BMObservation = class BMObservation extends ProtoClass {
    initPrototype () {
        this.newSlot("center", null) // NotificationCenter that owns this
        this.newSlot("targetId", null) // uniqueId string for target
        this.newSlot("name", null)
        this.newSlot("observer", null)
        this.newSlot("isOneShot", false)
    }

    init() {
        super.init()
        //this.setIsDebugging(true)
    }

    setTargetId (aString) {
        assert(Type.isString(aString))
        this._targetId = aString
        return this
    }

    setTarget (obj) {
        this.setTargetId(obj ? obj.typeId() : null)
        return this
    }

    matchesNotification (note) {
        const tid = this.targetId()
        const matchesTarget = (tid === null) || (note.senderId() === tid) 
        if (matchesTarget) {
            const name = this.name()
            const matchesName = (note.name() === name) || (name === null)
            return matchesName
        }
        return false
    }

    tryToSendNotification (note) {
        try {
            this.sendNotification(note)       
        } catch(error) {
            console.log("NOTIFICATION EXCEPTION: '" + error.message + "'");
            console.log("  OBSERVER (" + this.observer() + ") STACK: ", error.stack)
            if (note.senderStack()) {
                console.log("  SENDER (" + note.senderId() + ") STACK: ", note.senderStack())
            }

            // how to we propogate the exception so we can inspect it in the debugger
            // without causing an inconsistent state by not completing the other notifications?
            throw error
        }
        return null
    }

    sendNotification (note) {
        if (this.center().isDebugging()) {
            //console.log(this._observer + " received note " + note.name() + " from " + note.sender() )
        }

        const method = this._observer[note.name()]
        if (method) {
            method.apply(this._observer, [note])
        } else {
            if (this.isDebugging()) {
                this.debugLog(" no method found for note name " + note.name())
            }
        }

        if (this.isOneShot()) {
            this.stopWatching()
        }
    }

    isEqual (obs) {
        const sameName = this.name() === obs.name()
        const sameObserver = this.observer() === obs.observer()
        const sameTargetId = this.targetId() === obs.targetId()
        return sameName && sameObserver && sameTargetId
    }

    watch () {
        this.center().addObservation(this)
        //this.target().onStartObserving()
        return this
    }

    stopWatching () {
        this.center().removeObservation(this)
        //this.target().onStopObserving()
        return this
    }

    description () {
        return this.observer().typeId() + " listening to " + this.targetId() + " " + this.name()
    }

}.initThisClass()

"use strict"

/*

    Broadcaster

    Fast notifications that immediately message listeners 
    instead of using Observer and Notification objects.
    As mltiple notifications of the same name are not merged
    within the same event loop, so listeners should implement handlers efficiently.

    Example use:

        // inside a storable node
        init () {
            ...
            Broadcaster.shared().addListenerForName(this, "didChangeStoredSlot")
            ...
        }

        // inside a StoreableNode, on slot change
        onSlotChange (...) {
            ...
            Broadcaster.shared().broadcastEventName("didChangeStoredSlot")
            ...
        }

        // inside a persistent store
        didChangeStoredSlot (aSender) {
            ... tell store to persist it ...
        }

    Example use:
*/

window.Broadcaster = class Broadcaster extends ProtoClass {
    initPrototype () {
        this.newSlot("nameToListenerSet", null)  // dict to set
    }

    init() {
        super.init()
        this.setNameToListenerSet({})
    }

    listenerSetForName (name) {
        assert(!Type.isNullOrUndefined(name))

        // probably not inneficient since 
        // 1. we don't remove listeners often
        // 2. we don't have many names
        const n2l = this.nameToListenerSet()

        let listenerSet = n2l[name]
        if (!listenerSet) {
            listenerSet = new Set()
            n2l[name] = listenerSet
        }
        return listenerSet
    }
	
    addListenerForName (aListener, name) {
        this.listenerSetForName(name).add(aListener)
        return this
    }
    
    removeListenerForName (aListener, name) {
        this.listenerSetForName(name).delete(aListener)
        return this
    }

    broadcastNameAndArgument (methodName, anArgument) {
        for (let it = this.listenerSetForName(methodName).values(), v= null; v=it.next().value; ) {
            v[methodName].apply(v, [anArgument])
        }
        return this
    }

    clean () {
        const n2l = this.nameToListenerSet()
        Object.keys(n2l).forEach((name) => {
            const listenerSet = n2l[name]
            if (listenerSet.values().length === 0) {
                n2l.delete(name)
            }
        })
    }

}.initThisClass()

Object.defineSlots(ProtoClass.prototype, {

    broadcastMessage: function(methodName) {
        window.Broadcaster.shared().broadcastEventName(methodName, this)
        return this
    }
    
})

"use strict"

ResourceLoader.pushRelativePaths([
    "IndexedDBFolder.js",
    "IndexedDBTx.js",
    "PersistentAtomicDictionary.js",
    "PersistentAsyncDictionary.js",
])

"use strict"

/* 

    IndexedDBFolder

*/

window.IndexedDBFolder = class IndexedDBFolder extends ProtoClass {
    initPrototype() {
        this.newSlot("path", "/")
        this.newSlot("pathSeparator", "/") // path should end with pathSeparator
        this.newSlot("db", null)
        this.newSlot("didRequestPersistence", false)
        this.newSlot("isGranted", false)
    }

    init() {
        super.init()
        //this.requestPersistenceIfNeeded()
        this.setIsDebugging(false)
    }

    hasIndexedDB() {
        return "indexedDB" in window;
    }

    requestPersistenceIfNeeded() {
        if (!IndexedDBFolder.didRequestPersistence()) {
            this.requestPersistence()
        }
        return this
    }

    requestPersistence() {
        if (navigator.storage && navigator.storage.persist) {
            navigator.storage.persist().then((granted) => {
                this.setIsGranted(granted)
                if (granted) {
                    alert("Storage will not be cleared except by explicit user action");
                } else {
                    alert("Storage may be cleared by the UA under storage pressure.");
                }
            })
        }

        IndexedDBFolder.setDidRequestPersistence(true)

        return this
    }

    storeName() {
        return this.path()
    }

    root() {
        if (!IndexedDBFolder._root) {
            IndexedDBFolder._root = IndexedDBFolder.clone()
            // IndexedDBFolder._root.rootShow()
        }
        return IndexedDBFolder._root
    }

    isOpen() {
        return (this.db() !== null)
    }

    asyncOpenIfNeeded(callback, errorCallback) {
        if (!this.isOpen()) {
            this.asyncOpen(callback, errorCallback)
        } else {
            callback()
        }
    }

    asyncOpen(successCallback, errorCallback) {

        if (!this.hasIndexedDB()) {
            errorCallback("IndexedDB unavailable on this client.")
            return
        }

        this.debugLog(() => { "asyncOpen '" + this.path() + "'" })

        const request = window.indexedDB.open(this.path(), 2);

        request.onsuccess = (event) => {
            this.onOpenSuccess(event, successCallback, errorCallback)
        }

        request.onupgradeneeded = (event) => {
            this.onOpenUpgradeNeeded(event, successCallback, errorCallback)
        }

        request.onerror = (event) => {
            this.onOpenError(event, successCallback, errorCallback)
        }


        return this
    }

    onOpenError (event, successCallback, errorCallback) {
        let message = event.message
        if (!message) {
            message = "Unable to open IndexedDB.<br>May not work on Brave Browser."
            this.debugLog(" open db error: ", event);
        }

        if (errorCallback) {
            errorCallback(message)
        }
    }

    onOpenUpgradeNeeded (event, successCallback, errorCallback) {
        this.debugLog(" onupgradeneeded - likely setting up local database for the first time")

        const db = event.target.result;

        db.onerror = function (event) {
            console.log("db error ", event)
        };

        this.setDb(db)

        const objectStore = db.createObjectStore(this.storeName(), { keyPath: "key" }, false);
        objectStore.createIndex("key", "key", { unique: true });
    }

    onOpenSuccess(event, successCallback, errorCallback) {
        this.setDb(event.target.result)
        if (successCallback) {
            successCallback()
        }
    }

    close() {
        if (this.isOpen()) {
            this.db().close()
            this.setIsOpen(false)
            this.setDb(null)
        }
        return this
    }

    // paths

    folderAt(pathComponent) {
        assert(!pathComponent.contains(this.pathSeparator()))
        const db = IndexedDBFolder.clone().setPath(this.path() + pathComponent + this.pathSeparator())
        return db
    }

    pathForKey(key) {
        //assert(!key.contains(this.pathSeparator()))
        return this.path() + key
    }

    // reading

    asyncHasKey (key, callback) {
        const objectStore = this.db().transaction(this.storeName(), "readonly").objectStore(this.storeName())
        //const keyRangeValue = IDBKeyRange.bound(key, key)
        //const request = objectStore.openCursor(keyRangeValue)
        const request = objectStore.openCursor(key)

        request.onsuccess = function(e) {
          var cursor = e.target.result
          if (cursor) { // key already exist
             callback(true)
          } else { // key not exist
            callback(false)
          }
        }

        /*
        request.onerror = (event) => {
            console.log("asyncAt('" + key + "') onerror", event.target.error)
            callback(undefined)
        }
        */
    }
    
    asyncAt (key, callback) {
        //console.log("asyncAt ", key)
        const objectStore = this.db().transaction(this.storeName(), "readonly").objectStore(this.storeName())
        const request = objectStore.get(key);

        const stack = "(stack recording disabled)" //new Error().stack
        
        request.onerror = (event) => {
            console.log("asyncAt('" + key + "') onerror", event.target.error)
            callback(undefined)
        }
        
        request.onsuccess = (event) => {
            // request.result is undefined if value not in DB
            try {
                if (!Type.isUndefined(request.result)) {
                    const entry = request.result
                    const value = JSON.parse(entry.value)
                    callback(value)
                } else {
                    callback(undefined)
                }
            } catch (e) {
                this.debugLog(" asyncAt('" +  key + "') caught stack ", stack)
            }
        }
        
        return this
    }
    

    asyncAllKeys(callback) {
        const keys = []
        const cursorRequest = this.db().transaction(this.storeName(), "readonly").objectStore(this.storeName()).openCursor()

        cursorRequest.onsuccess = (event) => {
            const cursor = event.target.result
            if (cursor) {
                keys.push(cursor.value.key)
                cursor.continue()
            } else {
                callback(keys)
            }
        }

        cursorRequest.onerror = (event) => {
            this.debugLog(" asyncAsJson cursorRequest.onerror ", event)
            throw newError("error requesting cursor")
        }
    }

    asyncForeachKey(callback) {
        const cursorRequest = this.db().transaction(this.storeName(), "readonly").objectStore(this.storeName()).openCursor()

        cursorRequest.onsuccess = (event) => {
            const cursor = event.target.result
            if (cursor) {
                const key = cursor.value.key
                callback(key)
                cursor.continue()
            }
        }

        cursorRequest.onerror = (event) => {
            this.debugLog(" asyncAsJson cursorRequest.onerror ", event)
            throw newError("error requesting cursor")
        }
    }


    asyncAsJson(callback) {
        //console.log("asyncAsJson start")
        const cursorRequest = this.db().transaction(this.storeName(), "readonly").objectStore(this.storeName()).openCursor()
        const dict = {}

        cursorRequest.onsuccess = (event) => {
            const cursor = event.target.result;

            if (cursor) {
                dict[cursor.value.key] = JSON.parse(cursor.value.value)
                cursor.continue();
            } else {
                //this.debugLog(" asyncAsJson returning dict ", JSON.stringify(dict))
                callback(dict)
            }
        };

        cursorRequest.onerror = (event) => {
            this.debugLog(" asyncAsJson cursorRequest.onerror ", event)
            throw newError("error requesting cursor")
        }
    }

    show() {
        this.asyncAsJson((json) => {
            this.debugLog(" " + this.path() + " = " + JSON.stringify(json, null, 2))
        })
    }

    // removing

    asyncClear(callback, errorCallback) {
        const transaction = this.db().transaction([this.storeName()], "readwrite");

        transaction.onerror = function (event) {
            if (errorCallback) {
                console.log("db clear error")
                errorCallback(event)
            }
        };

        transaction.oncomplete = function (event) {
            console.log("db clear completed")
        }

        const objectStore = transaction.objectStore(this.storeName());
        const request = objectStore.clear();

        request.onsuccess = function (event) {
            if (callback) {
                console.log("db clear request success")
                callback(event)
            }
        };
    }

    asyncDelete() {
        const request = window.indexedDB.deleteDatabase(this.storeName())

        request.onerror = (event) => {
            this.debugLog("Error deleting '" + this.storeName() + "'");
        }

        request.onsuccess = (event) => {
            this.debugLog(" deleted successfully '" + this.storeName() + "'");
        }

        this.setDb(null)
        return this
    }

    // test

    test() {
        const folder = IndexedDBFolder.clone()
        folder.asyncOpen(() => {
            folder.atPut("test", "x")

            folder.asyncAsJson(function (dict) {
                console.log("db dict = ", dict)
            })

            folder.asyncAt("test", function (value) {
                console.log("read ", value)
            })
        })

    }

    newTx() {
        return window.IndexedDBTx.clone().setDbFolder(this)
    }
}.initThisClass()

"use strict"

/* 

    IndexedDBTx

    Abstraction of a single IndexedDB transaction.

*/

window.IndexedDBTx = class IndexedDBTx extends ProtoClass {
    initPrototype () {
        this.newSlot("dbFolder", null)
        this.newSlot("objectStore", null)
        this.newSlot("tx", null)
        this.newSlot("requests", [])
        this.newSlot("isCommitted", false)
        this.newSlot("txRequestStack", null)
        this.newSlot("succcessCallback", null)
        this.newSlot("errorCallback", null)
    }

    init() {
        super.init()
        this.setIsDebugging(false)
    }

    db () {
        return this.dbFolder().db()
    }
    
    storeName () {
        return this.dbFolder().storeName()
    }
	
    // --- being and commit ---

    assertNotCommitted () {
	    assert(this.isCommitted() === false)
    }

    newTx () {
        assert(Type.isNullOrUndefined(this.tx()))
        const tx = this.db().transaction(this.storeName(), "readwrite")        
        //tx.onerror = (event) => { this.onTxError(event) }
        //tx.onsuccess = (event) => { this.onTxSuccess(event) }

        tx.onerror = (event) => { this.onTxError(event) }
        tx.oncomplete = (event) => { this.onTxSuccess(event) }

        this.setTx(tx)
        return tx
    }

    begin () {
	    this.assertNotCommitted()
        this.setTxRequestStack(this.isDebugging() ? new Error().stack : null)
	    const tx = this.newTx()
        const objectStore = tx.objectStore(this.storeName());
        this.setObjectStore(objectStore)
        return this
    }

    showTxRequestStack () {
        const rs = this.txRequestStack()
        if (rs) { 
            console.log("error stack ", rs)
        }
    }

    onTxError (event) {
        this.showTxRequestStack()
        throw new Error("tx error " + event.target.error)
    }

    onTxSuccess (event) {
        const f = this.succcessCallback()
        if (f) {
            f()
        }
    }
	
    abort () {
	    this.assertNotCommitted()
	    this.tx().abort()
	    return this
    }
	
    commit () {
        this.assertNotCommitted()
        this.setIsCommitted(true)
        if (!Type.isUndefined(this.tx().commit)) {
            this.tx().commit()
        } else {
            console.log("WARNING: no IDBTransation.commit method found for this browser")
        }
	    return this
    }
	
    // --- helpers ---
	
    pushRequest (aRequest) {
	    this.assertNotCommitted()

        const requestStack = this.isDebugging() ? new Error().stack : null
        aRequest.onerror = (event) => {
		    const fullDescription = "writing key '" + aRequest._key + "' on objectStore '" + this.storeName() + "' error: '" + event.target.error + "'"
		    console.warn(fullDescription)
		    if (requestStack) { 
                console.log("error stack ", requestStack)
            }
		  	throw new Error(fullDescription)
        }
	    this.requests().push(aRequest)
	    return this
    }
	
    entryForKeyAndValue (key, object) {
        if (Type.isNullOrUndefined(object)) {
            throw new Error(this.type() + ".entryForKeyAndValue('" + key + "', ...) can't add null value")
        }
		
        const v = JSON.stringify(object)
        if (v === null) {
            throw new Error("can't add entry for null value")
        }
		
        return { key: key, value: v }
    }
	
    // --- operations ----

    /*
    atPut (key, object) {
	    this.assertNotCommitted()

        if (this.hasKey(key)) {
            this.atUpdate(key, object)
        } else {
            this.atAdd(key, object)
        }
        return this
    }
    */
	
    atAdd (key, object) { 
        //assert(!this.hasKey(key))

        assert(Type.isString(key))
        assert(Type.isString(object))
        this.assertNotCommitted()
        
        this.debugLog(() => " add " + key + "'" + object + "'")

        const entry = this.entryForKeyAndValue(key, object)
        const request = this.objectStore().add(entry);
        request._action = "add"
        request._key = key 
        /*
        request.onsuccess = function(event) {
            // report the success of the request (this does not mean the item
            // has been stored successfully in the DB - for that you need transaction.onsuccess)

        }
        */
        this.pushRequest(request)
        return this
    }

    atUpdate (key, object) {
        //assert(!this.hasKey(key))

        assert(Type.isString(key))
        assert(Type.isString(object))
	    this.assertNotCommitted()

        this.debugLog(() => " atUpdate " + key)

        const entry = this.entryForKeyAndValue(key, object)
        const request = this.objectStore().put(entry);
        request._action = "put"
        request._key = key
        this.pushRequest(request)
        return this
    }
    
    removeAt (key) {
	    this.assertNotCommitted()

        this.debugLog(() => " removeAt " + key)

        const request = this.objectStore().delete(key);
        request._action = "remove"
        request._key = key
        this.pushRequest(request)
        return this
    }
    
}.initThisClass()





"use strict"

/*

    PersistentAtomicDictionary

    An atomic persistent dictionary implemented as 
    a read & write cache on top of IndexedDB.
    
    On open, it reads the entire db into a dictionary
    so we can do synchronous reads and writes (avoiding IndexedDB's async API),
    and then call the async commit at the end of the event loop.

    - keys and values are assumed to be strings

    - at(key) returns a value from the internal dict
    - begin() shallow copies the current internal dict
    - atPut(key, value) & removeAt(key)
        applies normal op and adds key to changedKeys
    - revert()
        not supported yet
    - commit() constructs a transaction using changedKeys 
	- at(key) first checks the writeCache beforing checking the readCache
	
	- any exception between begin and commit should halt the app and require a restart to ensure consistency
	
    TODO: auto sweep after a write if getting full?
        
*/

window.PersistentAtomicDictionary = class PersistentAtomicDictionary extends ideal.AtomicDictionary {
    initPrototype () {
        this.newSlot("name", "PersistentAtomicDictionary")
        this.newSlot("idb", null)
        this.newSlot("changedKeys", null)
    }

    init() {
        super.init()
        this.setIsOpen(false)
        this.setChangedKeys(new Set())
        this.setIdb(IndexedDBFolder.clone())
        //this.setIsDebugging(true)
    }
    
    // open

    assertAccessible () {
        super.assertAccessible()
        this.assertOpen()
    }

    open () {
        throw new Error(this.type() + " synchronous open not supported")
        return this
    }

    close () {
        if (this.isOpen()) {
            this.idb().close()
            this.setIsOpen(false)
        }
        return this
    }

    asyncOpen (callback, errorCallback) {
        this.idb().setPath(this.name())
        this.idb().asyncOpenIfNeeded( () => this.onOpen(callback), errorCallback )
        return this
    }
	
    onOpen (callback, errorCallback) {
        // load the cache
        this.debugLog(" onOpen() - loading cache")
        
        if (false) {
            this.setJsDict({})
            this.setIsOpen(true)
            this.asyncClear(callback)
        } else {
            this.idb().asyncAsJson((dict) => {
                //console.log(this.type() + " onOpen() --- loaded cache with " + Object.keys(dict).length + " keys")
                this.setJsDict(dict)
                this.setIsOpen(true)
                if (callback) {
                    callback()
                }
                //this.verifySync()
            })
        }
    }
	
    assertOpen () {
        assert(this.isOpen())
        return this
    }
	
    // ----
		
    asyncClear (callback) {
        //throw new Error("PersistentAtomicDictionary clear")
        this.setJsDict({})
        this.idb().asyncClear(callback) // TODO: lock until callback?
    }
		
    // transactions

    begin() {
        this.debugLog(this.type() + " begin ---")
        this.assertOpen()
        super.begin()
        assert(this.changedKeys().size === 0)
        this.changedKeys().clear()
        return this
    }

    revert() {
        super.revert()
        this.changedKeys().clear()
        return this
    }
	
    commit () { // public
        this.debugLog(this.type() + " prepare commit ---")
	    // push to indexedDB tx 
	    // TODO: lock until IndexedDB's tx complete callback is received,
        // ::: super.commit() is at end of method

	    this.assertInTx()
	    const tx = this.idb().newTx()
	    tx.begin()
        tx.setIsDebugging(this.isDebugging())
        
	    let count = 0
        
        const keys = this.changedKeys().keysArray()
        const dict = this.jsDict()
        keys.forEach((k) => {
            const isDelete = !dict.hasOwnProperty(k)

            if (isDelete) {
                tx.removeAt(k)
            } else {
                const isUpdate = this.oldVersion().hasOwnProperty(k)
                const v = dict[k]
                
                if (isUpdate) {
                    tx.atUpdate(k, v)
                } else {
                    tx.atAdd(k, v)
                }                
            }
            count ++
        })
		
        // indexeddb commits on next event loop automatically
        // this tx.commit() is just a sanity check -  marks the tx as committed so it raises exception 
        // if we attempt to write more to the same tx 
		 
        tx.commit() // TODO: lock until commit callback?
		
        this.debugLog(() => "---- " + this.type() + " committed tx with " + count + " writes ----")

        super.commit()
        this.changedKeys().clear()
        return count
    }
	
    atPut (key, value) {
        if (this.at(key) !== value) { 
            super.atPut(key, value)
            this.changedKeys().add(key)
        }
        return this
    }
	
    removeKey (key) {
        if (this.hasKey(key)) {
            super.removeKey(key)
            this.changedKeys().add(key)
        }
        return this
    }

    // --- helpers ---

    verifySync () {
        this.idb().asyncAsJson( (json) => {	 // BUG: we want to compare strings not json
            const isSynced = json.isEqual(this.jsDict())
            if (!isSynced) {
                //this.idb().show()
                //console.log("syncdb idb json: ", JSON.stringify(json, null, 2))
                throw new Error(this.type() + " verifySync failed")
            }
        })
    }
}.initThisClass()


"use strict"

/*

    PersistentAsyncDictionary

    An async dictionary wrapper for IndexedDB.

    Public methods:

        asyncOpen(resolve, errorCallback) 
        close()
        asyncClear(resolve)
        asyncHasKey(key, resolve)  // resolve passes true or false
        asyncAt(key, resolve) // resolve passes value or undefined
        asyncAtPut(key, value, resolve, reject) 
        asyncRemoveKey(key, resolve, reject)
        
*/

window.PersistentAsyncDictionary = class PersistentAsyncDictionary extends ProtoClass {
    initPrototype () {
        this.newSlot("name", "PersistentAsyncDictionary")
        this.newSlot("idb", null)
    }

    init() {
        super.init()
        this.setIdb(IndexedDBFolder.clone())
        //this.setIsDebugging(true)
    }
    
    // open

    assertAccessible () {
        super.assertAccessible()
        this.assertOpen()
    }

    isOpen () {
        return this.idb().isOpen()
    }

    open () {
        throw new Error(this.type() + " synchronous open not supported")
        return this
    }

    close () {
        if (this.isOpen()) {
            this.idb().close()
            this.setIsOpen(false)
        }
        return this
    }

    asyncOpen (resolve, reject) {
        this.idb().setPath(this.name())
        this.idb().asyncOpenIfNeeded( () => {
            this.onOpen(resolve) 
        }, reject )
        return this
    }
	
    onOpen (resolve, reject) {
        // load the cache
        this.debugLog(" onOpen() - loading cache")
        
        if (false) {
            this.asyncClear(callback)
        } else {
            if (resolve) {
                resolve()
            }
        }
    }
	
    assertOpen () {
        assert(this.isOpen())
        return this
    }
	
    // ---- operations ---
		
    asyncClear (resolve) {
        this.idb().asyncClear(resolve) 
    }

    asyncAllKeys (resolve) {
        this.idb().asyncAllKeys(resolve) 
    }

    asyncHasKey (key, resolve) { // resolve passes true or false
        this.idb().asyncHasKey(key, resolve) 
    }

    /*
    async asyncHasKey (key) {
        return new Promise((resolve, reject) => {
            this.idb().hasKey(key, resolve) 
        })
    }
    */

    asyncAt (key, resolve, reject) { // resolve passes value or undefined
        assert(!Type.isNullOrUndefined(resolve))
        this.idb().asyncAt(key, resolve, reject)
    }

    asyncAtPut (key, value, resolve, reject) {
        this.asyncHasKey(key, (hasKey) => {
            if (hasKey) {
                this.asyncUpdate(key, value, resolve, reject)
            } else {
                this.asyncAdd(key, value, resolve, reject)
            }
        })
    }

    asyncUpdate (key, value, resolve, reject) { // private
	    const tx = this.idb().newTx()
	    tx.begin()
        tx.setIsDebugging(this.isDebugging())
        tx.setSucccessCallback(resolve)
        tx.setErrorCallback(reject)
        tx.atUpdate(key, value)
        tx.commit() 
    }

    asyncAdd (key, value, resolve, reject) { // private
	    const tx = this.idb().newTx()
	    tx.begin()
        tx.setIsDebugging(this.isDebugging())
        tx.setSucccessCallback(resolve)
        tx.setErrorCallback(reject)
        tx.atAdd(key, value)
        tx.commit() 
    }

    asyncRemoveKey (key, resolve, reject) {
	    const tx = this.idb().newTx()
	    tx.begin()
        tx.setIsDebugging(this.isDebugging())
        tx.setSucccessCallback(resolve)
        tx.setErrorCallback(reject)
        tx.removeAt(key)
        tx.commit() 
    }

}.initThisClass()


"use strict"

ResourceLoader.pushRelativePaths([
    //"css/_imports.js",
    "geometry/_imports.js",
    "events/_imports.js",
    "webbrowser/_imports.js",
    "dom_views/_imports.js",
])


"use strict"

ResourceLoader.pushRelativePaths([
    "Point.js",
    "Rectangle.js",
    "Transform.js",
])


"use strict"

/*
    Point

    Class to represent a 2d or 3d point, optionally with a time.

    TODO: create a separate EventPoint class...

*/


window.Point = class Point extends ProtoClass {
    initPrototype () {
        this.newSlot("x", 0)
        this.newSlot("y", 0)
        this.newSlot("z", 0)
        this.newSlot("t", 0)
    }

    /*
    init () {
        super.init()
        return this
    }
    */

    valueArray () {
        return [this._x, this._y, this._z]
    }

    setTimeToNow () {
        const d = new Date();
        this._t = d.getTime();
        return this
    }

    copyFrom (p, copyDict) {
        this._x = p._x
        this._y = p._y
        this._z = p._z
        this._t = p._t
        return this
    }
    
    set (x, y, z, t) {
        this._x = x;
        this._y = y;
        if (z || z === 0) {
            this._z = z
        }
        if (t || t === 0) {
            this._t = t
        }
        return this
    }

    addInPlace (p) {
        this._x += p._x
        this._y += p._y
        this._z += p._z
        this._t += p._t
        return this
    }

    subtractInPlace (p) {
        this._x -= p._x
        this._y -= p._y
        this._z -= p._z
        this._t -= p._t
        return this
    }

    floorInPlace () {
        this._x = Math.floor(this._x)
        this._y = Math.floor(this._y)
        this._z = Math.floor(this._z)
        return this
    }

    copy () {
        return this.thisClass().clone().copyFrom(this)
    }

    add (p) {
        return this.copy().addInPlace(p)
    }

    subtract (p) {
        return this.copy().subtractInPlace(p)
    }

    asString () {
        let s = this.type() + "(" + this._x + ", " + this._y 

        if (this._z) { 
            s += ", " + this._z
        }

        /*
        if (this._t) { 
            s += ", " + this._t + "t" 
        }
        */

        return s + ")"
    }

    distanceFromOrigin () {
        const ds = Math.pow(this.x(), 2) + Math.pow(this.y(), 2) + Math.pow(this.z(), 2)
        return Math.sqrt(ds)
    }

    // difference with another point

    dxFrom (p) {
        return this.x() - p.x()
    }

    dyFrom (p) {
        return this.y() - p.y()
    }

    dzFrom (p) {
        return this.z() - p.z()
    }

    dtFrom (p) {
        return this.t() - p.t()
    }

    distanceFrom (p) {
        const dx = this.dxFrom(p)
        const dy = this.dyFrom(p)
        const dz = this.dzFrom(p)
        return Math.sqrt(dx*dx + dy*dy + dz*dz)
    }

    // eqaulity

    isEqual (p) {
        return (this.x() === p.x()) && (this.y() === p.y()) && (this.z() === p.z()) // && (this.t() === p.t())
    }

    isEqualWithTime (p) { // not ideal
        return (this.x() === p.x()) && (this.y() === p.y()) && (this.z() === p.z()) && (this.t() === p.t())
    }

    // comparison 

    isGreaterThan (p) {
        return this.x() > p.x() && this.y() > p.y()
    }

    isLessThan (p) {
        return this.x() < p.x() && this.y() < p.y()
    }

    isGreaterThanOrEqualTo (p) {
        return this.x() >= p.x() && this.y() >= p.y()
    }

    isLessThanOrEqualTo (p) {
        return this.x() <= p.x() && this.y() <= p.y()
    }

    angleInRadians () {
        return Math.atan2(y, x);
    }

    angleInDegrees () {
        return this.angleInRadians() * 180 / Math.PI;
    }

    angleInRadiansTo (p) {
        return p.subtract(this).angleInRadians()
    }

    angleInDegreesTo (p) {
        return p.subtract(this).angleInDegrees()
    }

    midpointTo (p) {
        return this.add(p).divideByScalar(2)
    }

    multiplyByScalar (v) {
        const p = Point.clone()
        p.set(this.x() * v, this.y() * v, this.z() * v)
        return p
    }

    divideByScalar (v) {
        return this.multiplyByScalar(1/v)
    }

    negated (p) {
        return this.multiplyByScalar(-1)
    }

    // css

    asCssStringWithUnitSuffix (name, unitSuffix) {
        if (!unitSuffix) { 
            unitSuffix = ""
        }

        const us = unitSuffix;
        return name + "(" + this._x + us + "," + this._y + us + "," + this._z + us + ")"
        //const s = this.valueArray().map(v => v + unitSuffix).join(",")
        //return name + "(" + s + ")"
    }

    asCssTranslate3dString () {
        return this.asCssStringWithUnitSuffix("translate3d", "px")
    }

    asCssRotate3dDegreesString () {
        return this.asCssStringWithUnitSuffix("rotate3d", "deg")
    }

    asCssScale3dString () {
        return this.asCssStringWithUnitSuffix("scale3d", "")
    }

    // size - TODO: move to Size type?

    width () {
        return this.x()
    }

    height () {
        return this.y()
    }
    
}.initThisClass()

"use strict"

/*
    Rectangle

    Class to represent a rectangle.

    NOTES

    For top & bottom, we assume we are using screen coordinates so:

        top = x
    
    and:

        bottom = x + height

*/

window.Rectangle = class Rectangle extends ProtoClass {
    initPrototype () {
        this.newSlot("origin", null)
        this.newSlot("size", null)
    }

    init () {
        super.init()
        this.setOrigin(Point.clone())
        this.setSize(Point.clone())
        return this
    }

    duplicate () {
        return this.thisClass().clone().copyFrom(this)
    }

    copyFrom (aRect) {
        this.origin().copyFrom(aRect.origin())
        this.size().copyFrom(aRect.size())
        return this
    }
    
    containsPoint (p) {
        const a = p.isGreaterThanOrEqualTo(this.origin()) 
        const b = p.isLessThanOrEqualTo(this.maxPoint())
        return a && b
    }

    containsRectangle (r) {
        return r.origin().isGreaterThanOrEqualTo(this.origin()) && r.maxPoint().isLessThanOrEqualTo(this.maxPoint())
    }

    unionWith (r) {
        const u = Rectangle.clone()
        const o1 = this.origin()
        const o2 = r.origin()
        const m1 = this.maxPoint()
        const m2 = r.maxPoint()
        const minX = Math.min(o1.x(), o2.x())
        const minY = Math.min(o1.y(), o2.y())
        u.origin().setX(minX)
        u.origin().setY(minY)
        const maxX = Math.max(m1.x(), m2.x())
        const maxY = Math.max(m1.y(), m2.y())
        u.setWidth(maxX - minX)
        u.setHeight(maxY - minY)
        return u
    }

    maxPoint () {
        return this.origin().add(this.size())
    }

    asString () {
        return this.type() + "(" + this.origin().asString() + ", " + this.size().asString() + ")"
    }

    // x, y

    x () {
        return this.origin().x();
    }

    y () {
        return this.origin().y();
    }

    minX () {
        return this.x()
    }

    minY () {
        return this.y()
    }

    maxX () {
        return this.x() + this.width()
    }

    maxY () {
        return this.y() + this.height()
    }
    
    setMaxX (mx) {
        const w = mx - this.x()
        this.setWidth(w)
        return this
    }

    setMaxY (my) {
        const h = my - this.y()
        this.setHeight(h)
        return this
    }

    // width 

    setWidth (w) {
        assert(w >= 0)
        this.size().setX(w)
        return this
    }

    width () {
        return this.size().x();
    }

    // height

    setHeight (h) {
        assert(h >= 0)
        this.size().setY(h)
        return this
    }

    height () {
        return this.size().y();
    }

    // top, bottom

    top () {
        return this.y() 
    }

    bottom () {
        return this.y() + this.height() 
    }

    // left, right

    left () {
        return this.x() 
    }

    right () {
        return this.x() + this.width() 
    }

    makeBoundsOfPoints (points) {
        let minX = points[0].x()
        let maxX = points[0].x()
        let minY = points[0].y()
        let maxY = points[0].y()
        points.forEach((p) => {
            const x = p.x()
            const y = p.y()

            if (x < minX) {
                minX = x
            } else if (x > maxX) {
                maxX = x 
            }

            if (y < minY) {
                minY = y 
            } else if (y > maxY) {
                maxY = y
            }
        })
        this.origin().setX(minX).setY(minY)
        this.setMaxX(maxX)
        this.setMaxY(maxY)
        return this
    }

}.initThisClass()


"use strict"

/*

    DivTransform
    
*/

window.Transform = class Transform extends ProtoClass {
    initPrototype () {
        this.newSlot("position", null).setComment("in px units") 
        this.newSlot("rotation", null).setComment("in degrees units") 
        this.newSlot("scale", null)
    }

    init () {
        super.init()
        this.setPosition(Point.clone())
        this.setRotation(Point.clone())
        this.setScale(Point.clone().setX(1).setY(1).setZ(1))
        return this
    }

    // css

    cssString() {
        // NOTE: multiple transform one line directives are applied from right to left
        const s = 
          this.scale().asCssScale3dString() + " " 
        + this.position().asCssTranslate3dString() + " " 
        + this.rotation().asCssRotate3dDegreesString(); // is this the expected order?
        return s
    }

    // operations

    copy() {
        const t = Transform.clone()
        t.position().copy(this.position())
        t.rotation().copy(this.rotation())
        t.scale().copy(this.scale())
        return t
    }


    addInPlace(otherTransform) {
        this.position().addInPlace(otherTransform.position())
        this.rotation().addInPlace(otherTransform.rotation())
        this.scale().addInPlace(otherTransform.scale())
        return this
    }

    /*
    add(aTransform) {
        const t = this.copy()
        t.position().addInPlace(aTransform.position())
        t.rotation().addInPlace(aTransform.rotation())
        t.scale().addInPlace(aTransform.scale())
        return t
    }


    subtract(aTransform) {
        const t = this.copy()
        t.position().subtractInPlace(aTransform.position())
        t.rotation().subtractInPlace(aTransform.rotation())
        t.scale().subtractInPlace(aTransform.scale())
        return t
    }
    */
   
}.initThisClass()
"use strict"

ResourceLoader.pushRelativePaths([
    "devices/_imports.js",
    "listeners/_imports.js",
    "gestures/_imports.js"
])


"use strict"

ResourceLoader.pushRelativePaths([
    "Event-cachedPoints.js",
    "EventPoint.js",
    "Device.js",
    "KeyboardKey.js",
    "BMKeyboard.js",
    "Mouse.js",
    "TouchScreen.js",
    "GamePadManager.js",
    "GamePad.js",
    "Devices.js"
])


"use strict"

/*
    
    Event-cachedPoints

*/

if (!getGlobalThis().Event) {
    console.log("WARNING: no Event object found - maybe we are not in browser?")
}

Object.defineSlots(Event.prototype, {
    hasCachedPoints: function() {
        return this._cachedPoints !== undefined
    },

    setCachedPoints: function(points) {
        this._cachedPoints = points
    },

    cachedPoints: function() {
        return this._cachedPoints
    },
    
    pushCachedPoint: function(point) {
        assert(this._cachedPoints)
        this._cachedPoints.push(point)
    }
})


"use strict"

/*

    EventPoint

    Class to represent a 2d or 3d point, optionally with a time.

    NOTES

    Event's positions are set to the document (event.pageX, event.pageY) coordinates.
    To get the viewport coordinates (event.clientX, event.clientY), 
    use the viewportPosition() method.

*/

window.EventPoint = class EventPoint extends Point {
    initPrototype () {
        this.newSlot("id", null)
        this.newSlot("state", null)
        this.newSlot("target", null)
        this.newSlot("isDown", false)
        this.newSlot("overView", null)
        this.newSlot("event", null)
    }
   
    /*
    init () {
        super.init()
        return this
    }
    */

    copyFrom (p, copyDict) {
        super.copyFrom(p, copyDict)
        this._id = p._id
        this._state = p._state
        this._target = p._target
        return this
    }

    overView () {
        if (this._overView === null) {
            this._overView = this.findOverview()
        }
        return this._overView
    }

    findOverview () {
        // search up the dom elements until we find one 
        // associated with a DomView instance 

        let e = document.elementFromPoint(this.x(), this.y());


        while (e) {
            const view = e._domView
            if (view) {
                return view
            }
            e = e.parentElement
        }
        return null
    }

    // viewport helpers

    viewportPosition () {
        const e = this.event()
        const p = Point.clone().set(e.clientX, e.clientY)
        return p
    }

    viewportHeight () {
        return window.innerHeight
    }

    viewportWidth () {
        return window.innerWidth
    }

    distFromTopOfViewport () {
        return this.event().clientY
    }

    distFromBottomOfViewport () {
        return this.viewportHeight() - this.distFromTopOfViewport()
    }

    distFromLeftOfViewport () {
        return this.event().clientX
    }

    distFromRightOfViewport () {
        return this.viewportWidth() - this.distFromLeftOfViewport()
    }
    
}.initThisClass()

"use strict"

/*
    Device

*/

window.Device = class Device extends ProtoClass {
    
    initPrototype () {

    }

    init () {
        super.init()
        return this
    }

}.initThisClass()

"use strict"

/*
    KeyboardKey


*/

window.KeyboardKey = class KeyboardKey extends Device {
    
    initPrototype () {
        this.newSlot("isDown", false)
        this.newSlot("code", null)
        this.newSlot("name", "")
        this.newSlot("keyboard", null)
    }

    init () {
        super.init()
        this.setIsDebugging(true)
        return this
    }

    onKeyDown (event) {
        //this.debugLog(() => this.name() + " onKeyDown " + event._id)
        let shouldPropogate = true
        this.setIsDown(true)
        return shouldPropogate
    }

    onKeyUp (event) {
        //this.debugLog(() => this.name() + " onKeyUp " + event._id)
        let shouldPropogate = true
        this.setIsDown(false)
        return shouldPropogate
    }

    isUp() {
        return !this.isDown()
    }

    isOnlyKeyDown() {
        return this.isDown() && this.keyboard().currentlyDownKeys().length
    }

    isAlphabetical(event) {
        const c = this.code()
        return c >= 65 && c <= 90
    }
    
}.initThisClass()

"use strict"

/*
    Keyboard

    Global shared instance that tracks current keyboard state.
    Registers for capture key events on document.body.

    MacOS/iOS note:

        These Mac keys use different names in JS events:
        CommandLeft -> MetaLeft
        CommandRight -> MetaRight
        Option/Alt -> Alternate
        Control -> Control
        Function -> [not seen by JS either as key event or modifier]

    Browser Issues:

        Key combinations intercepted by browser:

            OSX:
                meta-n (new window)
                meta-m (minimize window)
                meta-w (close window)
                meta-t (new tab)

                but we can intercept:
                meta-o


*/


window.BMKeyboard = class BMKeyboard extends Device {
    initPrototype () {
        this.newSlot("codeToKeys", null).setComment("dictionary of KeyboardKey objects")
        this.newSlot("keyboardListener", null)
        this.newSlot("allModifierKeys", null)
    }

    init () {
        super.init()
        this.setupCodeToKeys()
        this.startListening()
        this.setIsDebugging(false)
        this.setAllModifierKeys(this.allModifierNames().map(kn => this.keyForName(kn)))
        return this
    }

    startListening () {
        const listener = KeyboardListener.clone().setUseCapture(true).setListenTarget(document.body).setDelegate(this)
        this.setKeyboardListener(listener)
        this.keyboardListener().setIsListening(true)
        return this
    }

    setupCodeToKeys () {
        const dict = {}
        const c2k = this.keyCodesToNamesDict()
        Object.keys(c2k).forEach((code) => {
            const name = c2k[code]
            dict[code] = KeyboardKey.clone().setName(name).setCode(code).setKeyboard(this)
        })
        this.setCodeToKeys(dict)
        return this
    }

    keyForCode (aCode) {
        return this.codeToKeys()[aCode]
    }

    keyForName (aName) {
        const code = this.keyCodeForName(aName)
        return this.keyForCode(code)
    }

    nameForKeyCode (aCode) {
        const key = this.keyForCode(aCode)
        if (key) {
            return key.name()
        }
        return null
    }

    k2c () {
        if (!this._k2c) {
            this._k2c = {}
            const c2k = this.keyCodesToNamesDict()
            Object.keys(c2k).forEach((c) => {
                const k = c2k[c]
                this._k2c[k] = c
            })
        }
        return this._k2c
    }

    keyCodeForName (aName) {
        return this.k2c()[aName]
    }

    
    eventIsJustModifierKey (event) {
        const name = this.nameForKeyCode(event.keyCode)
        return this.allModifierNames().contains(name)
    }


    keyCodesToNamesDict () {
        return {
            8: "Backspace",
            9: "Tab",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alternate",
            19: "PauseBreak",
            20: "Capslock",
            27: "Escape",
            32: "Space",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "LeftArrow",
            38: "UpArrow",
            39: "RightArrow",
            40: "DownArrow",
            45: "Insert",
            46: "Delete",
            48: "0",
            49: "1",
            50: "2",
            51: "3",
            52: "4",
            53: "5",
            54: "6",
            55: "7",
            56: "8",
            57: "9",
            65: "a", // characters are the same code for upper and lower case in JS
            66: "b",
            67: "c",
            68: "d",
            69: "e",
            70: "f",
            71: "g",
            72: "h",
            73: "i",
            74: "j",
            75: "k",
            76: "l",
            77: "m",
            78: "n",
            79: "o",
            80: "p",
            81: "q",
            82: "r",
            83: "s",
            84: "t",
            85: "u",
            86: "v",
            87: "w",
            88: "x",
            89: "y",
            90: "z",
            91: "MetaLeft",
            92: "RightWindow", // correct?
            93: "MetaRight",
            96: "NumberPad0",
            97: "NumberPad1",
            98: "NumberPad2",
            99: "NumberPad3",
            100: "NumberPad4",
            101: "NumberPad5",
            102: "NumberPad6",
            103: "NumberPad7",
            104: "NumberPad8",
            105: "NumberPad9",
            106: "Multiply",
            107: "Plus",
            109: "Minus",
            110: "DecimalPoint",
            111: "Divide",
            112: "Function1",
            113: "Function2",
            114: "Function3",
            115: "Function4",
            116: "Function5",
            117: "Function6",
            118: "Function7",
            119: "Function8",
            120: "Function9",
            121: "Function10",
            122: "Function11",
            123: "Function12",
            144: "NumberLock",
            145: "ScrollLock",
            186: "Semicolon",
            187: "EqualsSign",
            188: "Comma",
            189: "Dash",
            190: "Period",
            191: "ForwardSlash",
            192: "GraveAccent",
            219: "OpenBracket",
            220: "Backslash",
            221: "CloseBracket",
            222: "SingleQuote",
        }
    }

    /*
    shiftChangingKeysDict () {
        // Based on a Macbook Pro keyboard. 
        // Not sure if this is platform specific.

        return {
            "\`": ["Tilda", "~"],
            "1": ["ExclaimationPoint", "!"],
            "2": ["AtSymbol", "@"],
            "3": ["Hash", "#"],
            "4": ["DollarSign", "$"],
            "5": ["Percent", "%"],
            "6": ["Carot"],
            "7": ["Ampersand", "&"],
            "8": ["Asterisk", "*"],
            "9": ["OpenParenthesis", "("],
            "0": ["CloseParenthesis", ")"],
            "-": ["Underscore", "_"],
            "=": ["Plus", "+"],
            "[": ["OpenCurlyBracket", "{"],
            "]": ["CloseCurlyBracket", "}"],
            "\\": ["Pipe", "|"],
            ";": ["Colon", ":"],
            "'": ["DoubleQuote", "\""],
            ",": ["LessThan", "<"],
            ".": ["GreaterThan", ">"],
            "/": ["QuestionMark", "?"],
        }
    }
    */

    shiftDict () {
        // Based on a Macbook Pro keyboard. 
        // Not sure if this is platform specific.

        return {
            "~": "Tilda",
            "!": "ExclaimationPoint",
            "@": "AtSymbol",
            "#": "Hash",
            "$": "DollarSign",
            "%": "Percent",
            "^": "Carot",
            "&": "Ampersand",
            "*": "Asterisk",
            "(": "OpenParenthesis",
            ")": "CloseParenthesis",
            "_": "Underscore",
            "+": "Plus",
            "{": "OpenCurlyBracket",
            "}": "CloseCurlyBracket",
            "|": "Pipe",
            ":": "Colon",
            "\\": "DoubleQuote",
            "<": "LessThan",
            ">": "GreaterThan",
            "?": "QuestionMark",
        }
    }

    /*
    specialKeyCodes () { 
        return {
            8:  "delete", // "delete" on Apple keyboard
            9:  "tab", 
            13: "enter", 
            16: "shift", 
            17: "control", 
            18: "alt", 
            20: "capsLock", 
            27: "escape", 
            33: "pageUp", 
            34: "pageDown", 
            37: "leftArrow",  
            38: "upArrow",  
            39: "rightArrow", 
            40: "downArrow",  
            46: "delete", 

        }
    }
    */

    keyForCode (aCode) {
        return this.codeToKeys()[aCode]
    }

    // -- events ---

    showCodeToKeys () {
        const c2k = this.keyCodesToNamesDict()

        //const s = JSON.stringify(c2k, null, 4)

        const lines = Object.keys(c2k).map((code) => {
            return "    " + code + ": \"" + this.codeToKeys()[code].name() + "\""
        })
        const s = "{\n" + lines.join(",\n") + "}\n"
        console.log("c2k:", s)

        /*
        console.log("Keyboard:")
        Object.keys(this.codeToKeys()).forEach((code) => {
            console.log("  code: ", code + " key name: ", this.codeToKeys()[code].name())
        })
        */
        return this
    }

    keyForEvent (event) {
        const code = event.keyCode
        const key = this.codeToKeys()[code]
        return key
    }

    onKeyDownCapture (event) {
        //console.log("event.metaKey = ", event.metaKey)
        
        const shouldPropogate = true
        const key = this.keyForEvent(event)

        if (key) {
            key.onKeyDown(event)

            if (this.isDebugging()) {
                this.debugLog(" " + this.downMethodNameForEvent(event))
            }
        } else {
            console.warn("BMKeyboard.shared() no key found for event ", event)
        }
            
        return shouldPropogate
    }

    onKeyUpCapture (event) {
        const shouldPropogate = true
        const key = this.keyForEvent(event)
        if (!key) {
            console.log("]]]]]]]]]]] WARNING: missing key for event: ", event)
            return
        }
        key.onKeyUp(event)

        if (this.isDebugging()) {
            this.debugLog(" " + this.upMethodNameForEvent(event))
            //this.debugLog(".onKeyUpCapture " + key.name() + " -> " + this.modsAndKeyNameForEvent(event) + "KeyUp")
        }

        return shouldPropogate
    }
    
    // --- event handling method names ---

    downMethodNameForEvent (event) {
        return "on" + this.modsAndKeyNameForEvent(event) + "KeyDown"
    }

    upMethodNameForEvent (event) {
        return "on" + this.modsAndKeyNameForEvent(event) + "KeyUp"
    }

    eventIsAlphabetical (event) {
        const c = event.keyCode
        return c >= 65 && c <= 90
    }

    modsAndKeyNameForEvent (event) {
        // examples: AltB AltShiftB
        // Note that shift is explicit and the B key is always uppercase

        if (Type.isUndefined(event.keyCode)) {
            return ""
        }
        
        const key = this.keyForCode(event.keyCode)
        const isJustModifier = this.eventIsJustModifierKey(event)
        const modifiers = this.modifierNamesForEvent(event)
        const isAlpabetical = this.eventIsAlphabetical(event)
        let keyName = key ? key.name() : event.code

        
        if (isJustModifier) {
            return keyName
        }

        if (event.shiftKey) {
            // Note: if another modifier besides the shift key is down, 
            // the non-shift version of event.key is use e.g.
            // shift-equals is "Plus"
            // control-shift-equals is "ControlShiftEquals"
            // this follows the Javascript event.key convention

            const shiftName = this.shiftDict()[event.key]
            if (shiftName) {
                keyName = shiftName
            }
        }

        if (isAlpabetical) {
            keyName = "_" + keyName + "_"
            if (event.shiftKey) {
                keyName = keyName.capitalized()
                modifiers.remove("Shift")
            }
        }

        return modifiers.join("") + keyName
    }

    // --- special ---

    // get key helpers

    shiftKey () {
        return this.keyForName("Shift")
    }

    controlKey () {
        return this.keyForName("Control")
    }

    alternateKey () {
        return this.keyForName("Alternate")
    }

    leftCommandKey () {
        return this.keyForName("MetaLeft")
    }

    rightCommandKey () {
        return this.keyForName("MetaRight")
    }

    // get key state helpers

    shiftIsDown () {
        return this.shiftKey().isDown()
    }

    commandIsDown () {
        return this.leftCommandKey().isDown() || this.rightCommandKey().isDown()
    }


    equalsSignKey () {
        return this.keyForName("EqualsSign")
    }

    minusKey () {
        return this.keyForName("Dash")
    }

    plusKey () {
        return this.keyForName("Plus")
    }

    plusIsDown () {
        return this.plusKey().isDown()
    }

    currentlyDownKeys () {
        return Object.values(this.codeToKeys()).select(key => key.isDown())
    }

    currentlyUpKeys () {
        return Object.values(this.codeToKeys()).select(key => !key.isDown())
    }

    hasKeysDown () {
        return this.currentlyDownKeys().length !== 0
    }

    downKeyNames () {
        return BMKeyboard.shared().currentlyDownKeys().map(k => k.name())
    }

    show () {
        this.debugLog(" downKeys: ", this.downKeyNames())
    }

    allModifierNames () {
        return [
            "Alternate", 
            "Control", 
            "Meta",
            "MetaLeft", 
            "MetaRight", 
            "Shift", 
        ]
    }

    modifierNamesForEvent (event) {
        let modifierNames = []

        // event names are ordered alphabetically to avoid ambiguity

        if (event.altKey) {
            modifierNames.push("Alternate")
        } 
        
        if (event.ctrlKey) {
            modifierNames.push("Control")
        }
        
        if (event.metaKey) {
            const n = event.location

            //console.log("event.location = ", event.location)

            if (n === 1) {
                modifierNames.push("MetaLeft")
            } else if (n === 2) {
                modifierNames.push("MetaRight")
            } else {
                modifierNames.push("Meta")
            }
        } 
        
        if (event.shiftKey) {
            modifierNames.push("Shift")
        }

        return modifierNames
    }

    showEvent (event) {
        const kb = BMKeyboard.shared()
        console.log("---")
        console.log("BMKeyboard.showEvent():")
        console.log("  code: ", event.keyCode)
        console.log("  name: ", kb.nameForKeyCode(event.keyCode))
        console.log("  is modifier: ", kb.eventIsJustModifierKey(event))
        console.log("  modifierNames: ", kb.modifierNamesForEvent(event))
        console.log("  modsAndKeyName: ", kb.modsAndKeyNameForEvent(event))
        console.log("---")
    }
    
}.initThisClass()

"use strict"

/*

    Mouse

    Global shared instance that tracks current mouse state in window coordinates.
    Registers for capture mouse events on document.body.

*/

window.Mouse = class Mouse extends Device {
    
    initPrototype () {
        this.newSlot("isDown", false)
        this.newSlot("downEvent", null)
        this.newSlot("currentEvent", null)
        this.newSlot("upEvent", null)
        this.newSlot("mouseListener", null)
    }

    init () {
        super.init()
        this.startListening()
        return this
    }

    setCurrentEvent (event) {
        this._currentEvent = event
        //Devices.shared().setCurrentEvent(event)
        return this
    }

    startListening () {
        this.setMouseListener(MouseListener.clone().setUseCapture(true).setListenTarget(document.body).setDelegate(this))
        this.mouseListener().setIsListening(true)
        return this
    }

    // positions

    downPos () {
        return this.pointForEvent(this.downEvent())
    }

    currentPos () {
        return this.pointForEvent(this.currentEvent())
    }

    upPos () {
        return this.pointForEvent(this.upEvent())
    }

    // events

    onMouseDownCapture (event) {
        this.setDownEvent(event)
        this.setCurrentEvent(event)
        this.setIsDown(true);
        return true
    }

    onMouseMoveCapture (event) {
        this.setCurrentEvent(event)
        return true
    }

    onMouseUpCapture (event) {
        this.setCurrentEvent(event)
        this.setUpEvent(event)
        this.setIsDown(false);
        return true
    }  

    // -- helpers ---

    pointForEvent (event) {
        assert(event.__proto__.constructor === MouseEvent)

        const p = EventPoint.clone()
        p.set(event.pageX, event.pageY) // document position
        p.setTarget(event.target)
        p.setTimeToNow()
        p.setId("mouse")
        p.setState(event.buttons)
        p.setIsDown(event.buttons !== 0)
        p.setEvent(event)
        //p.findOverview()

        return p
    }

    dragVector (event) {   
        if (this.downPos()) {
            return this.currentPos().subtract(this.downPos())
        }
        /*  
        if (this.isDown()) {
            return this.currentPos().subtract(this.downPos())
        }
        */
        return Point.clone()
    }

    pointsForEvent (event) {
        if (!event.hasCachedPoints()) {
            const points = [this.pointForEvent(event)]
            event.setCachedPoints(points)
        }

        return event.cachedPoints()
    }

    currentPoints () {
        if (this.currentEvent()) {
            return this.pointsForEvent(this.currentEvent())
        }
        return []
    }

    // full event name

    downMethodNameForEvent (event) {
        const s = BMKeyboard.shared().modsAndKeyNameForEvent(event)
        return "on" + s + "MouseDown"
    }

    upMethodNameForEvent (event) {
        const s = BMKeyboard.shared().modsAndKeyNameForEvent(event)
        return "on" + s + "MouseUp"
    }
    
}.initThisClass()

"use strict"

/*

    TouchScreen

    Global shared instance that tracks current touch state in window coordinates.
    Registers for capture events on document.body.

*/

window.TouchScreen = class TouchScreen extends Device {

    initPrototype () {
        this.newSlot("currentEvent", null)
        this.newSlot("lastEvent", null)
        this.newSlot("touchListener", null)
        //this.newSlot("isVisualDebugging", false)
    }

    isSupported () {
        // return WebBrowserWindow.isTouchDevice()
        let result = false 
        if ("ontouchstart" in window) { result = true; } // works on most browsers 
        if (navigator.maxTouchPoints) { result = true; } // works on IE10/11 and Surface	
        return result
    }

    init () {
        super.init()
        this.startListening()
        //this.setIsDebugging(true)
        if (this.isDebugging()) {
            this.debugLog(".init()")
        }
        return this
    }

    setCurrentEvent (event) {
        if (this._currentEvent !== event) {
            this.setLastEvent(this._currentEvent)
            this._currentEvent = event
            if (this.isDebugging()) {
                console.log(this.type() + " touch count: " + this.currentPoints().length)
            }
            //Devices.shared().setCurrentEvent(event)
        }
        return this
    }

    startListening () {
        this.setTouchListener(TouchListener.clone().setUseCapture(true).setListenTarget(document.body).setDelegate(this))
        this.touchListener().setIsListening(true)
        return this
    }

    // events

    onTouchBeginCapture (event) {
        if (this.isDebugging()) {
            console.log(this.type() + ".onTouchBeginCapture()")
        }
        this.setCurrentEvent(event)
        //this.handleLeave(event)
        return true
    }

    /*
    elementsForEvent (event) {
        const elements = [];
        const points = this.pointsForEvent(event)
        points.forEach((point) => {
            const e = document.elementFromPoint(p.x(), p.y());
            if (e) {
                elements.push(e)
            }
        })
        return elements
    }
    */

    lastPointForId (id) {
        const lastPoints = this.pointsForEvent(this.lastEvent())
        return lastPoints.detect(p => p.id() === id)
    }

    currentPointForId (id) {
        const currentPoints = this.pointsForEvent(this.currentEvent())
        return currentPoints.detect(p => p.id() === id)
    }

    onTouchMoveCapture (event) {
        this.setCurrentEvent(event)
        //this.handleLeave(event)
        return true
    }

    onTouchEndCapture (event) {
        this.setCurrentEvent(event)
        //this.handleLeave(event)
        return true
    }

    pointForTouch (touch) {
        assert(event.__proto__.constructor === TouchEvent)
        const p = EventPoint.clone()
        p.setId(touch.identifier)
        p.setTarget(touch.target)
        p.set(touch.pageX, touch.pageY)  // document position
        p.setTimeToNow()
        p.setIsDown(true)
        p.setEvent(touch)
        //p.findOverview()
        return p
    }

    justPointsForEvent (event) {
        //if (this.isDebugging()) {
        //  console.log("touches.length = ", event.touches.length)
        //}

        const points = []
        // event.touches isn't a proper array, so we can't enumerate it normally
        const touches = event.touches // all current touches
        for (let i = 0; i < touches.length; i++) {
            const touch = touches[i]
            const p = this.pointForTouch(touch)
            points.append(p)
        }

        return points
    }


    pointsForEvent (event) {
        if (!event.hasCachedPoints()) {
            event.preventDefault() // needed to prevent browser from handling touches?

            const points = this.justPointsForEvent(event)
            event.setCachedPoints(points)
        }

        return event.cachedPoints(event)
    }

    currentPoints () {
        if (this.currentEvent()) {
            return this.pointsForEvent(this.currentEvent())
        }
        return []
    }

    // There are no standard onTouchLeave & onTouchOver events,
    // so this is an attempt to add them. Only really need them
    // for visual gesture debugging at the moment though.
    
    /*
    sendEventToView (eventName, event, aView) {
        // send to listeners instead?
        aView.gestureRecognizers().forEach((gr) => {
            gr[eventName].apply(gr, [event])
        })
        return this
    }

    handleLeave (event) {
        // an attempt to add onTouchLeave and onTouchOver events
        const currentPoints = this.pointsForEvent(this.currentEvent())

        currentPoints.forEach((cp) => {
            const lp = this.lastPointForId(cp.id())
            if (lp) {
                const lastView    = lp.overview()
                const currentView = cp.overview()

                // check if overView is the same
                if (lastView !== currentView) {
                    this.sendEventToView("onTouchLeave", event, lastView)
                    this.sendEventToView("onTouchOver", event, currentView)
                }
            } else {
                // this is a new finger
            }
        })

        return this
    }
    */
   
}.initThisClass()

"use strict"

/*
    GamePadManager

    - checks if gamepad API is supported
    - polls navigator gamepads state
    - creates and removes GamePad instances to match current state
    - can send notification of state changes for each GamePad

    Since Chrome doesn't support gamePadListener, I'm just implementing
    it to work without it, though this requires polling for game pad connected.

    Example use:

    // check for game pad support
    const isSupported = GamePadManager.shared().isSupported()
    
    // start monitoring gamepads
    GamePadManager.shared().startPolling()

    // get array of connected game pads
    const pads = GamePadManager.shared().connectedGamePads()

    // each pad will have a unique id to identiy it
    pads.forEach( (pad) => { 
        console.log("pad id:", pad.id()) 
    })

*/

window.GamePadManager = class GamePadManager extends ProtoClass {
    
    initPrototype () {
        //this.newSlot("gamePadListener", null)
        this.newSlot("gamePadsDict", null)
        this.newSlot("pollPeriod", 1000).setComment("milliseconds")
    }

    init () {
        super.init()
        this.setIsDebugging(true)
        this.setGamePadsDict({})
        //this.startListening()
        this.startPollingIfSupported() // could delay this until connection if listen API is supported
        return this
    }

    connectedGamePads () {
        const dict = this.gamePadsDict()
        return Object.keys(dict).map(k => dict[k])
    }
    
    /*
    canListenForConnect () {
        return ("ongamepadconnected" in window); 
    }

    startListening () {
        if (this.canListenForConnect()) {
            this.setGamePadListener(GamePadListener.clone().setUseCapture(true).setListenTarget(window).setDelegate(this))
            this.gamePadListener().setIsListening(true)
        }
        return this
    }
    
    // listener events

    
    onGamePadConnected (event) {
        this.poll()
        return true
    }

    onGamePadDisconnected (event) {
        this.poll()
        return true
    }
    */

    startPollingIfSupported () {
        if (this.isSupported()) {
            this.startPolling()
        }
    }

    isSupported () {
        return this.navigatorGamepads() !== null
    }

    navigatorGamepads () {
        if (navigator.getGamepads) {
            return navigator.getGamepads()
        } 
        
        if (navigator.webkitGetGamepads) {
            return navigator.webkitGetGamepads;
        }

        return null
    }

    startPolling () {
        if (!this._intervalId) {
            console.log(this.type() + ".startPolling()")
            this._intervalId = setInterval(() => { 
                this.poll() 
            }, this.pollPeriod());
        }
    }

    stopPolling () {
        if (this.intervalId()) {
            clearInterval(this.intervalId());
            this.setIntervalId(null)
        }
    }

    newGamePad (index) {
        return GamePad.clone().setGamePadManager(this)
    }

    poll () {
        const gamepads = this.navigatorGamepads()
        //console.log(this.type() + ".poll() gamepads.length = ", gamepads.length)
        const padDict = this.gamePadsDict()

        for (let i = 0; i < gamepads.length; i++) {
            const gp = gamepads[i];
            let gamePad = padDict[i]

            if (gp) {
                if (!gamePad) {
                    gamePad = this.newGamePad().setIndex(i).setId(gp.id)
                    gamePad.onConnected()
                    this.gamePadsDict().atPut(i, gamePad)
                }
                gamePad.updateData(gp)

                if (this.isDebugging()) {
                    console.log("Gamepad index:" + gp.index + " id:" + gp.id + 
                    ". buttonCount:" + gp.buttons.length + " axisCount:" + gp.axes.length);
                }
            } else {
                if (gamePad) {
                    gamePad.onDisconnected()
                    padDict.atPut(i, null)
                }
            }
        }
    }

}.initThisClass()

"use strict"

/*
    GamePad

    A single GamePad with a unique id.

*/

window.GamePad = class GamePad extends Device {
    
    initPrototype () {
        this.newSlot("gamePadManager", null)
        this.newSlot("index", null)
        this.newSlot("id", null)
        this.newSlot("timestamp", null)
        this.newSlot("buttons", null)
        this.newSlot("axes", null)
        this.newSlot("isConnected", false)
        this.newSlot("shouldSendNotes", false)
    }

    init () {
        super.init()
        this.setButtons([])
        this.setAxes([])
        this.setIsDebugging(true)
        return this
    }

    updateData (gp) {
        assert(gp.id() === this.id()) // quick sanity check

        if (gp.timestamp !== this.timestamp()) {
            this.setTimestamp(gp.timestamp)
            this.updateButtons(gp.buttons)
            this.updateAxes(gp.axes)
        }
    }

    // buttons

    updateButtons (newButtons) {
        // make sure number of buttons is correct
        const currentButtons = this.buttons()
        while (currentButtons.length < newButtons.length) {
            currentButtons.push(0)
        }

        if (this.shouldSendNotes()) {
            // check for differences
            for (let i = 0; i < newButtons.length; i ++) {
                if (currentButtons.at(i) !== newButtons.at(i)) {
                    currentButtons.atPut(i, newButtons.at(i))
                    this.changedButtonIndexTo(i, newButtons.at(i))
                }
            }
        } else {
            this.setButtons(newButtons.shallowCopy())
        }

        return this
    }

    changedButtonIndexTo (index, isDown) {
        const note = BMNotificationCenter.shared().newNote().setSender(this)
        note.setName("onGamePadButton" + index + (isDown ? "Down" : "Up")) // TODO: optimize
        note.setInfo(isDown)
        note.post()
        return this
    }

    // axes

    updateAxes (newAxes) {
        // make sure number of buttons is correct
        const currentAxes = this.axes()
        while (currentAxes.length < newAxes.length) {
            currentAxes.push(0)
        }

        if (this.shouldSendNotes()) {
            // check for differences
            for (let i = 0; i < newAxes.length; i ++) {
                if (currentAxes.at(i) !== newAxes.at(i)) {
                    currentAxes.atPut(i, newAxes.at(i))
                    this.changedAxesIndexTo(i, newAxes[i])
                }
            }
        } else {
            this.setAxes(newAxes.copy())
        }

        return this
    }

    changedAxesIndexTo (index, value) {
        const note = BMNotificationCenter.shared().newNote().setSender(this)
        note.setName("onGamePadAxis" + index + "Changed") // TODO: optimize?
        note.setInfo(value)
        note.post()
        return this
    }

    // connecting

    onConnected () {
        this.setIsConnected(true)
        const note = BMNotificationCenter.shared().newNote().setSender(this)
        note.setName("onGamePadConnected")
        note.post()
        return this
    }

    onDisconnected () {
        this.setIsConnected(false)
        const note = BMNotificationCenter.shared().newNote().setSender(this)
        note.setName("onGamePadDisconnected")
        note.post()
        return this
    }

}.initThisClass()

"use strict"

/*
    Devices

    Right now, this just sets up the standard devices. 
    Later, we can using it for 
        - discovering
        - organizing
        - inspecting
        - managing
        - globally intercepting & recording input for debugging or playback
        etc.

*/

window.Devices = class Devices extends ProtoClass {
    
    initPrototype () {
        //this.newSlot("gamePadListener", null)
        this.newSlot("keyboard", null)
        this.newSlot("mouse", null)
        this.newSlot("touchScreen", null)
        this.newSlot("gamePadManager", null)
        this.newSlot("isSetup", false)
    }

    init () {
        super.init()
        this.setupIfNeeded() 
        return this
    }

    setupIfNeeded () {
        if (!this.isSetup()) {
            Mouse.shared()
            BMKeyboard.shared()
            TouchScreen.shared()
            //GamePadManager.shared()
            this.setIsSetup(true)
        }
        return this
    }

    currentTouchOrMouseEvent () {
        // needed?
        const me = Mouse.shared().currentEvent()
        const te = TouchScreen.shared().currentEvent()
        const es = [me, te]
        es.filter(e => !TypeError.isNullOrUndefined(e))
        return es.min(e => e.timeStamp)
    }
    
}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "EventSetListener.js",

    "ClipboardListener.js",
    "DocumentListener.js",
    "DragListener.js",
    "DropListener.js",
    "FocusListener.js",
    "KeyboardListener.js",
    "MouseListener.js",
    "SelectListener.js",
    "TouchListener.js",
    "TransitionListener.js",
    "GamePadListener.js",
    "WebSocketListener.js",
    "WheelListener.js"
])


"use strict"

/*
    EventSetListener

    Manages registering a DOM element for a set of events which will be sent to a delegate
    using a (potentially different) method name. Subclasses override init to define the
    event set by calling this.addEventNameAndMethodName(...) for each event.

    Example use:

    const mouseListener = MouseListener.clone().setListenTarget(element).setDelegate(anObject)

    will send onMouseDown(event), onMouseOver(event) etc to anObject when those events occur on the element.
    
*/

window.EventSetListener = class EventSetListener extends ProtoClass {
    
    initPrototype () {
        this.newSlot("listenTarget", null)
        this.newSlot("delegate", null)
        this.newSlot("isListening", false)
        this.newSlot("eventsDict", null).setComment("should only write from within class & subclasses")
        this.newSlot("useCapture", false).setComment("whether event will be dispatched to listener before EventTarget beneath it in DOM tree")
        this.newSlot("methodSuffix", "")
    }

    init () {
        super.init()
        this.setEventsDict({})
        this.setupEventsDict()
        return this
    }

    setupEventsDict () {
        // subclasses override to call addEventNameAndMethodName() for their events
        return this
    }

    /*
    view () {
        return this.element()._domView
    }
    */

    setListenTarget (t) {
        assert(t)
        this._listenTarget = t
        return this
    }

    listenTargetDescription () {
        return DomElement_description(this.listenTarget())

        /*        
        const type = typeof(this.listenTarget())
        
        if (type === "Element") { // right type?
            return DomElement_description(this.listenTarget())
        }
        
        return type
        */
    }

    // --------------

    setUseCapture (v) {
        this._useCapture = v ? true : false;
        //this.setupEventsDict()

        if (this.isListening()) {
            this.stop()
            this.start()
        }

        return this
    }

    // ---

    fullMethodNameFor (methodName) {
        let suffix = ""

        if (this.useCapture()) {
            suffix = "Capture"
        }

        suffix += this.methodSuffix()
        return methodName + suffix
    }

    addEventNameAndMethodName (eventName, methodName) {
        this.eventsDict().atPut(eventName, { 
            methodName: methodName, 
            handlerFunc: null,
            useCapture: this.useCapture(),
        })
        return this
    }

    // ---

    setIsListening (aBool) {
        if (aBool) {
            this.start()
        } else {
            this.stop()
        }
        return this
    }

    forEachEventDict (func) {
        const eventsDict = this.eventsDict()
        this.eventsDict().ownForEachKV((eventName, eventDict) => {
            func(eventName, eventDict);
        })
        return this
    }

    assertHasListenTarget () {
        const t = this.listenTarget()
        assert(t !== null)
        assert(t !== undefined)
        return this
    }

    start () {
        if (this.isListening()) {
            return this
        }
        this._isListening = true;

        this.assertHasListenTarget()

        this.eventsDict().ownForEachKV((eventName, dict) => {
            const fullMethodName = this.fullMethodNameFor(dict.methodName)
            dict.handlerFunc = (event) => { 

                /*
                if (!event._id) {
                    event._id = Math.floor(Math.random()*100000) // TODO: remove when not debugging
                }
                */

                const delegate = this.delegate()
                const method = delegate[fullMethodName]
                
                //console.log("fullMethodName = " + fullMethodName)

                this.onBeforeEvent(fullMethodName, event)

                //try {
                let result = true
                if (method) {
                    result = method.apply(delegate, [event]); 

                    if (this.isDebugging()) {
                        console.log("sent: " + delegate.type() + "." + fullMethodName, "(" + event.type + ") and returned " + result)
                    }

                    if (result === false) {
                        event.stopPropagation()
                        event.preventDefault()
                    }
                } else {
                    if (this.isDebugging()) {
                        console.log(this.listenTargetDescription() + " MISSING method: " + delegate.type() + "." + fullMethodName, "(" + event.type + ")" )
                    }
                }

                // } catch (e) {

                //}

                this.onAfterEvent(fullMethodName, event)

                return result
            }
            dict.useCapture = this.useCapture()

            if (this.isDebugging()) {
                console.log("'" + this.listenTargetDescription() + ".addEventListener('" + eventName + "', handler, " + dict.useCapture + ") " + fullMethodName) 
            }

            this.listenTarget().addEventListener(eventName, dict.handlerFunc, dict.useCapture);
        })

        return this
    }

    onBeforeEvent (methodName, event) {
        /*
        const a = methodName.contains("Capture") ||  methodName.contains("Focus") || methodName.contains("Move") || methodName.contains("Leave") || methodName.contains("Enter") || methodName.contains("Over")
        if (!a) {
            this.debugLog(" onBeforeEvent " + methodName)
        }
        */
        return this
    }

    onAfterEvent (methodName, event) {
        if (window.SyncScheduler) {
            /*
                run scheduled events here to ensure that a UI event won't occur
                before sync as that could leave the node and view out of sync
                e.g. 
                - edit view #1
                - sync to node
                - node posts didUpdateNode
                - edit view #2
                - view get didUpdateNode and does syncFromNode which overwrites view state #2
            */

            /*
            if ( window.SyncScheduler.shared().actionCount()) {
                this.debugLog(" onAfterEvent " + methodName)
            }
            */
            window.SyncScheduler.shared().fullSyncNow()
        }
        return this
    }

    stop () {
        if (!this.isListening()) {
            return this
        }

        this._isListening = false;

        this.assertHasListenTarget()

        const t = this.listenTarget()
        this.eventsDict().ownForEachKV((eventName, dict) => {
            this.debugLog(() => this.delegate().typeId() + " will stop listening for " + dict.methodName)
            t.removeEventListener(eventName, dict.handlerFunc, dict.useCapture);
        })

        return this
    }   

}.initThisClass()

/*
    // globally track whether we are inside an event 

    setIsHandlingEvent () {
        DomView._isHandlingEvent = true
        return this
    }
	
    isHandlingEvent () {
        return DomView._isHandlingEvent
    }

    handleEventFunction (event, eventFunc) {
        //  a try gaurd to make sure isHandlingEvent has correct value
        //  isHandlingEvent is used to determine if view should inform node of changes
        //  - it should only while handling an event
		
        let error = null
		
        this.setIsHandlingEvent(true)
		
        try {
            eventFunc(event)
        } catch (e) {
            //console.log(e)
            e.show()
            //error = e
        }
		
        this.setIsHandlingEvent(false)
		
        if (error) {
            throw error
        }
    }
*/
"use strict"

/*
    ClipboardListener

    Listens to a set of clip board events.

*/

window.ClipboardListener = class ClipboardListener extends EventSetListener {
    
    initPrototype () {

    }

    init () {
        super.init()
        return this
    }

    setupEventsDict () {
        this.addEventNameAndMethodName("copy", "onCopy");
        this.addEventNameAndMethodName("cut", "onCut");
        this.addEventNameAndMethodName("paste", "onPaste");
        return this
    }

}.initThisClass()

"use strict"

/*
    DocumentListener

    Listens to a set of document related events.

*/

window.DocumentListener = class DocumentListener extends EventSetListener {
    
    initPrototype () {

    }

    init () {
        super.init()
        return this
    }

    setupEventsDict () {
        this.addEventNameAndMethodName("resize", "onDocumentResize");

        // not sure how to organize these other events yet

        //this.addEventNameAndMethodName("pagehide", "onPageHide");
        //this.addEventNameAndMethodName("pageshow", "onPageShow");

        //this.addEventNameAndMethodName("submit", "onSumit");

        //this.addEventNameAndMethodName("online", "onBrowserOnline");
        //this.addEventNameAndMethodName("offline", "onBrowserOffline");

        //this.addEventNameAndMethodName("error", "onBrowserResourceLoadError");

        //this.addEventNameAndMethodName("fullscreenchange", "onBrowserFullScreenChange");
        //this.addEventNameAndMethodName("fullscreenerror", "onBrowserFullScreenError");

        return this
    }

    listenTarget () {
        return window // is this the best way to handle this?
    }
    
}.initThisClass()

"use strict"

/*
    DragListener

    Listens to a set of drag event on element being dragged.

*/

window.DragListener = class DragListener extends EventSetListener {
    
    initPrototype () {

    }

    init () {
        super.init()
        return this
    }

    setupEventsDict () {
        // fired on draggable element
        this.addEventNameAndMethodName("dragstart", "onBrowserDragStart");
        this.addEventNameAndMethodName("drag",      "onBrowserDrag");
        this.addEventNameAndMethodName("dragend",   "onBrowserDragEnd");
        return this
    }

    start () {
        super.start()
        //this.listenTarget().ondragstart = (e) => { console.log("--- ondragstart ---"); } // TODO: still needed?
        return this
    }
    
}.initThisClass()
"use strict"

/*
    DropListener

    Listens to a set of events on a drop target.

*/

window.DropListener = class DropListener extends EventSetListener {
    
    initPrototype () {

    }

    init () {
        super.init()
        return this
    }

    setupEventsDict () {
        // fired on drop target
        this.addEventNameAndMethodName("dragover",  "onBrowserDragOver"); // must prevent default
        this.addEventNameAndMethodName("dragenter", "onBrowserDragEnter"); // must prevent default
        this.addEventNameAndMethodName("drop",      "onBrowserDrop");
        this.addEventNameAndMethodName("dragleave", "onBrowserDragLeave");
        return this
    }

    start () {
        super.start()
        //this.listenTarget().__isListeningForDrop___ = true
        return this
    }

    stop () {
        super.stop()
        //this.listenTarget().__isListeningForDrop___ = false // breaks if multiple drop listeners on same element
        return this
    }

    onBeforeEvent (methodName, event) {
        this.debugLog(() => { return " onBeforeEvent " + methodName })
        return this
    }
    
}.initThisClass()

"use strict"

/*
    FocusListener

    Listens to a set of focus events.

*/

window.FocusListener = class FocusListener extends EventSetListener {
    
    initPrototype () {

    }

    init () {
        super.init()
        return this
    }

    setupEventsDict () {
        this.addEventNameAndMethodName("blur", "onBlur");
        this.addEventNameAndMethodName("focus", "onFocus");
        this.addEventNameAndMethodName("focusin", "onFocusIn");
        this.addEventNameAndMethodName("focusout", "onFocusOut"); 
        return this
    }

}.initThisClass()

"use strict"

/*
    KeyboardListener

    Listens to a set of keyboard events.

*/

window.KeyboardListener = class KeyboardListener extends EventSetListener {
    
    initPrototype () {
    }

    init () {
        super.init()
        //this.setIsDebugging(true)
        return this
    }

    setupEventsDict () {
        this.addEventNameAndMethodName("keyup", "onKeyUp");
        this.addEventNameAndMethodName("keydown", "onKeyDown");
        //this.addEventNameAndMethodName("keypress", "onKeyPress");
        //this.addEventNameAndMethodName("change", "onChange");
        //this.addEventNameAndMethodName("select", "onSelect");
        return this
    }
    
}.initThisClass()

"use strict"

/*
    MouseListener

    Listens to a set of mouse events.

*/


window.MouseListener = class MouseListener extends EventSetListener {
    
    initPrototype () {
    }

    init () {
        super.init()
        return this
    }

    setupEventsDict () {
        this.addEventNameAndMethodName("mousedown", "onMouseDown");
        this.addEventNameAndMethodName("mouseup",   "onMouseUp");

        this.addEventNameAndMethodName("mouseover",  "onMouseOver");  // triggered only when mouse enters element
        this.addEventNameAndMethodName("mouseleave", "onMouseLeave"); // triggered only when mouse exits element

        this.addEventNameAndMethodName("mousemove", "onMouseMove");

        // NOTE: don't see a good use case for these, so commenting out for now
        //this.addEventNameAndMethodName("mouseout",   "onMouseOut");   // triggered when mouse exits any child element        
        //this.addEventNameAndMethodName("mouseenter", "onMouseEnter"); // triggered when mouse enters any child element

        this.addEventNameAndMethodName("click",    "onClick");
        this.addEventNameAndMethodName("dblclick", "onDoubleClick"); // is this valid?

        this.addEventNameAndMethodName("contextmenu", "onContextMenu"); // occurs on right mouse click on element
        return this
    }

}.initThisClass()

"use strict"

/*
    SelectListener

    Listens to a set of select events on element.

*/

window.SelectListener = class SelectListener extends EventSetListener {
    
    initPrototype () {
    }

    init () {
        super.init()
        return this
    }

    setListenTarget (anElement) {
        // is event only works on document or window?
        assert(anElement === document || anElement === window)
        super.setListenTarget(anElement)
        return this
    }

    setupEventsDict () {
        this.addEventNameAndMethodName("selectstart", "onSelectStart");
        this.addEventNameAndMethodName("selectionchange", "onSelectionChange");
        return this
    }
    
}.initThisClass()
"use strict"

/*
    TouchListener

    Listens to a set of touch events.

*/
 
window.TouchListener = class TouchListener extends EventSetListener {
    
    initPrototype () {
    }

    init () {
        super.init()
        return this
    } 

    setupEventsDict () {
        this.addEventNameAndMethodName("touchstart",  "onTouchStart");
        this.addEventNameAndMethodName("touchmove",   "onTouchMove");
        this.addEventNameAndMethodName("touchcancel", "onTouchCancel");
        this.addEventNameAndMethodName("touchend",    "onTouchEnd");
        return this
    }

}.initThisClass()

"use strict"

/*
    TransitionListener

    Listens to a set of animation transition events.

*/

window.TransitionListener = class TransitionListener extends EventSetListener {
    
    initPrototype () {

    }

    init () {
        super.init()
        return this
    }

    setupEventsDict () {
        this.addEventNameAndMethodName("transitionrun", "onTransitionRun");
        this.addEventNameAndMethodName("transitionstart", "onTransitionStart");
        this.addEventNameAndMethodName("transitioncancel", "onTransitionCancel");
        this.addEventNameAndMethodName("transitionend", "onTransitionEnd");
        return this
    }
    
}.initThisClass()

"use strict"

/*
    GamePadListener

    Listens to a set of mouse events.

*/

window.GamePadListener = class GamePadListener extends EventSetListener {
    
    initPrototype () {

    }

    init () {
        super.init()
        return this
    }

    setupEventsDict () {
        this.addEventNameAndMethodName("gamepadconnected",   "onGamePadConnected");
        this.addEventNameAndMethodName("gamepaddisconnected", "onGamePadDisconnected");
        return this
    }

}.initThisClass()


"use strict"

/*
    WebSocketListener

    Listens to a set of web socket events.

*/

window.WebSocketListener = class WebSocketListener extends EventSetListener {
    
    initPrototype () {

    }

    init () {
        super.init()
        return this
    }

    setupEventsDict () {
        this.addEventNameAndMethodName("open", "onOpen");
        this.addEventNameAndMethodName("close", "onClose");
        this.addEventNameAndMethodName("error", "onError");
        this.addEventNameAndMethodName("message", "onMessage");
        return this
    }

}.initThisClass()

"use strict"

/*
    WheelListener

    Listens to a set of wheel (mouse or other wheel) events.

*/

window.WheelListener = class WheelListener extends EventSetListener {
    
    initPrototype () {

    }

    init () {
        super.init()
        return this
    }

    setupEventsDict () {
        this.addEventNameAndMethodName("wheel",   "onWheel");
        return this
    }

}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "GestureManager.js",
    "GestureRecognizer.js",
    "LongPressGestureRecognizer.js",
    "SlideGestureRecognizer.js",
    "TapGestureRecognizer.js",
    "OrientGestureRecognizer.js",
    "PanGestureRecognizer.js",
    "PinchGestureRecognizer.js",
    "RotationGestureRecognizer.js",
    "edges/_imports.js",
])


"use strict"

/*
    GestureManager

    We typically only want one gesture to be active globally.
    GestureManager helps to coordinate which gesture has control.

    To pause all gestures:
    
        GestureManager.shared().setIsPaused(true)

    To unpause:

        GestureManager.shared().setIsPaused(true)

*/

window.GestureManager = class GestureManager extends ProtoClass {
    
    initPrototype () {
        this.newSlot("activeGesture", null)
        this.newSlot("begunGestures", null)
        this.newSlot("isPaused", false) // used to pause gestures while editing text fields
    }

    init () {
        super.init()
        this.setBegunGestures({})
        return this
    }

    hasActiveGesture () {
        return this.activeGesture() && this.activeGesture().isActive()
    }

    setIsPaused (aBool) {
        if (this._isPaused !== aBool) {
            this._isPaused = aBool
            if (aBool) {
                this.cancelAllGestures()
            }
        }
        return this
    }

    cancelAllGestures () {
        this.cancelAllBegunGestures()
        const ag = this.activeGesture()
        if (ag) {
            ag.cancel()
        }
    }

    requestActiveGesture (aGesture) { // sent by gestures themselves
        if (this.isPaused()) {
            return false
        }

        assert(aGesture)
        //this.releaseActiveGestureIfInactive()
        if(aGesture === this.activeGesture()) {
            console.warn("attempt to activeate an already active gesture ", aGesture.typeId())
            return false
        }

        const ag = this.activeGesture()
        if (ag) {
            // allow child views to steal the active gesture
            const childViewIsRequesting = ag.viewTarget().hasSubviewDescendant(aGesture.viewTarget())
            if (childViewIsRequesting) {
                this.acceptGesture(aGesture)
                return true
            }
        }

        if (!ag) {
            this.acceptGesture(aGesture)
            return true
        } else {
            this.rejectGesture(aGesture)
        }

        return false
    }

    acceptGesture (aGesture) { // private method
        aGesture.viewTarget().cancelAllGesturesExcept(aGesture)
        this.cancelBegunGesturesExcept(aGesture)
        this.setActiveGesture(aGesture)
        if (this.isDebugging()) {
            console.log(this.type() + " activating " + aGesture.description())
        }
        return this
    }

    rejectGesture (aGesture) { // private method
        if (this.isDebugging()) {
            console.log(this.type() + " rejecting " + aGesture.description())
            console.log(this.type() + " already active " + this.activeGesture().description())
        }
        return this
    }

    deactivateGesture (aGesture) {
        if (this.activeGesture() === aGesture) {
            this.setActiveGesture(null)
        }
        return this
    }

    addBegunGesture (aGesture) {
        this.begunGestures().atPut(aGesture.typeId(), aGesture)
        return this
    }

    removeBegunGesture (aGesture) {
        delete this.begunGestures().at(aGesture.typeId())
        return this
    }

    cancelAllBegunGestures () {
        Object.values(this.begunGestures()).forEach(g => g.requestCancel() );
        return this
    }

    cancelBegunGesturesExcept (aGesture) {
        Object.values(this.begunGestures()).forEach((g) => {
            if (g !== aGesture) {
                g.requestCancel()
            }
        });
        return this
    }
    
}.initThisClass()

"use strict"

/*
    GestureRecognizer

    Listens for events and uses logic to detect gestures, 
    coordinate which gestures are active with a GestureManager,
    and send delegate messages for gesture state changes. This class supports general
    gesture logic & helper methods, and is intended to be sublclassed to implement
    particular gesture types. See SlideGestureRecognizer, for an example subclass.

    Event Listeners

    Listeners are typically on a particular view's element. document.body listeners
    are usually added once the gesture has begun, in order to track events outside 
    the element. The document listeners are then removed once the gesture has ended or cancelled.

    Delegate Messages

    State change delegate messages are send to the viewTarget. These are typically:
    
        accepts<GestureType>(aGesture)
        on<GestureType>Begin(aGesture)
        on<GestureType>Move(aGesture)
        on<GestureType>End(aGesture)
        on<GestureType>Cancel(aGesture)

    Simulating Touches with the Mouse

    Holding the SHIFT key and click-dragging the mouse can be used to simulate 2 finger 
    gestures on non-touch devices.

    Marked event semantics:

        downEvent - set onDownEvent *if* number of touchs is in correct range
        beginEvent - set when sending begin message - typically in onMove: 
        activePoints() - returns downEvent points for fingers contained in currentEvent
        upEvent - usually set on complete, not used much yet

    NOTES

    Browsers may implement their own touch gestures. To prevent these from 
    interfering with our own, be sure to call:

        aView.setTouchAction("none")

    On related views (or probably all views, to be safe) or set these in the CSS e.g.

        html * { touch-action: none; }

    TODO: move visualizer to separate class?
*/

window.GestureRecognizer = class GestureRecognizer extends ProtoClass {
    
    initPrototype () {
        this.newSlot("viewTarget", null)
        this.newSlot("shouldRemoveOnComplete", false)

        // listeners

        this.newSlot("listenerClasses", null)
        this.newSlot("viewListeners", null)
        this.newSlot("docListeners", null)
        this.newSlot("defaultListenerClasses", ["MouseListener", "TouchListener"])

        // events

        this.newSlot("overEvent", null)
        this.newSlot("leaveEvent", null)
        this.newSlot("didBegin", false)
        this.newSlot("downEvent", null)
        this.newSlot("beginEvent", null)
        this.newSlot("currentEvent", null)
        this.newSlot("lastEvent", null)
        this.newSlot("upEvent", null)

        // standard messages

        this.newSlot("gestureName", null) // sets <GestureType> name used for messages
        this.newSlot("acceptMessage", null)  //"accepts<GestureType>"
        this.newSlot("beginMessage", null) //"on<GestureType>Begin",
        this.newSlot("moveMessage", null) //"on<GestureType>Move",
        this.newSlot("requestCancelMessage", null) // "on<GestureType>RequestCancel"
        this.newSlot("cancelledMessage", null) // "on<GestureType>Cancelled",
        this.newSlot("completeMessage", null) // "on<GestureType>Complete",
        
        // debugging

        this.newSlot("isEmulatingTouch", false) // assumes touch and mouse events aren't mixed
        this.newSlot("isVisualDebugging", false)
        this.newSlot("fingerViewDict", null)

        // begin pressing 

        this.newSlot("isPressing", false)
        this.newSlot("minFingersRequired", 2)
        this.newSlot("maxFingersAllowed", 4)
        this.newSlot("minDistToBegin", 10)
        this.newSlot("allowsKeyboardKeys", false)
        this.newSlot("requiresKeyboardKeys", null)
        this.newSlot("shouldRequestActivation", true)
        this.newSlot("isActive", false) // only used if shouldRequestActivation === false
    }

    init () {
        super.init()
        this.setListenerClasses([]) // subclasses override this in their
        this.setDocListeners([])
        this.setViewListeners([])
        //this.setGestureName(this.type().before("GestureRecognizer"))
        this.autoSetMessageNames()
        this.setIsEmulatingTouch(true)
        this.setFingerViewDict({})

        //this.setIsDebugging(true)
        //this.setIsVisualDebugging(true)
        return this
    }

    // -- event helpers --

    clearEvents () {
        this.setDownEvent(null)
        this.setBeginEvent(null)
        this.setCurrentEvent(null)
        return this
    }
    
    setCurrentEvent (event) {
        if (this._currentEvent !== event) {
            this.setLastEvent(this._currentEvent)
            this._currentEvent = event
        }
        return this
    }

    currentPosition () {
        return this.pointsForEvent(this.currentEvent()).first()
    }

    downPosition () {
        return this.pointsForEvent(this.downEvent()).first()
    }

    beginPosition () {
        return this.pointsForEvent(this.beginEvent()).first()
    }

    upPosition () {
        return this.pointsForEvent(this.upEvent()).first()
    }

    numberOfFingersDown () {
        const points = this.pointsForEvent(this.currentEvent())
        return points.length
    }

    currentEventIsOnTargetView () {
        const points = this.pointsForEvent(this.currentEvent())
        const p = points.first()
        const view = this.viewTarget()
        return view.containsPoint(p)
        //return points.detect(p1 => !view.containsPoint(p1)) === null
    }

    // --- listeners ---

    newListeners () {
        return this.listenerClasses().map((className) => {
            const proto = window[className];
            const listener = proto.clone();
            listener.setDelegate(this);
            return listener
        })
    }

    // --- view listeners ---

    stopViewListeners () {
        this.viewListeners().forEach(listener => listener.stop())
        this.setViewListeners([])
        return this
    }

    startViewListeners () {
        this.stopViewListeners()

        const listeners = this.newListeners().map((listener) => {
            listener.setListenTarget(this.viewTarget().element())
            listener.start()
            return listener
        })
        this.setViewListeners(listeners)
        return this
    }

    // --- doc listeners ---

    startDocListeners () {
        this.stopDocListeners()

        const listeners = this.newListeners().map((listener) => {
            listener.setUseCapture(true)
            //listener.setListenTarget(document.body)
            listener.setListenTarget(window)
            //listener.setIsDebugging(true)
            listener.start()
            return listener
        })
        this.setDocListeners(listeners)
        return this
    }

    stopDocListeners () {
        this.docListeners().forEach(listener => listener.stop())
        this.setDocListeners([])
        return this
    }

    // condition helpers

    hasMovedEnough () {
        // intended to be overridden by subclasses
        // e.g. a rotation recognizer might look at how much first two fingers have rotated
        const m = this.minDistToBegin()
        const d = this.currentPosition().distanceFrom(this.downPosition())
        return d >= m
    }

    hasAcceptableFingerCount () {
        const n = this.numberOfFingersDown()
        return  n >= this.minFingersRequired() &&
                n <= this.maxFingersAllowed();
    }

    hasAcceptableKeyboardState () {
        if (!this.allowsKeyboardKeys()) {
            if (BMKeyboard.shared().hasKeysDown()) {
                // make exception for shift key since we use it to emulate multi-touch
                if(BMKeyboard.shared().shiftKey().isOnlyKeyDown()) {
                    return true
                }
                return false
            }
        }
        return true
    }

    canBegin () {
        return !this.isActive() && 
                this.hasMovedEnough() && 
                this.hasAcceptableFingerCount() &&
                this.hasAcceptableKeyboardState();
    }

    // --- start / stop ---

    start () {
        this.startViewListeners()
        // We typically don't want to listen to document level events all the time.
        // Instead, some view events will start and stop the doc listeners.
        //this.startDocListeners() 
        return this
    }

    stop () {
        this.stopViewListeners()
        this.stopDocListeners()
        return this
    }

    // active

    requestActivationIfNeeded () {
        if (this.shouldRequestActivation()) {
            return GestureManager.shared().requestActiveGesture(this);
        }
        this.setIsActive(true)
        return true
    }

    isActive () {
        if (this.shouldRequestActivation()) {
            return GestureManager.shared().activeGesture() === this
        }
        return this._isActive
    }

    deactivate () {
        if (this.shouldRequestActivation()) {
            GestureManager.shared().deactivateGesture(this);
        }
        this.setIsActive(false)
        return this
    }

    // finish

    didFinish () {
        this.setDidBegin(false)
        GestureManager.shared().removeBegunGesture(this)

        // why do we do this with a delay?
        // is it needed now to prevent a move
        setTimeout(() => { 
            GestureManager.shared().removeBegunGesture(this)
            this.deactivate();
        }, 0)

        if (this.shouldRemoveOnComplete() && this.viewTarget()) {
            this.stop()
            this.viewTarget().removeGestureRecognizer(this)
        }

        this.removeFingerViews()
        return this
    }

    // subclass helpers

    sendDelegateMessage (methodName, argument) {
        let result = undefined
        assert(methodName !== null)
        const vt = this.viewTarget()

        if (this.isDebugging()) {
            console.log(this.shortTypeId() + " sending " + methodName + " to " + vt.typeId())
        }

        //try {
        if (vt) {
            if (vt[methodName]) {
                result = vt[methodName].apply(vt, [this, argument])
            } else {
                if (this.isDebugging()) {
                    console.log("gesture delegate missing method " + methodName)
                }
                result = false
            }
        }
        /*
        } catch(e) {
            console.error(this.typeId() + ".sendDelegateMessage(" + methodName + ") caught exception ", e.stack)
            result = false
            //this.cancel() // how to do this without potentially cause a loop?
            throw e
        }
        */

        return result
    }

    // points helper
    // maps mouse and touch events to a common list of points (with times and ids) format
    // so we can share the event handling code for both devices 

    pointsForEvent (event) {
        if (Type.isNullOrUndefined(event)) {
            throw new Error(this.type() + ".pointsForEvent(event) event is missing")
        }

        const eventClass = event.__proto__.constructor;

        if (eventClass === MouseEvent) {
            //this.debugLog(" got mouse")
            return Mouse.shared().pointsForEvent(event)
        } else if (eventClass === TouchEvent) {   
            //this.debugLog(" got touch")
            return TouchScreen.shared().pointsForEvent(event)
        }
        
        console.warn(this.type() + " can't handle this event type yet: ", event)

        return []
    }

    // all events hook

    onEvent (event) {
        if (this.isVisualDebugging()) {
            this.updateOutlineView()
            this.updateFingerViews()
            //this.updateDebugTimer()
        }
    }

    // --- events ---

    onOver (event) {
        this.setOverEvent(event)
        this.setCurrentEvent(event)
        this.onEvent(event)
    }

    onDown (event) {
        this.setDownEvent(event)
        this.setCurrentEvent(event)
        this.onEvent(event)
    }

    onMove (event) {
        this.setCurrentEvent(event)
        this.onEvent(event)
    }

    onUp (event) {
        this.setUpEvent(event)
        //this.setCurrentEvent(event) // on Windows, the up event may not have any positions
        this.onEvent(event)
    }

    onLeave (event) {
        this.setLeaveEvent(event)
        this.setCurrentEvent(event)
        this.onEvent(event)
    }

    // --- mouse events ---

    shouldEmulateEvent (event) {
        return this.isEmulatingTouch() && 
                event.shiftKey && 
                event.__proto__.constructor === MouseEvent &&
                this.pointsForEvent(event).length === 1;
    }

    emulateDownIfNeeded (event) {
        const p1 = this.pointsForEvent(event).first()

        if (this.shouldEmulateEvent(event)) {
            // make a duplicate of the down event point with a different id
            const p2 = p1.copy().setId("emulatedTouch")
            p2.setX(p2.x() + 10)
            p2.setY(p2.y() + 10)
            event.pushCachedPoint(p2)
        }
        return this
    }

    onMouseDown (event) {        
        this.emulateDownIfNeeded(event)
        this.setDownEvent(event)
        this.onDown(event)
    }

    emulateMoveIfNeeded (event) {
        const p2 = this.pointsForEvent(event).first()

        if (this.shouldEmulateEvent(event) && this.downEvent()) {      
            // get down point and current point and add an emulated point on the other side
            const p1 = this.pointsForEvent(this.downEvent()).first()
            const v = p2.subtract(p1).negated()
            const emulatedPoint = p1.add(v).setId("emulatedTouch")
            event.pushCachedPoint(emulatedPoint)
        }

        return this
    }

    onMouseMove (event) {
        this.emulateMoveIfNeeded(event)
        this.onMove(event)
    }

    onMouseUp (event) {
        this.onUp(event)
    }

    onMouseLeave (event) {
        this.onLeave(event)
    }

    // mouse capture events

    onMouseOverCapture (event) {
        this.onOver(event)
    }

    onMouseDownCapture (event) {
        this.emulateDownIfNeeded(event)
        this.onDown(event)
    }

    onMouseMoveCapture (event) {
        this.emulateMoveIfNeeded(event)
        this.onMove(event)
    }

    onMouseUpCapture (event) {
        this.onUp(event)
    }

    onMouseLeaveCapture (event) {
        this.onLeave(event)
    }

    // touch events

    onTouchStart (event) {
        this.onDown(event)
    }

    onTouchMove (event) {
        this.onMove(event)
    }

    onTouchEnd (event) {
        this.onUp(event)
    }

    onTouchCancel (event) { 
        //this.onUp(event)
        this.cancel()
    }
    
    // touch capture events

    onTouchStartCapture (event) {
        this.onDown(event)
    }

    onTouchMoveCapture (event) {
        this.onMove(event)
    }

    onTouchEndCapture (event) {
        this.onUp(event)
    }

    onTouchCancelCapture (event) {
        //this.onUp(event)
        this.cancel()
    }

    // diff position helper

    diffPos () {
        return this.currentPosition().subtract(this.beginPosition()).floorInPlace() // floor here?
    }

    distance () {
        const dp = this.diffPos()
        const dx = Math.abs(dp.x())
        const dy = Math.abs(dp.y())
        const funcs = {
            left: (dx, dy) => dx,
            right: (dx, dy) => dx,
            up: (dx, dy) => dy,
            down: (dx, dy) => dy,
            x: (dx, dy) => dx,
            y: (dx, dy) => dy
        }
        return funcs[this.direction()](dx, dy)
    }

    setGestureName (aName) {
        this._gestureName = aName
        this.autoSetMessageNames()
        return this
    }

    gestureName () {
        if (this._gestureName) {
            return this._gestureName
        }
        return this.type().before("GestureRecognizer")
    }

    defaultMessageForState (state) {
        return "on" + this.gestureName() + state.capitalized()
    }

    autoSetMessageNames () {
        this.setAcceptMessage("accepts" + this.gestureName())
        this.setBeginMessage(this.defaultMessageForState("Begin"))
        this.setMoveMessage(this.defaultMessageForState("Move"))
        this.setRequestCancelMessage("on" + this.gestureName() + "RequestCancel")
        this.setCancelledMessage(this.defaultMessageForState("Cancelled"))
        this.setCompleteMessage(this.defaultMessageForState("Complete"))
        return this
    }

    // sending delegate messages

    doesTargetAccept () {

        // see if view accepts the gesture before we begin
        // for now, assume it accepts if it doesn't implement the accept<GestureType> method
        const vt = this.viewTarget()
        if (vt[this.acceptMessage()]) {
            if (!this.sendDelegateMessage(this.acceptMessage())) {
                this.cancel()
                return false
            }
        }

        return true
    }

    sendBeginMessage () {
        if (!this.doesTargetAccept()) {
            return this
        }
        
        this.setDidBegin(true)
        this.setBeginEvent(this.currentEvent())
        this.sendDelegateMessage(this.beginMessage())
        GestureManager.shared().addBegunGesture(this)
        return this
    }

    sendMoveMessage () {
        this.sendDelegateMessage(this.moveMessage())
        //this.didMove()
        return this
    }

    sendCompleteMessage () {
        this.sendDelegateMessage(this.completeMessage())
        this.didFinish()
        return this
    }

    sendCancelledMessage () {
        this.sendDelegateMessage(this.cancelledMessage())
        this.didFinish()
        return this
    }

    requestCancel (byGesture) {
        this.cancel()
        /*
        const shouldCancel = this.sendDelegateMessage(this.requestCancelMessage(), byGesture)
        //console.log("this.requestCancelMessage() =================== ", this.requestCancelMessage(), " -> ", shouldCancel)
        if (shouldCancel || Type.isUndefined(shouldCancel)) { 
            this.cancel()
        }
        */
    }

    cancel () {
        this.debugLog(" cancel")
        //this.willCancel()
        this.sendCancelledMessage()
        //this.didCancel()
    }

    /*\
    willCancel () {

    }

    didCancel () {
        //this.didFinish()
    }
    */

    // ---

    cleanup () {
        this.setDownEvent(null)
        this.setCurrentEvent(null)
        this.setUpEvent(null)
        return this
    }

    shouldShowVisualDebugger () {
        return this.hasDownPointsInView() || this.isActive() // || this.isPressing());
    }

    // ---  outline view for debugging ---

    newOutlineView () {
        const v = DomView.clone()
        v.setPointerEvents("none")
        v.setBorder("1px dashed white")
        v.setBackgroundColor("transparent")
        v.setPosition("absolute")
        v.setZIndex(10000)
        return v
    }

    outlineView () {
        if (!this._outlineView) {
            const v = this.newOutlineView()
            this._outlineView = v
        }
        return this._outlineView
    }

    updateOutlineView () {
        /*
        if (this.shouldShowVisualDebugger()) {
            this.showOutlineView()
        } else {
            const v = this.outlineView()
            if (v.parentView()) {
                v.removeFromParentView()
            }
        }
        */
    }

    showOutlineView () {
        const v = this.outlineView()
        if (!v.parentView()) {
            DocumentBody.shared().addSubview(v)
        }
        const vt = this.viewTarget()
        const bounds = vt.frameInDocument()

        v.setMinAndMaxHeight(bounds.height())
        v.setMinAndMaxWidth(bounds.width())
        v.setLeftPx(bounds.x())
        v.setTopPx(bounds.y())
    }



    // --- finger views for debugging ---

    newFingerView () {
        const v = DomView.clone()
        v.setPointerEvents("none")

        const size = 50
        v.setMinAndMaxHeight(size)
        v.setMinAndMaxWidth(size)
        v.setBorderRadiusPx(Math.round(size/2) + "px")
        v.setBorder("1px dashed white")
        //v.setBackgroundColor("rgba(255, 255, 255, 0.5)")
        v.setPosition("absolute")
        v.setTextAlign("center")
        v.setZIndex(10000)
        v.setInnerHTML(this.type())
        v.setPxFontSize(10)
        v.setColor("white")
        return v
    }

    viewForFingerId (id) {
        const fvs = this.fingerViewDict()
        let v = fvs.at(id)
        if (!v) {
            v = this.newFingerView()
            DocumentBody.shared().addSubview(v)
            fvs.atPut(id, v)
        }
        return v
    }

    removeFingerViews () {
        const dict = this.fingerViewDict()
        Object.keys(dict).forEach((id) => {
            const fingerView = dict[id]
            fingerView.removeFromParentView()
        })
        this.setFingerViewDict({})
        return this
    }

    titleForFingerNumber (n) {
        return "&nbsp;".repeat(26) + this.type() + "&nbsp;" + n + "&nbsp;of&nbsp;" + this.numberOfFingersDown() 
    }

    showFingers () {
        const points = this.pointsForEvent(this.currentEvent());
        const idsToRemove = Object.keys(this.fingerViewDict()) // TODO: move to dict
        let count = 1

        points.forEach((point) => {
            const id = point.id()
            const v = this.viewForFingerId(id);
            idsToRemove.remove(id) 
            const nx = point.x() - v.clientWidth()/2;
            const ny = point.y() - v.clientHeight()/2;
            v.setLeftPx(nx);
            v.setTopPx(ny);
            v.setInnerHTML(this.titleForFingerNumber(count))
            v.setBorder("1px dashed white")
            if(this.isPressing()) {
                v.setBorder("1px solid white")
                v.setColor("white")
            } else {
                v.setBorder("1px dashed #888")
                v.setColor("#888")
            }
            count ++
        })

        const fvd = this.fingerViewDict()
        idsToRemove.forEach((id) => {
            const fingerView = fvd[id]
            assert(fingerView)
            fingerView.removeFromParentView()
            delete fvd[id]
        })

        return this
    }

    updateFingerViews () {
        if (this.shouldShowVisualDebugger()) {
            this.showFingers()
        } else {            
            this.removeFingerViews()
        }

        return this
    }

    updateDebugger () {
        this.updateOutlineView() 
        this.updateFingerViews()
        if (this.viewTarget()) {
            console.log(this.viewTarget().typeId() + ".updateDebugger")
        }
    }

    updateDebugTimer () {
        if (this._debugTimerId) {
            clearTimeout(this._debugTimerId) 
            this._debugTimerId = null
        }

        this._debugTimerId = setTimeout(() => { 
            this._debugTimerId = null
            this.updateDebugger() 
        }, 100);

        return this
    }

    // down points

    hasDownPointsInView () {
        if (!this.viewTarget()) {
            return false
        }

        const view = this.viewTarget();
        const points = this.allDownPoints();
        const match = points.detect(p => view.containsPoint(p)) 
        //console.log("all points.length:", points.length, " has match:", match != null)
        return match !== null
    }

    allPoints () { // TODO: some better abstraction for Touch+Mouse?
        const points = []
        points.appendItems(TouchScreen.shared().currentPoints())
        points.appendItems(Mouse.shared().currentPoints())
        return points
    }

    allDownPoints () { // TODO: some better abstraction for Touch+Mouse?
        const points = this.allPoints().select(p => p.isDown())
        return points
    }

    shortTypeId () {
        return this.typeId().replaceAll("GestureRecognizer", "")
    }

    description () {
        return this.shortTypeId() + " on " + (this.viewTarget() ? this.viewTarget().typeId() : "null view target")
    }
    
}.initThisClass()


"use strict"

/*

    LongPressGestureRecognizer

    Recognize a long press and hold in (roughly) one location.

    Notes:

        Should gesture cancel if press moves?:
        
            1. outside of a distance from start point or
            2. outside of the view


    Delegate messages:

        onLongPressBegin
        onLongPressComplete
        onLongPressCancelled

*/

window.LongPressGestureRecognizer = class LongPressGestureRecognizer extends GestureRecognizer {
    
    initPrototype () {
        this.newSlot("timePeriod", 500).setComment("milliseconds")
        this.newSlot("timeoutId", null).setIsPrivate(true)
    }

    init () {
        super.init()
        this.setListenerClasses(this.defaultListenerClasses())
        this.setIsDebugging(false) 

        this.setMinFingersRequired(1)
        this.setMaxFingersAllowed(1)
        this.setMinDistToBegin(null)
        return this
    }

    // --- timer ---

    startTimer () {
        if (this.timeoutId()) {
            this.stopTimer()
        }

        const tid = setTimeout(() => { this.onLongPress() }, this.timePeriod());
        this.setTimeoutId(tid)
        this.startDocListeners() // didFinish will stop listing
        return this
    }

    stopTimer () {
        if (this.hasTimer()) {
            clearTimeout(this.timeoutId());
            this.setTimeoutId(null)
        }
        return this
    }

    hasTimer () {
        return this.timeoutId() !== null
    }

    // -- the completed gesture ---
    
    onLongPress () {
        this.setTimeoutId(null)

        if(this.currentEventIsOnTargetView()) {
            if (this.requestActivationIfNeeded()) {
                this.sendCompleteMessage()
                this.didFinish()
            }
        } else {
            this.cancel()
        }
    }

    // -- single action for mouse and touch up/down ---

    onDown (event) {
        super.onDown(event)
        
        const isWithin = this.currentEventIsOnTargetView();

        if (isWithin && 
            this.hasAcceptableFingerCount() && 
            !GestureManager.shared().hasActiveGesture()) {
            this.startTimer()
            this.sendBeginMessage()
        }
    }

    onMove (event) {
        super.onMove(event)
    
        if (this.hasTimer()) { // TODO: also check move distance?
            if(this.currentEventIsOnTargetView()) {
                this.setCurrentEvent(event)
            } else {
                this.cancel()
            }
        }

    }

    onUp (event) {
        super.onUp(event)

        if (this.hasTimer()) {
            this.cancel()
        }
    }

    cancel () {
        if (this.hasTimer()) {
            this.stopTimer()
            this.sendCancelledMessage()
            this.didFinish()
        }
        return this
    }

    /*

    shouldCancel () {
        return this.hasTimer()
    }

    willCancel () {
        this.stopTimer()
    }

    didCancel () {
        this.didFinish()
    }
    */
    
}.initThisClass()

"use strict"

/*

    SlideGestureRecognizer

    This gets tricky as we need to follow movement outside the view.
    To do this, we add special event move and up handlers to the document after getting
    a down event and then remove them after the up event. 
    
    We ignore the view's own move and up events.

    Delegate messages :

        onSlideBegin
        onSlideMove
        onSlideComplete
        onSlideCancelled
    
    Gesture state info methods:

        direction()
        distance() 
        downPosInView()

    TODO

        make multitouch

        optimization: floor the move event points and only send delegate messages if
        new position is different from last?

*/


window.SlideGestureRecognizer = class SlideGestureRecognizer extends GestureRecognizer {
    
    initPrototype () {
        this.newSlot("direction", "left")
        this.newSlot("validDirectionsDict", { left: 1, right: 2, up: 3, down: 4 })
        this.newSlot("maxPerpendicularDistToBegin", 10) // will not begin if this is exceeded
        //downPositionInTarget: null,
    }

    init () {
        super.init()
        this.setListenerClasses(this.defaultListenerClasses())     
        this.setMinFingersRequired(1)
        this.setMaxFingersAllowed(1)
        this.setMinDistToBegin(10)
        //this.setIsDebugging(false)
        return this
    }

    setDirection (directionName) {
        assert(this.validDirectionsDict().hasOwnProperty(directionName));
        this._direction = directionName
        return this
    }

    setNumberOfTouchesRequired (n) {
        assert(n === 1) // need to add multi-touch support
        this._numberOfTouchesRequired = n
        return this
    }

    // --- events --------------------------------------------------------------------

    onDown (event) {
        super.onDown(event)

        if (!this.isPressing()) {
            if (this.hasAcceptableFingerCount()) {
                this.setIsPressing(true)
                this.setBeginEvent(event)
                this.startDocListeners()
            }
        }
    }

    onMove (event) {
        super.onMove(event)

        if (this.isPressing()) {
            if (!this.isActive() && this.hasMovedTooMuchPerpendicular()) {
                this.cancel()
                return this
            }

            if (!this.isActive() && this.hasMovedEnough()) {
                if(this.requestActivationIfNeeded()) {
                    //this.setIsActive(true)
                    this.sendBeginMessage() // being
                }
            }
        
            if (this.isActive()) {
                this.sendMoveMessage() // move
            }
        }
    }

    // -----------

    onUp (event) {
        super.onUp(event)

        if (this.isPressing()) {
            this.setIsPressing(false)
            if (this.isActive()) {
                this.sendCompleteMessage() // complete
            }
            this.finish()
        }

        return true
    }

    cancel () {
        if (this.isActive()) {
            this.sendCancelledMessage()
        }
        this.finish()
        return this
    }

    finish () {
        //this.debugLog(".finish()")
        this.setIsPressing(false)
        this.deactivate()
        this.stopDocListeners()
        this.didFinish()
        return this
    }

    // ----------------------------------

    hasMovedTooMuchPerpendicular () {
        let m = this.maxPerpendicularDistToBegin()
        let dp = this.diffPos()

        let funcs = {
            left: (dx, dy) => dy,
            right: (dx, dy) => dy,
            up: (dx, dy) => dx,
            down: (dx, dy) => dx
        }

        let r = Math.abs(funcs[this.direction()](dp.x(), dp.y())) > m
        return r
    }

    hasMovedEnough () {
        let m = this.minDistToBegin()
        let dp = this.diffPos()

        let funcs = {
            left: (dx, dy) => -dx,
            right: (dx, dy) =>  dx,
            up: (dx, dy) =>  dy,
            down: (dx, dy) => -dy
        }

        let r = funcs[this.direction()](dp.x(), dp.y()) > m
        return r
    }

    // --- helpers ----

    diffPos () {
        let cp = this.currentPosition()
        let bp = this.beginPosition()

        assert(cp)
        assert(bp)
        
        let p = cp.subtract(bp).floorInPlace() // floor here?
        let dx = p.x()
        let dy = p.y()
        let funcs = {
            left: (p) => p.setX(Math.min(dx, 0)),
            right: (p) => p.setX(Math.max(dx, 0)),
            up: (p) => p.setY(Math.max(dy, 0)),
            down: (p) => p.setY(Math.min(dy, 0))
        }

        funcs[this.direction()](p)
        return p
    }

    distance () {
        let p = this.diffPos()
        let dx = p.x()
        let dy = p.y()
        let funcs = {
            left: (dx, dy) => dx,
            right: (dx, dy) => dx,
            up: (dx, dy) => dy,
            down: (dx, dy) => dy
        }
        return Math.abs(funcs[this.direction()](dx, dy))
    }

}.initThisClass()

"use strict"

/*

    TapGestureRecognizer

    Recognize a number of taps inside a viewTarget and within a maxHoldPeriod.
        
    On first tap for finger count, start timer. 
    If second tap for finger count occurs before it's expired, it's recognized. 
    Otherwise, restart timer.

    Delegate messages:

        onTapBegin
        onTapComplete
        onTapCancelled

        Typically, delegate will ignore onTapBegin & onTapCancelled.

    The names of the delegate messages can be specified. Example:

        const tg = TapGestureRecognizer.clone()
        tg.setNumberOfTapsRequired(2)
        tg.setNumberOfFingersRequired(2)
        tg.setGestureName("DoubleFingerDoubleTap") // on recognize, will send a onDoubleFingerDoubleTapComplete() message
        this.addGestureRecognizer(tg)

*/

window.TapGestureRecognizer = class TapGestureRecognizer extends GestureRecognizer {
    
    initPrototype () {
        this.newSlot("maxHoldPeriod", 1000).setComment("milliseconds per tap")
        this.newSlot("timeoutId", null) // private
        this.newSlot("numberOfTapsRequired", 1)
        this.newSlot("numberOfFingersRequired", 1)
        this.newSlot("tapCount", 0)
    }

    init () {
        super.init()
        this.setListenerClasses(this.defaultListenerClasses())
        //this.setIsDebugging(true) 
        this.resetTapCount()
        this.setShouldRequestActivation(false) // allow multiple tap targets?
        return this
    }

    resetTapCount () {
        this.setTapCount(0)
        return this
    }

    // --- timer ---

    startTimer (event) {
        if (this.timeoutId()) {
            this.stopTimer()
        }

        const tid = setTimeout(() => { this.cancel() }, this.maxHoldPeriod());
        this.setTimeoutId(tid)
        return this
    }

    stopTimer () {
        if (this.hasTimer()) {
            clearTimeout(this.timeoutId());
            this.setTimeoutId(null)
            this.resetTapCount()
        }
        return this
    }

    hasTimer () {
        return this.timeoutId() !== null
    }

    // -- single action for mouse and touch up/down ---

    onDown (event) {
        super.onDown(event)
        
        if (this.numberOfFingersDown() < this.numberOfFingersRequired()) {
            return this
        }

        if (!this.hasTimer()) {
            this.setTapCount(1)
            this.startTimer()
            this.sendBeginMessage() // begin
        } else {
            this.setTapCount(this.tapCount() + 1)
        }

        return true
    }

    onUp (event) {
        super.onUp(event)
 
        if (true || this.isDebugging()) {
            this.debugLog(".onUp()  tapCount:" + this.tapCount() + " viewTarget:" + this.viewTarget().typeId())
        }

        if (this.hasTimer()) {
            if (this.tapCount() === this.numberOfTapsRequired()) {
                this.stopTimer()
                this.complete()
            }
        } else {
            //this.cancel()
        }
    }

    // end states

    complete () {
        this.stopTimer()
        if (this.requestActivationIfNeeded()) {
            this.sendCompleteMessage() // complete
        }
    }

    cancel () {
        if (this.hasTimer()) {
            this.stopTimer()
            this.sendCancelledMessage() // cancelled
        }
        return this
    }

    /*
    // was going to do some auto-naming but decided against it for now
    // too many names for point tap count and number of fingers?
    // 3 taps * 10 fingers?

    incrementTapCountForFingerCount (n) {
        const d = this.tapCountDict()
        if (d.hasOwnProperty(n)) { 
            d.atPut(n, d.at(n)+1)
        } else {
            d.atPut(n, 1)
        }
        return this
    }

    
    nameForCount (n) {
        if (n === 1) { return "Single" }
        if (n === 2) { return "Double" }
        if (n === 3) { return "Triple"; }
        if (n === 4) { return "Quadruple"; }
        if (n === 5) { return "Quintuple"; }
        return "Many"
    }
    beginMessageForCount (n) {
        return "on" + this.nameForCount(n) + "TapBegin"
    }

    completeMessageForCount (n) {
        return "on" + this.nameForCount(n) + "TapComplete"
    }

    cancelledMessageForCount (n) {
        return "on" + this.nameForCount(n) + "TapCancelled"
    }
    */

}.initThisClass()

"use strict"

/*

    OrientGestureRecognizer

    - on down, note 1st and 2nd fingers
    - on move, use noted 1st and 2nd finger for pinch info
        if either disappear, gesture ends

    - track center point of 1st & 2nd finger for translation info

    Delegate messages:

        onOrientBegin
        onOrientMove
        onOrientComplete
        onOrientCancelled

    Helper methods:

        points:
            downPoints // initial 1st two fingers down
            beginPoints // location (of 1st two fingers down) when gesture began
            activePoints // current locations of the 1st two fingers down

        position:
            beginCenterPosition //  initial midpoint between 1st two fingers down
            currentCenterPosition // current midpoint between 1st two fingers down
            diffPosition // currentCenterPosition - beginCenterPosition

        rotation:
            activeAngleInDegress // current angle between 1st two fingers down
            rotationInDegrees // difference between initial angle between 1st two fingers down and their current angle

        scale:
            scale // current distance between 1st to fingers down divided by their intitial distance  

*/


window.OrientGestureRecognizer = class OrientGestureRecognizer extends GestureRecognizer {

    initPrototype() {

    }

    init() {
        super.init()
        this.setListenerClasses(this.defaultListenerClasses())

        this.setMinFingersRequired(2)
        this.setMaxFingersAllowed(4)
        this.setMinDistToBegin(10)

        //this.setIsDebugging(true)
        return this
    }

    // events

    onDown(event) {
        super.onDown(event)
        //console.log(this.shortTypeId() + ".onDown() this.isPressing() = ", this.isPressing())

        if (!this.isPressing()) {
            const downCount = this.numberOfFingersDown()
            if (downCount >= this.minFingersRequired() &&
                downCount <= this.maxFingersAllowed()
            ) {
                this.setIsPressing(true)
                //this.setBeginEvent(event)
                this.startDocListeners()
            }
        }
    }

    /*
    hasMovedEnough () {
        // intended to be overridden by subclasses
        // e.g. a rotation recognizer might look at how much first two fingers have rotated
        const m = this.minDistToBegin()
        const d = this.currentPosition().distanceFrom(this.downPosition())
        return d >= m
    }

    hasAcceptableFingerCount () {
        const n = this.numberOfFingersDown()
        return  n >= this.minFingersRequired() &&
                n <= this.maxFingersAllowed();
    }

    canBegin () {
        return !this.isActive() && 
                this.hasMovedEnough() && 
                this.hasAcceptableFingerCount();
    }
    */

    onMove(event) {
        super.onMove(event)

        if (this.isPressing()) {
            if (this.canBegin()) {
                if (this.requestActivationIfNeeded()) {
                    this.sendBeginMessage()
                }
            }

            if (this.activePoints().length < this.minFingersRequired()) {
                this.onUp(event)
                return
            }

            if (this.isActive()) {
                if (this.activePoints().length >= this.minFingersRequired()) {
                    this.sendMoveMessage()
                } else {
                    this.onUp(event)
                }
            }
        }
    }

    // -----------

    onUp(event) {
        super.onUp(event)

        if (this.isPressing()) {
            this.setIsPressing(false)
            if (this.isActive()) {
                this.sendCompleteMessage()
            }
            this.didFinish()
        }
    }

    cancel() {
        if (this.isActive()) {
            this.sendCancelledMessage()
        }
        this.didFinish()
        return this
    }

    didFinish() {
        super.didFinish()
        this.setIsPressing(false)
        this.deactivate()
        this.stopDocListeners()
        return this
    }

    // points - move to GestureRecognizer?

    downPoints() {
        const p = this.pointsForEvent(this.downEvent())
        return [p[0], p[1]]
    }

    activeForEvent(event) {
        // looks for two points whose id matchs those of the two down points
        const points = this.pointsForEvent(event)
        const ids = this.downPoints().map(p => p.id())
        return points.select(p => ids.contains(p.id()))
    }

    beginPoints() {
        return this.activeForEvent(this.beginEvent())
    }

    lastPoints() {
        return this.activeForEvent(this.lastEvent())
    }

    activePoints() { // current points that were in down points
        return this.activeForEvent(this.currentEvent())
    }

    // position

    centerForPoints(p) {
        return p[0].midpointTo(p[1])
    }

    downCenterPosition() {
        return this.centerForPoints(this.downPoints())
    }

    beginCenterPosition() {
        return this.centerForPoints(this.beginPoints())
    }

    currentCenterPosition() {
        return this.centerForPoints(this.activePoints())
    }

    diffPosition() {
        return this.currentCenterPosition().subtract(this.beginCenterPosition())
    }

    // rotation

    angleInDegreesForPoints(p) {
        return p[0].angleInDegreesTo(p[1])
    }

    downAngleInDegress() {
        return this.angleInDegreesForPoints(this.downPoints())
    }

    beginAngleInDegress() {
        return this.angleInDegreesForPoints(this.beginPoints())
    }

    activeAngleInDegress() {
        return this.angleInDegreesForPoints(this.activePoints())
    }

    rotationInDegrees() {
        // difference between initial angle between 1st two fingers down and their current angle
        const a1 = this.beginAngleInDegress();
        const a2 = this.activeAngleInDegress();
        return a2 - a2;
    }

    // scale

    spreadForPoints(p) {
        return p[0].distanceFrom(p[1])
    }

    downSpread() {
        // initial distance between first two fingers down
        return this.spreadForPoints(this.downPoints())
    }

    beginSpread() {
        // initial distance between first two fingers down
        return this.spreadForPoints(this.beginPoints())
    }

    currentSpread() {
        // current distance between first two fingers down
        return this.spreadForPoints(this.activePoints())
    }

    spread() {
        const s = this.currentSpread() - this.beginSpread();
        //console.log("spread = " + s + " = " + this.currentSpread() + " - " + this.beginSpread() )
        return s
    }

    downSpreadX() {
        const p = this.downPoints()
        return Math.abs(p[0].x() - p[1].x())
    }

    downSpreadY() {
        const p = this.downPoints()
        return Math.abs(p[0].y() - p[1].y())
    }

    currentSpreadX() {
        const p = this.activePoints()
        return Math.abs(p[0].x() - p[1].x())
    }

    currentSpreadY() {
        const p = this.activePoints()
        return Math.abs(p[0].y() - p[1].y())
    }

    spreadX() {
        return this.currentSpreadX() - this.downSpreadX()
    }

    spreadY() {
        return this.currentSpreadY() - this.downSpreadY()
    }

    scale() {
        const s = this.currentSpread() / this.beginSpread();
        //console.log("scale = " + s + " = " + this.currentSpread() + "/" + this.beginSpread() )
        return s
    }

    // show

    debugJson() {
        const dp = this.diffPosition()
        return {
            id: this.typeId(),
            dx: dp.x(),
            dy: dp.y(),
            scale: this.scale(),
            rotation: this.rotationInDegrees()
        }
    }

    show() {
        console.log(this.debugJson())
    }

}.initThisClass()

"use strict"

/*

    PanGestureRecognizer

    Gesture begins when the minimal number of fingers have moved the minimal distance.
    Will requestActive before beginning.

    Delegate messages:

        onPanBegin
        onPanMove
        onPanComplete
        onPanCancelled

*/

window.PanGestureRecognizer = class PanGestureRecognizer extends GestureRecognizer {
    
    initPrototype () {
        this.newSlot("minNumberOfFingersRequired", 1)
        this.newSlot("maxNumberOfFingersAllowed", 1)
        //downPositionInTarget: null,
    }

    init () {
        super.init()
        this.setListenerClasses(this.defaultListenerClasses()) 
        //this.setIsDebugging(false)
        return this
    }

    // --- events --------------------------------------------------------------------

    // tap events

    hasOkFingerCount () {
        const n = this.numberOfFingersDown()
        const min = this.minNumberOfFingersRequired()
        const max = this.maxNumberOfFingersAllowed()
        return (n >= min && n <= max)
    }

    isReadyToBegin () {
        return this.hasOkFingerCount();
    }

    doPress (event) {
        this.setIsPressing(true)
        this.setDownEvent(event)
        this.startDocListeners()
        return this
    }

    onDown (event) {
        super.onDown(event)

        if (!this.isPressing()) {
            if (this.isReadyToBegin()) {
                this.doPress(event)
            }
        }
        
        return this
    }

    attemptBegin () {
        if (!this.doesTargetAccept()) {
            return;
        }

        if(this.requestActivationIfNeeded()) {
            this.sendBeginMessage() // begin
        } else {
            if (this.isDebugging()) {
                console.log(this.shortTypeId() + ".attemptBegin() FAILED")
            }
        }
    }

    onMove (event) {
        super.onMove(event)

        if (this.isPressing()) {
            if (!this.isActive() && this.hasMovedEnough()) {
                this.attemptBegin()
            }
        
            if (this.isActive()) {
                this.sendMoveMessage() // move
            }
        }
        return this
    }

    onUp (event) {
        super.onUp(event)

        if (this.isPressing()) {
            if (this.isActive()) {
                this.sendCompleteMessage() // complete
            }
            this.didFinish() // will set isPressing to false
        }
        return this
    }

    // ----------------------------------

    cancel () {
        if (this.isActive()) {
            this.sendCancelledMessage()
        }
        this.didFinish()
        return this
    }

    didFinish () {
        super.didFinish()
        this.setIsPressing(false)
        this.stopDocListeners()
        return this
    }

    // ----------------------------------

    hasMovedEnough () {
        const m = this.minDistToBegin()
        const d = this.currentPosition().distanceFrom(this.downPosition())
        return d >= m
    }

    distance () {
        return this.currentPosition().distanceFrom(this.beginPosition())
    }

}.initThisClass()

"use strict"

/*

    PinchGestureRecognizer

    Subclass of OrientGestureRecognizer that overrides hasMovedEnough() to 
    check for minDistToBegin.

    Delegate messages:

        onPinchBegin
        onPinchMove
        onPinchComplete
        onPinchCancelled

    Helper methods:

        scale:
            scale // current distance between 1st to fingers down divided by their intitial distance  

*/


window.PinchGestureRecognizer = class PinchGestureRecognizer extends GestureRecognizer {
    
    initPrototype () {

    }

    init () {
        super.init()
        this.setListenerClasses(this.defaultListenerClasses()) 
        //this.setIsDebugging(false)
        //this.setIsVisualDebugging(true)
        this.setMinFingersRequired(2)
        this.setMaxFingersAllowed(2)
        return this
    }

    hasMovedEnough () {
        const m = this.minDistToBegin()
        const d = this.currentPosition().distanceFrom(this.downPosition())
        //console.log(this.shortTypeId() + ".hasMovedEnough() " + d + ">= min " + m)
        return d >= m
    }
    
}.initThisClass()

"use strict"

/*

    RotationGestureRecognizer

    Overrides OrientGestureRecognizer's hasMovedEnough() method to 
    check for minRotationInDegreesToBegin.
    
    Delegate messages:

        onRotationBegin
        onRotationMove
        onRotationComplete
        onRotationCancelled

    Helper methods:
    
        rotation:
            activeAngleInDegress // current angle between 1st two fingers down
            rotationInDegrees // difference between initial angle between 1st two fingers down and their current angle

*/

window.RotationGestureRecognizer = class RotationGestureRecognizer extends GestureRecognizer {
    
    initPrototype () {

    }

    init () {
        super.init()
        this.setListenerClasses(this.defaultListenerClasses()) 
        //this.setIsDebugging(true)
        return this
    }

    hasMovedEnough () {
        const ma = this.minRotatationInDegreesToBegin()
        const a = this.activeAngleInDegress()
        return a >= ma
    }
    
}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    //"screen/_imports.js",
    "EdgePanGestureRecognizer.js",
    "TopEdgePanGestureRecognizer.js",
    "BottomEdgePanGestureRecognizer.js",
    "LeftEdgePanGestureRecognizer.js",
    "RightEdgePanGestureRecognizer.js",
])


"use strict"

/*

    EdgePanGestureRecognizer

    Subclass of PanGestureRecognizer that limits pan detection to gestures starting at the edge fo the view. 
    Don't use this class directed - instead use it's subclass for the edge you're interested in.

    Delegate messages:

        onEdgePanBegin
        onEdgePanMove
        onEdgePanComplete
        onEdgePanCancelled
        
*/

window.EdgePanGestureRecognizer = class EdgePanGestureRecognizer extends PanGestureRecognizer {

    initPrototype() {
        this.newSlot("edgeName", null)
        this.newSlot("maxStartDistance", 15)
    }

    init() {
        super.init()
        this.setListenerClasses(this.defaultListenerClasses())
        this.setMinDistToBegin(5)
        //this.setIsDebugging(true)
        return this
    }

    start() {
        return super.start()
    }

    /*
    start () {
        this.startDocListeners() // only want to listen to the document
        // TODO: do we always want to listen outside the view? 
        // is listening only inside both more efficient and good enough?
        return this
    }
    */

    // --- events --------------------------------------------------------------------

    /*
    didFinish () {
        super.didFinish()
        this.setIsPressing(false)
        this.stopDocListeners()
        return this
    }
    */

    /*
    onDown(event) {
        super.onDown(event)

        if (this.isReadyToBegin()) {
            this.doPress(event)
        }

        return this
    }
    */


    isReadyToBegin() {
        return this.hasOkFingerCount() &&
            this.distanceFromEdge() <= this.maxStartDistance();
    }

    distanceFromEdge() {
        const name = this.edgeName()
        //assert(name)
        const d = this.currentEdgeDistances()[name]
        //assertDefined(d)
        //console.log("distanceFromEdge ", d)
        return d
    }

    // -------------

    maxEdgeDistance() {
        return 100000
    }

    currentEdgeDistances() {
        const max = this.maxEdgeDistance()
        const points = this.allPoints() // event points are in document coordinates
        const vt = this.viewTarget()

        if (!vt) {
            this.debugLog(" missing viewTarget")
            return max
        }

        const f = vt.frameInDocument()

        // use maxValue to make sure all fingers are close to the edge

        return {
            top: points.maxValue(p => Math.abs(f.top() - p.y()), max),
            bottom: points.maxValue(p => Math.abs(f.bottom() - p.y()), max),
            left: points.maxValue(p => Math.abs(f.left() - p.x()), max),
            right: points.maxValue(p => Math.abs(f.right() - p.x()), max)
        }
    }

}.initThisClass()

"use strict"

/*

    TopEdgePanGestureRecognizer

    Delegate messages:

        onTopEdgePanBegin
        onTopEdgePanMove
        onTopEdgePanComplete
        onTopEdgePanCancelled

*/

window.TopEdgePanGestureRecognizer = class TopEdgePanGestureRecognizer extends EdgePanGestureRecognizer {
    
    initPrototype () {

    }

    init () {
        super.init()
        this.setEdgeName("top")
        return this
    }

}.initThisClass()

"use strict"

/*

    BottomEdgePanGestureRecognizer

    Delegate messages:

        onBottomEdgePanBegin
        onBottomEdgePanMove
        onBottomEdgePanComplete
        onBottomEdgePanCancelled

*/

window.BottomEdgePanGestureRecognizer = class BottomEdgePanGestureRecognizer extends EdgePanGestureRecognizer {
    
    initPrototype () {

    }

    init () {
        super.init()
        this.setEdgeName("bottom")
        //this.setIsDebugging(true)
        return this
    }
    
    
}.initThisClass()

"use strict"

/*

    LeftEdgePanGestureRecognizer

    Delegate messages:

        onLeftEdgePanBegin
        onLeftEdgePanMove
        onLeftEdgePanComplete
        onLeftEdgePanCancelled

*/

window.LeftEdgePanGestureRecognizer = class LeftEdgePanGestureRecognizer extends EdgePanGestureRecognizer {
    
    initPrototype () {

    }

    init () {
        super.init()
        this.setEdgeName("left")
        return this
    }

}.initThisClass()

"use strict"

/*

    RightEdgePanGestureRecognizer

    Delegate messages:

        onRightEdgePanBegin
        onRightEdgePanMove
        onRightEdgePanComplete
        onRightEdgePanCancelled

*/

window.RightEdgePanGestureRecognizer = class RightEdgePanGestureRecognizer extends EdgePanGestureRecognizer {
    
    initPrototype () {

    }

    init () {
        super.init()
        this.setEdgeName("right")
        return this
    }

}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "WebBrowserScreen.js",
    "WebBrowserWindow.js",
    "WebBrowserNotifications.js",
    "WebBrowserNotification.js",
    "WebDocument.js",
    "BMStyleSheet.js",
])


"use strict"

/*

    WebBrowserScreen

*/

window.WebBrowserScreen = class WebBrowserScreen extends ProtoClass {
    
    initPrototype () {

    }

    init () {
        assert(!this.thisClass().hasShared()) // enforce singleton
        super.init()
    }

    width () {
        return screen.width
    }

    height () {
        return screen.height
    }
    
    aspectRatio () {
        return this.width() / this.height()
    }
    
    isRotated () { // screen aspect doesn't match window (only works on mobile)
        const a = this.aspectRatio() > 1 
        const b = WebBrowserWindow.shared().aspectRatio() > 1
        return a !== b && WebBrowserWindow.shared().isOnMobile()
    }
    
    orientedWidth () {
        return this.isRotated() ? this.height() : this.width()
    }
    
    orientedHeight () {
        return this.isRotated() ? this.width() : this.height()
    }
        
    show () {
        this.debugLog(" size " + this.width() + "x" + this.height())
    }

    lesserOrientedSize () {
        // lesser of window and oriented screen size
        const w = Math.min(this.orientedWidth(), WebBrowserWindow.shared().width())
        const h = Math.min(this.orientedHeight(), WebBrowserWindow.shared().height())
        return { width: w, height: h }
    }

    userPrefersDarkMode () {
        // should we add a timer to monitor this value and post notifications on changes?
        // how about an NoteMonitor object that does this? example:
        // const m = NoteMonitor.clone().setTarget(this).setMethod("userPrefersDarkMode")
        // m.setName("didChangeDarkMode").setPeriodInSeconds(1).start()
        const prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
        return prefersDark
    }

}.initThisClass()


"use strict"

/*

    WebBrowserWindow

    Abstraction for the main web browser window. 
    Owns a DocumentBody view.

*/

window.WebBrowserWindow = class WebBrowserWindow extends ProtoClass {
    
    initPrototype () {
    }
    
    init () {
        //throw new Error("this class is meant to be used as singleton, for now")
        super.init()
        //this.showAgent()
        return this
    }

    documentBody () {
        return DocumentBody.shared()
    }
    
    /*  
    electronWindow () {
        if (!this._electronWindow) {
            const remote = require("electron").remote;
            this._electronWindow = remote.getCurrentWindow()
        }
        return this._electronWindow
    }
    */
	
    // attributes
    
    width () {
        return window.innerWidth
    }

    height () {
        return window.innerHeight
    }
    
    aspectRatio () {
        return this.width() / this.height()
    }
    
    setWidth (w) {
        console.warn("warning: WebBrowserWindow.setWidth() unavailable in browser")
        return this
    }
    
    setHeight (h) {
        console.warn("warning: WebBrowserWindow.setHeight() unavailable in browser")
        return this
    }
    
    show () {
        console.log("Window size " + this.width() + "x" + this.height())
    }

    showAgent () {
        console.log("navigator.userAgent = ", navigator.userAgent);
        console.log("   agentIsSafari: ", this.agentIsSafari())
        console.log("   agentIsChrome: ", this.agentIsChrome())
        console.log("  agentIsFirefox: ", this.agentIsFirefox())
        console.log("      isOnMobile: ", this.isOnMobile())
        console.log("   isTouchDevice: ", this.isTouchDevice())
    }
    
    mobileNames () {
        return ["android", "webos", "iphone", "ipad", "ipod", "blackBerry", "windows phone"]  
    }

    agent () {
        return navigator.userAgent.toLowerCase()
    }

    vendor () {
        return navigator.vendor.toLowerCase()
    }

    agentIsFirefox () {
        const agent = navigator.userAgent;
        return agent.contains("Firefox")
    }

    agentIsSafari () {
        const vendor = navigator.vendor;
        const agent = navigator.userAgent;
        
        const isSafari = !Type.isNullOrUndefined(vendor) && 
                vendor.contains("Apple") &&
                !Type.isNullOrUndefined(agent) &&
                !agent.contains("CriOS") &&
                !agent.contains("FxiOS");
        return isSafari
    }

    agentIsChrome () {
        const isChrome = Boolean(window.chrome) //&& 
        //!navigator.userAgent.contains('Brave');
        //console.log("window.chrome = ", window.chrome);
        return isChrome
    }
    
    isOnMobile () { 
        const agent = this.agent();
        const match = this.mobileNames().detect((name) => { return agent.contains(name); })
        return match !== null
    }

    isTouchDevice () {
        //return TouchScreen.shared().isSupported()

        // via https://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript
        let result = false 
        if ("ontouchstart" in window) { result = true; }        // works on most browsers 
        if (navigator.maxTouchPoints) { result = true; }       // works on IE10/11 and Surface	
        //console.log("WebBrowserWindow.isTouchDevice() = ", result)
        return result
    }

    urlHash () {
        return decodeURI(window.location.hash.substr(1)) // return string after # character
    }
    
    setUrlHash (aString) {
        if (this.urlHash() !== aString) {
            window.location.hash = encodeURI(aString)
            //console.log("window.location.hash = [" + window.location.hash + "]")
        }
        return this
    }
    
    descriptionDict () {
        const dict = {
            agent: this.agent(),
            size: this.width() + "x" + this.height(),
            isOnMobile: this.isOnMobile()
        }
        return dict
    }

    urlHostname () {
        const parser = document.createElement("a")
        parser.href = window.location.href
        let name = parser.hostname
        if (!name) {
		    name = ""
        }
        return name
    }
	
    setTitle (aName) {
        document.title = aName
        return this
    }

    title () {
        return document.title
    }
    
    activeDomView () {
        const e = document.activeElement
        if (e && e._domView) {
            return e._domView
        }
        return null
    }

}.initThisClass()



"use strict"

/*

    WebBrowserNotifications

    Simple interface to browser notifications. Takes care of:
    - only checking for permissions once
    - sending any waiting notifications after permission is gained
    - notification timeouts

    Todo: 
    - support for multiple waiting notes? waiting note limit
    - add any abstractions specific to special Chrome/Android notifications

    example use:

    WebBrowserNotifications.shared().newNote().setTitle("hello").setBody("...").tryToPost()

*/


window.WebBrowserNotifications = class WebBrowserNotifications extends ProtoClass {
    
    initPrototype () {
        this.newSlot("permissionRequestResult", null)
        this.newSlot("waitingNote", null)
    }

    init () {
        super.init()
        //throw new Error("this class is meant to be used as singleton, for now")
        return this
    }

    hasPermission () {
        return this.permissionRequestResult() === "granted"
    }

    wasDenied () {
        return this.permissionRequestResult() === "denied"
    }

    hasAskedForPermission () {
        return this.permissionRequestResult() !== null
    }

    requestPermissionIfNeeded () {
        if (!this.hasAskedForPermission()) {
            this.requestPermission()
        }
        return this
    }

    requestPermission () {
        Notification.requestPermission().then((result) => {
            this.setPermissionRequestResult(result)
            console.log("requestPermission:", result);
            this.postWaitingNotes()
        });
        Notification.requestPermission();
    }

    isSupported () {
        return window.hasOwnProperty("Notification")
    }

    postNote (aNote) {
        this.setWaitingNote(aNote)

        if (!this.isSupported()) {
            return this
        }

        this.requestPermissionIfNeeded() // will call this.postWaitingNotes()

        if (this.hasPermission()) {
            this.postWaitingNotes()
        }

        return this
    }

    postWaitingNotes () {
        if (this.waitingNote()) {
            this.waitingNote().tryToPost()
            this.setWaitingNote(null)
        }
        return this
    }

    newNote () {
        return WebBrowserNotification.clone()
    }
    
}.initThisClass()


"use strict"

/*

    WebBrowserNotification


*/

window.WebBrowserNotification = class WebBrowserNotification extends ProtoClass {
    
    initPrototype () {
        this.newSlot("title", "")
        this.newSlot("body", null)
        this.newSlot("icon", null).setComment("a url to an image")
        this.newSlot("notificationRef", null)
        this.newSlot("timeoutMs", 4000)
    }

    init () {
        super.init()
        return this
    }

    tryToPost () {
        WebBrowserNotifications.postNote(this)
        return this
    }

    justPost () {
        const note = new Notification(this.title(), { body: this.body(), icon: this.icon() });
        this.setNotificationRef(note)
        this.startTimeout()
        return this
    }

    startTimeout () {
        setTimeout(notification.close.bind(this.notificationRef()), this.timeoutMs());
    }

}.initThisClass()




"use strict"

/*

    WebDocument

    Abstraction for web document object.

*/

window.WebDocument = class WebDocument extends ProtoClass {
    
    initPrototype () {

    }

    init () {
        super.init()
        return this
    }

    body () {
        return DocumentBody.shared()
    }

    styleSheets () {
        const elements = document.styleSheets;
        const sheets = []

        for (let i = 0; i < elements.length; i ++) {
            const sheetElement = elements[i];
            sheets.push(StyleSheet.clone().setSheetElement(sheetElement))
        }

        return sheets
    }

    show () {
        this.debugLog(":")
        this.styleSheets().forEach(sheet => sheet.show())
    }

}.initThisClass()
"use strict"

/*

    BMStyleSheet

    const sheet = DocumentBody.shared().styleSheets().first()
    sheet.setSelectorProperty("body", "color", "red")
*/

window.BMStyleSheet = class BMStyleSheet extends ProtoClass {
    
    initPrototype () {
        this.newSlot("sheetElement", null)
    }

    init () {
        super.init()
        return this
    }

    href () {
        return this.sheetElement().href
    }

    changeStylesheetRule (selector, property, value) {
        const sheet = this.sheetElement()

        selector = selector.toLowerCase();
        property = property.toLowerCase();
        value = value.toLowerCase(); // assumed to be a string?

        // Change it if it exists
        for(let i = 0; i < sheet.cssRules.length; i++) {
            const rule = sheet.cssRules[i];
            if(rule.selectorText === selector) {
                rule.style[property] = value;
                return this;
            }
        }

        // Add it if it does not
        sheet.insertRule(selector + " { " + property + ": " + value + "; }", 0);
        return this;
    }

    show () {
        console.log("sheetElement:", this.sheetElement())
    }

}.initThisClass()


"use strict"

ResourceLoader.pushRelativePaths([
    "dom_attributes/_imports.js",
    "dom_helpers/_imports.js",
    "DomView.js",
    "DomFlexView.js",
    "DomStyledView.js",
    "subclasses/_imports.js",
    "BrowserDragAndDrop/_imports.js"
])


"use strict"

ResourceLoader.pushRelativePaths([
    "DomTransition.js",
    "DomTransitions.js",
    "DomBorderRadius.js",
    "ViewAnimator.js",
])

"use strict"

/*

    DomTransition
         

*/

window.DomTransition = class DomTransition extends ProtoClass {
    initPrototype () {
        this.newSlot("property", "")
        this.newSlot("duration", 0)
        this.newSlot("timingFunction", "ease-in-out") // "linear", "ease", "ease-in", cubic-bezier(n, n, n, n)
        this.newSlot("delay", 0) // set to number type (unit = seconds)
        this.newSlot("transitions", null)
    }

    init() {
        super.init()
    }

    updateDuration(s) {
        if (Type.isNumber(s)) {
            s = s + "s"
        }
        this.setDuration(s)
        this.syncToDomView()
        return this
    }

    updateDelay(s) {
        this.setDelay(s)
        this.syncToDomView()
        return this
    }

    updateTimingFunction(s) {
        this.setTimingFunction(s)
        this.syncToDomView()
        return this
    }

    durationString() {
        const v = this.duration()
        if (Type.isNumber(v)) {
            return v + "s"
        }
        return v
    }

    delayString() {
        const v = this.delay()
        if (Type.isNumber(v)) {
            return v + "s"
        }
        return v
    }

    asString() {
        const parts = [
            this.property(),
            this.durationString(),
            this.timingFunction(),
            this.delayString(),
        ]

        return parts.join(" ")
    }

    setFromString(aString) {
        const parts = aString.split(" ").select((part) => { return part !== "" })

        let v = parts.removeFirst()
        assert(!Type.isNull(v))
        this.setProperty(v)

        v = parts.removeFirst()
        if (!Type.isNull(v)) {
            this.setDuration(v)
        }

        v = parts.removeFirst()
        if (!Type.isNull(v)) {
            this.setTimingFunction(v)
        }

        v = parts.removeFirst()
        if (!Type.isNull(v)) {
            this.setDelay(v)
        }

        return this
    }

    syncToDomView() {
        this.transitions().syncToDomView()
        return this
    }
}.initThisClass()



"use strict"

/*

    DomTransition
         
    Example use in a DomView:

            aDomView.transitions().at("opacity").updateDuration("0.3s")

        updates the opacity time without changing other transition settings
        

    NOTES:

        CSS transition value example:
        
            transition: width 2s linear 1s, height 2s ease 1s; 
        
        1st time value is the duration, 
        2nd time value is the delay


*/


window.DomTransitions = class DomTransitions extends ProtoClass {
    initPrototype () {
        this.newSlot("properties", null)
        this.newSlot("domView", null)
    }

    init() {
        super.init()
        this.setProperties({})
    }

    at(aName) {
        const d = this.properties()
        if (!d.hasOwnProperty(name)) {
            d[name] = DomTransition.clone().setProperty(aName).setTransitions(this)
        }
        return d[name]
    }

    propertiesAsList() {
        return Object.values(this.properties())
    }

    asString() {
        return this.propertiesAsList().map(t => t.asString()).join(", ")
    }

    syncToDomView() {
        //this.debugLog(".setTransition('" + this.asString() + "')")
        this.domView().setTransition(this.asString())
        return this
    }

    syncFromDomView() {
        this.setProperties({})

        const s = this.domView().transition()

        if (s !== "") {
            const transitionStrings = s.split(",")

            transitionStrings.forEach((tString) => {
                const t = DomTransition.clone().setFromString(tString)
                this.properties()[t.property()] = t
            })
        }

        return this
    }
}.initThisClass()




"use strict"

/*

    DomBorderRadius
         

    // this.titleView().setBorderRadius("8px 8px 0px 8px") // top-left, top-right,  bottom-right, bottom-left
    // TODO: em vs px support?

*/


window.DomBorderRadius = class DomBorderRadius extends ProtoClass {
    initPrototype () {
        this.newSlot("divView", null)
        this.newSlot("topLeft", 0)
        this.newSlot("topRight", 0)
        this.newSlot("bottomRight", 0)
        this.newSlot("bottomLeft", 0)
        this.newSlot("partNames", ["topLeft", "topRight", "bottomRight", "bottomLeft"])
    }

    init() {
        super.init()
    }

    clear() {
        this.setAll(0)
        return this
    }

    setAll(v) {
        if (!v) {
            v = 0
        }

        this.partSetters().forEach((setter) => {
            this[setter].apply(this, [v])
        })
        return this
    }

    partSetters() {
        return this.partNames().map(k => k.asSetter())
    }

    partValues() {
        return this.partNames().map(k => this[k].apply(this))
    }

    asString(aString) {
        return this.partValues().map(v => v + "px").join(" ")
    }

    setFromString(aString) {
        const parts = aString.split(" ").select(part => part !== "")

        this.clear()

        if (parts.length === 1) {
            this.setAll(Number(parts[0]))
        }

        let v;

        v = parts.removeFirst()
        if (Type.isString(v)) {
            this.setTopLeft(Number(v))
        }

        v = parts.removeFirst()
        if (Type.isString(v)) {
            this.setTopRight(Number(v))
        }

        v = parts.removeFirst()
        if (Type.isString(v)) {
            this.setBottomRight(Number(v))
        }

        v = parts.removeFirst()
        if (Type.isString(v)) {
            this.setBottomLeft(Number(v))
        }

        return this
    }

    syncToDomView() {
        this.divView().setBorderRadius(this.asString())
        return this
    }

    syncFromDomView() {
        const s = this.divView().borderRadius()

        if (s) {
            this.setFromString(s)
        } else {
            this.clear()
        }

        return this
    }
}.initThisClass()



"use strict"

/*

    ViewAnimator
         

*/

window.ViewAnimator = class ViewAnimator extends ProtoClass {
    initPrototype () {
        this.newSlot("startValue", 0)
        this.newSlot("targetValue", 0)
        this.newSlot("viewProperty", "")
        this.newSlot("duration", 200).setComment("milliseconds")
        this.newSlot("easing", "linear")
        this.newSlot("view", null)
    }

    init() {
        super.init()
    }

    currentValue() {
        const view = this.view()
        return view[this.viewProperty()].apply(view)
    }

    start() {
        this.setStartValue(this.currentValue())
        this.setStartTime(new Date().getTime())
        this.nextFrame()
        return this
    }

    timeRatioDone() {
        const now = new Date().getTime();
        return Math.min(1, ((now - this.startTime()) / this.duration()));
    }

    setterName() {
        if (!this._setterName) {
            this._setterName = this.viewProperty().asSetter()
        }
        return this._setterName
    }

    setValue(v) {
        view[this.setterName()].apply(view, [v])
        return this
    }

    nextFrame() {
        const tr = this.timeRatioDone()
        const newValue = Math.ceil((this.timeRatioDone() * (this.currentValue() - this.startValue())) + this.startValue());
        this.setValue(newValue)

        if (tr !== 1) {
            requestAnimationFrame(() => { this.nextFrame() })
        } else {
            this.didComplete()
        }
        return this
    }

    didComplete() {

    }

    /*
    EasingsFunctions() {
        linear(t) {
            return t;
        }
        easeInQuad(t) {
            return t * t;
        }
        easeOutQuad(t) {
            return t * (2 - t);
        }
        easeInOutQuad(t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }
        easeInCubic(t) {
            return t * t * t;
        }
        easeOutCubic(t) {
            return (--t) * t * t + 1;
        }
        easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
        }
        easeInQuart(t) {
            return t * t * t * t;
        }
        easeOutQuart(t) {
            return 1 - (--t) * t * t * t;
        }
        easeInOutQuart(t) {
            return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t;
        }
        easeInQuint(t) {
            return t * t * t * t * t;
        }
        easeOutQuint(t) {
            return 1 + (--t) * t * t * t * t;
        }
        easeInOutQuint(t) {
            return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t;
        }
    }
    */
}.initThisClass()



"use strict"

ResourceLoader.pushRelativePaths([
    "DomTextTapeMeasure.js",
    "DomCSSInspector.js",
    "CSSColor.js",
    "DomElementHelpers.js"
])


"use strict"

/*

    DomTextTapeMeasure

    Used to measure rendered text dimensions given a string and a style.
    
    Example uses:

            const size1 = DomTextTapeMeasure.shared().sizeOfCSSClassWithText(this.divClassName(), text);
            const h = size1.height;

            const size2 = DomTextTapeMeasure.shared().sizeOfElementWithText(domElement, text);
            const w = size2.width;

*/

window.DomTextTapeMeasure = class DomTextTapeMeasure extends ProtoClass {
    
    initPrototype () {
        this.newSlot("idName", "DomTextTapeMeasure")
        this.newSlot("stylesToCopy", [
            "fontSize",
            "fontStyle", 
            "fontWeight", 
            "fontFamily",
            "lineHeight", 
            "textTransform", 
            "letterSpacing"
        ])
    }
	
    testElement () {
        if (!this._testElement) {
            this._testElement = this.createTestElement()
            if (!document.getElementById(this.idName())) {
                throw new Error("missing element '" + this.idName() + "'")
            }
        }
        return this._testElement
    }
	
    createTestElement () {
        const e = document.createElement("div");
	    e.setAttribute("id", this.idName());
        document.body.appendChild(e);
        e.style.display = "block";
        e.style.position = "absolute";
        e.style.width = "auto";
        e.style.left = -1000;
        e.style.top  = -1000;
        e.style.visibility = "hidden";
        return e		
    }

    sizeOfElementWithText (element, text) { 
        const e = this.testElement()
		
        this.stylesToCopy().forEach(function (styleName) {
            const v = element.style[styleName]
            if (v) {
                e.style[styleName] = v
            } else {
                delete e.style[styleName]
            }
        })
		
        e.innerHTML = element.innerHTML
		
        const width = (e.clientWidth + 1) 
        const height = (e.clientHeight + 1) 
        this.clean()
        return { width: width, height: height }
    }
	
    sizeOfCSSClassWithText (divClassName, text) { 
        const e = this.testElement()
        this.clean()
        e.className = divClassName
        e.innerHTML = text
		
        const width = (e.clientWidth + 1) 
        const height = (e.clientHeight + 1) 
        e.innerHTML = ""
        return { width: width, height: height }
    }
	
    clean () {
        const e = this.testElement()
        e.innerHTML = ""
        e.className = ""
        this.stylesToCopy().forEach(styleName => delete e.style[styleName] )
        return this	
    }
	
}.initThisClass()

"use strict"

/*
    DomCSSInspector
    Used to inspect class styles since css hides stylesheet.cssRules.
    
    example use:
    const value = DomCSSInspector.shared().setDivClassName("..").cssStyle.fontFamily

*/

window.DomCSSInspector = class DomCSSInspector extends ProtoClass {
    
    initPrototype () {
        this.newSlot("idName", "DomCSSInspector")
    }

    testElement () {
        if (!this._testElement) {
            this._testElement = this.createTestElement()
            document.body.appendChild(this._testElement);
            if (!document.getElementById(this.idName())) {
                throw new Error("missing element '" + this.idName() + "'")
            }
        }
        return this._testElement
    }
	
    createTestElement () {
        const e = document.createElement("div");
	    e.setAttribute("id", this.idName());
        e.style.display = "none";
        e.style.visibility = "hidden";
        return e
    }

    setDivClassName (aName) {
        this.testElement().setAttribute("class", aName);
        return this
    }

    cssStyle (key) {
        return this.testElement().style
    }
    
}.initThisClass()

"use strict"

/*
    
    CSSColor
    
    Helpful for manipulating css colors.
	
*/


const RGB2HSV = function (rgb) {
    const hsv = new Object();
    const max = max3(rgb.r, rgb.g, rgb.b);
    const dif = max - min3(rgb.r, rgb.g, rgb.b);
    hsv.saturation = (max == 0.0) ? 0 : (100 * dif / max);
    if (hsv.saturation == 0) hsv.hue = 0;
    else if (rgb.r == max) hsv.hue = 60.0 * (rgb.g - rgb.b) / dif;
    else if (rgb.g == max) hsv.hue = 120.0 + 60.0 * (rgb.b - rgb.r) / dif;
    else if (rgb.b == max) hsv.hue = 240.0 + 60.0 * (rgb.r - rgb.g) / dif;
    if (hsv.hue < 0.0) hsv.hue += 360.0;
    hsv.value = Math.round(max * 100 / 255);
    hsv.hue = Math.round(hsv.hue);
    hsv.saturation = Math.round(hsv.saturation);
    return hsv;
}

// RGB2HSV and HSV2RGB are based on Color Match Remix see: http://color.twysted.net/
// which is based on or copied from ColorMatch 5K see: http://colormatch.dk/
const HSV2RGB = function (hsv) {
    const rgb = new Object();
    if (hsv.saturation == 0) {
        rgb.r = rgb.g = rgb.b = Math.round(hsv.value * 2.55);
    } else {
        hsv.hue /= 60;
        hsv.saturation /= 100;
        hsv.value /= 100;
        let i = Math.floor(hsv.hue);
        let f = hsv.hue - i;
        let p = hsv.value * (1 - hsv.saturation);
        let q = hsv.value * (1 - hsv.saturation * f);
        let t = hsv.value * (1 - hsv.saturation * (1 - f));
        switch (i) {
        case 0: rgb.r = hsv.value; rgb.g = t; rgb.b = p; break;
        case 1: rgb.r = q; rgb.g = hsv.value; rgb.b = p; break;
        case 2: rgb.r = p; rgb.g = hsv.value; rgb.b = t; break;
        case 3: rgb.r = p; rgb.g = q; rgb.b = hsv.value; break;
        case 4: rgb.r = t; rgb.g = p; rgb.b = hsv.value; break;
        default: rgb.r = hsv.value; rgb.g = p; rgb.b = q;
        }
        rgb.r = Math.round(rgb.r * 255);
        rgb.g = Math.round(rgb.g * 255);
        rgb.b = Math.round(rgb.b * 255);
    }
    return rgb;
}

//Adding HueShift via Jacob (see comments)
const HueShift = function (h, s) {
    h += s; 
    while (h >= 360.0) { 
        h -= 360.0; 
    }
    while (h < 0.0) { 
        h += 360.0; 
    }
    return h;
}

//min max via Hairgami_Master (see comments)
const min3 = function(a, b, c) {
    return (a < b) ? ((a < c) ? a : c) : ((b < c) ? b : c);
}
const max3 = function(a, b, c) {
    return (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c);
}

window.CSSColor = class CSSColor extends ProtoClass {
    
    initPrototype () {
        // values between 0.0 and 1.0
        this.newSlot("red", 0)
        this.newSlot("green", 0)
        this.newSlot("blue", 0)
        this.newSlot("opacity", 1)
        //isMutable: true,
    }
    
    init () {
        super.init()
        return this
    }

    randomize () {
        this.setRed(Math.random())
        this.setGreen(Math.random())
        this.setBlue(Math.random())
        return this
    }

    copyFrom (aColor, copyDict) {
        return CSSColor.clone().set(aColor.red(), aColor.green(), aColor.blue(), aColor.opacity())
    }

    static colorMapCache () {
        if (!CSSColor._colorMapCache) {
            CSSColor._colorMapCache = {}
        }
        return CSSColor._colorMapCache
    }

    justParseColorString (aColorString) { // private
        // TODO: test if this is expensive
        // also, check for any risk of causing an event?
        const div = document.createElement("div");
        document.body.appendChild(div);
        div.style.color = aColorString;
        const style = window.getComputedStyle(div);
        const color = style.color;
        document.body.removeChild(div);

        assert(color.beginsWith("rgb"))
        const inner = color.between("(", ")");
        const parts = inner.split(",");
        const numbers = parts.map((v) => parseInt(v));

        // add an alpha of 1 if no alpha is specified
        // in order to make returned array format consistent

        if (numbers.length === 3) {
            numbers.push(1)
        }

        assert(numbers.length === 4)

        numbers[0] /= 255
        numbers[1] /= 255
        numbers[2] /= 255
        return numbers
    }

    parseColorString (string) {
        const cache = CSSColor.colorMapCache()
        const cachedResult = cache.at(string)
        if (!Type.isUndefined(cachedResult)) {
            return cachedResult
        }

        if (Type.isNull(cachedResult)) {
            throw new Error("invalid color string '" + string + "'")
        }

        const result = this.justParseColorString(string)

        cache.atPut(string, result)
        return result
    }

    setCssColorString (aString) {
        const array = this.parseColorString(aString)
        this.set(array.at(0), array.at(1), array.at(2), array.at(3))
        return this
    }

    setHex (hex) {
        return this.setCssColorString(hex)
    }

    set (r, g, b, opacity) {
        this.setRed(r)
        this.setGreen(g)
        this.setBlue(b)

        if (!opacity) {
            this.setOpacity(0)
        } else {
            this.setOpacity(opacity)
        }

        return this
    }

    // conversion helpers

    v255toUnit (v) {
        return v / 255;
    }

    unitTo255 (v) {
        return Math.round(v * 255)
    }

    red255 () {
        return this.unitTo255(this.red());
    }

    green255 () {
        return this.unitTo255(this.green());
    }

    blue255 () {
        return this.unitTo255(this.blue());
    }

    /*
    setCssColorString (s) {

    }
    */

    cssColorString () {
        return "rgba(" + this.red255() + ", " + this.green255() + ", " + this.blue255() + ", " + this.opacity()  + ")"
    }

    // operations

    interpV1V2Ratio(v1, v2, r) {
        const diff = v2 - v1;
        if (v1 > v2) {
            return v1 - (v1 - v2)*r
        }
        return v2 - (v2 - v1)*r
    }

    interpolateWithColorTo (other, v) {
        const r1 = this.red()
        const g1 = this.green()
        const b1 = this.blue()
        const o1 = this.opacity()

        const r2 = other.red()
        const g2 = other.green()
        const b2 = other.blue()
        const o2 = other.opacity()

        const r = this.interpV1V2Ratio(r1, r2, v)
        const g = this.interpV1V2Ratio(g1, g2, v)
        const b = this.interpV1V2Ratio(b1, b2, v)
        const o = this.interpV1V2Ratio(o1, o2, v)

        const result = CSSColor.clone().set(r, g, b, o)
        return result
    }

    darken (v) {
        assertDefined(v)
        assert(v <= 1)
        const r = this.red()
        const g = this.green()
        const b = this.blue()
        this.setRed(r * v)
        this.setGreen(g * v)
        this.setBlue(b * v)
        return this
    }

    lighten (v) {
        assertDefined(v)
        const r = this.red()
        const g = this.green()
        const b = this.blue()
        this.setRed(r + (1 - r) * v)
        this.setGreen(g + (1 - g) * v)
        this.setBlue(b + (1 - b) * v)
        return this
    }

    brightness () {  
        // return value between 0.0 and 1.0
        return (this.red() + this.green() + this.blue() ) / 3.0;
    }

    whiteColor () {
        return CSSColor.clone().set(1, 1, 1, 1)
    }

    blackColor () {
        return CSSColor.clone().set(0, 0, 0, 1)
    }

    lightGrayColor () {
        return CSSColor.clone().set(0.75, 0.75, 0.55, 1)
    }

    grayColor () {
        return CSSColor.clone().set(0.5, 0.5, 0.5, 1)
    }

    darkGrayColor () {
        return CSSColor.clone().set(0.25, 0.25, 0.25, 1)
    }

    redColor () {
        return CSSColor.clone().set(1, 0, 0, 1)
    }

    greenColor () {
        return CSSColor.clone().set(0, 1, 0, 1)
    }

    blueColor () {
        return CSSColor.clone().set(0, 0, 1, 1)
    }

    yellowColor () {
        return CSSColor.clone().set(1, 1, 0, 1)
    }

    randomColor () {
        return CSSColor.clone().randomize()
    }

    asDict255 () {
        return { r:this.red255(), g:this.green255(), b:this.blue255() }
    }

    fromDict255 (d) {
        this.setRed(  d.r / 255)
        this.setGreen(d.g / 255)
        this.setBlue( d.b / 255)
        return this
    }

    complement () {
        const temprgb = this.asDict255();
        const temphsv = RGB2HSV(temprgb);
        temphsv.hue = HueShift(temphsv.hue, 180.0);
        temprgb = HSV2RGB(temphsv);
        return CSSColor.clone().fromDict255(temprgb)
    }

    contrastComplement (v) { // v should be a value in the range of 0.0 to 1.0
        // returns another CSSColor object which is the same as the receiver but darkened
        //

        const b = this.brightness() 

        if (b < 0.55) {
            const lightened = this.copy().lighten(v)
            return lightened
        } else {
            const darkened = this.copy().darken(v)
            return darkened
        }
    }

}.initThisClass()


"use strict"

/*

`   DomElement_...
`
    Helper functions for DOM elements.
    Mostly for use inside DomView.
    Not for general consumption as elements typically shouldn't be interacted with directly. 

*/

function DomElement_atInsertElement(el, index, child) {
    const children = el.children
    
    if (index < children.length) {
        el.insertBefore(child, children[index])
        return
    }
    
    if (index === children.length) {
        el.appendChild(child)
        return
    }
    
    throw new Error("invalid dom child index")
}

function DomElement_description(element) {
    let s = false

    if (element === window) {
        s = "window"
    }

    if (!s) {
        s = element.getAttribute("id")
    }

    if (!s) {
        s = element.getAttribute("class")
    }

    if (!s) {
        s = element.tagName
    }

    return s
}

window.Element_setStyleIncludingDecendants = function(e, k, v) {
    if (e.style) {
        e.style[k] = v
    }
    
    for(let i = 0; i < e.childNodes.length; i ++) {
        const child = e.childNodes[i]
        Element_setStyleIncludingDecendants(child, k, v)
    }
}
"use strict"

/*
    DomView

    Base view class. Wraps a dom element.

    TODO: add dict[propertyName] -> validValueSet and check css values when set
*/

window.DomView = class DomView extends ProtoClass {
    
    initPrototype () {
        this.newSlot("divClassName", "")
        this.newSlot("elementType", "div")
        this.newSlot("element", null)

        // parent view and subviews

        this.newSlot("parentView", null)
        this.newSlot("subviews", null)

        // target / action

        this.newSlot("target", null)
        this.newSlot("action", null)
        this.newSlot("showsHaloWhenEditable", false)
        this.newSlot("tabCount", 0)
        this.newSlot("validColor", null)
        this.newSlot("invalidColor", null)

        // key views

        this.newSlot("interceptsTab", true)
        this.newSlot("nextKeyView", null)
        this.newSlot("canMakeKey", true)
        this.newSlot("unfocusOnEnterKey", false)

        // event handling

        this.newSlot("isRegisteredForVisibility", false)
        this.newSlot("intersectionObserver", null)
        this.newSlot("acceptsFirstResponder", false)
        this.newSlot("gestureRecognizers", null)
        this.newSlot("eventListenersDict", null)
        //this.newSlot("activeTimeoutIdSet", null)
        this.newSlot("defaultTapGesture", null)
        this.newSlot("defaultDoubleTapGesture", null)
        this.newSlot("defaultPanGesture", null)

        // extras
    
        this.newSlot("hiddenDisplayValue", undefined)
        this.newSlot("hiddenMinHeight", undefined)
        this.newSlot("hiddenMaxHeight", undefined)
        this.newSlot("hiddenTransitionValue", undefined)
    }

    init () {
        super.init()
        this.setSubviews([])
        this.setupElement()
        this.setEventListenersDict({})
        return this
    }

    // retiring

    prepareToRetire () {
        super.prepareToRetire()
        
        this.blur()
        this.removeAllGestureRecognizers()
        this.removeAllListeners()
        this.cancelAllTimeouts()

        this.setIsRegisteredForVisibility(false) // this one isn't a listener
        
        const e = this.element()
        if (e) {
            e._domView = null
        }

        this.retireSubviewTree()
        if (this.parentView()) {
            this.removeFromParentView()
        }
        
        return this
    }

    removeAllListeners () {
        this.eventListenersDict().ownForEachKV( (k, v) => { v.setIsListening(false) } )
        this.setEventListenersDict({})
        return this
    }

    retireSubviewTree () {
        this.subviews().forEach(sv => {
            sv.prepareToRetire()
            sv.retireSubviewTree()
        })
        //this.removeAllSubviews()
    }

    /*
        timeouts 
        
        Sometimes we can't use the SyncScheduler as we have to make sure 
        something happens *after* the current event loop ends (and control is returned to the browser),
        but scheduler runs while still in (but at the end of) the current event.
        Also, we sometimes need timeout delays.

    */

    activeTimeoutIdSet () {
        if (Type.isNullOrUndefined(this._activeTimeoutIdSet)) {
            Object.defineSlot(this, "_activeTimeoutIdSet", new Set())
        }
        return this._activeTimeoutIdSet
    }

    addTimeout (aFunc, msDelay) {
        const tids = this.activeTimeoutIdSet()
        const tidInfo = {}
        const tid = setTimeout(() => { 
            tids.delete(tidInfo.tid) 
            aFunc() 
        }, msDelay)
        tidInfo.tid = tid
        this.activeTimeoutIdSet().add(tid)
        return tid
    }

    cancelTimeoutId (tid) {
        const tids = this.activeTimeoutIdSet()
        tids.delete(tid)
        clearTimeout(tid)
        return this
    }

    cancelAllTimeouts () {
        const tids = this.activeTimeoutIdSet()
        tids.forEach(tid => clearTimeout(tid))
        tids.clear()
        return this
    }

    // gestures

    gestureRecognizers () {
        if (this._gestureRecognizers == null) {
            this._gestureRecognizers = []
        }
        return this._gestureRecognizers
    }

    // element

    setDivId (aString) {
        this.element().id = aString
        return this
    }

    setElement (e) {
        this._element = e
        this.addTimeout(() => { this.setIsRegisteredForFocus(true); }, 0)
        e._domView = this // try to avoid depending on this as much as possible - keep refs to divViews, not elements
        return this
    }

    createElement () {
        const e = document.createElement(this.elementType())
        return e
    }

    setupElement () {
        const e = this.createElement()
        this.setElement(e)
        this.setDivId(this.typeId())
        this.setupDivClassName()
        return this
    }

    escapedElementId () {
        const id = this.element().id
        const escapedId = id.replace(/[^a-z|\d]/gi, '\\$&');
        return escapedId
    }

/*
    setupDivClassNameOld () {
        const ancestorNames = this.thisClass().ancestorClassesIncludingSelf().map(obj => obj.type())
        const divName = ancestorNames.join(" ").strip()
        this.setDivClassName(divName)
        return this
    }

    insertDivClassName (aName) {
        const names = this.divClassName().split(" ")
        names.removeOccurancesOf(aName) // avoid duplicates
        names.atInsert(0, aName)
        this.setDivClassNames(names)
        return this
    }

    removeDivClassName (aName) {
        const names = this.divClassName().split(" ")
        names.removeOccurancesOf(aName)
        this.setDivClassNames(names)
        return this
    }
*/


    setupDivClassName () {
        const e = this.element()
        const ancestorNames = this.thisClass().ancestorClassesIncludingSelf().map(obj => obj.type())
        ancestorNames.forEach(name => e.classList.add(name))
        return this
    }

    insertDivClassName (aName) {
        const e = this.element()
        e.classList.add(aName)
        return this
    }

    removeDivClassName (aName) {
        const e = this.element()
        e.classList.remove(aName)
        return this
    }

    setDivClassNames (names) {
        this.setDivClassName(names.join(" "))
        return this
    }

    /*    
    applyCSS (ruleName) {
        if (ruleName == null) { 
            ruleName = this.divClassName()
        }
        CSS.ruleAt(ruleName).applyToElement(this.element())
        return this
    }
    */

    stylesheetWithClassName (className) {
        for (let i = 0; i < document.styleSheets.length; i++) {
            const stylesheet = document.styleSheets[i]

            if ("cssRules" in stylesheet) {
                try {
                    const rules = stylesheet.cssRules
                    for (let j = 0; j < rules.length; j++) {
                        const rule = rules[j]
                        const ruleClassName = rule.selectorText.split(" ")[0]
                        console.log("rule.selectorText: ", rule.selectorText)
                        if (ruleClassName === className) {
                            return stylesheet
                        }
                    }
                } catch (e) {
                    //console.log("couldn't add CSS rule: " + rule + "")
                }
            }
        }
        return null
    }

    setCssDict (aDict) {
        Reflect.ownKeys(aDict).forEach((k) => {
            const v = aDict[k]
            this.setCssAttribute(k, v)
        })
        return this
    }

    setCssAttribute (key, newValue, didChangeCallbackFunc) {
        assert(Type.isString(key))

        const style = this.cssStyle()
        const doesSanityCheck = false
        const oldValue = style[key]

        if (String(oldValue) !== String(newValue)) {
            if (newValue == null) {
                //console.log("deleting css key ", key)
                //delete style[key]
                style.removeProperty(key)
                //console.log(this.cssStyle()[key])
            } else {
                style[key] = newValue

                if (doesSanityCheck) {
                    // sanity check the result
                    // but ignore these keys as they have equivalent functional values 
                    // that can have different string values
                    const ignoredKeys = { 
                        "background-position": true,  
                        "transition": true, 
                        "color": true , 
                        "background-color": true,
                        "box-shadow": true,
                        "border-bottom": true,
                        "transform-origin": true,
                        "outline": true,
                        "border": true,
                        "border-color": true
                    }

                    const resultValue = style[key]
                    if (!(key in ignoredKeys) && resultValue != newValue) {
                        let msg = "DomView: style['" + key + "'] not set to expected value\n";
                        msg += "     set: <" + typeof(newValue) + "> '" + newValue + "'\n";
                        msg += "     got: <" + typeof(resultValue) + "> '" + resultValue + "'\n";
                        console.warn(msg)
                        //throw new Error(msg) 
                    }
                }
            }

            if (didChangeCallbackFunc) {
                didChangeCallbackFunc()
            }
        }

        return this
    }

    getCssAttribute (key, errorCheck) {
        if (errorCheck) {
            throw new Error("getCssAttribute called with 2 arguments")
        }
        return this.cssStyle()[key]
    }

    // css px attributes

    setPxCssAttribute (name, value, didChangeCallbackFunc) {
        this.setCssAttribute(name, this.pxNumberToString(value), didChangeCallbackFunc)
        return this
    }

    getPxCssAttribute (name, errorCheck) {
        const s = this.getCssAttribute(name, errorCheck)
        if (s.length) {
            return this.pxStringToNumber(s)
        }
        return 0
    }

    // computed style

    getComputedCssAttribute (name, errorCheck) {
        return window.getComputedStyle(this.element()).getPropertyValue(name)
    }

    getComputedPxCssAttribute (name, errorCheck) {
        const s = this.getComputedCssAttribute(name, errorCheck)
        if (s.length) {
            return this.pxStringToNumber(s)
        }
        return 0
    }

    // --- css properties ---

    setPosition (s) {
        this.setCssAttribute("position", s)
        return this
    }

    position () {
        return this.getCssAttribute("position")
    }

    // pointer events

    setPointerEvents (s) {
        assert([null, 
            "auto", "none", "visiblePainted", 
            "visibleFill", "visibleStroke", "visible", 
            "painted", "fill", "stroke", "all", 
            "inherit", "initial", "unset"].contains(v))
        return this.setCssAttribute("pointer-events", s)
    }

    pointerEvents () {
        return this.getCssAttribute("pointer-events")
    }

    // transform

    setTextTransform (v) {
        assert([null, "none", "capitalize", "uppercase", "lowercase", "initial", "inherit"].contains(v))
        this.setCssAttribute("text-transform", v)
        return this
    }

    textTransform () {
        return this.getCssAttribute("text-transform")
    }

    // word wrap

    setWordWrap(v) {
        assert([null, "normal", "break-word", "initial", "inherit"].contains(v))
        this.setCssAttribute("word-wrap", v)
        return this
    }

    wordWrap () {
        return this.getCssAttribute("word-wrap")
    }

    // zoom

    setZoom (s) {
        this.setCssAttribute("zoom", s)
        return this
    }

    zoom () {
        return this.getCssAttribute("zoom")
    }

    zoomRatio () {
        return Number(this.zoom().before("%")) / 100
    }

    setZoomRatio (r) {
        //console.log("setZoomRatio: ", r)
        this.setZoomPercentage(r * 100)
        return this
    }

    setZoomPercentage (aNumber) {
        assert(Type.isNumber(aNumber))
        this.setCssAttribute("zoom", aNumber + "%")
        return this
    }

    // font family

    setFontFamily (s) {
        assert(Type.isString(s) || Type.isNull(s))
        this.setCssAttribute("font-family", s)
        return this
    }

    fontFamily () {
        return this.getCssAttribute("font-family")
    }

    // font weight

    fontWeightValidatorFunction (v) {
       return (v) => { Type.isNumber(v) || [null, "normal", "bold", "bolder", "lighter", "initial", "inherit"].contains(v) }
    }

    setFontWeight (v) {
        //assert(this.fontWeightValidatorFunction()(v))
        this.setCssAttribute("font-weight", v)
        return this
    }

    fontWeight () {
        return this.getCssAttribute("font-weight")
    }

    // font size

    setFontSizeAndLineHeight (s) {
        this.setFontSize(s)
        this.setLineHeight(s)
        return this
    }

    setFontSize (s) {
        this.setCssAttribute("font-size", s)
        return this
    }

    fontSize () {
        return this.getCssAttribute("font-size")
    }

    computedFontSize () {
        return this.getComputedCssAttribute("font-size")
    }

    // px font size

    setPxFontSize (s) {
        this.setPxCssAttribute("font-size", s)
        return this
    }

    pxFontSize () {
        return this.getPxCssAttribute("font-size")
    }

    computedPxFontSize () {
        return this.getComputedPxCssAttribute("font-size")
    }

    // text-shadow

    setTextShadow (s) {
        this.setCssAttribute("text-shadow", s)
        return this
    }

    textShadow () {
        return this.getCssAttribute("text-shadow")
    }

    // ---

    // letter spacing

    setLetterSpacing (s) {
        this.setCssAttribute("letter-spacing", s)
        return this
    }

    letterSpacing () {
        return this.getCssAttribute("letter-spacing")
    }

    computedLetterSpacing () {
        return this.getComputedCssAttribute("letter-spacing")
    }

    // margin

    setMarginString (s) {
        this.setCssAttribute("margin", s)
        return this
    }

    // margin

    setMargin (s) {
        this.setCssAttribute("margin", s)

        this.setMarginTop(null)
        this.setMarginBottom(null)
        this.setMarginLeft(null)
        this.setMarginRight(null)

        return this
    }

    margin () {
        return this.getCssAttribute("margin")
    }

    // margin px

    setMarginPx (s) {
        this.setPxCssAttribute("margin", s)

        this.setMarginTop(null)
        this.setMarginBottom(null)
        this.setMarginLeft(null)
        this.setMarginRight(null)

        return this
    }

    marginPx () {
        return this.getPxCssAttribute("margin")
    }

    // margin top

    setMarginTop (m) {
        if (Type.isNumber(m)) {
            this.setPxCssAttribute("margin-top", m)
        } else {
            this.setCssAttribute("margin-top", m)
        }
        return this
    }

    // margin bottom

    setMarginBottom (m) {
        if (Type.isNumber(m)) {
            this.setPxCssAttribute("margin-bottom", m)
        } else {
            this.setCssAttribute("margin-bottom", m)
        }
        return this
    }

    // margin left

    setMarginLeft (m) {
        if (Type.isNumber(m)) {
            this.setPxCssAttribute("margin-left", m)
        } else {
            this.setCssAttribute("margin-left", m)
        }
        return this
    }

    // margin right

    setMarginRight (m) {
        this.setCssAttribute("margin-right", m)
        return this
    }

    marginRight () {
        return this.getCssAttribute("margin-right")
    }

    // margin right px

    setMarginRightPx (m) {
        this.setPxCssAttribute("margin-right", m)
        return this
    }

    marginRightPx () {
        return this.getPxCssAttribute("margin-right")
    }

    // padding

    setPadding (v) {
        assert(Type.isNull(v) || Type.isString(v))
        this.setPaddingTop(null)
        this.setPaddingBottom(null)
        this.setPaddingLeft(null)
        this.setPaddingRight(null)
        this.setCssAttribute("padding", v)
        return this
    }
    
    padding () {
        return this.getCssAttribute("padding")
    }

    // top

    setPaddingTop (v) {
        assert(Type.isString(v) || Type.isNull(v))
        this.setCssAttribute("padding-top", v)
        return this
    }

    paddingTop () {
        return this.getCssAttribute("padding-top")
    }
    // bottom

    setPaddingBottom (v) {
        assert(Type.isString(v) || Type.isNull(v))
        this.setCssAttribute("padding-bottom", v)
        return this
    }

    paddingBottom () {
        return this.getCssAttribute("padding-bottom")
    }

    // left

    setPaddingLeft (v) {
        assert(Type.isString(v) || Type.isNull(v))
        this.setCssAttribute("padding-left", v)
        return this
    }

    paddingLeft () {
        return this.getCssAttribute("padding-left")
    }

    // right
    
    setPaddingRight (v) {
        assert(Type.isString(v) || Type.isNull(v))
        this.setCssAttribute("padding-right", v)
        return this
    }

    paddingRight () {
        return this.getCssAttribute("padding-right")
    }

    // padding px

    setPaddingPx (aNumber) {
        this.setPxCssAttribute("padding", aNumber)
        return this
    }

    paddingPx () {
        return this.getPxCssAttribute("padding")
    }

    // padding right px

    setPaddingRightPx (aNumber) {
        this.setPxCssAttribute("padding-right", aNumber)
        return this
    }

    paddingRightPx () {
        return this.getPxCssAttribute("padding-right")
    }

    // padding left px

    setPaddingLeftPx (aNumber) {
        this.setPxCssAttribute("padding-left", aNumber)
        return this
    }

    paddingLeftPx () {
        return this.getPxCssAttribute("padding-left")
    }

    // padding top px

    setPaddingTopPx (aNumber) {
        this.setPxCssAttribute("padding-top", aNumber)
        return this
    }

    paddingTopPx () {
        return this.getPxCssAttribute("padding-top")
    }

    // padding bottom px

    setPaddingBottomPx (aNumber) {
        this.setPxCssAttribute("padding-bottom", aNumber)
        return this
    }

    paddingBottomPx () {
        return this.getPxCssAttribute("padding-bottom")
    }

    // background color

    setBackgroundColor (v) {
        this.setCssAttribute("background-color", v)
        return this
    }

    backgroundColor () {
        return this.getCssAttribute("background-color")
    }

    computedBackgroundColor () {
        return this.getComputedCssAttribute("background-color")
    }

    // background image

    setBackgroundImage (v) {
        this.setCssAttribute("background-image", v)
        return this
    }

    backgroundImage () {
        return this.getCssAttribute("background-image")
    }

    setBackgroundImageUrlPath (path) {
        this.setBackgroundImage("url(\"" + path + "\")")
        return this
    }

    // background size

    setBackgroundSizeWH (x, y) {
        this.setCssAttribute("background-size", x + "px " + y + "px")
        return this
    }

    setBackgroundSize (v) {
        assert(Type.isNull(v) || Type.isString(v))
        this.setCssAttribute("background-size", v)
        return this
    }

    makeBackgroundCover () {
        this.setBackgroundSize("cover")
        return this
    }

    makeBackgroundContain () {
        this.setBackgroundSize("contain")
        return this
    }

    // background repeat

    makeBackgroundNoRepeat () {
        this.setBackgroundRepeat("no-repeat")
        return this
    }

    setBackgroundRepeat (s) {
        assert(Type.isString(s))
        this.setCssAttribute("background-repeat", s)
        return this
    }

    backgroundRepeat () {
        return this.getCssAttribute("background-repeat")
    }

    // background position

    makeBackgroundCentered () {
        this.setBackgroundPosition("center")
        return this
    }

    setBackgroundPosition (s) {
        this.setCssAttribute("background-position", s)
        return this
    }

    backgroundPosition () {
        return this.getCssAttribute("background-position")
    }

    // icons - TODO: find a better place for this

    pathForIconName (aName) {
        const pathSeparator = "/"
        return ["resources", "icons", aName + ".svg"].join(pathSeparator)
    }

    // transition

    setTransition (s) {
        this.setCssAttribute("transition", s)

        if (this._transitions) {
            this.transitions().syncFromDomView()
        }

        return this
    }

    transition () {
        return this.getCssAttribute("transition")
    }

    // helper for hide/unhide transition

    isTransitionHidden () {
        return !Type.isNullOrUndefined(this.hiddenTransitionValue())
    }

    hideTransition () {
        if (!this.isTransitionHidden()) {
            this.setHiddenTransitionValue(this.transition())
            this.setTransition("all 0s")
            this.subviews().forEach(sv => sv.hideTransition())
        }
        return this
    }

    unhideTransition () {
        if (this.isTransitionHidden()) {
            this.setTransition(this.hiddenTransitionValue())
            this.setHiddenTransitionValue(null)
            this.subviews().forEach(sv => sv.unhideTransition())
        } else {
            this.setTransition(null)
        }
        return this
    }

    // hide/unhide transition

    /*
    hideTransition () {
        if (!Type.isNull(this.transition())) {
            this.setHiddenTransitionValue(this.transition())
            this.setTransition(null)
            this.subviews().forEach(sv => sv.hideTransition())
        }
        return this
    }

    unhideTransition () {
        if (Type.isNull(this.transition())) {
            if (this.hiddenTransitionValue()) {
                this.setTransition(this.hiddenTransitionValue())
                this.setHiddenTransitionValue(null)
                this.subviews().forEach(sv => sv.unhideTransition())
            }
        }
        return this
    }
    */

    // transitions

    transitions () {
        if (this._transitions == null) {
            this._transitions = DomTransitions.clone().setDomView(this).syncFromDomView()
        }
        return this._transitions
    }

    // transforms

    setTransform (s) {
        this.setCssAttribute("transform", s)
        return this
    }

    setTransformOrigin (s) {
        //transform-origin: x-axis y-axis z-axis|initial|inherit;
        //const percentageString = this.percentageNumberToString(aNumber)
        this.setCssAttribute("transform-origin", s)
        return this
    }

    /*
    TODO: add setter/getters for:

        perspective-origin: x-axis y-axis|initial|inherit;
        transform-style: flat|preserve-3d|initial|inherit;
        backface-visibility: hidden | visible;

    */

    // perspective

    setPerspective (n) {
        this.setPxCssAttribute("perspective", n)
        return this
    }

    // opacity

    opacityValidatorFunction () {
        return (v) => { return Type.isNumber(v) || [null, "auto", "inherit", "initial", "unset"].contains(v) }
    }

    setOpacity (v) {
        //assert(this.opacityValidatorFunction()(v))
        this.setCssAttribute("opacity", v)
        return this
    }

    opacity () {
        return this.getCssAttribute("opacity")
    }

    // z index 

    setZIndex (v) {
        this.setCssAttribute("z-index", v)
        return this
    }

    zIndex () {
        return this.getCssAttribute("z-index")
    }

    // cursor 

    setCursor (s) {
        this.setCssAttribute("cursor", s)
        return this
    }

    cursor () {
        return this.getCssAttribute("cursor")
    }

    makeCursorDefault () {
        this.setCursor("default")
        return this
    }

    makeCursorPointer () {
        this.setCursor("pointer")
        return this
    }

    makeCursorText () {
        this.setCursor("text")
        return this
    }

    makeCursorGrab () {
        this.setCursor("grab")
        return this
    }

    makeCursorGrabbing () {
        this.setCursor("grabbing")
        return this
    }

    makeCursorColResize () {
        this.setCursor("col-resize")
        return this
    }

    makeCursorRowResize () {
        this.setCursor("row-resize")
        return this
    }

    // --- focus and blur ---

    hasParentViewAncestor (aView) {
        const pv = this.parentView()
        
        if (!pv) {
            return false
        }

        if (pv === aView) {
            return true
        }

        return pv.hasParentViewAncestor(aView)
    }

    hasSubviewDescendant (aView) {
        if (aView == this) {
            return true
        }
        return this.subviews().detect(sv => sv.hasSubviewDescendant(aView))
    }

    hasFocusedDecendantView () {
        const focusedView = WebBrowserWindow.shared().activeDomView()
        if (focusedView) {
            return this.hasSubviewDescendant(focusedView)
        }
        return false
    }

    focus () {
        if (!this.isActiveElement()) {
            //console.log(this.typeId() + " focus <<<<<<<<<<<<<<<<<<")
            /*
            const focusedView = WebBrowserWindow.shared().activeDomView()

            // TODO: need a better solution to this problem
            if (focusedView && !this.hasFocusedDecendantView()) {
                
                if (focusedView && focusedView.type() === "TextField") {
                    console.log("  -- taking focus from " + focusedView.typeId())
                }
                
                //this.debugLog(".focus() " + document.activeElement._domView)
                this.addTimeout(() => { this.element().focus() }, 0)
            }
            */
            //this.addTimeout(() => { this.element().focus() }, 0)

            this.element().focus()
        }
        return this
    }

    focusAfterDelay (seconds) {
        this.addTimeout(() => {
            this.element().focus()
        }, seconds * 1000)
        return this
    }

    hasFocus () {
        return this.isActiveElement()
    }

    blur () { 
        // i.e. unfocus
        this.element().blur()
        return this
    }

    // top

    setTop (v) {
        assert(Type.isNull(v) || Type.isString(v))
        this.setCssAttribute("top", v)
        return this
    }

    top () {
        return this.getCssAttribute("top")
    }

    // top px

    setTopPx (v) {
        assert(Type.isNull(v) || Type.isNumber(v))
        this.setPxCssAttribute("top", v)
        return this
    }

    topPx () {
        return this.getPxCssAttribute("top")
    }

    // left

    setLeft (v) {
        assert(Type.isNull(v) || Type.isString(v))
        this.setCssAttribute("left", v)
        return this
    }

    left () {
        return this.getCssAttribute("left")
    }

    // left px

    setLeftPx (v) {
        assert(Type.isNull(v) || Type.isNumber(v))
        this.setPxCssAttribute("left", v)
        return this
    }

    leftPx () {
        return this.getPxCssAttribute("left")
    }

    // right

    setRight (v) {
        assert(Type.isNull(v) || Type.isString(v))
        this.setCssAttribute("right", v)
        return this
    }


    right () {
        return this.getCssAttribute("right")
    }

    // right px

    setRightPx (v) {
        assert(Type.isNull(v) || Type.isNumber(v))
        this.setPxCssAttribute("right", v)
        return this
    }

    rightPx () {
        return this.getPxCssAttribute("right")
    }

    // bottom

    setBottom (v) {
        assert(Type.isNull(v) || Type.isString(v))
        this.setCssAttribute("bottom", v)
        return this
    }

    bottom () {
        return this.getCssAttribute("bottom")
    }

    // bottom px

    setBottomPx (v) {
        assert(Type.isNull(v) || Type.isNumber(v))
        this.setPxCssAttribute("bottom", v)
        return this
    }

    bottomPx () {
        return this.getPxCssAttribute("bottom")
    }

    // float

    setFloat (v) {
        assert([null, "left", "right", "none", "inline-start", "inline-end", "start", "end", "initial", "inherit"].contains(v))
        this.setCssAttribute("float", v)
        return this
    }

    float () {
        return this.getCssAttribute("float")
    }

    // box shadow

    setBoxShadow (s) {
        //this.debugLog(".setBoxShadow(" + s + ")")
        this.setCssAttribute("box-shadow", s)
        return this
    }

    boxShadow () {
        return this.getCssAttribute("box-shadow")
    }

    // sizing

    setBoxSizing (s) {
        //this.setBoxSizing("border-box") content-box
        return this.setCssAttribute("box-sizing", s)
    }

    boxSizing () {
        return this.getCssAttribute("box-sizing")
    }


    // border 

    setBorder (s) {
        this.setCssAttribute("border", s)
        return this
    }

    border () {
        return this.getCssAttribute("border")
    }

    // border style

    setBorderStyle (s) {
        this.setCssAttribute("border-style", s)
        return this
    }

    borderStyle () {
        return this.getCssAttribute("border-style")
    }

    // border color

    setBorderColor (s) {
        this.setCssAttribute("border-color", s)
        return this
    }

    borderColor () {
        return this.getCssAttribute("border-color")
    }

    // border top

    setBorderTop (s) {
        this.setCssAttribute("border-top", s)
        return this
    }

    borderTop () {
        return this.getCssAttribute("border-top")
    }

    // border bottom

    setBorderBottom (s) {
        this.setCssAttribute("border-bottom", s)
        return this
    }

    borderBottom () {
        return this.getCssAttribute("border-bottom")
    }

    // border left

    setBorderLeft (s) {
        //this.debugLog(" border-left set '", s, "'")
        this.setCssAttribute("border-left", s)
        return this
    }

    borderLeft () {
        return this.getCssAttribute("border-left")
    }

    // border right

    setBorderRight (s) {
        this.setCssAttribute("border-right", s)
        return this
    }

    borderRight () {
        return this.getCssAttribute("border-right")
    }

    borderRightPx () {
        return this.getPxCssAttribute("border-right")
    }

    // border radius

    setBorderRadius (v) {
        assert(Type.isNull(v) || Type.isString(v))
        this.setCssAttribute("border-radius", v)
        return this
    }

    borderRadius () {
        return this.getCssAttribute("border-radius")
    }

    // border radius

    setBorderRadiusPx (v) {
        assert(Type.isNull(v) || Type.isNumber(v))
        this.setPxCssAttribute("border-radius", v)
        return this
    }

    borderRadiusPx () {
        return this.getPxCssAttribute("border-radius")
    }

    // outline

    setOutline (s) {
        assert(Type.isString(s) || Type.isNull(s))
        this.setCssAttribute("outline", s)
        return this
    }

    outline () {
        return this.getCssAttribute("outline")
    }

    // px line height

    setPxLineHeight (aNumber) {
        this.setPxCssAttribute("line-height", aNumber)
        assert(this.lineHeight() === aNumber)
        return this
    }

    pxLineHeight () {
        return this.getPxCssAttribute("line-height")
    }

    // line height

    setLineHeight (aString) {
        assert(Type.isString(aString) || Type.isNull(aString))
        this.setCssAttribute("line-height", aString)
        return this
    }

    lineHeight () {
        return this.getCssAttribute("line-height")
    }

    // alignment

    setTextAlign (v) {
        assert([null, "left", "right", "center", "justify", "justify-all", "start", "end", "match-parent", "initial", "inherit", "unset"].contains(v))
        this.setCssAttribute("text-align", v)
        return this
    }

    textAlign () {
        return this.getCssAttribute("text-align")
    }

    // clear

    setClear (v) {
        assert([null, "none", "left", "right", "both", "initial", "inherit"].contains(v))
        this.setCssAttribute("clear", v)
        return this
    }

    clear () {
        return this.getCssAttribute("clear")
    }

    // flex 

    setFlex (v) {
        assert(Type.isString(v) || Type.isNull(v))
        this.setCssAttribute("flex", v)
        return this
    }

    flex () {
        return this.getCssAttribute("flex")
    }

    // flex wrap

    setFlexWrap (v) {
        assert(["nowrap", "wrap", "wrap-reverse", "initial", "inherit"].contains(v))
        this.setCssAttribute("flex-wrap", v)
        return this
    }

    flex () {
        return this.getCssAttribute("flex-wrap")
    }

    // flex order

    setOrder (v) {
        assert(Type.isNull(v) || Type.isNumber(v) || ["initial", "inherit"].contains(v))
        this.setCssAttribute("order", v)
        return this
    }

    order () {
        return this.getCssAttribute("order")
    }

    // flex align-items (flex-start, center, flex-end) - NOTE: alignment depends on direct of flex!

    setAlignItems (v) {
        assert([null, "flex-start", "center", "flex-end"].contains(v))
        this.setCssAttribute("align-items", v)
        return this
    }

    alignItems () {
        return this.getCssAttribute("align-items")
    }

    // flex justify-content (flex-start, center, flex-end) - NOTE: alignment depends on direct of flex!
    
    setJustifyContent (v) {
        assert([null, "flex-start", "center", "flex-end"].contains(v))
        this.setCssAttribute("justify-content", v)
        return this
    }

    justifyContent () {
        return this.getCssAttribute("justify-content")
    }

    // flex direction - (row, column)

    setFlexDirection (v) {
        this.setCssAttribute("flex-direction", v)
        return this
    }

    flexDirection () {
        return this.getCssAttribute("flex-direction")
    }

    // flex grow

    setFlexGrow (v) {
        this.setCssAttribute("flex-grow", v)
        return this
    }

    flexGrow () {
        return this.getCssAttribute("flex-grow")
    }

    // flex shrink

    setFlexShrink (v) {
        this.setCssAttribute("flex-shrink", v)
        return this
    }

    flexShrink () {
        return this.getCssAttribute("flex-shrink")
    }

    // flex basis

    setFlexBasis (v) {
        if (Type.isNumber(v)) {
            v = this.pxNumberToString(v)
        }
        this.setCssAttribute("flex-basis", v)
        return this
    }

    flexBasis () {
        return this.getCssAttribute("flex-basis")
    }

    // color

    setColor (v) {
        this.setCssAttribute("color", v)
        return this
    }

    color () {
        return this.getCssAttribute("color")
    }

    // filters

    setFilter (s) {
        this.setCssAttribute("filter", s)
        return this
    }

    filter () {
        return this.getCssAttribute("filter")
    }

    // visibility

    setIsVisible (aBool) {
        const v = aBool ? "visible" : "hidden"
        this.setCssAttribute("visibility", v)
        return this
    }

    isVisible () {
        return this.getCssAttribute("visibility") !== "hidden";
    }

    // display

    setDisplay (s) {
        //assert(s in { "none", ...} );
        this.setCssAttribute("display", s)
        return this
    }

    display () {
        return this.getCssAttribute("display")
    }

    // hide height

    hideHeight () {
		if (Type.isUndefined(this.hiddenMinHeight())) {
            this.setHiddenMinHeight(this.minHeight())
            this.setHiddenMaxHeight(this.maxHeight())
            this.setMinAndMaxHeight("0em")
        }
		return this
	}
	
	unhideHeight() {
		if (!Type.isUndefined(this.hiddenMinHeight())) {
			this.setMinHeight(this.hiddenMaxHeight())
			this.setHiddenMinHeight(undefined)

			this.setMaxHeight(this.hiddenMaxHeight())
			this.setHiddenMaxHeight(undefined)
		}
		
		return this
	}

    // helper for hide/show display

    setDisplayIsHidden (aBool) {
        if (aBool) {
            this.hideDisplay()
        } else {
            this.unhideDisplay()
        }
        return this
    }

    isDisplayHidden () {
        return this.display() === "none"
    }

    hideDisplay () {
        if (this.display() !== "none") {
            this.setHiddenDisplayValue(this.display())
            this.setDisplay("none")
        }
        return this
    }

    unhideDisplay () {
        if (this.display() === "none") {
            if (this._hiddenDisplayValue) {
                this.setDisplay(this.hiddenDisplayValue())
                this.setHiddenDisplayValue(null)
            } else {
                this.setDisplay(null)
                // we don't now what value to set display to, so we have to raise an exception
                //throw new Error(this.type() + " attempt to unhide display value that was not hidden")
            }
        }
        return this
    }

    // visibility

    setVisibility (s) {
        this.setCssAttribute("visibility", s)
        return this
    }

    visibility () {
        return this.getCssAttribute("visibility")
    }

    // white space

    setWhiteSpace (s) {
        this.setCssAttribute("white-space", s)
        return this
    }

    whiteSpace () {
        return this.getCssAttribute("white-space")
    }


    // word-break

    setWordBreak (s) {
        assert(Type.isString(s))
        this.setCssAttribute("word-break", s)
        return this
    }

    wordBreak () {
        return this.getCssAttribute("word-break")
    }

    // webkit specific

    setWebkitOverflowScrolling (s) {
        assert(Type.isString(s))
        this.setCssAttribute("-webkit-overflow-scrolling", s)
        assert(this.webkitOverflowScrolling() === s)
        return this
    }

    webkitOverflowScrolling () {
        return this.getCssAttribute("-webkit-overflow-scrolling")
    }

    // ms specific 

    setMsOverflowStyle (s) {
        /* -ms-overflow-style: none; removes scrollbars on IE 10+  */
        assert(Type.isString(s))
        this.setCssAttribute("-ms-overflow-style", s)
        assert(this.msOverflowStyle() === s)
        return this
    }

    msOverflowStyle () {
        return this.getCssAttribute("-ms-overflow-style")
    }


    // overflow

    setOverflow (s) {
        assert(Type.isString(s))
        this.setCssAttribute("overflow", s)
        return this
    }

    overflow () {
        return this.getCssAttribute("overflow")
    }

    // overflow wrap

    setOverflowWrap (s) {
        assert(Type.isString(s))
        this.setCssAttribute("overflow-wrap", s)
        return this
    }

    overflowWrap () {
        return this.getCssAttribute("overflow-wrap")
    }

    // overflow x

    setOverflowX (s) {
        assert(Type.isString(s))
        this.setCssAttribute("overflow-x", s)
        return this
    }

    overflowX () {
        return this.getCssAttribute("overflow-x")
    }

    // overflow y

    setOverflowY (s) {
        assert(Type.isString(s))
        this.setCssAttribute("overflow-y", s)
        return this
    }

    overflowY () {
        return this.getCssAttribute("overflow-y")
    }



    /*	

    // text over flow

    // Overflow behavior at line end
    // Right end if ltr, left end if rtl 
    text-overflow: clip;
    text-overflow: ellipsis;
    text-overflow: "â€¦";
    text-overflow: fade;
    text-overflow: fade(10px);
    text-overflow: fade(5%);

    // Overflow behavior at left end | at right end
    // Directionality has no influence 
    text-overflow: clip ellipsis;
    text-overflow: "â€¦" "â€¦";
    text-overflow: fade clip;
    text-overflow: fade(10px) fade(10px);
    text-overflow: fade(5%) fade(5%);

    // Global values 
    text-overflow: inherit;
    text-overflow: initial;
    text-overflow: unset;
    */

    setTextOverflow (s) {
        this.setCssAttribute("text-overflow", s)
        return this
    }

    textOverflow () {
        return this.getCssAttribute("text-overflow")
    }

    // user select

    userSelectKeys () {
        return [
            "-moz-user-select",
            "-khtml-user-select",
            "-webkit-user-select",
            "-o-user-select"
        ]
    }

    userSelect () {
        const style = this.cssStyle()
        let result = this.userSelectKeys().detect(key => style[key])
        result = result || style.userSelect
        return result
    }

    turnOffUserSelect () {
        this.setUserSelect("none");
        return this
    }

    turnOnUserSelect () {
        this.setUserSelect("text")
        return this
    }

    // user selection 

    setUserSelect (aString) {
        const style = this.cssStyle()
        //console.log("'" + aString + "' this.userSelect() = '" + this.userSelect() + "' === ", this.userSelect() == aString)
        if (this.userSelect() !== aString) {
            style.userSelect = aString
            this.userSelectKeys().forEach(key => style[key] = aString)
        }
        return this
    }

    // spell check

    setSpellCheck (aBool) {
        this.element().setAttribute("spellcheck", aBool);
        return this
    }

    // tool tip

    setToolTip (aName) {
        if (aName) {
            this.element().setAttribute("title", aName);
        } else {
            this.element().removeAttribute("title");
        }
        return this
    }

    // width and height

    computedWidth () {
        const w = this.getComputedPxCssAttribute("width")
        return w
    }

    computedHeight () {
        const h = this.getComputedPxCssAttribute("height")
        return h
    }

    // desired size

    desiredWidth () {
        return this.calcCssWidth()
    }

    desiredHeight () {
        return this.calcCssHeight()
    }

    // calculated CSS size (outside of parent view)

    calcCssWidth () {
        return DomTextTapeMeasure.shared().sizeOfCSSClassWithText(this.divClassName(), this.innerHTML()).width;
    }

    calcCssHeight () {
        return DomTextTapeMeasure.shared().sizeOfCSSClassWithText(this.element(), this.innerHTML()).height;
    }

    // calculated size (within parent view)

    calcWidth () {
        return DomTextTapeMeasure.shared().sizeOfElementWithText(this.element(), this.innerHTML()).width;
    }

    calcHeight () {
        return DomTextTapeMeasure.shared().sizeOfElementWithText(this.element(), this.innerHTML()).height;
    }

    // width

    setWidthString (v) {
        assert(Type.isString(v) || Type.isNull(v))
        this.setCssAttribute("width", v, () => { this.didChangeWidth() })
        return this
    }

    setWidth (s) {
        this.setWidthString(s)
        return this
    }

    setWidthPercentage (aNumber) {
        const newValue = this.percentageNumberToString(aNumber)
        this.setCssAttribute("width", newValue, () => { this.didChangeWidth() })
        return this
    }

    /*
    hideScrollbar () {
        // need to do JS equivalent of: .class::-webkit-scrollbar { display: none; }
	    // this.setCssAttribute("-webkit-scrollbar", { display: "none" }) // doesn't work
	    return this
    }
    */

    // clientX - includes padding but not scrollbar, border, or margin

    clientWidth () {
        return this.element().clientWidth
    }

    clientHeight () {
        return this.element().clientHeight
    }

    // offsetX - includes borders, padding, scrollbar 

    offsetWidth () {
        return this.element().offsetWidth
    }

    offsetHeight () {
        return this.element().offsetHeight
    }

    // width px

    minWidthPx () {
        const s = this.getCssAttribute("min-width")
        // TODO: support em to px translation 
        return this.pxStringToNumber(s)
    }

    maxWidthPx () {
        const w = this.getCssAttribute("max-width")
        if (w === "") {
            return null
        }
        return this.pxStringToNumber(w)
    }

    // height px

    minHeightPx () {
        const s = this.getCssAttribute("min-height")
        // TODO: support em to px translation 
        return this.pxStringToNumber(s)
    }

    maxHeightPx () {
        const s = this.getCssAttribute("max-height")
        if (s === "") {
            return null
        }
        return this.pxStringToNumber(s)
    }

    // -----------

    cssStyle () {
        return this.element().style
    }

    setMinWidth (v) {
        if (Type.isNumber(v)) {
            v = this.pxNumberToString(v)
        }
        this.setCssAttribute("min-width", v, () => { this.didChangeWidth() })
        return this
    }

    didChangeWidth () {
    }

    didChangeHeight () {
    }

    // --- lock/unlock size ---

    /*
    lockSize () {
        const h = this.computedHeight() 
        const w = this.computedWidth()
        this.setMinAndMaxWidth(w)
        this.setMinAndMaxHeight(h)
        return this
    }

    unlockSize () {
        this.setMinAndMaxWidth(null)
        this.setMinAndMaxHeight(null)
        return this
    }
    */

    // ----

    displayIsFlex () {
        // TODO: choose a better name for this method?
        return (this.display() === "flex" || this.hiddenDisplayValue() === "flex")
    }

    // fixed width

    /*
    setFixedWidthPx (v) {
        assert(Type.isNumber(v))
        if (this.displayIsFlex()) {
            this.setFlexGrow(0)
            this.setFlexShrink(0)
            this.setFlexBasis(v + "px")
        } else {
            this.setMinAndMaxWidth(v)
        }
        return this
    }

    fixedWidthPx () {
        if (this.displayIsFlex()) {
            const w = this.getPxCssAttribute("flex-basis")
            assert(Type.isNumber(w))
            return w
        } else {
            const w1 = this.getPxCssAttribute("min-width")
            const w2 = this.getPxCssAttribute("max-width")
            assert(Type.isNumber(w1) && w1 === w2)
            return w1
        }
    }
    */

    // fixed height
    /*
    setFixedHeightPx (v) {
        assert(Type.isNumber(v))
        if (this.displayIsFlex()) {
            this.setFlexGrow(0)
            this.setFlexShrink(0)
            this.setFlexBasis(v + "px")
        } else {
            this.setMinAndMaxWidth(v)
        }
        return this
    }

    fixedHeightPx () {
        if (this.displayIsFlex()) {
            const w = this.getPxCssAttribute("flex-basis")
            assert(Type.isNumber(w))
            return w
        } else {
            const w1 = this.getPxCssAttribute("min-width")
            const w2 = this.getPxCssAttribute("max-width")
            assert(Type.isNumber(w1) && w1 === w2)
            return w1
        }
    }
    */

    // ----

    setMinAndMaxSize (aSize) {
        this.setMinAndMaxWidth(aSize.x())
        this.setMinAndMaxHeight(aSize.y())
        return this
    }

    setMaxWidth (v) {
        if (Type.isNumber(v)) {
            v = this.pxNumberToString(v)
        }
        this.setCssAttribute("max-width", v, () => { this.didChangeWidth() })
        return this
    }

    setMinAndMaxWidth (v) {
        if (Type.isNumber(v)) {
            v = this.pxNumberToString(v)
        }
        this.setCssAttribute("max-width", v, () => { this.didChangeWidth() })
        this.setCssAttribute("min-width", v, () => { this.didChangeWidth() })
        return this
    }

    setMinAndMaxHeight (v) {
        if (Type.isNumber(v)) {
            v = this.pxNumberToString(v)
        }
        this.setCssAttribute("min-height", v, () => { this.didChangeHeight() })
        this.setCssAttribute("max-height", v, () => { this.didChangeHeight() })
        return this
    }

    setMinAndMaxWidthAndHeight (v) {
        this.setMinAndMaxWidth(v)
        this.setMinAndMaxHeight(v)
        return this
    }


    percentageNumberToString (aNumber) {
        assert(Type.isNumber(aNumber) && (aNumber >= 0) && (aNumber <= 100))
        return aNumber + "%"
    }

    pxNumberToString (aNumber) {
        if (Type.isNull(aNumber)) {
            return null
        }

        if (Type.isString(aNumber)) {
            if (aNumber.beginsWith("calc") || aNumber.endsWith("px")) {
                return aNumber
            }
        }

        assert(Type.isNumber(aNumber))
        return aNumber + "px"
    }

    pxStringToNumber (s) {
        assert(Type.isString(s))
        
        if (s === "") {
            return 0
        }
        
        if (s === "auto") {
            return 0
        }

        if (s.contains("%")) {
            return 0
        }

        assert(s.endsWith("px"))
        return Number(s.replace("px", ""))
    }

    setMinAndMaxHeightPercentage (aNumber) {
        const newValue = this.percentageNumberToString(aNumber)
        this.setCssAttribute("min-height", newValue, () => { this.didChangeHeight() })
        this.setCssAttribute("max-height", newValue, () => { this.didChangeHeight() })
        return this
    }

    setHeightPercentage (aNumber) {
        const newValue = this.percentageNumberToString(aNumber)
        this.setHeightString(newValue)
        return this
    }

    setMinWidthPx (aNumber) {
        this.setMinWidth(this.pxNumberToString(aNumber))
        return this
    }

    setMinHeightPx (aNumber) {
        this.setMinHeight(this.pxNumberToString(aNumber))
        return this
    }

    setMaxHeightPx (aNumber) {
        this.setMaxHeight(this.pxNumberToString(aNumber))
        return this
    }

    maxHeight () {
        return this.getCssAttribute("max-height")
    }

    minHeight () {
        return this.getCssAttribute("min-height")
    }

    maxWidth () {
        return this.getCssAttribute("max-width")
    }

    minWidth () {
        return this.getCssAttribute("min-width")
    }

    setMinHeight (newValue) {
        assert(Type.isString(newValue) || Type.isNull(newValue))
        // <length> | <percentage> | auto | max-content | min-content | fit-content | fill-available
        this.setCssAttribute("min-height", newValue, () => { this.didChangeHeight() })
        return this
    }

    setMaxHeight (newValue) {
        assert(Type.isString(newValue) || Type.isNull(newValue))
        // <length> | <percentage> | none | max-content | min-content | fit-content | fill-available
        this.setCssAttribute("max-height", newValue, () => { this.didChangeHeight() })
        return this
    }

    setWidthPx (aNumber) {
        this.setWidthString(this.pxNumberToString(aNumber))
        return this
    }

    setHeightPx (aNumber) {
        this.setHeightString(this.pxNumberToString(aNumber))
        return this
    }

    setHeight (s) {
        // height: auto|length|initial|inherit;

        if (Type.isNumber(s)) {
            return this.setHeightPx(s)
        }
        this.setHeightString(s)
        return this
    }

    setWidthToAuto () {
        this.setWidthString("auto")
        return this
    }

    setHeightToAuto () {
        this.setHeightString("auto")
        return this
    }

    setHeightString (s) {
        assert(Type.isString(s) || Type.isNull(s))
        this.setCssAttribute("height", s, () => { this.didChangeHeight() })
        return this
    }

    height () {
        return this.getCssAttribute("height")
    }

    // --- div class name ---

    setDivClassName (aName) {
        if (this._divClassName !== aName) {
            this._divClassName = aName
            if (this.element()) {
                this.element().setAttribute("class", aName);
            }
        }
        return this
    }

    divClassName () {
        if (this.element()) {
            const className = this.element().getAttribute("class");
            this._divClassName = className
            return className
        }
        return this._divClassName
    }

    // --- parentView ---

    setParentView (aView) {
        if (this._parentView !== aView) {
            this._parentView = aView
            this.didChangeParentView()
        }
        return this
    }

    hasParentView () {
        return Type.isNullOrUndefined(this.parentView()) === false
    }

    didChangeParentView () {
        return this
    }

    // view chains

    parentViewChain () {
        // returned list in order of very top parent first
        const chain = []
        let p = this.parentView()
        while (p) {
            chain.push(p)
            p = p.parentView()
        }
        return chain.reversed()
    }

    parentViewsOfClass (aClass) {
        return this.parentViewChain().filter(v => v.thisClass().isSubclassOf(aClass))
    }

    // --- subviews ---


    subviewCount () {
        return this.subviews().length
    }

    hasSubview (aSubview) {
        return this.subviews().contains(aSubview)
    }

    addSubviewIfAbsent (aSubview) {
        if (!this.hasSubview(aSubview)) {
            this.addSubview(aSubview)
        }
        return this
    }

    addSubview (aSubview) {
        assert(!Type.isNullOrUndefined(aSubview)) 
        assert(!Type.isNullOrUndefined(aSubview.element())) 

        if (this.hasSubview(aSubview)) {
            throw new Error(this.type() + ".addSubview(" + aSubview.type() + ") attempt to add duplicate subview ")
        }

        assert(Type.isNullOrUndefined(aSubview.parentView()))
        /*
        if (aSubview.parentView()) {
            aSubview.removeFromParent()
        }
        */

        this.willAddSubview(aSubview)
        this.subviews().append(aSubview)

        this.element().appendChild(aSubview.element());
        aSubview.setParentView(this)
        this.didChangeSubviewList()
        return aSubview
    }

    addSubviews (someSubviews) {
        someSubviews.forEach(sv => this.addSubview(sv))
        return this
    }

    swapSubviews (sv1, sv2) {
        assert(sv1 !== sv2)
        assert(this.hasSubview(sv1))
        assert(this.hasSubview(sv2))
        
        const i1 = this.indexOfSubview(sv1)
        const i2 = this.indexOfSubview(sv2)

        this.removeSubview(sv1)
        this.removeSubview(sv2)

        if (i1 < i2) {
            this.atInsertSubview(i1, sv2) // i1 is smaller, so do it first
            this.atInsertSubview(i2, sv1)
        } else {
            this.atInsertSubview(i2, sv1) // i2 is smaller, so do it first          
            this.atInsertSubview(i1, sv2)
        }

        assert(this.indexOfSubview(sv1) === i2)
        assert(this.indexOfSubview(sv2) === i1)

        return this
    }

    orderSubviewFront (aSubview) {
        if (this.subviews().last() !== aSubview) {
            this.removeSubview(aSubview)
            this.addSubview(aSubview)
        }
        return this
    }

    orderFront () {
        const pv = this.parentView()
        if (pv) {
            pv.orderSubviewFront(this)
        }
        return this
    }

    orderSubviewBack (aSubview) {
        this.removeSubview(aSubview)
        this.atInsertSubview(0, aSubview)
        return this
    }

    orderBack () {
        const pv = this.parentView()
        if (pv) {
            pv.orderSubviewBack(this)
        }
        return this
    }

    replaceSubviewWith (oldSubview, newSubview) {
        assert(this.hasSubview(oldSubview))
        assert(!this.hasSubview(newSubview))
        
        const index = this.indexOfSubview(oldSubview)
        this.removeSubview(oldSubview)
        this.atInsertSubview(index, newSubview)

        assert(this.indexOfSubview(newSubview) === index)
        assert(this.hasSubview(newSubview))
        assert(!this.hasSubview(oldSubview))
        return this
    }

    atInsertSubview (anIndex, aSubview) {
        this.subviews().atInsert(anIndex, aSubview)
        assert(this.subviews()[anIndex] === aSubview)

        DomElement_atInsertElement(this.element(), anIndex, aSubview.element())
        assert(this.element().childNodes[anIndex] === aSubview.element())

        aSubview.setParentView(this) // TODO: unify with addSubview
        this.didChangeSubviewList() // TODO:  unify with addSubview
        return aSubview
    }

    moveSubviewToIndex (aSubview, i) {
        assert(i < this.subviews().length)
        assert(this.subviews().contains(aSubview))

        if (this.subviews()[i] !== aSubview) {
            this.removeSubview(aSubview)
            this.atInsertSubview(i, aSubview)
        }
        return this
    }

    updateSubviewsToOrder (orderedSubviews) {
        assert(this.subviews() !== orderedSubviews)
        assert(this.subviews().length === orderedSubviews.length)

        for (let i = 0; i < this.subviews().length; i ++) {
            const v2 = orderedSubviews[i]
            this.moveSubviewToIndex(v2, i)
        }
        
        return this
    }

    // --- subview utilities ---

    sumOfSubviewHeights () {
        return this.subviews().sum(subview => subview.clientHeight())
    }

    performOnSubviewsExcept (methodName, exceptedSubview) {
        this.subviews().forEach(subview => {
            if (subview !== exceptedSubview) {
                subview[methodName].apply(subview)
            }
        })

        return this
    }

    // --- animations ---

    animateToDocumentFrame (destinationFrame, seconds, completionCallback) {
        this.setTransition("all " + seconds + "s")
        assert(this.position() === "absolute")
        this.addTimeout(() => {
            this.setTopPx(destinationFrame.origin().y())
            this.setLeftPx(destinationFrame.origin().x())
            this.setMinAndMaxWidth(destinationFrame.size().width())
            this.setMinAndMaxHeight(destinationFrame.size().height())
        }, 0)

        this.addTimeout(() => {
            completionCallback()
        }, seconds * 1000)
        return this
    }

    animateToDocumentPoint (destinationPoint, seconds, completionCallback) {
        this.setTransition("all " + seconds + "s")
        assert(this.position() === "absolute")
        this.addTimeout(() => {
            this.setTopPx(destinationPoint.y())
            this.setLeftPx(destinationPoint.x())
        }, 0)

        this.addTimeout(() => {
            completionCallback()
        }, seconds * 1000)
        return this
    }

    hideAndFadeIn () {
        this.setOpacity(0)
        this.setTransition("all 0.5s")
        this.addTimeout(() => {
            this.setOpacity(1)
        }, 0)
    }

    fadeInToDisplayInlineBlock () {
        this.transitions().at("opacity").updateDuration("0.3s")
        this.setDisplay("inline-block")
        this.setOpacity(0)
        this.addTimeout(() => {
            this.setOpacity(1)
        }, 0)
        return this
    }

    fadeOutToDisplayNone () {
        this.transitions().at("opacity").updateDuration("0.3s")
        this.setOpacity(0)
        this.addTimeout(() => {
            this.setDisplay("none")
        }, 200)
        return this
    }

    // --- fade + height animations ----

    fadeInHeightToDisplayBlock () {
        this.setMinHeight("100%")
        this.setMaxHeight("100%")
        const targetHeight = this.calcHeight()

        this.setOverflow("hidden")
        this.transitions().at("opacity").updateDuration("0.3s")
        this.transitions().at("min-height").updateDuration("0.2s")
        this.transitions().at("max-height").updateDuration("0.2s")

        this.setDisplay("block")
        this.setOpacity(0)
        this.setMinAndMaxHeight(0)

        this.addTimeout(() => {
            this.setOpacity(1)
            this.setMinAndMaxHeight(targetHeight)
        }, 0)
        return this
    }

    fadeOutHeightToDisplayNone () {
        this.setOverflow("hidden")
        this.transitions().at("opacity").updateDuration("0.2s")
        this.transitions().at("min-height").updateDuration("0.3s")
        this.transitions().at("max-height").updateDuration("0.3s")

        this.addTimeout(() => {
            this.setOpacity(0)
            this.setMinAndMaxHeight(0)
        }, 1)

        /*
        this.addTimeout(() => {
            this.setDisplay("none")
        }, 300)
        */
        return this
    }

    // -----------------------

    removeFromParentView () {
        this.parentView().removeSubview(this)
        return this
    }

    removeAfterFadeDelay (delayInSeconds) {
        // call removeSubview for a direct actions
        // use justRemoteSubview for internal changes

        this.setTransition("all " + delayInSeconds + "s")

        this.addTimeout(() => {
            this.setOpacity(0)
        }, 0)

        this.addTimeout(() => {
            this.parentView().removeSubview(this)
        }, delayInSeconds * 1000)

        return this
    }

    willRemove () {
    }

    didChangeSubviewList () {
    }

    hasSubview (aSubview) {
        return this.subviews().indexOf(aSubview) !== -1;
    }

    hasChildElement (anElement) {
        const children = this.element().childNodes
        for (let i = 0; i < children.length; i++) {
            const child = children[i]
            if (anElement === child) {
                return true
            }
        }
        return false
    }

    willAddSubview (aSubview) {
        // for subclasses to over-ride
    }

    willRemoveSubview (aSubview) {
        // for subclasses to over-ride
    }

    removeSubviewIfPresent (aSubview) {
        if (this.hasSubview(aSubview)) {
            this.removeSubview(aSubview)
        }
        return this
    }

    removeSubview (aSubview) {
        //console.warn("WARNING: " + this.type() + " removeSubview " + aSubview.type())

        if (!this.hasSubview(aSubview)) {
            console.warn(this.type() + " removeSubview " + aSubview.typeId() + " failed - no child found among: ", this.subviews().map(view => view.typeId()))
            Error.showCurrentStack()
            return aSubview
        }

        this.willRemoveSubview(aSubview)
        aSubview.willRemove()

        this.subviews().remove(aSubview)

        // sanity check 

        const e = aSubview.element()
        if (this.hasChildElement(e)) {
            this.element().removeChild(e);

            if (this.hasChildElement(e)) {
                console.warn("WARNING: " + this.type() + " removeSubview " + aSubview.type() + " failed - still has element after remove")
                Error.showCurrentStack()
            }
        } else {
            //console.warn("WARNING: " + this.type() + " removeSubview " + aSubview.type() + " parent element is missing this child element")
        }
 

        aSubview.setParentView(null)
        this.didChangeSubviewList()
        return aSubview
    }

    removeAllSubviews () {
        //const sv = this.subviews().shallowCopy()
        //sv.forEach(subview => this.removeSubview(subview))
        while(this.subviews().length) {
            this.removeSubview(this.subviews().last())
        }
        assert(this.subviews().length === 0)
        return this
    }

    indexOfSubview (aSubview) {
        return this.subviews().indexOf(aSubview)
    }

    subviewAfter (aSubview) {
        const index = this.indexOfSubview(aSubview)
        const nextIndex = index + 1
        if (nextIndex < this.subviews().length) {
            return this.subviews()[nextIndex]
        }
        return null
    }

    sendAllViewDecendants (methodName, argList) {
        this.subviews().forEach((v) => {
            v[methodName].apply(v, argList)
            v.sendAllViewDecendants(methodName, argList)
        })
        return this
    }

    // --- active element ---

    isActiveElement () {
        return document.activeElement === this.element()
    }

    isActiveElementAndEditable () {
        return this.isActiveElement() && this.contentEditable()
    }

    isFocused () {
        return this.isActiveElement()
    }

    // --- inner html ---

    setInnerHTML (v) {
        const oldValue = this.element().innerHTML

        if (v === null) {
            v = ""
        }

        v = "" + v

        if (v === oldValue) {
            return this
        }

        const isFocused = this.isActiveElementAndEditable()

        if (isFocused) {
            this.blur()
            const savedSelection = this.saveSelection()
            this.element().innerHTML = v
            savedSelection.collapse()
            this.restoreSelection(savedSelection)
            this.focus()
        } else {
            this.element().innerHTML = v
        }

        return this
    }

    innerHTML () {
        return this.element().innerHTML
    }

    setString (v) {
        return this.setInnerHTML(v)
    }

    string () {
        return this.innerHTML()
    }

    loremIpsum (maxWordCount) {
        this.setInnerHTML("".loremIpsum(10, 40))
        return this
    }

    // --- updates ---

    tellParentViews (msg, aView) {
        const f = this[msg]
        if (f) {
            const r = f.apply(this, [aView]) 
            if (r === true) {
                return // stop propogation on first view returning non-false
            }
        }

        const p = this.parentView()
        if (p) {
            p.tellParentViews(msg, aView)
        }
    }

    askParentViews (msg, aView) {
        const f = this[msg]
        if (f) {
            const r = f.call(this, aView)
            return r
        }

        const p = this.parentView()
        if (p) {
            return p.getParentViewMethod(msg, aView)
        }

        return undefined
    }

    firstParentViewWithAncestorClass (aClass) {
        const p = this.parentView()
        if (p) {
            if (p.isSubclassOf(aClass)) {
                return p
            }
            return p.firstParentViewWithAncestorClass(aClass)
        }
        return undefined
    }

    // --- events --------------------------------------------------------------------

    // --- event listeners ---

    listenerNamed (className) {
        const dict = this.eventListenersDict()
        if (!dict[className]) {
            assert(className in window)
            const proto = window[className]
            dict[className] = proto.clone().setListenTarget(this.element()).setDelegate(this)
        }
        return dict[className]
    }

    clipboardListener () {
        return this.listenerNamed("ClipboardListener")
    }

    documentListener () {
        return this.listenerNamed("DocumentListener") // listen target will be the window
    }

    browserDragListener () {
        return this.listenerNamed("DragListener")
    }

    dropListener () {
        return this.listenerNamed("DropListener")
    }

    focusListener () {
        return this.listenerNamed("FocusListener")
    }

    mouseListener () {
        return this.listenerNamed("MouseListener")
    }

    keyboardListener () {
        return this.listenerNamed("KeyboardListener")
    }

    touchListener () {
        return this.listenerNamed("TouchListener")
    }

    // ---


    // --- window resize events ---

    isRegisteredForDocumentResize () {
        return this.documentListener().isListening()
    }

    setIsRegisteredForDocumentResize (aBool) {
        this.documentListener().setIsListening(aBool)
        return this
    }

    onDocumentResize (event) {
        return true
    }

    // --- onClick event, target & action ---

    isRegisteredForClicks () {
        return this.mouseListener().isListening()
    }

    setIsRegisteredForClicks (aBool) {
        this.mouseListener().setIsListening(aBool)

        if (aBool) {
            this.makeCursorPointer()
        } else {
            this.makeCursorDefault()
        }

        return this
    }

    hasTargetAndAction () {
        return (this.target() !== null) && (this.action() !== null)
    }

    setTarget (anObject) {
        this._target = anObject
        this.setIsRegisteredForClicks(this.hasTargetAndAction())
        return this
    }

    setAction (anActionString) {
        this._action = anActionString
        this.setIsRegisteredForClicks(this.hasTargetAndAction())
        return this
    }

    onClick (event) {
        this.debugLog(".onClick()")
        this.sendActionToTarget()
        event.stopPropagation()
        return false
    }

    sendActionToTarget () {
        if (!this.action()) {
            return null
        }

        const t = this.target()
        if (!t) {
            throw new Error("no target for action " + this.action())
        }

        const method = t[this.action()]
        if (!method) {
            throw new Error("no target for action " + this.action())
        }

        return method.apply(t, [this])
    }

    onDoubleClick (event) {
        return true
    }

    // -- browser dropping ---

    isRegisteredForBrowserDrop () {
        return this.dropListener().isListening()
    }

    setIsRegisteredForBrowserDrop (aBool) {
        this.dropListener().setIsListening(aBool)
        return this
    }

    acceptsDrop () {
        return true
    }

    // ---------------------

    onBrowserDragEnter (event) {
        // triggered on drop target
        //console.log("onBrowserDragEnter acceptsDrop: ", this.acceptsDrop());
        event.preventDefault() // needed?

        if (this.acceptsDrop(event)) {
            this.onBrowserDragOverAccept(event)
            return true
        }

        return false;
    }

    onBrowserDragOver (event) {
        // triggered on drop target
        //console.log("onBrowserDragOver acceptsDrop: ", this.acceptsDrop(event), " event:", event);

        event.preventDefault()

        if (this.acceptsDrop(event)) {
            event.dataTransfer.dropEffect = "copy";
            event.dataTransfer.effectAllowed = "copy";
            this.onBrowserDragOverAccept(event)
            return true
        }

        return false;
    }

    onBrowserDragOverAccept (event) {
        //console.log("onBrowserDragOverAccept ");
        this.dragHighlight()
    }

    onBrowserDragLeave (event) {
        // triggered on drop target
        //console.log("onBrowserDragLeave ", this.acceptsDrop(event));
        this.dragUnhighlight()
        return this.acceptsDrop(event);
    }

    dragHighlight () {

    }

    dragUnhighlight () {

    }

    onBrowserDrop (event) {
        if (this.acceptsDrop(event)) {
            //const file = event.dataTransfer.files[0];
            //console.log('onDrop ' + file.path);
            this.onBrowserDataTransfer(event.dataTransfer)
            this.dragUnhighlight()
            event.preventDefault();
            event.stopPropagation()
            return true;
        }
        event.preventDefault();
        return false
    }

    dropMethodForMimeType (mimeType) {
        let s = mimeType.replaceAll("/", " ")
        s = s.replaceAll("-", " ")
        s = s.capitalizeWords()
        s = s.replaceAll(" ", "")
        return "onBrowserDrop" + s
    }

    onBrowserDataTransfer (dataTransfer) {
        // TODO: we need a way to avoid handling the same item twice...

        if (dataTransfer.files.length) {
            for (let i = 0; i < dataTransfer.files.length; i++) {
                const file = dataTransfer.files[i]
                this.onBrowserDropFile(file)
            }
        } else if (dataTransfer.items) {
            let data = dataTransfer.items

            let dataTransferItems = []
            for (let i = 0; i < data.length; i++) {
                dataTransferItems.push(data[i])
            }

            dataTransferItems = dataTransferItems.reversed()

            for (let i = 0; i < dataTransferItems.length; i++) {
                const dataTransferItem = dataTransferItems[i]
                const mimeType = dataTransferItem.type

                // Example MIME types: 
                // text/plain, text/html, text/uri-list

                if (mimeType) {
                    dataTransferItem.getAsString((s) => {
                        const chunk = BMDataUrl.clone()
                        chunk.setMimeType(mimeType)
                        chunk.setDecodedData(s)
                        console.log("mimeType:", mimeType)
                        console.log("    data:", s)
                        this.onBrowserDropChunk(chunk)
                    })
                }
                break; // only send the first MIME type for now
            }
        }
    }

    onBrowserDropFile (file) {
        const mimeType = file.type
        const reader = new FileReader();
        reader.onload = (event) => {
            const data = event.target.result
            this.onBrowserDropMimeTypeAndRawData(mimeType, data)
        }
        reader.readAsDataURL(file);
    }

    onBrowserDropMimeTypeAndRawData (mimeType, dataUrl) {
        const dd = BMDataUrl.clone().setDataUrlString(dataUrl)
        this.onBrowserDropChunk(dd)
    }

    onBrowserDropChunk (dataChunk) {
        // if the view has a method for the mime type of the file
        // e.g. onBrowserDropImageJpeg
        // then we call it. If the view wants to handle all types,
        // it can override this method.

        const methodName = this.dropMethodForMimeType(dataChunk.mimeType())
        const method = this[methodName]
        console.log("onBrowserDropFile => ", methodName)

        if (method) {
            method.apply(this, [dataChunk])
        }
    }

    // browser dragging

    setDraggable (aBool) {
        assert(Type.isBoolean(aBool))
        this.element().setAttribute("draggable", aBool)
        return this
    }

    draggable () {
        return this.element().getAttribute("draggable")
    }

    isRegisteredForBrowserDrag () {
        return this.browserDragListener().isListening()
    }

    setIsRegisteredForBrowserDrag (aBool) {
        this.browserDragListener().setIsListening(aBool)
        this.setDraggable(aBool)
        return this
    }

    onBrowserDragStart (event) {
        return false;
    }

    onBrowserDragEnd (event) {
        // triggered in element being dragged
        this.dragUnhighlight();
        //console.log("onDragEnd");
    }

    // --- editing - abstracted from content editable for use in non text views ---

    setIsEditable (aBool) {
        // subclasses can override for non text editing behaviors e.g. a checkbox, toggle switch, etc
        this.setContentEditable(aBool)
        return this
    }

    isEditable () {
        return this.isContentEditable()
    }

    // --- content editing ---

    setContentEditable (aBool) {
        //console.log(this.divClassName() + " setContentEditable(" + aBool + ")")
        if (aBool) {
            this.makeCursorText()
            //this.element().ondblclick = (event) => { this.selectAll();	}
        } else {
            this.element().ondblclick = null
        }

        this.element().contentEditable = aBool ? "true" : "false"

        /*
        if (this.showsHaloWhenEditable()) {
            this.setBoxShadow(aBool ? "0px 0px 5px #ddd" : "none")
        }
        */

        //this.element().style.hideFocus = true
        this.element().style.outline = "none"

        this.setIsRegisteredForKeyboard(aBool)

        if (aBool) {
            this.turnOnUserSelect()
        }

        this.setIsRegisteredForClipboard(aBool)

        return this
    }

    isContentEditable () { // there's a separate method for contentEditable() that just accesses element attribute
        //const v = window.getComputedStyle(this.element(), null).getPropertyValue("contentEditable");
        const s = this.element().contentEditable
        if (s === "inherit" && this.parentView()) {
            return this.parentView().isContentEditable()
        }
        const aBool = (s === "true" || s === true)
        return aBool
    }

    contentEditable () {
        return this.element().contentEditable === "true"
    }

    // touch events

    setTouchAction (s) {
        this.setCssAttribute("-ms-touch-action", s) // needed?
        this.setCssAttribute("touch-action", s)
        return this
    }

    isRegisteredForTouch () {
        return this.touchListener().isListening()
    }

    setIsRegisteredForTouch (aBool) {
        this.touchListener().setIsListening(aBool)

        if (aBool) {
            this.setTouchAction("none") // testing
        }

        return this
    }

    onTouchStart (event) {
        //this.onPointsStart(points)
    }

    onTouchMove (event) {
        //this.onPointsMove(points)
    }

    onTouchCancel (event) {
        //this.onPointsCancel(points)
    }

    onTouchEnd (event) {
        //this.onPointsEnd(points)
    }

    /// GestureRecognizers

    hasGestureType (typeName) {
        return this.gesturesOfType(typeName).length > 0
    }

    hasGestureRecognizer (gr) {
        return this.gestureRecognizers().contains(gr)
    }

    addGestureRecognizerIfAbsent (gr) {
        if (!this.hasGestureRecognizer(gr)) {
            this.addGestureRecognizer(gr)
        }
        return this
    }

    addGestureRecognizer (gr) {
        assert(!this.hasGestureRecognizer(gr))
        this.gestureRecognizers().append(gr)
        gr.setViewTarget(this)
        gr.start()
        return gr
    }

    removeGestureRecognizer (gr) {
        if (this.gestureRecognizers()) {
            gr.stop()
            gr.setViewTarget(null)
            this.gestureRecognizers().remove(gr)
        }
        return this
    }

    gesturesOfType (typeName) {
        return this.gestureRecognizers().select(gr => gr.type() == typeName)
    }

    removeGestureRecognizersOfType (typeName) {
        if (this.gestureRecognizers()) {
            this.gestureRecognizers().select(gr => gr.type() == typeName).forEach(gr => this.removeGestureRecognizer(gr))
        }
        return this
    }

    removeAllGestureRecognizers () {
        this.gestureRecognizers().forEach(gr => this.removeGestureRecognizer(gr))
        return this
    }

    // default tap gesture

    addDefaultTapGesture () {
        if (!this.defaultTapGesture()) {
            this.setDefaultTapGesture( this.addGestureRecognizer(TapGestureRecognizer.clone()) )
        }
        return this.defaultTapGesture()
    }

    removeDefaultTapGesture () {
        if (this.defaultTapGesture()) {
            this.removeGestureRecognizer(this.defaultTapGesture())
            this.setDefaultTapGesture(null)
        }
        return this
    }

    // double tap gesture

    newDoubleTapGestureRecognizer () { // private
        const tg = TapGestureRecognizer.clone()
        tg.setNumberOfTapsRequired(2)
        tg.setNumberOfFingersRequired(1)
        tg.setGestureName("DoubleTap")
        //tg.setCompleteMessage("onDoubleTapComplete")
        //tg.setIsDebugging(true)
        return tg
    }

    addDefaultDoubleTapGesture () { 
        if (!this.defaultDoubleTapGesture()) {
            const gr = this.newDoubleTapGestureRecognizer()
            this.setDefaultDoubleTapGesture(gr)
            this.addGestureRecognizer(gr)
        }
        return this.defaultDoubleTapGesture()
    }

    removeDefaultDoubleTapGesture () { 
        if (this.defaultDoubleTapGesture()) {
            this.removeGestureRecognizer(this.defaultDoubleTapGesture())
            this.setDefaultDoubleTapGesture(null)
        }
        return this
    }

    // default pan gesture

    addDefaultPanGesture () {
        if (!this._defaultPanGesture) {
            this._defaultPanGesture = this.addGestureRecognizer(PanGestureRecognizer.clone()) 
        }
        return this._defaultPanGesture
    }

    defaultPanGesture () {
        return this._defaultPanGesture
    }

    removeDefaultPanGesture () {
        if (this._defaultPanGesture) {
            this.removeGestureRecognizer(this._defaultPanGesture)
            this._defaultPanGesture = null
        }
        return this
    }

    // orient testing

    /*
    onOrientBegin (aGesture) {
        this.debugLog(".onOrientBegin()")
        aGesture.show()
    }

    onOrientMove (aGesture) {
        this.debugLog(".onOrientMove()")
        aGesture.show()
    }

    onOrientComplete (aGesture) {
        this.debugLog(".onOrientComplete()")
        aGesture.show()
    }
    */

    cancelAllGesturesExcept (aGesture) {
        this.gestureRecognizers().forEach((gr) => {
            //if (gr.type() !== aGesture.type()) {
            if (gr !== aGesture) {
                gr.cancel()
            }
        })
        return this
    }

    // --- mouse events ---

    isRegisteredForMouse () {
        return this.mouseListener().isListening()
    }

    setIsRegisteredForMouse (aBool, useCapture) {
        this.mouseListener().setUseCapture(useCapture).setIsListening(aBool) //.setIsDebugging(true)
        return this
    }

    onMouseMove (event) {
        return true
    }

    onMouseOver (event) {
        return true
    }

    onMouseLeave (event) {
        return true
    }

    onMouseOver (event) {
        return true
    }

    onMouseDown (event) {
        const methodName = Mouse.shared().downMethodNameForEvent(event)
        if (methodName !== "onMouseDown") {
            this.debugLog(".onMouseDown calling: ", methodName)
            this.invokeMethodNameForEvent(methodName, event)
        }
        return true
    }

    onMouseUp (event) {
        const methodName = Mouse.shared().upMethodNameForEvent(event)
        if (methodName !== "onMouseUp") {
            this.debugLog(".onMouseUp calling: ", methodName)
            this.invokeMethodNameForEvent(methodName, event)
        }
        return true
    }

    // --- keyboard events ---

    isRegisteredForKeyboard () {
        return this.keyboardListener().isListening()
    }

    setIsRegisteredForKeyboard (aBool, useCapture) {
        this.keyboardListener().setUseCapture(useCapture).setIsListening(aBool)

        const e = this.element()
        if (aBool) {
            DomView._tabCount++
            e.tabIndex = DomView._tabCount // need this in order for focus to work on BrowserColumn?
            //this.setCssAttribute("outline", "none"); // needed?
        } else {
            delete e.tabindex
        }

        return this
    }

    /*
    onEnterKeyDown (event) {
        this.debugLog(" onEnterKeyDown")
        if (this.unfocusOnEnterKey() && this.isFocused()) {
            this.debugLog(" releasing focus")
            // this.releaseFocus() // TODO: implement something to pass focus up view chain to whoever wants it
            //this.element().parentElement.focus()
            if (this.parentView()) {
                this.parentView().focus()
            }
        }
        return this
    }
    */

    onKeyDown (event) {
        //BMKeyboard.shared().showEvent(event)

        let methodName = BMKeyboard.shared().downMethodNameForEvent(event)

        //console.log("event.repeat = ", event.repeat)
        //console.log(" onKeyDown ", methodName)
        
        if (!event.repeat) {
            return this.invokeMethodNameForEvent(methodName, event)
        } else {
            //const upMethodName = BMKeyboard.shared().upMethodNameForEvent(event)
            //this.invokeMethodNameForEvent(upMethodName, event)
            //this.forceRedisplay()
        }
        

        return true
    }

    forceRedisplay() {
        // NOTE: not sure this works
        const p = this.parentView()
        if (p) {
            const d = p.display()
            p.setDisplay("none")
            p.setDisplay(d)  
        }
        return this
    }

    invokeMethodNameForEvent (methodName, event) {
        //this.debugLog(".invokeMethodNameForEvent('" + methodName + "')")
        if (this[methodName]) {
            const stopProp = this[methodName].apply(this, [event])
            //event.preventDefault()
            if (stopProp === false) {
                //event.preventDefault()
                event.stopPropagation()
                return false
            }
        }

        return true
    }

    onKeyPress (event) {
        // console.log("onKeyPress")
        return true
    }

    onKeyUp (event) {
        let shouldPropogate = true
        //this.debugLog(" onKeyUp ", event._id)

        const methodName = BMKeyboard.shared().upMethodNameForEvent(event)
        //console.log("methodName: ", methodName)
        this.invokeMethodNameForEvent(methodName, event)

        this.didEdit()
        return shouldPropogate
    }

    didEdit () {
        this.debugLog(" didEdit")
        this.tellParentViews("onDidEdit", this)
        return this
    }

    onEnterKeyUp (event) {
        return true
    }

    // --- tabs and next key view ----

    onTabKeyDown (event) {
        // need to implement this on key down to prevent browser from handling tab?
        //this.debugLog(" onTabKeyDown ", event._id)

        if(this.selectNextKeyView()) {
            //event.stopImmediatePropagation() // prevent other listeners from getting this event
            //console.log("stopImmediatePropagation ")
        }
        return false
    }

    onTabKeyUp (event) {
        //this.debugLog(" onTabKeyUp ", event._id)
        return false
    }

    becomeKeyView () { 
        // use this method instead of focus() in order to give the receiver 
        // a chance to give focus to one of it's decendant views
        this.focus()
        return this
    }

    selectNextKeyView () {
        // returns true if something is selected, false otherwise

        //this.debugLog(" selectNextKeyView")
        const nkv = this.nextKeyView()
        if (nkv) {
            nkv.becomeKeyView()
            return true
        } else {
            const p = this.parentView()
            if (p) {
                return p.selectNextKeyView()
            }
        }
        return false
    }

    // --- error checking ---

    isValid () {
        return true
    }

    // --- focus and blur event handling ---

    isRegisteredForFocus () {
        return this.focusListener().isListening()
    }

    setIsRegisteredForFocus (aBool) {
        this.focusListener().setIsListening(aBool)
        return this
    }

    willAcceptFirstResponder () {
        //this.debugLog(".willAcceptFirstResponder()")
        return this
    }

    didReleaseFirstResponder () {
        // called on blur event from browser?
        return this
    }

    // firstResponder

    isFirstResponder () {
        return document.activeElement === this.element()
    }

    willBecomeFirstResponder () {
        // called if becomeFirstResponder accepts
    }

    becomeFirstResponder () {
        if (this.acceptsFirstResponder()) {
            this.willBecomeFirstResponder()
            this.focus()
        } else if (this.parentView()) {
            this.parentView().becomeFirstResponder()
        }
        return this
    }

    releaseFirstResponder () {
        // walk up parent view chain and focus on the first view to 
        // answer true for the acceptsFirstResponder message
        //this.debugLog(".releaseFirstResponder()")

        if (this.isFocused()) { 
            this.blur()
        }

        this.tellParentViews("decendantReleasedFocus", this)
        /*
        if (this.parentView()) {
            this.parentView().becomeFirstResponder()
        }
        */
        return this
    }

    // --------------------------------------------------------

    onFocusIn (event) {
        return true
    }

    onFocusOut (event) {
        return true
    }

    onFocus (event) {
        //console.log(this.typeId() + " onFocus")
        this.willAcceptFirstResponder();
        // subclasses can override 
        //this.debugLog(" onFocus")
        return true
    }

    onBlur (event) {
        //console.log(this.typeId() + " onBlur")
        this.didReleaseFirstResponder();
        // subclasses can override 
        //this.debugLog(" onBlur")
        return true
    }

    innerText () {
        const e = this.element()
        return e.textContent || e.innerText || "";
    }

    // --- set caret ----

    insertTextAtCursor(text) {
        const savedSelection = this.saveSelection()

        if (window.getSelection) {
            const sel = window.getSelection();
            if (sel.getRangeAt && sel.rangeCount) {
                const range = sel.getRangeAt(0);
                range.deleteContents();
                range.insertNode( document.createTextNode(text) );
            }
        } else if (document.selection && document.selection.createRange) {
            document.selection.createRange().text = text;
        }
        savedSelection.collapse()
        this.restoreSelection(savedSelection)

        return this
    }

    saveSelection() {
        if (window.getSelection) {
            const sel = window.getSelection();
            if (sel.getRangeAt && sel.rangeCount) {
                return sel.getRangeAt(0);
            }
        } else if (document.selection && document.selection.createRange) {
            return document.selection.createRange();
        }
        return null;
    }
    
    restoreSelection(range) {
        if (range) {
            if (window.getSelection) {
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            } else if (document.selection && range.select) {
                range.select();
            }
        }
    }

    // --- set caret ----


    moveCaretToEnd () {
        const contentEditableElement = this.element()
        let range, selection;

        if (document.createRange) {
            //Firefox, Chrome, Opera, Safari, IE 9+
            range = document.createRange(); //Create a range (a range is a like the selection but invisible)
            range.selectNodeContents(contentEditableElement); //Select the entire contents of the element with the range
            range.collapse(false); //collapse the range to the end point. false means collapse to end rather than the start
            selection = window.getSelection(); //get the selection object (allows you to change selection)
            selection.removeAllRanges(); //remove any selections already made
            selection.addRange(range); //make the range you have just created the visible selection
        }
        else if (document.selection) {
            //IE 8 and lower
            range = document.body.createTextRange(); //Create a range (a range is a like the selection but invisible)
            range.moveToElementText(contentEditableElement); //Select the entire contents of the element with the range
            range.collapse(false); //collapse the range to the end point. false means collapse to end rather than the start
            range.select();//Select the range (make it the visible selection
        }
        return this
    }

    // --- text selection ------------------

    selectAll () {
        if (document.selection) {
            const range = document.body.createTextRange();
            range.moveToElementText(this.element());
            range.select();
        } else if (window.getSelection) {
            const selection = window.getSelection(); 
            const range = document.createRange();
            range.selectNodeContents(this.element());
            selection.removeAllRanges();
            selection.addRange(range);  
        }
    }

    // --- paste from clipboard ---

    onPaste (e) {
        // prevent pasting text by default after event
        e.preventDefault();

        const clipboardData = e.clipboardData;
        const rDataHTML = clipboardData.getData("text/html");
        const rDataPText = clipboardData.getData("text/plain");

        const htmlToPlainTextFunc = function (html) {
            const tmp = document.createElement("DIV");
            tmp.innerHTML = html;
            return tmp.textContent || tmp.innerText || "";
        }

        if (rDataHTML && rDataHTML.trim().length !== 0) {
            this.replaceSelectedText(htmlToPlainTextFunc(rDataHTML))
            return false; // prevent returning text in clipboard
        }

        if (rDataPText && rDataPText.trim().length !== 0) {
            this.replaceSelectedText(htmlToPlainTextFunc(rDataPText))
            return false; // prevent returning text in clipboard
        }
        return true
    }

    // ------------

    isRegisteredForClipboard () {
        return this.clipboardListener().isListening()
    }

    setIsRegisteredForClipboard (aBool) {
        this.clipboardListener().setIsListening(aBool)
        return this
    }

    replaceSelectedText (replacementText) {
        let range;
        if (window.getSelection) {
            const sel = window.getSelection();
            if (sel.rangeCount) {
                range = sel.getRangeAt(0);
                range.deleteContents();
                range.insertNode(document.createTextNode(replacementText));
            }

            console.log("inserted node")
        } else if (document.selection && document.selection.createRange) {
            range = document.selection.createRange();
            range.text = replacementText;
            console.log("set range.text")
        }

        if (range) {
            // now move the selection to just the end of the range
            range.setStart(range.endContainer, range.endOffset);
        }

        return this
    }

    // untested

    getCaretPosition() {
        const editableDiv = this.element()
        let caretPos = 0
        if (window.getSelection) {
            const sel = window.getSelection();
            if (sel.rangeCount) {
                const range = sel.getRangeAt(0);
                if (range.commonAncestorContainer.parentNode == editableDiv) {
                    caretPos = range.endOffset;
                }
            }
        } else if (document.selection && document.selection.createRange) {
            const range = document.selection.createRange();
            if (range.parentElement() == editableDiv) {
                const tempEl = document.createElement("span");
                editableDiv.insertBefore(tempEl, editableDiv.firstChild);
                const tempRange = range.duplicate();
                tempRange.moveToElementText(tempEl);
                tempRange.setEndPoint("EndToEnd", range);
                caretPos = tempRange.text.length;
            }
        }
        return caretPos;
    }

    setCaretPosition (caretPos) {
        const elem = this.element();

        if(elem != null) {
            if(elem.createTextRange) {
                const range = elem.createTextRange();
                range.move("character", caretPos);
                range.select();
            }
            else {
                if(elem.selectionStart) {
                    elem.focus();
                    elem.setSelectionRange(caretPos, caretPos);
                } else {
                    elem.focus();
                }
            }
        }
    }

    // ---------------

    clearSelection () {
        if (window.getSelection) {
            window.getSelection().removeAllRanges();
        } else if (document.selection) {
            document.selection.empty();
        }
        return this
    }

    setContentAfterOrBeforeString (aString, afterOrBefore) {
        const uniqueClassName = "UniqueClass_" + this.puuid()
        const e = this.element()
        if (e.className.indexOf(uniqueClassName) === -1) {
            const newRuleKey = "DomView" + uniqueClassName + ":" + afterOrBefore
            const newRuleValue = "content: \"" + aString + "\;"
            //console.log("newRule '" + newRuleKey + "', '" + newRuleValue + "'")
            document.styleSheets[0].addRule(newRuleKey, newRuleValue);
            e.className += " " + uniqueClassName
        }
        return this
    }

    setContentAfterString (aString) {
        this.setContentAfterOrBeforeString(aString, "after")
        return this
    }

    setContentBeforeString (aString) {
        this.setContentAfterOrBeforeString(aString, "before")
        return this
    }

    // scroll top

    setScrollTop (v) {
        this.element().scrollTop = v
        return this
    }

    scrollTop () {
        return this.element().scrollTop
    }

    // scroll width & scroll height

    scrollWidth () {
        return this.element().scrollWidth // a read-only value
    }

    scrollHeight () {
        return this.element().scrollHeight // a read-only value
    }

    // offset width & offset height

    offsetLeft () {
        return this.element().offsetLeft // a read-only value
    }

    offsetTop () {
        return this.element().offsetTop // a read-only value
    }

    // scroll actions

    scrollToTop () {
        this.setScrollTop(0)
        return this
    }

    scrollToBottom () {
        const focusedElement = document.activeElement
        const needsRefocus = focusedElement !== this.element()
        // console.log("]]]]]]]]]]]] " + this.typeId() + ".scrollToTop() needsRefocus = ", needsRefocus)

        this.setScrollTop(this.scrollHeight())

        if (needsRefocus) {
            focusedElement.focus()
        }
        //e.animate({ scrollTop: offset }, 500); // TODO: why doesn't this work?
        return this
    }

    scrollSubviewToTop (aSubview) {
        console.log("]]]]]]]]]]]] " + this.typeId() + ".scrollSubviewToTop()")
        assert(this.hasSubview(aSubview))
        //this.setScrollTop(aSubview.offsetTop())
        //this.setScrollTopSmooth(aSubview.offsetTop())
        //this.setScrollTop(aSubview.offsetTop() + aSubview.scrollHeight())
        this.animateValue(
            () => { return aSubview.offsetTop() },
            () => { return this.scrollTop() },
            (v) => { this.setScrollTop(v) },
            200)
        return this
    }

    animateValue (targetFunc, valueFunc, setterFunc, duration) { // duration in milliseconds         
        console.log("]]]]]]]]]]]] " + this.typeId() + ".animateValue()")
        if (duration == null) {
            duration = 200
        }
        //duration = 1500
        const startTime = Date.now();

        const step = () => {
            const dt = (Date.now() - startTime)
            let r = dt / duration
            r = Math.sin(r * Math.PI / 2)
            r = r * r * r

            const currentValue = valueFunc()
            const currentTargetValue = targetFunc()

            //console.log("time: ", dt, " /", duration, " r:", r, " top:", currentValue, "/", currentTargetValue)

            if (dt > duration) {
                setterFunc(currentTargetValue)
            } else {
                const newValue = currentValue + (currentTargetValue - currentValue) * r
                setterFunc(newValue)
                window.requestAnimationFrame(step);
            }
        }

        window.requestAnimationFrame(step);

        return this
    }

    setScrollTopSmooth (newScrollTop, scrollDuration) {
        this.animateValue(() => { return newScrollTop }, () => { return this.scrollTop() }, (v) => { this.setScrollTop(v) }, scrollDuration)
        return this
    }

    dynamicScrollIntoView () {
        this.parentView().scrollSubviewToTop(this)
        return this
    }

    scrollIntoView () {
        const focusedView = WebBrowserWindow.shared().activeDomView()
        //console.log("]]]]]]]]]]]] " + this.typeId() + ".scrollIntoView() needsRefocus = ", focusedView !== this)

        if (focusedView && focusedView !== this) {
            //console.log("scrollIntoView - registerForVisibility")
            // this hack is needed to return focus that scrollIntoView grabs from other elements
            // need to do this before element().scrollIntoView appearently
            this.registerForVisibility()
            this._endScrollIntoViewFunc = () => {
                //console.log("_endScrollIntoViewFunc - returning focus")
                //focusedView.focus()
                // need delay to allow scroll to finish - hack - TODO: check for full visibility
                focusedView.focusAfterDelay(0.2)
            }
        }
        this.addTimeout(() => {
            this.element().scrollIntoView({ block: "start", inline: "nearest", behavior: "smooth", })
        }, 0)



        /*
        if (focusedView !== this) {
            focusedView.focusAfterDelay(0.5) // TODO: get this value from transition property
        }
        */
        return this
    }

    boundingClientRect () {
        return this.element().getBoundingClientRect()
    }

    viewportX () {
        return this.boundingClientRect().x
    }

    viewportY () {
        return this.boundingClientRect().y
    }

    containsViewportPoint () {
        throw new Error("unimplemented")
    }

    isScrolledIntoView () {
        const r = this.boundingClientRect()
        const isVisible = (r.top >= 0) && (r.bottom <= window.innerHeight);
        return isVisible;
    }

    // helpers

    /*
    mouseUpPos () { 
        return this.viewPosForWindowPos(Mouse.shared().upPos())
    }

    mouseCurrentPos () { 
        return this.viewPosForWindowPos(Mouse.shared().currentPos())
    }
    */

    mouseDownPos () {
        return this.viewPosForWindowPos(Mouse.shared().downPos())
    }

    // view position helpers ----

    setRelativePos (p) {
        // why not a 2d transform?
        this.setLeftPx(p.x())
        this.setTopPx(p.y())
        return this
    }

    containsPoint (aPoint) {
        // point must be in document coordinates
        return this.frameInDocument().containsPoint(aPoint)
    }

    // viewport coordinates helpers

    frameInViewport () {
        const origin = this.positionInViewport()
        const size = this.sizeInViewport()
        const frame = Rectangle.clone().setOrigin(origin).setSize(size)
        return frame
    }

    positionInViewport () {
        const box = this.element().getBoundingClientRect();
        return Point.clone().set(Math.round(box.left), Math.round(box.top));
    }

    sizeInViewport () {
        const box = this.element().getBoundingClientRect();
        return Point.clone().set(Math.round(box.width), Math.round(box.height));
    }

    // document coordinates helpers

    // --- document positioning ---

    setFrameInDocument (aRect) {
        this.setPosition("absolute")
        this.setLeftPx(aRect.origin().x())
        this.setTopPx(aRect.origin().y())
        this.setMinAndMaxSize(aRect.size())
        return this
    }

    frameInDocument () {
        const origin = this.positionInDocument()
        const size = this.size()
        const frame = Rectangle.clone().setOrigin(origin).setSize(size)
        return frame
    }

    // -------------------
    // fixed - assumes position is absolute and width and height are fixed via min-width === max-width, etc
    // -------------------

    // fixed position

    hasFixedX () {
        return !Type.isNullOrUndefined(this.leftPx() ) 
    }

    hasFixedY () {
        return !Type.isNullOrUndefined(this.topPx() ) 
    }

    hasFixedPosition () {
        return this.position() === "absolute" && this.hasFixedX() && this.hasFixedY()
    }

    // fixed size

    hasFixedSize () {
        return this.hasFixedWidth() && this.hasFixedHeight()
    }

    hasFixedWidth () {
        const v1 = this.minWidthPx()
        const v2 = this.maxWidthPx()
        return !Type.isNullOrUndefined(v1) && v1 === v2
    }

    hasFixedHeight () {
        const v1 = this.minHeightPx()
        const v2 = this.maxHeightPx()
        return !Type.isNullOrUndefined(v1) && v1 === v2
    }

    decrementFixedWidth () {
        assert(this.hasFixedWidth())
        this.setMinAndMaxWidth(Math.max(0, this.minWidthPx()-1))
        return this
    }

    decrementFixedHeight () {
        assert(this.hasFixedHeight())
        this.setMinAndMaxHeight(Math.max(0, this.minHeightPx()-1))
        return this
    }

    // fixed frame

    hasFixedFrame () {
        return this.hasFixedPosition() && this.hasFixedSize()
    }

    fixedFrame () {
        assert(this.hasFixedFrame())
        const origin = Point.clone().set(Math.round(this.leftPx()), Math.round(this.topPx()))
        const size   = Point.clone().set(Math.round(this.minWidthPx()), Math.round(this.minHeightPx()))
        const frame  = Rectangle.clone().setOrigin(origin).setSize(size)
        return frame
    }

    //--------------

    estimatedWidthPx () {
        const v1 = this.minWidthPx()
        const v2 = this.maxWidthPx()
        if (!Type.isNullOrUndefined(v1) && v1 === v2) {
            return v1
        }
        return this.clientWidth()
    }

    estimatedHeightPx () {
        const v1 = this.minHeightPx()
        const v2 = this.maxHeightPx()
        if (!Type.isNullOrUndefined(v1) && v1 === v2) {
            return v1
        }
        return this.clientHeight()
    }

    // ------------------------


    positionInDocument () {
        const box = this.element().getBoundingClientRect();

        // return Point.clone().set(Math.round(box.left), Math.round(box.top));

        const body = document.body;
        const docEl = document.documentElement;

        const scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
        const scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;

        const clientTop = docEl.clientTop || body.clientTop || 0;
        const clientLeft = docEl.clientLeft || body.clientLeft || 0;

        const top = box.top + scrollTop - clientTop;
        const left = box.left + scrollLeft - clientLeft;

        const p = Point.clone().set(Math.round(left), Math.round(top));
        return p
    }

    size () {
        return EventPoint.clone().set(this.clientWidth(), this.clientHeight());
    }

    // ---------------------

    setFrameInParent (aRect) {
        this.setPosition("absolute")
        this.setLeftPx(aRect.origin().x())
        this.setTopPx(aRect.origin().y())
        this.setMinAndMaxSize(aRect.size())
        return this
    }

    frameInParentView () {
        const origin = this.relativePos()
        const size = this.size()
        const frame = Rectangle.clone().setOrigin(origin).setSize(size)
        return frame
    }

    // ---

    relativePos () {
        const pv = this.parentView()
        if (pv) {
            return this.positionInDocument().subtract(pv.positionInDocument())
            //return pv.positionInDocument().subtract(this.positionInDocument())
        }
        return this.positionInDocument()
    }

    setRelativePos (p) {
        //this.setPosition("absolute")
        this.setLeftPx(p.x())
        this.setTopPx(p.y())
        return this
    }

    // ---

    viewPosForWindowPos (pos) {
        return pos.subtract(this.positionInDocument())
    }

    // --------------

    makeAbsolutePositionAndSize () {
        const f = this.frameInParentView()
        this.setFrameInParent(f)
        return this 
    }

    makeRelativePositionAndSize () {
        // TODO: check if it's flex and set flex basis in flex direction instead?
        this.setPosition("relative")

        this.setTopPx(null)
        this.setLeftPx(null)
        this.setRightPx(null)
        this.setBottomPx(null)

        this.setMinAndMaxWidth(null)
        this.setMinAndMaxHeight(null)  
        return this 
    }

    // --------------

    cancelVerticallyAlignAbsolute () {
        this.setPosition("relative")
    }

    verticallyAlignAbsoluteNow () {
        const pv = this.parentView()
        if (pv) {
            this.setPosition("absolute")
            const parentHeight = pv.computedHeight() //pv.calcHeight() // computedHeight?
            const height = this.computedHeight()
            this.setTopPx((parentHeight / 2) - (height / 2))
        } else {
            throw new Error("missing parentView")
        }
        return this
    }

    horizontallyAlignAbsoluteNow () {
        const pv = this.parentView()
        if (pv) {
            this.setPosition("absolute")
            this.addTimeout(() => {
                this.setRightPx(pv.clientWidth() / 2 - this.clientWidth() / 2)
            }, 0)
        }
        return this
    }

    setVerticalAlign (s) {
        this.setCssAttribute("vertical-align", s)
        return this
    }

    // visibility event

    onVisibility () {
        //this.debugLog(".onVisibility()")
        this.unregisterForVisibility()
        return true
    }

    setIsRegisteredForVisibility (aBool) {
        if (aBool !== this.isRegisteredForVisibility()) {
            if (aBool) {
                this.registerForVisibility()
            } else {
                this.unregisterForVisibility()
            }
        }
        return this
    }

    unregisterForVisibility () {
        const obs = this.intersectionObserver()
        if (obs) {
            obs.disconnect()
            this.setIntersectionObserver(null);
            this._isRegisteredForVisibility = false
        }
        return this
    }

    registerForVisibility () {
        if (this.isRegisteredForVisibility()) {
            return this
        }

        let root = document.body

        if (this.parentView()) {
            root = this.parentView().parentView().element() // hack for scroll view - TODO: make more general
            //root = this.parentView().element()
        }

        const intersectionObserverOptions = {
            root: root, // watch for visibility in the viewport 
            rootMargin: "0px",
            threshold: 1.0
        }

        const obs = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    //console.log("onVisibility!")
                    if (this._endScrollIntoViewFunc) {
                        this._endScrollIntoViewFunc()
                        // hack around lack of end of scrollIntoView event 
                        // needed to return focus that scrollIntoView grabs from other elements
                    }

                    this.onVisibility()
                }
            })
        }, intersectionObserverOptions)

        this.setIntersectionObserver(obs);
        obs.observe(this.element());

        this._isRegisteredForVisibility = true
        return this
    }

    // centering

    fillParentView () {
        this.setWidthPercentage(100)
        this.setHeightPercentage(100)
        return this
    }

    centerInParentView () {
        this.setMinAndMaxWidth(null)
        this.setMinAndMaxHeight(null)
        //this.setWidth("100%")
        //this.setHeight("100%")
        this.setOverflow("auto")
        this.setMarginString("auto")
        this.setPosition("absolute")
        this.setTopPx(0).setLeftPx(0).setRightPx(0).setBottomPx(0)
    }

    /*
    verticallyCenterFromTopNow () {
        if (this.parentView() === null) {
            console.warn("verticallyCenterFromTopNow called on view with no superview")
            return this
        }

        this.setPosition("absolute")
        this.setDisplay("inline-block")

        // timeout used to make sure div is placed and laid out first
        // TODO: consider ordering issue
        this.addTimeout(() => { 
            let sh = this.parentView().clientHeight()
            let h = this.clientHeight()
            this.setTopPx(sh/2 - h/2)
        }, 1)

        return this
    }

    horiontallyCenterFromLeftNow () {
        if (this.parentView() === null) {
            console.warn("horiontallyCenterFromLeftNow called on view with no superview")
            return this
        }

        this.setPosition("absolute")
        this.setDisplay("inline-block")

        // timeout used to make sure div is placed and laid out first
        // TODO: consider ordering issue
        this.addTimeout(() => { 
            let sw = this.parentView().clientWidth()
            let w = this.clientWidth()
            this.setTopPx(sw/2 - w/2)
        }, 1)

        return this
    }
    */

    static documentBodyView () {
        return DocumentBody.shared()
    }

    rootView () {
        const pv = this.parentView()
        if (pv) {
            return pv.rootView()
        }
        return this
    }

    isInDocument () {
        return this.rootView() === DocumentBody.shared()
    }

    disablePointerEventsUntilTimeout (ms) {
        this.setPointerEvents("none")
        this.debugLog(" disabling pointer events")

        this.addTimeout(() => {
            this.debugLog(" enabling pointer events")
            this.setPointerEvents("inherit")
        }, ms)

        return this
    }

    containerize () {
        // create a subview of same size as parent and put all other subviews in it
        const container = DomView.clone()
        container.setMinAndMaxHeight(this.clientHeight())
        container.setMinAndMaxWidth(this.clientWidth())
        this.moveAllSubviewsToView(container)
        this.addSubview(container)
        return container
    }

    uncontainerize () {
        assert(this.subviewCount() === 1)
        const container = this.subviews().first()
        this.removeSubview(container)
        container.moveAllSubviewsToView(this)
        return this
    }

    moveAllSubviewsToView (aView) {
        this.subviews().shallowCopy().forEach((sv) => {
            this.remove(sv)
            aView.addSubview(sv)
        })
        return this
    }

    // auto fit 
    // need to be careful about interactions as some of these change 
    // display and position attributes
    // NOTE: when we ask parent to fit child, should we make sure child position attribute allows this?

    hasAbsolutePositionChild () {
        const match = this.subviews().detect(sv => sv.position() === "absolute")
        return !Type.isNullOrUndefined(match)
    }

    // auto fit width

    autoFitParentWidth () {
        this.setDisplay("block")
        this.setWidth("-webkit-fill-available")
        //this.setHeight("fill-available")
        return this
    }

    autoFitChildWidth () {
        //assert(!this.hasAbsolutePositionChild()) // won't be able to autofit!
        this.setDisplay("inline-block")
        this.setWidth("auto")
        this.setOverflow("auto")
        return this
    }

    // auto fit height

    autoFitParentHeight () {
        this.setPosition("absolute")
        //this.setHeightPercentage(100)
        this.setHeight("-webkit-fill-available")
        //this.setHeight("fill-available")
        return this
    }

    autoFitChildHeight () {
        //assert(!this.hasAbsolutePositionChild()) // won't be able to autofit!
        this.setPosition("relative") // or static? but can't be absolute
        this.setHeight("fit-content")
        return this
    }

    // organizing

    moveToAbsoluteDocumentBody () {
        const f = this.frameInDocument()
        this.setFrameInDocument(f)
        this.removeFromParentView()
        DocumentBody.shared().addSubview(this)
        return this
    }

    // organizing

    absoluteOrganizeSubviewsVertically () {
        let top = 0
        this.subviews().shallowCopy().forEach((sv) => {
            const h = sv.clientHeight()
            sv.setLeftPx(0)
            sv.setTopPx(top)
            top += h
        })
    }

    absoluteOrganizeSubviewsHorizontally () {
        let left = 0
        this.subviews().shallowCopy().forEach((sv) => {
            const w = sv.clientWidth()
            sv.setLeftPx(left)
            sv.setTopPx(0)
            left += x
        })
    }

    // html duplicates

    htmlDuplicateView () {
        const v = DomView.clone()
        v.setFrameInParent(this.frameInParentView())
        v.setInnerHTML(this.innerHTML())
        return v
    }

    htmlDuplicateViewAndSubviews (selectedSubviews) {
        selectedSubviews.forEach(sv => asset(sv.parentView() === this))

        const v = DomView.clone()
        v.setFrameInParent(this.frameInParentView())
        selectedSubviews.forEach(sv => v.addSubview(sv.htmlDuplicateView()))
        return v
    }

    htmlDuplicateViewWithSubviews () {
        const v = DomView.clone()
        v.setFrameInParent(this.frameInParentView())
        this.subviews().forEach(sv => v.addSubview(sv.htmlDuplicateView()))
        return v
    }

    // fitting

    fitSubviews () {
        const f = this.frameFittingSubviewsInParent()
        this.setFrameInParent(f)
        return this
    }

    frameFittingSubviewsInParent () {
        let u = null

        this.subviews().forEach(sv => {
            const f = sv.frameInParent()
            if (u === null) {
                u = f
            } else {
                u = u.unionWith(f)
            }
        })

        return u
    }

    fixedFrameFittingSubviews() {
        let u = null

        this.subviews().forEach(sv => {
            const f = sv.fixedFrame()
            if (u === null) {
                u = f
            } else {
                u = u.unionWith(f)
            }
        })

        return u
    }

    convertFrameToDocument (aRect) {
        const p = this.positionInDocument()
        const newOrigin = aRect.origin().add(p)
        return aRect.copy().setOrigin(newOrigin)
    }

    // ----

    resyncAllViews () {
        this.subviews().forEach(sv => sv.resyncAllViews())
        return this
    }

}.initThisClass()

"use strict"

/*
    DomFlexView


*/

window.DomView = class DomFlexView extends DomView {
    
    initPrototype () {
    }

    init () {
        super.init()
        this.setDisplay("flex")
        return this
    }

    makeFlexAndCenterContent () {
        this.setDisplay("flex")
        this.setAlignItems("center")
        this.setJustifyContent("center")
        return this
    }

    canSplit () {
        return this.subviews().length === 0
    }

    addSubviewCount (count) {
        for (let i = 0; i < count; i++) {
            this.newFlexSubview()     
        }
        return this
    }

    newFlexSubview () {
        const v = DomFlexView.clone()
        v.setDisplay("flex")
        v.setMinHeight("0em")
        v.setMinWidth("0em")
        const order = this.subviews().length
        v.setOrder(order)
        this.addSubview(v) 
        return v
    }

    makeSubviewsOrdered () {
        this.subviews().forEachKV((i, sv) => {
            sv.setOrder(i)
        })
    }

    makeSubviewsReverseOrdered () {
        const count = this.subviews().length
        this.subviews().forEachKV((i, sv) => {
            sv.setOrder(count - 1 - i)
        })
    }

    /*
    flexSplitIntoRowsNamed (nameList) {
        this.flexSplitIntoRows(nameList.length)
        for (let i = 0; i < nameList.length; i++) {
            const name = nameList.at(i)
            const subview = this.subviews().at(i)
            this.newSlot(name, subview, true)
        }
        return this
    }
    */

    flexSplitIntoRows (count) {
        assert(this.canSplit()) // temporary
        this.setDisplay("flex")
        this.setFlexDirection("column")
        this.addSubviewCount(count)
        this.debugBorders()
        return this
    }

    flexSplitIntoColumns (count) {
        assert(this.canSplit()) // temporary
        this.setDisplay("flex")
        this.setFlexDirection("row")
        this.addSubviewCount(count)
        this.debugBorders()
        return this
    }

    flexCenterContent () {
        this.setJustifyContent("center")
        this.setAlignItems("center")
        return this
    }

    makeStandardFlexView () {
        this.setDisplay("flex")
        this.setPosition("relative")
        this.flexCenterContent()
        this.setOverflow("hidden")
        return this
    }

    debugBorders () {
        //this.subviews().forEach(sv => sv.setBorder("1px solid rgba(255, 255, 255, 0.2)"))
    }

}.initThisClass()

"use strict"

/*
    DomStyledView

   (one step towards eliminating the remaining css files)

    A base view to handle styles in a uniform way. 
    Holds an instance of BMViewStyles which holds a set of BMViewStyle instances, one for each style.

    Overview:

        DomStyledView
          styles -> BMViewStyles
                        selected -> BMViewStyle
                        unselected -> BMViewStyle
                                        color
                                        backgroundColor
                                        opacity
                                        borderLeft
                                        borderRight

                       
    

    Supported styles:

    - unselected
    - selected

*/


window.DomStyledView = class DomStyledView extends DomFlexView {
    
    initPrototype () {
        this.newSlot("styles", null)
        this.newSlot("isSelected", false).setOwnsSetter(true).setDoesHookSetter(true)
        this.newSlot("lockedStyleAttributeSet", null)
    }

    init () {
        super.init()
        this.setLockedStyleAttributeSet(new Set())
        return this
    }

    // styles

    lookedUpStyles () {
        return null
    }
	
    styles () { 
        // since not all views use them, do lazy style setup 
        if (!this._styles) {
            this.setStyles(BMViewStyles.clone()) 
        }
        return this._styles
    }

    /*
    currentStyle () {
        let style = null
        if (this.isSelected()) {
            style = this.styles().selected()
            //this.debugLog(".applyStyles() selected ", style.description())
        } else {
            style = this.styles().unselected()
            //this.debugLog(".applyStyles() unselected ", style.description())
        }
        return style
    }
    */
	
    applyStyles () {
        //const style = this.currentStyle()
        //style.applyToView(this)	
        const state = this.currentThemeState()
        if (state) {
            state.applyToView(this)
        }
        return this
    }

    // select

    didUpdateSlotIsSelected (oldValue, newValue) {
        // sent by hooked setter
        this.applyStyles()
        return this
    }

    toggleSelection () {
        if (this.isSelected()) {
            this.unselect()
        } else {
            this.select()
        }
        return this
    }

    select () {
        this.setIsSelected(true)		
        return this
    }

    unselect () {
        if (this.isSelected()) { // for debugging 
            this.setIsSelected(false)
        }
        return this
    }

    // -----------------------------------------

    themeClassName () {
        return null
    }

    themeStateName () {
        //const states = []
        /*
        if (this.isActive()) {
            return "active"
        }
        */

        if (this.isSelected()) {
            return "selected"
        }

        return "unselected"

        /*
        if (this.isEditable()) {
            return "editable" //["selected", "active", "editable", "disabled"]
        }

        return "disabled"
        */
    }

    themePathArray () {
        const path = []

        const themeClassName = this.themeClassName()
        if (themeClassName) {
            path.push(themeClassName)
        } else {
            path.push("DefaultThemeClass")
        }

        const stateName = this.themeStateName() 
        path.push(stateName)

        return path
    }

    currentThemeClass () {
        const theme = BMThemeResources.shared().activeTheme()
        if (!theme) {
            return null
        }
        const className = this.themeClassName() ? this.themeClassName() : "DefaultThemeClass"
        const themeClass = theme.firstSubnodeWithTitle(className)
        return themeClass
    }

    currentThemeState () {
        const tc = this.currentThemeClass() 
        let state = null
        if (tc) {
            let stateName = this.isSelected() ? "selected" : "unselected"
            const state = tc.firstSubnodeWithTitle(stateName)
            return state
        }
        return null
    }

    themeValueForAttribute (attributeName) {
        const fullPath = this.themePathArray()
        fullPath.push(attributeName)
        //console.log("fullPath = ", fullPath)

        const theme = BMThemeResources.shared().activeTheme()
        const attribtueNode = theme ? theme.nodeAtSubpath(fullPath) : null
        if (attribtueNode) {
            const value = attribtueNode.value()
            if (!value) {
                //console.log("no color found for ", fullPath)
                return null
            }
            return value
        }
        //console.log("no color found for ", fullPath)

        return null
    }

    // -------------------------------------

    currentColor () {
        const v = this.themeValueForAttribute("color")
        if (v) {
            return v
        }
        return "yellow"

        //console.log("this.themeValueForAttribute('color') = ", this.themeValueForAttribute('color') )
        //return this.currentStyle().color()
    }

    currentBgColor () {
        const v = this.themeValueForAttribute("backgroundColor")
        if (v) {
            return v
        }
        return "orange"

        //return this.currentStyle().backgroundColor()
    }
	
}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "BooleanView.js",
    "ButtonView.js",
    "CloseButton.js",
    "DocumentBody.js",
    "DragBarView.js",
    "DragView.js",
    "PanelView.js",
    "SvgIconView.js",
    "TextField.js"
])


"use strict"

/*

    BooleanView

    The checkbox is composed of 2 overlapping inner views,
    one for the inner check itself, and one for the outer border around.
    The check components are rendered with scalable SVG and 
    are synced to match the color of the parent view's text color by
    getting the computed color and applying it to the fill or stroke of the
    svg views.

    TODO: support disabled/uneditable color style?

*/

window.BooleanView = class BooleanView extends DomStyledView {
    
    initPrototype () {
        this.newSlot("doesClearOnReturn", false)  // needed?
        this.newSlot("doesHoldFocusOnReturn", false)  // needed?
        this.newSlot("value", false)
        this.newSlot("isEditable", false)
        this.newSlot("innerCheckView", null)
        this.newSlot("outerCheckView", null)
    }

    init () {
        super.init()
        this.setDisplay("flex")
        this.setPosition("relative")
        this.setFilter("blur(0.2px)")
        this.flexCenterContent()
        //this.setBorder("1px dashed red")
       
        this.turnOffUserSelect()
        this.setSpellCheck(false)
        this.setContentEditable(false)

        const size = this.checkboxSize()
        this.setMinAndMaxWidthAndHeight(size)
        //this.setMinAndMaxWidthAndHeight("fit-content")

        this.setOverflow("hidden")

        /*
        const iconSetView = DomView.clone().setDivClassName("IconSetView")
        //this.setBorder("1px dashed white")
        iconSetView.setDisplay("flex")
        iconSetView.setPosition("relative")
        //iconSetView.setWidth("fit-content").setHeight("fit-content")
        iconSetView.setMinAndMaxWidthAndHeight(size)
        this.addSubview(iconSetView)
        */

        {
            const inner = SvgIconView.clone().setIconName("inner-checkbox")
            //inner.setBorder("1px dashed blue")
            inner.setDisplay("flex")
            inner.setPosition("absolute")
            inner.setTopPx(0)
            inner.setLeftPx(0)
            inner.setMinAndMaxWidthAndHeight(size)
            inner.setStrokeColor("transparent")
            this.setInnerCheckView(inner)
            this.addSubview(inner)
        }

        {
            const outer = SvgIconView.clone().setIconName("outer-checkbox")
            //outer.setBorder("1px dashed green")
            outer.setDisplay("flex")
            outer.setPosition("absolute")
            outer.setTopPx(0)
            outer.setLeftPx(0)
            outer.setMinAndMaxWidthAndHeight(size)
            outer.setFillColor("transparent")
            this.setOuterCheckView(outer)
            this.addSubview(outer)
        }
        
        this.setIsEditable(this.isEditable())

        return this
    }

    checkboxSize () {
        return "1em"
    }

    // editable
    
    setIsEditable (aBool) {        
        this._isEditable = aBool
        
        if (this._isEditable) {
            const g = this.addDefaultTapGesture()
            g.setShouldRequestActivation(false) // so the row doesn't block the initial tap
        } else {
            this.removeDefaultTapGesture()
        }
        
        this.updateAppearance()
        
        return this
    }
    
    toggle () {
        this.setValue(!this.value())
        this.didEdit()
        return this
    }
    
    activate () {
        this.toggle()
        return this
    }
    
    // ------------------
    
    setValue (v) {
        if (Type.isNullOrUndefined(v)) {
            v = false;
        }
        
	    this._value = v

        this.updateAppearance()
        return this
    }
	
    value () {
	    return this._value
    }
	
    isChecked () {
	    return this.value()
    }
    
    setBackgroundColor (s) {
        // needed?
        return this
    }
	
    // svg icon

    updateAppearance () {
        // sent by superview when it changes or syncs to a node
        // so we can update our appearance to match changes to the parent view's style

        const color = this.getComputedCssAttribute("color")

        this.outerCheckView().setStrokeColor(color)
        this.innerCheckView().setFillColor(this.value() ? color : "transparent")
        
        return this
    }

    onTapComplete (aGesture) {
        super.sendActionToTarget()
        this.toggle()
        return false
    }
    
}.initThisClass()

"use strict"

/*

    ButtonView

    A simple push button view with a TextView label.


    .BMActionNodeView {
        min-height: 28px;

        padding-top: 8px;
        padding-bottom: 8px;

        background-color: #888;
        color: #ccc;

        border-style: none;
        border-radius: 5px;
        border-width: 1px;
        border-color:#888;
        
        text-align: center;
        vertical-align: center;

        transition: all 0.1 ease;
    }

    .BMActionNodeView:hover {
        color: white;
        background-color: #888;
        transition: opacity background-color 1s ease;
    }

*/

window.ButtonView = class ButtonView extends DomView {
    
    initPrototype () {
        this.newSlot("titleView", null)
        this.newSlot("isEnabled", true)
        this.newSlot("iconView", null)
    }

    init () {
        super.init()
        this.setDisplay("flex")
        this.flexCenterContent()
        this.setHeight("fit-content")
        this.setWidth("100%")
        this.setMinHeight("1em")

        this.setPaddingTop("0.75em")
        this.setPaddingBottom("0.85em")

        this.setPaddingLeft("1em")
        this.setPaddingRight("1em")

        this.turnOffUserSelect()
        this.setBorderRadiusPx(1)
        
        {
            const tv = TextField.clone()
            this.setTitleView(tv)
            this.addSubview(tv)
            tv.fillParentView()
            tv.setPaddingTop("0.1em").setPaddingBottom("0.1em")
            tv.setPaddingLeft("1em").setPaddingRight("1em")
            tv.flexCenterContent()
            tv.setTextAlign("center")
            tv.setMinHeight("1em")
            
        }

        this.setTitle("")

        const icon = SvgIconView.clone() //.setDivClassName("RightActionView")
        icon.setMinAndMaxWidth(12)
        icon.setMinAndMaxHeight(15)
        icon.setFillColor("white")
        icon.setStrokeColor("white")
        icon.setOpacity(1)
        icon.hideDisplay()
        this.setIconView(this.addSubview(icon))

        this.addDefaultTapGesture()

        return this
    }

    setIconName (aName) {
        this.iconView().setIconName(aName)
        return this
    }

    setTitle (s) {
        this.titleView().setValue(s)
        //this.titleView().setDisplayIsHidden(!s)
        return this
    }

    title () {
        return this.titleView().value()
    }

    setHasOutline (aBool) {
        if (aBool) {
            this.setBoxShadow("0px 0px 1px 1px rgba(255, 255, 255, 0.2)")
        } else {
            this.setBoxShadow("none")
        }
        return this
    }

    setTitleIsVisible (aBool) {
        this.titleView().setDisplayIsHidden(!aBool)
        return this
    }

    setIsEditable (aBool) {
        this.titleView().setIsEditable(aBool)
        return this
    }

    isEditable () {
        return this.titleView().isEditable()
    }

    sendActionToTarget () {
        if (!this.isEditable()) {
            super.sendActionToTarget()
        }
        return this
    }

    onTapComplete (aGesture) {
        //this.debugLog(".onTapComplete()")
        this.sendActionToTarget()
        return false
    }
    
}.initThisClass()

"use strict"


/* 

    CloseButton

    TODO: make subclass of ButtonView?

*/

window.CloseButton = class CloseButton extends DomView {
    
    initPrototype () {
        this.newSlot("isEnabled", true)
        this.newSlot("iconView", null)
    }

    init () {
        super.init()
        this.makeFlexAndCenterContent()
        this.setPadding("0em")
        this.turnOffUserSelect()
        //this.setDisplay("table") // to center svg

        const iv = SvgIconView.clone().setIconName("close")
        iv.makeFlexAndCenterContent()
        //iv.setTopPx(0)
        //iv.setLeftPx(0)
        
        //iv.setMarginBottom("1px") // TODO: fix the SVG for this icon so this isn't needed?
        
        iv.setWidth("fit-content")
        iv.setHeight("fit-content")
        iv.setStrokeColor("white")
        iv.setFillColor("white")
        this.setIconView(iv)
        this.addSubview(iv)

        this.setAction("close")
        this.addDefaultTapGesture()
        return this
    }

    setIconName (aString) {
        this.iconView().setIconName(aString)
        return this
    }

    // --- editable ---
    
    setIsEnabled (aBool) {
        if (this._isEnabled !== aBool) {
            this._isEnabled = aBool
            this.syncEnabled()
        }

        return this
    }

    syncEnabled () {
        this.setDisplayIsHidden(!this.isEnabled())
        return this
    }

    onTapComplete (aGesture) {
        //this.debugLog(".onTapComplete()")
        if (!this.isEditable()) {
            this.sendActionToTarget()
        }
        return false
    }
    
}.initThisClass()

"use strict"

/*

    DocumentBody

*/

window.DocumentBody = class DocumentBody extends DomView {
    
    initPrototype () {

    }

    init () {
        super.init()

        // setup shared devices for later use
        Devices.shared().setupIfNeeded()
        
        //this.documentListener().setIsListening(true)
        this.setIsRegisteredForBrowserDrop(true) // to avoid dropping on window

        return this
    }

    acceptsDrop (event) { // to avoid dropping on window
        event.preventDefault();
        return false
    }
    
    setupElement () {
        document.body._domView = this
        //this._element = document.body
        // get this from element override
        return this
    }
    
    element () {
        return document.body
    }
    
    zoomAdjustedWidth () {
        return WebBrowserWindow.shared().width() * this.zoomRatio()
    }
    
    zoomAdjustedHeight () {
        return WebBrowserWindow.shared().width() * this.zoomRatio()
    }
    
    zoomAdjustedSize () { // TODO: move to Point
        return { width: this.zoomAdjustedWidth(), height: this.zoomAdjustedHeight() }
    }

    allDomElements () {
        const domElements = this.element().getElementsByTagName("*");
        return domElements
    }

    viewsUnderPoint (aPoint) {
        const elements = document.elementsFromPoint(aPoint.x(), aPoint.y())
        const views = elements.map(e => this.firstViewForElement(e)).nullsRemoved()
        return views
    }

    firstViewForElement (e) {
        // search up the dom element parents to find one
        // associated with a DomView instance 

        while (e) {
            const view = e._domView
            if (view) {
                return view
            }
            e = e.parentElement
        }

        return null
    }

    /*
    onDocumentResize (event) {
        super.onDocumentResize(event)
    }
    */
   
}.initThisClass()


"use strict"

/* 

    DragBarView

*/


window.DragBarView = class DragBarView extends DomView {
    
    initPrototype () {
        this.newSlot("isEnabled", true)
        this.newSlot("isHighlighted", false)
        this.newSlot("isDragging", false)
        this.newSlot("normalColor", "#333")
        this.newSlot("highlightColor", "#555")
        this.newSlot("dragColor", "#999")
        this.newSlot("delegate", null)
        this.newSlot("thickness", 2)
        this.newSlot("isVerticalDrag", true)
    }

    init () {
        super.init()

        this.turnOffUserSelect()

        this.setDivClassName("DragBarView")
        this.setDisplay("inline-block")

        this.setIsRegisteredForMouse(true)
        this.syncHighlighted()
        this.syncEnabled()

        this._mouseMoveTrackerFunc = (event) => {
            this.mouseMoveTracker(event)
            return true
        }

        this._mouseUpTrackerFunc = (event) => {
            this.mouseUpTracker(event)
            return true
        }

        this.setBackgroundColor(this.normalColor())
        return this
    }

    hoverCursorType () {
        if (this.isVerticalDrag()) {
            return "row-resize"
        }

        return "col-resize"
    }

    setIsVertical (aBool) {
        if (this._isVertical !== aBool) {
            this._isVertical = aBool
            //console.log("this.hoverCursorType() = ", this.hoverCursorType())
            this.setCursor(this.hoverCursorType())
        }
        return this
    }

    // --- editable ---
    
    setIsEnabled (aBool) {
        if (this._isEnabled !== aBool) {
            this._isEnabled = aBool
            this.syncEnabled()
        }

        return this
    }

    syncEnabled () {
        this.setDisplayIsHidden(!this.isEnabled())
        return this
    }

    // --- highlighted ---
    
    setIsHighlighted (aBool) {
        if (this._isHighlighted !== aBool) {
            this._isHighlighted = aBool
            this.syncHighlighted()
        }

        return this
    }

    syncHighlighted () {
        if (this.isDragging()) {
            return this
        }

        if (this.isHighlighted()) {
            this.setBackgroundColor(this.highlightColor())
        } else {
            this.setBackgroundColor(this.normalColor())
        }
        this.syncCursor()

        return this
    }

    syncCursor () {
        if (this.isHighlighted()) {
            this.setCursor(this.hoverCursorType())
        } else {
            this.setCursor(null)
        }
        return this
    }

    // --- mouse ---

    mouseMoveTracker (event) {
        //console.log("mouse pos: ", event.clientX, " x ", event.clientY)
        if (this.delegate()) {
            this.delegate().didDragDivider(Math.floor(event.clientX), Math.floor(event.clientY))
        }
    }

    mouseUpTracker (event) {
        //console.log("mouse pos: ", event.clientX, " x ", event.clientY)
        this.onMouseUp(event)
    }

    setIsDragging (b) {
        this._isDragging = b;
        if (b) {
            this.setBackgroundColor(this.dragColor())
            this.parentView().setBorder("1px dashed white")
        } else {
            this.setBackgroundColor(this.normalColor())
            this.parentView().setBorder("0px dashed white")
        }
        return this
    }

    onMouseDown (event) {
        //this.debugLog(" onMouseDown")
        this.setIsDragging(true)

        this.removeParentTracking()
        return false
    }

    addParentTracking () {
        const r = this.documentBodyView()
        r.element().removeEventListener("mousemove", this._mouseMoveTrackerFunc, false);
        r.element().removeEventListener("mouseup", this._mouseUpTrackerFunc, false);
        return this
    }

    removeParentTracking () {
        const r = this.documentBodyView()
        r.element().addEventListener("mousemove", this._mouseMoveTrackerFunc, false);
        r.element().addEventListener("mouseup", this._mouseUpTrackerFunc, false);
        return this
    }

    onMouseMove (event) {
        return false
    }

    onMouseOver (event) {
        //this.debugLog(" onMouseOver")
        this.setIsHighlighted(true)
        return false
    }

    onMouseLeave (event) {
        //this.debugLog(" onMouseLeave")
        this.setIsHighlighted(false)
        return false
    }

    onMouseUp (event) {
        this.setIsDragging(false)
        this.addParentTracking()
        return false
    }
    
}.initThisClass()

"use strict"

/*

    DragView
    
    A view to globally drag and drop another view or data.

    Dragging Protocol

        Messages sent to the Item 
            
            - onDragItemBegin
            - onDragItemCancelled
            - onDragItemDropped   

        Messages sent to Source 
            
            - onDragSourceBegin
            - onDragSourceHover
            - onDragSourceCancelled // dropped on a view that doesn't accept it
            - onDragSourceDropped
            - onDragSourceEnd

            // using these messages avoids a bunch of conditions in the receiver 
            // the source is repsonsible for completing the drag operation
            // the DragView will set it's destination slot before calling these
            
            - onDragSourceMoveToDestination 
            - onDragSourceCopyToDestination
            - onDragSourceLinkToDestination
            
            - onDragSourceMoveToSelf
            - onDragSourceCopyToSelf
            - onDragSourceLinkToSelf
        
            
        Messages sent to Destination or Hover target 
            
            - acceptsDropHover
            - onDragDestinationEnter // not sent if destination === source
            - onDragDestinationHover
            - onDragDestinationExit
            - acceptsDropHoverComplete
            - onDragDestinationDropped
            - onDragDestinationEnd

        Messages sent by Destination to item

        onDragRequestRemove() // return true if approved


    Example use (from within a view to be dragged):

    onLongPressComplete (longPressGesture) {
        const dv = DragView.clone().setItem(this).setSource(this.column())
        dv.openWithEvent(longPressGesture.currentEvent()) // TODO: eliminate this step?
    } 

*/

window.DragView = class DragView extends DomStyledView {
    
    initPrototype () {
        // the view that will be dragged when operation is complete
        //this.newSlot("item", null)

        // the set of views that will be dragged
        this.newSlot("items", [])

        // a place for the source to store any extra info about the drag operation,
        // such as the indexes of the items
        this.newSlot("info", null)

        // the view which is the owner of the view being dragged that implements the source protocol
        this.newSlot("source", null)

        // the view on which the item is dropped
        this.newSlot("destination", null)

        this.newSlot("validOperations", new Set(["move", "copy", "link", "delete"]))

        // a list of views that self is currently hovering over
        this.newSlot("hoverViews", null)

        // start position in screen coordinates 
        this.newSlot("dragStartPos", null)

        // the drag operation type: move, copy, link, delete
        this.newSlot("dragOperation", "move").setDoesHookSetter(true)

        this.newSlot("slideBackPeriod", 0.2) // seconds
    }

    didUpdateSlotDragOperation () {
        assert(this.validOperations().has(this.dragOperation()))
    }

    init () {
        super.init()
        this.setHoverViews([])

        this.setDisplay("flex")
        this.setPosition("absolute")
        this.turnOffUserSelect()
        this.setOverflow("hidden")
        this.setMinWidthPx(10)
        this.setMinHeightPx(10)
        this.setWidth("fit-content")
        this.setMinHeight("fit-content")
        this.setOpacity(0.9)
        this.setInfo({})

        //this.setIsDebugging(true)
        return this
    }

    // operation type helpers

    isCopyOp () {
        return this.dragOperation() === "copy"
    }

    isMoveOp () {
        return this.dragOperation() === "move"
    }

    isLinkOp () {
        return this.dragOperation() === "link"
    }

    isDeleteOp () {
        return this.dragOperation() === "delete"
    }

    // ----

    setItem (aView) {
        this.setItems([aView])
        return this
    }

    item () {
        return this.items().first()
    }

    // ----

    setupView () {
        if (this.items().length === 1) {
            this.setupSingleItemView()
        } else {
            this.setupMultiItemView()
        }
        this.setZIndex(10)
        return this
    }

    setupMultiItemView () {
        const parentView = this.items().first().parentView()

        // copy parent frame
        const f = parentView.frameInDocument()
        this.setFrameInDocument(f)
        this.setBackgroundColor("transparent")

        // duplicate item subviews
        this.items().forEach(sv => {
            let dup = sv.htmlDuplicateView()
            this.addSubview(dup)
            assert(dup.hasFixedFrame())
            console.log("item dup subview frameInDocument: " + dup.frameInDocument().asString())
            console.log("item dup subview frameInParentView: " + dup.frameInParentView().asString())
        })

        const ff = this.fixedFrameFittingSubviews()
        const nf = parentView.convertFrameToDocument(ff)
        this.setFrameInDocument(nf)
        //this.setFrameInDocument(this.fixedFrameFittingSubviewsInDocument())
        //this.setBorder("1px dashed yellow")

        // make subviews inline-block
        this.subviews().forEach(sv => {
            sv.setDisplay("inline-block")
            sv.setPosition("relative")
            sv.setTop(null)
            sv.setLeft(null)
            sv.setBorder(null)
            sv.setFloat("left")
            /*
            sv.decrementFixedWidth()
            sv.decrementFixedHeight()
            sv.decrementFixedWidth()
            sv.decrementFixedHeight()
            sv.setMinAndMaxWidth(150)
            sv.setBorder("1px dashed blue")
            */
            //sv.setMinAndMaxHeight(30)
        })
        
        this.setDisplay("block")
        this.setWhiteSpace("normal")
        this.setOverflow("hidden")
        this.setWidth(null)
        this.setHeight(null)

        this.setWidth("fit-content")
        this.setHeight("fit-content")
        this.setMinAndMaxWidth(null)
        this.setMinAndMaxHeight(null)
        /*
        let maxWidth = this.items().map(v => v.frameInDocument().width()).maxValue()
        let minX = this.items().map(v => v.frameInDocument().left()).minValue()
        let minY = this.items().map(v => v.frameInDocument().top()).minValue()
        //let maxY = this.items().map(v => v.frameInDocument().bottom()).maxValue()

        //this.setMinAndMaxHeight(maxY - minY)
        let offset = minY - f.top()
        this.setTopPx(minY)

        // initial positions
        let y = 0
        this.items().map((item) => {
            const h = item.frameInDocument().height()
            const v = item.htmlDuplicateView()
            const vf = item.frameInParentView()
            v.setPosition("absolute")
            v.setLeftPx(vf.x())
            v.setTopPx(vf.y() - offset)
            v._targetTop = y
            y += h
            v.setTransition("top 0.2s")
            this.addSubview(v)
        })
        this.setMinAndMaxHeight(y)
        this.setOverflow("visible")

        setTimeout(() => {
            this.subviews().forEach(v => v.setTopPx(v._targetTop))
        }, 1)
        */

        /*
        // target positions
        let y = 0
        this.items().map((item) => {
            const h = item.frameInDocument().height()
            const v = item.htmlDuplicateView()
            const vf = item.frameInParentView()
            v.setPosition("absolute")
            v.setTopPx(y)
            y += h
            //this.addSubview(v)
        })
        this.setMinAndMaxHeight(y)
        */

    }

    setupSingleItemView () {
        const aView = this.item()
        this.setFrameInDocument(aView.frameInDocument())
        this.setInnerHTML(aView.innerHTML())
        //const clonedElement = aView.element().cloneNode(true);
        this.setOverflow("visible")
    }

    // --- 

    hasPan () {
        return !Type.isNull(this.defaultPanGesture())
    }

    openWithEvent (event) {
        // TODO: this is a hack, find a way to init pan without this
        // setup the Pan Gesture to already be started

        const pan = this.addDefaultPanGesture()
        pan.setShouldRemoveOnComplete(true)
        pan.setMinDistToBegin(0)
        pan.onDown(event)
        pan.attemptBegin()

        this.setTransition("all 0s, transform 0.1s, box-shadow 0.1s")
        this.open()
        
        return this
    }

    acceptsPan () {
        return true
    }

    // --------------------------

    open () {        
        this.setupView()
        DocumentBody.shared().addSubview(this)
        this.orderFront()
        this.onBegin()
        return this
    }

    onBegin () {
        this.sendProtocolMessage(this.source(), "onDragSourceBegin")
    }
    
    // --- panning ---

    onPanBegin (aGesture) {
        this.debugLog("onPanBegin")
        this.setDragStartPos(this.item().positionInDocument())

        // animate the start of the drag

        this.addTimeout(() => {
            this.addPanStyle()
        })

        this.onPanMove(aGesture)
    }

    updatePosition () {
        const newPosition = this.dragStartPos().add(this.defaultPanGesture().diffPos()) 
        this.setLeftPx(newPosition.x())
        this.setTopPx(newPosition.y())
    }

    onPanMove (aGesture) {
        this.updatePosition()
        
        this.addTimeout(() => { 
            this.hoverOverViews()
        })
    }

    onPanCancelled (aGesture) {
        const destFrame = this.source().dropCompleteDocumentFrame()

        const completionCallback = () => { 
            this.sendProtocolMessage(this.source(), "onDragSourceCancelled")
            this.sendProtocolMessage(this.source(), "onDragSourceEnd")
            this.close() 
        }

        this.animateToDocumentFrame(destFrame, this.slideBackPeriod(), completionCallback)
        this.removePanStyle()
    }

    firstAcceptingDropTarget () {
        return this.hoverViews().detect((v) => {
            return v.acceptsDropHoverComplete && v.acceptsDropHoverComplete(this)
        })
    }

    currentOperation () {
        const keyboard = BMKeyboard.shared()

        if (keyboard.alternateKey().isDown()) {
            return "copy"
        }

        if (keyboard.alternateKey().isDown()) {
            return "link"
        }

        return "move"
    }

    onPanComplete (aGesture) {
        this.debugLog("onPanComplete")

        //this.setDragOperation(this.currentOperation())

        const destView = this.firstAcceptingDropTarget()
        
        if(!destView) {
            this.onPanCancelled(aGesture)
            return;
        }

        const isSource = (destView === this.source())

        this.setDestination(destView)

        if (destView) {
            const completionCallback = () => {
                this.sendProtocolAction(destView, "Dropped") // onDragSourceDropped onDragDestinationDropped

                this.sendProtocolMessage(this.source(), "onDragSourceEnd")
                if (destView !== this.source()) {
                    this.sendProtocolMessage(destView, "onDragDestinationEnd")
                }

                this.close()
            }
            const destFrame = destView.dropCompleteDocumentFrame()
            this.animateToDocumentFrame(destFrame, this.slideBackPeriod(), completionCallback)
            this.removePanStyle()
            this.hoverViews().remove(destView) // so no exit hover message will be sent to it
        } else {
            this.close()
        }
    }

    // --- hovering behaviors ---

    viewsUnderDefaultPan () {
        return DocumentBody.shared().viewsUnderPoint(this.dropPoint())
    }

    dropPoint () {
        return this.defaultPanGesture().currentPosition()
    }

    newHoverViews () {
        //console.log("dropPoint: " + this.dropPoint().asString())
        return this.viewsUnderDefaultPan().select(v => v.acceptsDropHover && v.acceptsDropHover(this))
    }

    hoverOverViews () {
        const oldViews = this.hoverViews()
        const newViews = this.newHoverViews()

        // if new view was not in old one's, we must be entering it
        const enteringViews = newViews.select(v => !oldViews.contains(v))

        // if new view was in old one's, we're still hovering
        const hoveringViews = newViews.select(v => oldViews.contains(v))

        // if old view isn't in new ones, we must have exited it
        const exitingViews = oldViews.select( v => !newViews.contains(v))
 
        // onDragSourceEnter onDragDestinationEnter 
        enteringViews.forEach(aView => this.sendProtocolAction(aView, "Enter"))

        // onDragSourceHover onDragDestinationHover
        hoveringViews.forEach(aView => this.sendProtocolAction(aView, "Hover"))

        // onDragSourceExit onDragDestinationExit 
        exitingViews.forEach(aView =>  this.sendProtocolAction(aView, "Exit")) 

        this.setHoverViews(newViews)
        return this
    }

    exitAllHovers () {
        this.hoverViews().forEach((aView) => { this.sendProtocolAction(aView, "Exit") })
        this.setHoverViews([])
    }

    // drop hover protocol

    sendProtocolAction (aView, action) {
        // onDragSourceHover & onDragDestinationHover
        const isSource = aView === this.source()
        const methodName = "onDrag" + (isSource ? "Source" : "Destination") + action
        //this.debugLog(aView.node().title() + " " + methodName)
        this.sendProtocolMessage(aView, methodName)
    }

    sendProtocolMessage (receiver, methodName) {
        if (!methodName.contains("Hover") && this.isDebugging()) {

            let msg = receiver.typeId() + " " + methodName 

            if (methodName.contains("Dropped")) {
                msg += " " + this.dragOperation()
            }
    
            if (!receiver[methodName]) {
                msg += " <<<<<<<<<<<<<< NOT FOUND "
            }

            this.debugLog(msg)
        }

        if (receiver[methodName]) {
            receiver[methodName].apply(receiver, [this])
        }
    }
    
    // close

    close () {
        this.debugLog("close")
        // handle calling this out of seqence?

        this.exitAllHovers()
        // TODO: animate move to end location before removing

        this.removePanStyle()
        DocumentBody.shared().removeSubview(this)
        return this
    }


    // --- drag style ---

    addPanStyle () {
        const s = "0px 0px 10px 10px rgba(0, 0, 0, 0.5)"
        const r = 1.05 // 1.1 * (1/Math.sqrt(this.items().length))
        this.setTransform("scale(" + r + ")")
        if (this.subviews().length) {
            this.subviews().forEach(v => v.setBoxShadow(s))
        } else {
            this.setBoxShadow(s)
        }
        return this
    }

    removePanStyle () {
        const s = "none"
        this.setTransform("scale(1)")
        if (this.subviews().length) {
            this.subviews().forEach(v => v.setBoxShadow(s))
        } else {
            this.setBoxShadow(s)
        }
        return this
    }

}.initThisClass()

"use strict"

/*

    PanelView

*/

window.PanelView = class PanelView extends DomView {
    
    initPrototype () {
        this.newSlot("titleView", null)
        this.newSlot("subtitleView", null)
        this.newSlot("button1", null)
        this.newSlot("isDragging", false)
    }

    init () {
        super.init()
        this.setPosition("absolute")
        this.setTitleView(TextField.clone().setDivClassName("PanelTitleView"))
        this.addSubview(this.titleView())
        this.titleView().setTextAlign("center")
        this.titleView().setHeight("3em")
        this.titleView().setWhiteSpace("normal")
        this.titleView().centerInParentView()
        this.titleView().setValue("hello")
        this.titleView().setColor("white")

        //this.setSubtitleView(TextField.clone().setDivClassName("PanelSubtitleView"))
        //this.addSubview(this.subtitleView())

        this.setButton1(ButtonView.clone())
        this.addSubview(this.button1())
        this.button1().setPosition("absolute").setRightPx(10).setBottomPx(10)
        this.button1().setMinAndMaxWidth(100)
        this.button1().setTitle("OK")
        this.button1().setTarget(this).setAction("hitButton1")

        this.setMinAndMaxWidth(500)
        this.setMinAndMaxHeight(200)
        this.setBackgroundColor("black")
        //this.setBorder("1px solid #ccc")
        this.setPosition("absolute")
        this.setLeftPx(0)
        this.setTopPx(0)
        //this.setupForDraggingWithMouse()
        this.setBorderRadiusPx(5)
        this.centerInParentView()

        this._mouseMoveTrackerFunc = (event) => {
            this.mouseMoveTracker(event)
        }

        /*
        this._mouseUpTrackerFunc = (event) => {
            //
        }
        */

        return this
    }

    setTitle (s) {
        this.titleView().setValue(s)
        return this
    }


    // --- dragging ---

    setupForDraggingWithMouse () {
        this.setIsRegisteredForMouse(true)
    }

    mouseMoveTracker (event) {
        //console.log("mouse pos: ", event.clientX, " x ", event.clientY)
        if (this.isDragging()) {
            this.setLeftPx(event.clientX - (this._startClientX - this._startLeft))
            this.setTopPx(event.clientY  - (this._startClientY - this._startTop))
        }
    }

    onMouseDown (event) {
        //console.log("onMouseDown")
        this.setIsDragging(true)

        this.parentView().element().addEventListener("mousemove", this._mouseMoveTrackerFunc, false);

        this._startLeft = this.left()
        this._startTop = this.top()
        this._startClientX = event.clientX
        this._startClientY = event.clientY
    }

    onMouseMove (event) {
    }

    onMouseUp (event) {
        this.setIsDragging(false)
        //this.setBackgroundColor(this.normalColor())
        this.parentView().element().removeEventListener("mousemove", this._mouseMoveTrackerFunc, false);
    }

    hitButton1 () {
        this.close()
        return this
    }

    close () {
        this.removeFromParentView()
        return this
    }
    
}.initThisClass()

"use strict"

/*

    SvgIconView

    A view to render scalable SVG within a view that can be 
    synced to match the color of the parent view's text color by
    getting the computed color and applying it to the fill or stroke of the
    svg views.

    TODO: support disabled/uneditable color style?


    Example use:

    SvgIconView.clone().setIconName("add")

*/


window.SvgIconView = class SvgIconView extends DomView {
    
    initPrototype () {
        this.newSlot("doesMatchParentColor", false)
        this.newSlot("svgString", "")
        this.newSlot("url", null)
        this.newSlot("iconName", null)
        this.newSlot("strokeColor", "white")
        this.newSlot("fillColor", "transparent")
        this.newSlot("strokeWidth", 1)
    }

    init () {
        super.init()
        this.setDisplay("flex")
        this.setPosition("relative")
        this.setDivClassName("SvgIconView")
        this.turnOffUserSelect()
        this.setOverflow("hidden")

        //this.setPosition("absolute")
        //this.setTopPx(0)
        //this.setLeftPx(0)

        this.setPadding("0em")
        this.setMargin("0em")
        
        this.setOverflow("hidden")
        this.setTransition("all 0.2s")
        return this
    }

    debugTypeId () {
        super.debugTypeId() + "'" + this.iconName() 
    }

    setIconName (name) {
        this._iconName = name

        if (name) {
            const iconNode = BMIconResources.shared().firstSubnodeWithTitle(name)

            if (iconNode) {
                this.setSvgString(iconNode.svgString())
                this.unhideDisplay()
            } else {
                this.setSvgString(null)
                //throw new Error("can't find icon '" + name + "'") 
            }
        } else {
            this.setSvgString(null)
            this.hideDisplay()
        }

        return this
    }

    setSvgString (s) {
        this._svgString = s
        this.setInnerHTML(s)
        this.updateAppearance()
        /*
        const style = this.svgElement().style
        //this.svgElement().setAttribute("preserveAspectRatio", "xMidYMin slice")

        if (Type.isUndefined(style)) {
            console.warn("missing style on svgElement")
        } else {
            style.position = "absolute"
            //style.top = "0em"
            //style.left = "0em"
        }
        */
        return this
    }

    svgElement () {
        return this.element().childNodes[0]
    }

    // didUpdateSlot

    setColor (aColor) {
        this.setFillColor(aColor)
        this.setStrokeColor(aColor)
        return this
    }

    didUpdateSlotFillColor (oldValue, newValue) {
        this.updateAppearance()
    }

    didUpdateSlotStrokeColor (oldValue, newValue) {
        this.updateAppearance()
    }

    // svg icon

    updateAppearance () {
        // sent by superview when it changes or syncs to a node
        // so we can update our appearance to match changes to the parent view's style

        const e = this.element()

        if (this.doesMatchParentColor()) {
            if (this.parentView()) {
                const color = this.parentView().getComputedCssAttribute("color")
                Element_setStyleIncludingDecendants(e, "fill", color)
                Element_setStyleIncludingDecendants(e, "stroke", color)
            } else {
                console.warn("missing svg parentView to match color to")
            }
        } else {
            Element_setStyleIncludingDecendants(e, "fill", this.fillColor())
            Element_setStyleIncludingDecendants(e, "stroke", this.strokeColor())
        }

        Element_setStyleIncludingDecendants(e, "strokeWidth", this.strokeWidth().toString())
        Element_setStyleIncludingDecendants(e, "transition", this.transition())

        return this
    }

    /*
    setupBackground () {
        // can't use this because we can't walk and set the fill/stroke style on the svg elements 
        // if it's a background image

        const url = this.pathForIconName(this.iconName())

        this.setBackgroundImageUrlPath(url)
        this.setBackgroundSizeWH(16, 16) // use "contain" instead?
        this.setBackgroundPosition("center")
        this.makeBackgroundNoRepeat()
        Element_setStyleIncludingDecendants(this.element(), "fill", "white")
        Element_setStyleIncludingDecendants(this.element(), "stroke", "white")
        Element_setStyleIncludingDecendants(this.element(), "color", "white")
    }

    asyncLoad () {
        // can't do this on a file:// because of cross site request error
        const url = this.pathForIconName(this.iconName())
        const rawFile = new XMLHttpRequest();
        rawFile.open("GET", url, false);
        rawFile.onreadystatechange = function () {
            if(rawFile.readyState === 4) {
                if(rawFile.status === 200 || rawFile.status === 0) {
                    const data = rawFile.responseText;
                    this.setSvgString(data)
                }
            }
        }
        rawFile.send(null);
    }
    */

}.initThisClass()

"use strict"

/*

    TextField
    
    A view for a single line of text. 
    For multi-line text, use TextArea.
    
    Behavior:
    On Return/Enter key, it passes focus to the nextResponder/parent.

*/

window.TextField = class TextField extends DomStyledView {
    
    initPrototype () {
        this.newSlot("selectedColor", null)
        this.newSlot("unselectedColor", null)
        this.newSlot("doesClearOnReturn", false)
        this.newSlot("doesHoldFocusOnReturn", false)
        this.newSlot("doesTrim", false)
        this.newSlot("didTextInputNote", null)
        this.newSlot("didTextEditNote", null)
        this.newSlot("doesInput", false)
        this.newSlot("allowsSetStringWhileFocused", false)
        //this.newSlot("hasBackground", false)

        // has to start false for proper state setup
        this.newSlot("usesDoubleTapToEdit", false) 

        // need to separate from contentEditable since we want to override when usesDoubleTapToEdit is true.
        this.newSlot("isEditable", false).setOwnsSetter(true).setDoesHookSetter(true)

        this.newSlot("editableBorder", "1px solid rgba(255, 255, 255, 0.2)")
        this.newSlot("uneditableBorder", "none")
        this.newSlot("showsBorderWhenEditable", false)
    }

    init () {
        super.init()
        this.setDisplay("flex")
        this.setJustifyContent("flex-start")
        this.setAlignItems("flex-start")
        this.turnOffUserSelect()
        this.setWhiteSpace("pre-wrap")
        this.setWordWrap("normal")
        this.setOverflow("hidden")
        this.setOverflowWrap("normal")
        this.setTextOverflow("ellipsis")
        this.setWordBreak("keep-all")
        this.setSpellCheck(false)
        this.setMinWidth(10)
        this.setPaddingLeft("0.5em")
        this.setPaddingRight("0.5em")
        this.setPaddingTop("0.3em")
        this.setPaddingBottom("0.3em")
        this.setLineHeight("1.15em")
        this.setMinHeight("1em")
		
        //this.setUnfocusOnEnterKey(true)
        //this.setIsRegisteredForKeyboard(true) // gets set by setContentEditable()
        this.formatValue()

        //this.setDidTextInputNote(BMNotificationCenter.shared().newNote().setSender(this).setName("didTextInput"))
        //this.setDidTextEditNote(BMNotificationCenter.shared().newNote().setSender(this).setName("didTextEdit"))

        //this.setIsDebugging(true)
        this.lockedStyleAttributeSet().add("backgroundColor")
        return this
    }

    setPaddingTop (v) {
        if (v === "0.6em") {
            console.log(this.value() + " setPaddingTop " + v)
        }
        return super.setPaddingTop(v)
    }

    // editing control

    /*
    setIsEditable (aBool) {
        if (this._isEditable !== aBool) {
            this._isEditable = aBool
            this.syncEditingControl()
        }
        return this
    }

    
    isEditable () {
        return this._isEditable
    }
    */
    
    didUpdateSlotIsEditable () {
        this.syncEditingControl()
    }

    setUsesDoubleTapToEdit (aBool) {
        if (this._usesDoubleTapToEdit !== aBool) {
            this._usesDoubleTapToEdit = aBool
            this.syncEditingControl()
        }
        return this
    }

    syncBorder () {
        let b = this.uneditableBorder()

        if (this.isEditable()) {
            if (this.showsBorderWhenEditable()) {
                b = this.editableBorder()
            }
        }
        this.setBorder(b)
        return this
    }

    syncEditingControl () {
        this.syncBorder()

        if (this.isEditable()) {
            if (this.usesDoubleTapToEdit()) {
                this.addDefaultDoubleTapGesture()
                this.setContentEditable(false)
            } else {
                this.setContentEditable(true)
            }
        } else {
            if (this.usesDoubleTapToEdit()) {
                this.removeDefaultDoubleTapGesture()
            }
            this.setContentEditable(false)
        }

        return this
    }

    /*
    onDoubleTapRequestCancel (aGesture, requestingGesture) {
        //return false
    }

    onDoubleTapCancelled (aGesture) {
        //console.log(this.value() + " onDoubleTapCancelled")
    }
    */

    onDoubleTapComplete (aGesture) {
        //console.log(this.value() + " onDoubleTapComplete")
        // make content editable and select text
        //this.debugLog(".onDoubleTapComplete()")
        if (this.contentEditable()) {
            return this
        }
        this.setContentEditable(true)
        this.focus()
        this.selectAll()
        this.pauseGestures()
        //this.focus()
        //this.setBorder("1px dashed white")
        return this
    }

    pauseGestures () {
        GestureManager.shared().setIsPaused(true) // so things like text selection don't trigger gestures
    }

    onFocusIn () {
        super.onFocusIn()
        //console.log(this.typeId() + " '" + this.string() + "' onFocusIn")
        if (this.contentEditable()) {
            this.pauseGestures()
        }
    }

    onFocusOut () {
        super.onFocusOut()
        //console.log(this.typeId() + " '" + this.string() + "' onFocusOut")
        GestureManager.shared().setIsPaused(false)
    }

    onBlur () {
        //console.log(this.value() + " onBlur")
        super.onBlur()
        if (this.usesDoubleTapToEdit()) {
            this.setContentEditable(false)
            this.setBorder("none")
            this.turnOffUserSelect()
        }
    }

    setPxFontSize (aNumber) {
        super.setPxFontSize(aNumber)
        this.setMinAndMaxHeight(aNumber + 2) // make sure TextfField can fit font size
        this.didEdit()
        return this
    }

    setContentEditable (aBool) {
        super.setContentEditable(aBool)
        //this.debugLog(".setContentEditable(" + aBool + ") = ", this.contentEditable())
        //this.setIsRegisteredForClicks(this.contentEditable())  // is this needed after move to tap?
        return this
    }
	
    returnStrings () {
        return ["<div><br></div>", "<br><br>"]
    }
	
    containsReturns () {
        const value = this.value() // correct?
        return returnStrings.detect(returnString => value.contains(returnString))		
    }
	
    // ------------------

    setValue (newValue) {
        return this.setString(newValue)
    }

    value () {
        // this.element().text ?
        return this.string()
    }

    
    setString (newValue) {
        if (Type.isNullOrUndefined(newValue)) {
            newValue = ""
        }

        const oldValue = this.string()
        //let newValue = this.visibleValue()
        if (oldValue !== newValue) {

            if (this.isFocused()) {
                if (this.allowsSetStringWhileFocused()) {
                    super.setString(newValue)
                } 
                //throw new Error("attempt to call TextField.setString while it's focused")

            } else {
                //this.isFocused()
                super.setString(newValue)
            }
            
            /*
            this.debugLog(" setString(")
            console.log("    old: '" + oldValue + "'")
            console.log("    new: '" + newValue + "'")
            console.log("---")
            */
            
        }
        return this
    }

    // ------------------

    adjustFontSizeWithKeyboard () {
        const kb = BMKeyboard.shared()
        const controlDown   = kb.controlKey().isDown()
        const equalSignDown = kb.equalsSignKey().isDown()
        const minusDown     = kb.minusKey().isDown()

        // adjust font size (testing this out)
        if (controlDown) {
            const fontSize = this.computedFontSize()

            if (equalSignDown) {
                this.setPxFontSize(fontSize + 1)
            } else if (minusDown) {
                if (fontSize > 1) { 
                    this.setPxFontSize(fontSize - 1)
                }
            }
        }
        return this
    }
    
    onKeyUp (event) {
        //this.debugLog(" onKeyUp ", event)
        //this.adjustFontSizeWithKeyboard()
        super.onKeyUp(event)
        //this.debugLog(" onKeyUp value: [" + this.value() + "]")
        this.didEdit()
        return false
    }

    onAlternateEnterKeyUp (event) {
        console.log(this.typeId() + " onAlternateEnterKeyDown")
        //this.insertEnterAtCursor()
        //this.afterEnter()
    }

    insertEnterAtCursor (event) {
        if (this.isFocused()) {
            this.insertTextAtCursor("\n")
        }   
    }

    /*
    onKeyDown (event) {
        let result = super.onKeyDown(event)
        console.log("event.keyCode = ", event.keyCode)
        return result
    }
    */

    
    onEnterKeyDown (event) {    
        // insert 2 returns as cursor won't go to the second line with 1
        document.execCommand('insertHTML', false, "\n\n");
        // prevent the default behaviour of return key pressed
        return false;
    }
    

    onEnterKeyUp (event) {
        if (!this.doesInput()) {
            //this.insertEnterAtCursor()
            return
        }
	    //this.debugLog(".onEnterKeyUp()")
	    //this.didEdit()

        this.formatValue()
        this.afterEnter()
    }


    onEscapeKeyDown (event) {
        this.releaseFirstResponder()
        event.stopPropagation()
        return false
    }

    afterEnter (event) {
        this.tellParentViews("didInput", this) 
            
        if (!this.doesHoldFocusOnReturn()) {
            this.releaseFirstResponder()
        }
        
        if (this.doesClearOnReturn()) {
            this.setInnerHTML("")
            //this.focusAfterDelay(.125) // hack to get focus back after chat view scrolling - TODO: fix this
        }

        if (this.didTextInputNote()) {
            this.didTextInputNote().post()
        }
        
        event.stopPropagation()
        return false
    }
	
    formatValue () {
	    const oldValue = this.innerHTML()
	    let newValue = this.innerText() // removes returns
        
        if (this.doesTrim()) {
            newValue = newValue.trim()
        } 

        if (true) {
            //newValue.replaceAll("\n", "<br>")
        }
        
        
        if (newValue !== oldValue) {
            this.debugLog("formatValue newValue !== oldValue")
            this.debugLog(" newValue: [" + newValue + "]")
            this.setInnerHTML(newValue)
            this.didEdit()
        }
	    //console.trace(this.type() + " formatValue '" + oldValue + "' -> '" + this.innerHTML() + "'")
        //this.debugLog(" after formatValue: '" + this.innerHTML() + "'")
        return this
    }
    
    /*
    setInput (s) {
        const n = this.node()
        if (n) {
            const m = n.nodeInputFieldMethod()
            if (m) {
                n[m].apply(n, [s])
            }
        }
        return this
    }
    
    */

    activate () {
        if (this.usesDoubleTapToEdit()) {
            this.onDoubleTapComplete()
        } else {
            this.focus()
        }
        return this
    }
    
    onClick (event) {
        // needed to prevent click-to-edit event from selecting the background row
        //this.debugLog(".onClick()")

        if (this.contentEditable()) {
            this.sendActionToTarget()
            event.stopPropagation()
            return false
        }

        return super.onClick(event)
    }

    didEdit () {
        super.didEdit()
        return this
    }
    
    setBorder (v) {
        /*
        if (this.value() === "a") {
            console.log("break")
        }
        */
        return super.setBorder(v)
    }

    setBackgroundColor (aColor) {
        super.setBackgroundColor(aColor)
        return this
    }

}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "BMDataUrl.js",
])


"use strict"

/*
    BMDataUrl

    exmaples of setting up a dataTransfer for a drag out of browser event:

        event.dataTransfer.setData("DownloadURL", "application/json:hello.json:data:application/json;base64," + btoa("[1,2,3]"));
        event.dataTransfer.setData("DownloadURL", "text/plain:hello.txt:data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D");
*/

window.BMDataUrl = class BMDataUrl extends ProtoClass {
    
    initPrototype () {
        this.newSlot("dataUrl", null) // for drop
        this.newSlot("transferMimeType", "DownloadURL") // for drag
        this.newSlot("fileName", "file.txt") // for drag
        this.newSlot("mimeType", null)
        this.newSlot("decodedData", "") // non-base64 version
    }

    mimeTypeDescription () {
        const mimeType = this.mimeType()
        if (mimeType) {
            const name = this.mimeTypeToFileSuffixDict()[mimeType]
            if (name) {
                return name
            }
            return mimeType
        }
        return null
    }

    isXml () {
        return this.mimeType() === "application/xml"
    }

    isJson () {
        return this.mimeType() === "application/json"
    }

    isText () {
        return this.mimeType() === "text/plain"
    }

    isHtml () {
        return this.mimeType() === "text/html"
    }

    mimeTypeToFileSuffixDict () {
        return {
            "application/json" : "json",
            "application/xml" : "xml",
            "text/javascript" : "js",
            "text/plain" : "txt", 
            "text/html" : "html", 
            //"text/uri-list" 
        }
    }

    /*
    validMimeTypeSet () {
        return new Set([
            "application/json",
            "text/javascript",
            "text/plain", 
            "text/html", 
            "text/uri-list" 
        ])
    }
    */

   dataUrlString () {
        // e.g.: "application/json:hello.json:data:application/json;base64," + btoa("[1,2,3]"));
        const header = this.mimeType() + ":" + this.fileName() + ":data:" + this.mimeType() + ";base64,"  
        const content = btoa(this.decodedData())
        const s = header + content
        return s
    }

    setDataUrlString (dataUrl) {
        const type = dataUrl.before(":")
        assert(type === "data")
        const afterData = dataUrl.after("data:")
        const mimeType = afterData.before(";")
        const encodedData = afterData.after("base64,")
        const decodedData = encodedData.base64Decoded()
        
        this.setDataUrl(dataUrl)
        this.setMimeType(mimeType)
        this.setDecodedData(decodedData)
        return this
    }

    /*
    attachToEvent (event) {
        event.dataTransfer.setData(this.transferMimeType(), this.dataUrlString())
    }
    */

}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "styles/_imports.js",
    "SubnodesArray.js",
    "BMNode.js",
	
    "storage/_imports.js",
    "nodes/_imports.js",
    "fields/_imports.js",
    "storage/inspectors/BMDataStoreRecord.js", // because this is a subclass of BMFieldSetNode
    
    "node_views/_imports.js",

    "blobs/_imports.js",
    "network/_imports.js",

    "App.js"
])

"use strict"

ResourceLoader.pushRelativePaths([
    "BMViewStyles.js",
    "BMViewStyle.js",
])

"use strict"

/*

    BMViewStyles

    Represents the set of styles for a NodeView, e.g. selected, unselected.

    The basic idea is that both View and Nodes can own styles.
    Views will use their own style (or the style of some parent such as a row using a column rowStyle),
    unless their node specifies a style, which overrides the view's own style.

    See DomStyledView and BrowserRow to understand how Views lookup/access/change their style state.

    TODO: can we make view styles nodes? recursion?

    rowStyles: 
    
    Because rows need to be able to use the background and select colors of their columns,

    Row colors are looked up in:
    BrowserRow.lookedUpStyles

        which asks the node, then itself, then the columns for rowStyles()
        and uses the first non-null result .

 
*/


window.BMViewStyles = class BMViewStyles extends ProtoClass {
    
    initPrototype () {
        this.newSlot("name", "")
        this.newSlot("unselected", null)
        this.newSlot("selected", null) // aka focused
        this.newSlot("disabled", null)
        //hover: null, 
        //enabled: null,
        //error: null,
        this.newSlot("isMutable", true)
    }

    init () {
        super.init()
        this.setSelected(BMViewStyle.clone())
        this.setUnselected(BMViewStyle.clone())
        this.setDisabled(BMViewStyle.clone())
        //this.setHover(BMViewStyle.clone())
        return this
    }

    states () {
        return [this.unselected(), this.selected()]
    }

    isEmpty () {
        return this.states().detect(state => !state.isEmpty()) === null
    }

    sharedBlackOnWhiteStyle () {
        if (!BMViewStyles._sharedBlackOnWhiteStyle) {
            const vs = BMViewStyles.clone()
            vs.setToBlackOnWhite()
            vs.setIsMutable(false)
            vs.setName("BlackOnWhite")
            BMViewStyles._sharedBlackOnWhiteStyle = vs
        }
        return BMViewStyles._sharedBlackOnWhiteStyle
    }

    sharedWhiteOnBlackStyle () {
        //return this.sharedBlackOnWhiteStyle()
        if (!BMViewStyles._sharedWhiteOnBlackStyle) {
            BMViewStyles._sharedWhiteOnBlackStyle = BMViewStyles.clone().setToWhiteOnBlack().setIsMutable(false).setName("WhiteOnBlack")
        }
        return BMViewStyles._sharedWhiteOnBlackStyle
    }

    setToBlackOnWhite () {
        assert(this.isMutable())
        this.unselected().setColor("black")
        this.unselected().setBackgroundColor("white")
        this.unselected().setBorderBottom("1px solid #ddd") 

        this.selected().setColor("black")
        this.selected().setBackgroundColor("#eee")
        this.selected().setBorderBottom("1px solid rgba(255, 255, 255, 0.1)") // "1px solid #ddd"

        /*
        this.disabled().setColor("black")
        this.disabled().setBackgroundColor("#eee")
        this.disabled().setBorderColor("transparent")
        */

        return this
    }

    setToWhiteOnBlack () {
        assert(this.isMutable())
        this.unselected().setColor("#ccc")
        this.unselected().setBackgroundColor("#191919")
        this.unselected().setBorderBottom("none") 

        this.selected().setColor("white")
        this.selected().setBackgroundColor("#333") // change for column?
        this.selected().setBorderBottom("none")

        /*
        this.disabled().setColor("#aaa")
        this.disabled().setBackgroundColor("black")
        this.disabled().setBorderColor("transparent")
        */
        return this
    }
    
    /*
    setToGrayOnTransparent () {        
        assert(this.isMutable())
        this.unselected().setColor("#aaa")
        this.unselected().setBackgroundColor("transparent")
        
        this.selected().setColor("white")
        this.selected().setBackgroundColor("transparent")        
        return this
    }
    */
    
    copyFrom (styles, copyDict) {
        assert(this.isMutable())
        this.selected().copyFrom(styles.selected(), copyDict)
        this.unselected().copyFrom(styles.unselected(), copyDict)
        return this
    }
    
    setBackgroundColor (c) {
        this.selected().setBackgroundColor(c)
        this.unselected().setBackgroundColor(c)
        return this        
    }
    
    setColor (c) {
        this.selected().setColor(c)
        this.unselected().setColor(c)
        return this        
    }
    
}.initThisClass()

"use strict"

/*

    BMViewStyle

    Representation of a single style state (a example of a state is "selected").

    See BMViewStyles for docs.
 
*/

window.BMViewStyle = class BMViewStyle extends ProtoClass {
  
    static styleNames () {
        return  [
            "color", 
            "backgroundColor", 
            "opacity", 

            "borderLeft", 
            "borderRight", 
            "borderTop", 
            "borderBottom",

            "borderWidth", 
            "borderColor", 
            "borderRadius",

            "fontFamily",
            "fontWeight",
            "fontSize",
            "lineHeight",
            "letterSpacing",
        ]
    }

    initPrototype () {
        this.newSlot("name", "")

        // use same names as css style, nulls aren't applied
        const styleNames = this.thisClass().styleNames()
        this.newSlot("styleNames", styleNames)
        styleNames.forEach(k => this.newSlot(k, null))
    }

    init () {
        super.init()
        return this
    }

    isEmpty () {
        return this.styleNames().detect(s => s != null) === null
    }

    description () {
        const parts = []
		
        this.styleNames().forEach( (name) => { 
            const v = this[name].apply(this)
            if (!Type.isNull(v)) {
                parts.push(name + ":" + v)
            }
        })	
		
        return "{" + parts.join(", ") + "}"	
    }
	
    copyFrom (aViewStyle, copyDict) {
        aViewStyle.applyToView(this) // we're not a view but this works since we use the same methods/protocol
        return this
    }
	
    applyToView (aView) {		
        this.styleNames().forEach( (name) => { 
            const getterMethod = this[name]
            if (!getterMethod) {
                const errorMsg = "missing getter method: " + this.type() + "." + name + "()"
                console.warn(errorMsg)
                throw new Error(errorMsg)
            }
            const v = getterMethod.apply(this)
            if (v != null) {
                aView[aView.setterNameForSlot(name)].apply(aView, [v])
            }
        })
		
        return this
    }
    
}.initThisClass()

"use strict"

/*

    SubnodesArray

    Just here to avoid name changes for array type used in BMNode.

*/



window.SubnodesArray = class SubnodesArray extends SortedArray {


}
"use strict"

/*

    BMNode
 
    The base class of model objects that supports the protocol 
    used to sync with views (subclasses of NodeView).

    The BMStorableNode subclass is used to sync the model to
    the persistence system.


        Notifications (intended for views):

            - didUpdateNode // lets views know they need to scheduleSyncFromNode
            - shouldFocusSubnode // request that the UI focus on the sender

        Update messages sent to self:
            - didUpdateSlotParentNode(oldValue, newValue)
            
            - didChangeSubnodeList // hook to resort if needed and call didReorderParentSubnodes
            - prepareForFirstAccess // sent to self on first access to subnodes
            - prepareToAccess // sent to sent whenever a subnode is accessed

        Update messages sent to parent:
            - didUpdateNode // let parent know a subnode has changed

        Update messages sent to subnodes:
            - didReorderParentSubnodes // sent on subnode order change

        Protocol helpers:
            - watchOnceForNote(aNote) // typically used to watch for appDidInit

*/

window.BMNode = class BMNode extends ProtoClass {
    
    static availableAsNodePrimitive() {
        return true
    }

    static primitiveNodeClasses () {
        const classes = BMNode.allSubclasses()
        return classes.filter(aClass => aClass.availableAsNodePrimitive())
    }

    // --- for CreatorNode Prototypes ---

    static visibleClassName () {
        let name = this.type()
        name = name.sansPrefix("BM")
        name = name.sansSuffix("Field")
        name = name.sansSuffix("Node")
        return name
    }

    static availableAsNodePrimitive () {
        return false
    }

    static nodeCreate () {
        // we implemnet this on BMNode class and prototype so 
        // it works for both instance and class creator prototypes
        return this.clone()
    }

    static nodeCreateName () {
        return this.visibleClassName()
    }

    // --- mime types ---

    static canOpenMimeType (mimeTypeString) {
        return false
    }

    static openMimeChunk (dataChunk) {
        return null
    }

    // ----

    initPrototype () {
        
        // row view summary

        this.newSlot("title", null).setDuplicateOp("copyValue")
        
        {
            const slot = this.newSlot("nodeType", null)
            slot.setCanInspect(true)
            slot.setLabel("type")
            slot.setSlotType("String")
            //slot.setInspectorPath("Subtitle")
            slot.setCanEditInspection(false)
        }

        {
            const slot = this.newSlot("subtitle", null)
            slot.setDuplicateOp("copyValue")
            slot.setCanInspect(true)
            slot.setLabel("value")
            slot.setSlotType("String")
            slot.setInspectorPath("Subtitle")
        }

        this.newSlot("note", null).setDuplicateOp("copyValue")

        {
            const slot = this.newSlot("noteIconName", null)
            slot.setDuplicateOp("copyValue")
            slot.setCanInspect(true)
            slot.setLabel("icon")
            slot.setSlotType("String")
            slot.setValidValuesClosure(() => BMIconResources.shared().iconNames())
            slot.setInspectorPath("Note")
        }


        //this.newSlot("isDebuggingPersistence", false)

        // parent node, subnodes

        this.newSlot("parentNode", null)
        this.newSlot("nodeCanReorderSubnodes", false)
        this.newSlot("subnodes", null).setInitProto(SubnodesArray).setDoesHookSetter(true)
        this.newSlot("shouldStoreSubnodes", true).setDuplicateOp("duplicate") //.setShouldStore(true)
        this.newSlot("subnodeClasses", []) //.setInitProto([]) // ui will present creator node if more than one option

        // notification notes

        this.newSlot("didUpdateNodeNote", null) // private
        this.newSlot("shouldFocusSubnodeNote", null) // private
        this.newSlot("shouldFocusAndExpandSubnodeNote", null) // private

        // view related, but computed on node

        this.newSlot("subtitleIsSubnodeCount", false).setDuplicateOp("copyValue")
        this.newSlot("nodeVisibleClassName", null).setDuplicateOp("copyValue")
        this.newSlot("noteIsSubnodeCount", false).setDuplicateOp("copyValue")
        this.newSlot("nodeEmptyLabel", null) // shown in view when there are no subnodes

        // view settings

        this.newSlot("viewClassName", null)
        this.newSlot("nodeThumbnailUrl", null)
        this.newSlot("nodeCanEditTitle", false).setDuplicateOp("copyValue")

        {
            const slot = this.newSlot("nodeCanEditSubtitle", false)
            slot.setDuplicateOp("copyValue")
            slot.setCanInspect(true)
            slot.setLabel("editable")
            slot.setSlotType("Boolean")
            slot.setInspectorPath("Subtitle")
        }

        {
            const slot = this.newSlot("nodeIsVertical", true)
            slot.setDuplicateOp("copyValue")
            slot.setCanInspect(true)
            slot.setLabel("is vertical")
            slot.setSlotType("Boolean")
            slot.setInspectorPath("Layout")
            slot.setShouldStoreSlot(true)
        }

        this.newSlot("nodeRowIsSelectable", true).setDuplicateOp("copyValue")
        this.newSlot("nodeRowsStartAtBottom", false).setDuplicateOp("copyValue")

        {
            const slot = this.newSlot("nodeMinRowHeight", 0)
            slot.setDuplicateOp("copyValue")
            slot.setShouldStoreSlot(true)
            slot.setInspectorPath("style")
        }

        {
            const slot = this.newSlot("nodeMinRowWidth", 0)
            slot.setDuplicateOp("copyValue")
            slot.setShouldStoreSlot(true)
            slot.setInspectorPath("style")
        }

        // html

        this.newSlot("acceptsFileDrop", false)

        // view style overrides

        this.newSlot("viewDict", null)
        this.newSlot("nodeColumnStyles", null)
        this.newSlot("nodeRowStyles", null)

        // view footer

        this.newSlot("nodeHasFooter", false)
        this.newSlot("nodeInputFieldMethod", null)

        // column settings - TODO: auto adjust to fit?

        this.newSlot("nodeMinWidth", 200).setDuplicateOp("copyValue")
        
        {
            const slot = this.newSlot("nodeFillsRemainingWidth", false).setDuplicateOp("copyValue")
            slot.setSlotType("Boolean")
            slot.setLabel("fills remaining")
            slot.setCanEditInspection(false)
            slot.setCanInspect(false)
            slot.setInspectorPath("Layout")
        }

        {
            const slot = this.newSlot("nodeFillsWindow", false)
            slot.setSlotType("Boolean")
            slot.setLabel("fills window")
            slot.setCanEditInspection(true)
            slot.setCanInspect(true)
            slot.setShouldStoreSlot(true)
            slot.setInspectorPath("Layout")
        }

        {
            const slot = this.newSlot("themeClassName", "DefaultThemeClass")
            slot.setShouldStoreSlot(true)
            slot.setCanInspect(true)
            slot.setSlotType("String")
            slot.setLabel("Theme Class")
            slot.setSyncsToView(true)
            slot.setInspectorPath("Style")
        }

        this.newSlot("nodeUsesColumnBackgroundColor", true).setDuplicateOp("copyValue")
        this.newSlot("canDelete", false).setDuplicateOp("copyValue")
        this.newSlot("nodeCanEditRowHeight", false).setDuplicateOp("copyValue")
        this.newSlot("nodeCanEditColumnWidth", false).setDuplicateOp("copyValue")

        // inspector

        this.newSlot("nodeCanInspect", true).setDuplicateOp("copyValue")
        this.newSlot("nodeInspector", null)

        // actions

        this.newSlot("actions", null).setInitProto(Array)
    }

    nodeOrientation () {
        return this.nodeIsVertical() ? "right" : "down" 
    }

    init () {
        super.init()

        this.setDidUpdateNodeNote(BMNotificationCenter.shared().newNote().setSender(this).setName("didUpdateNode"))
        this.setShouldFocusSubnodeNote(BMNotificationCenter.shared().newNote().setSender(this).setName("shouldFocusSubnode"))
        this.setShouldFocusAndExpandSubnodeNote(BMNotificationCenter.shared().newNote().setSender(this).setName("shouldFocusAndExpandSubnode"))

        this._nodeMinWidth = 180
        
        //this.setNodeColumnStyles(this.sharedNodeColumnStyles())
        //this.setNodeRowStyles(this.sharedNodeRowStyles())

        this.setNodeColumnStyles(BMViewStyles.clone())
        //this.setNodeRowStyles(BMViewStyles.clone())
        this.setViewDict({})

        this.watchSubnodes()

        return this
    }

    nodeType () {
        return this.type()
    }

    prepareToRetire () {
        super.prepareToRetire() // will remove notification observations
        this._subnodes.removeMutationObserver(this)
    }

    nodeCreate () {
        // we implemnet this on BMNode class and prototype so 
        // it works for both instance and class creator prototypes
        return this.duplicate()
    }
    
    nodeCreateName () {
        return this.title()
    }

    duplicate () {
        const dup = super.duplicate()
        if (!this.shouldStore() || this.shouldStoreSubnodes()) {
            dup.copySubnodes(this.subnodes().map(sn => sn.duplicate()))
        }
        return dup
    }

    pid () {
        return this.puuid()
    }

    nodeInspector () {
        if (!this._nodeInspector) {
            this._nodeInspector = BMNode.clone().setNodeMinWidth(150)
            this.initNodeInspector()
        }
        return this._nodeInspector
    }

    initNodeInspector () {
        this.setupInspectorFromSlots()
        return this
    }

    setupInspectorFromSlots() {
        const slots = this.thisPrototype().allSlots()
        slots.ownForEachKV((name, slot) => {
            const field = slot.newInspectorField()
            if (field) {
                field.setTarget(this)
                let node = this.nodeInspector().createNodePath(slot.inspectorPath())
                node.addSubnode(field)
            }
        })
        return this
    }    


    createNodePath (aPath, pathSubnodeType = "BMFolderNode") {
        let node = this

        if (!aPath) {
            return node
        }

        const components = aPath.split("/")
        components.forEach(component => {
            node = this.subnodeWithTitleIfAbsentInsertClosure(component, () => {
                const node = window[pathSubnodeType].clone()
                node.setTitle(component)
                node.setNodeMinWidth(300)
                return node
            })
        })

        return node
    }

    customizeNodeRowStyles () {
        if (!this.getOwnProperty("_nodeRowStyles")) {
            //const styles = BMViewStyles.shared().sharedWhiteOnBlackStyle().setIsMutable(false)
            // NOTE: We can't use the shared style because column bg colors change

            const styles = BMViewStyles.clone()
            styles.selected().setColor("white")
            styles.unselected().setColor("#aaa")
            this._nodeRowStyles = styles
        }
        return this._nodeRowStyles
    }

    sharedNodeColumnStyles () {
        if (!BMNode.hasOwnProperty("_nodeColumnStyles")) {
            const styles = BMViewStyles.clone()
            //styles.selected().setColor("white")
            //styles.unselected().setColor("#aaa")
            BMNode._nodeColumnStyles = styles
        }
        return BMNode._nodeColumnStyles
    }

    sharedNodeRowStyles () {
        if (!BMNode._nodeRowStyles) {
            const styles = BMViewStyles.clone()
            BMNode._nodeRowStyles = styles
            styles.selected().setColor("white")
            styles.unselected().setColor("#aaa")
        }
        return BMNode._nodeRowStyles
    }

    // column view style
    
    setNodeColumnBackgroundColor (c) {
	    if (this.nodeColumnStyles()) {
            this.setNodeColumnStyles(BMViewStyles.clone())
	    }
	    
        this.nodeColumnStyles().selected().setBackgroundColor(c)
        this.nodeColumnStyles().unselected().setBackgroundColor(c)
        return this
    }

    nodeColumnBackgroundColor () {
	    if (this.nodeColumnStyles()) {
		    return this.nodeColumnStyles().selected().backgroundColor()
	    }
	    return null
    }
    
    // -----------------------
    
    nodeVisibleClassName () {
        if (this._nodeVisibleClassName) {
            return this._nodeVisibleClassName
        }
		
        return this.type().sansPrefix("BM")
    }

    // --- fields ---
    
    addLinkFieldForNode (aNode) {
        const field = BMLinkField.clone().setName(aNode.title()).setValue(aNode)
        return this.addStoredField(field)
    }
    
    addField (aField) {
        throw new Error("addField shouldn't be called - use BMFieldSetNode")
        return this.addSubnode(aField)
    }
        
    nodeRowLink () {
        // used by UI row views to browse into next column
        return this
    }

    // nodeRowLinkMethods
    // used by UI row views to choose the node ref to use for the next column
    // if returns null, the row won't open another column
    // 
    // The two typical use cases are :
    //
    // 1) A pointer row which links to some other node.
    //
    // 2) A means to toggle between viewing the row's node or
    //    skipping to one of its subnodes. This allows a node
    //    to have inspector separated from "subnode" browsing.
    //    Example: a Server object might have the subnodes:
    //    [ StringFieldNode (for server name),  
    //      ActionNode (to connect/disconnect),
    //      ServerClientsNode (holds list of connected server clients)
    //

    thisNode () {
        return this
    }

    nodeRowLinkMethods () {
        return ["thisNode"]
    }

    defaultNodeRowLinkMethod () {

    }

    // subtitle and note
    
    subtitle () {

        if (this.subtitleIsSubnodeCount() && this.subnodesCount()) {
            return this.subnodesCount()
        }
        
        return this._subtitle
    }
    
    note () {
        //console.log(this.title() + " noteIsSubnodeCount: " + this.noteIsSubnodeCount())
        if (this.noteIsSubnodeCount() && this.subnodesCount()) {
            return this.subnodesCount()
        }
        
        return this._note
    }

    nodeHeaderTitle () {
        return this.title()
    }

    // --- viewClassName ---
    
    /*
    viewClassName () {
        if (!this._viewClassName) {
            return this.type() + "View" //.sansPrefix("BM")
        }
        
        return this._viewClassName
    }
    */
    
    viewClass () {        
        const name = this.viewClassName()
        if (name) {
            return window[name]
        }

	  	return this.firstAncestorWithMatchingPostfixClass("View")
    }

    // --- nodeRowViewClass ---
    
    /*
    rowNode () {
        return this
    }
    */

    nodeRowViewClass () {   
	  	return this.firstAncestorWithMatchingPostfixClass("RowView")
    }

    // --- subnodes ----------------------------------------
    
    
    setParentNode (aNode) {
        if (aNode !== this._parentNode) { 
            if (this._parentNode && aNode) {
                console.warn(this.type() + " setParentNode(" + aNode.type() + ")  already has parent " + this._parentNode.type())
            }
            
            const oldNode = this._parentNode
            this._parentNode = aNode
            this.didUpdateSlotParentNode(oldNode, aNode)
        }
        return this
    }

    didUpdateSlotParentNode (oldValue, newValue) {
        // for subclasses to override
    }

    rootNode () {
        const pn = this.parentNode()
        if (pn) {
            return pn.rootNode()
        }
        return this
    }

    // subnodes

    subnodeCount () {
        return this._subnodes.length
    }

    hasSubnodes () {
        return this.subnodeCount() > 0
    }

    justAddSubnode (aSubnode) {
        return this.justAddSubnodeAt(aSubnode, this.subnodeCount())
    }
	
    justAddSubnodeAt (aSubnode, anIndex) {
        this.subnodes().atInsert(anIndex, aSubnode)
        aSubnode.setParentNode(this)
        return aSubnode        
    }

    addSubnodeAt (aSubnode, anIndex) {
        assert(anIndex >= 0)
        this.justAddSubnodeAt(aSubnode, anIndex)
        //this.didChangeSubnodeList() // happens automatically from hooked array
        return aSubnode
    }

    replaceSubnodeWith (aSubnode, newSubnode) {
        const index = this.indexOfSubnode(aSubnode)
        assert(index !== -1)
        this.removeSubnode(aSubnode)
        this.addSubnodeAt(newSubnode, index)
        return newSubnode
    }

    moveSubnodesToIndex (movedSubnodes, anIndex) {
        this.subnodes().moveItemsToIndex(movedSubnodes, anIndex)
        return this
    }

    addSubnode (aSubnode) {
        return this.addSubnodeAt(aSubnode, this.subnodeCount())
    }

    addLinkSubnode (aNode) {
        /*
        if(aNode.parentNode()) {
            console.warn("adding a link subnode to a node with no parent (yet)")
        }
        */
        const link = BMLinkNode.clone().setLinkedNode(aNode)
        this.addSubnode(link)
        return link
    }

    addSubnodes (subnodes) {
        subnodes.forEach(subnode => this.addSubnode(subnode))
        return this
    }

    addSubnodesIfAbsent (subnodes) {
        subnodes.forEach(subnode => this.addSubnodeIfAbsent(subnode))
        return this
    }
    
    addSubnodeIfAbsent (aSubnode) {
        if(!this.hasSubnode(aSubnode)) {
            this.addSubnode(aSubnode)
            return true
        }
        return false
    }

    subnodeProto () {
        return this.subnodeClasses().first()
    }

    setSubnodeProto (aProto) {
        this.subnodeClasses().removeAll()
        this.subnodeClasses().appendIfAbsent(aProto)
        return this
    }

    acceptedSubnodeTypes () {
        const types = []
        this.subnodeClasses().forEach(c => types.push(c.type()))
        return types
    }

    acceptsAddingSubnode (aSubnode) {
        if (aSubnode === this) {
            return false
        }

        /*
        if (this.hasSubnode(aSubnode)) {
            return false
        }
        */
        //const type = aSunode.type()
        const ancestors = aSubnode.thisClass().ancestorClassesTypesIncludingSelf()
        const match = this.acceptedSubnodeTypes().detect(type => ancestors.contains(type))
        return !Type.isNullOrUndefined(match)
    }

    onBrowserDropChunk (dataChunk) {
        const mimeType = dataChunk.mimeType()
        const canOpenNodes = BMNode.allSubclasses().select((aClass) => aClass.canOpenMimeType(mimeType))
        const okTypes = this.acceptedSubnodeTypes()
        const canUseNodes = canOpenNodes /// canOpenNodes.select(nodeType => okTypes.contains(nodeType))

        if (canUseNodes.length) {

            if (canUseNodes.length === 1) {
                const match = canUseNodes.first()

                const newNode = match.openMimeChunk(dataChunk)
                this.addSubnode(newNode)

                /*
                if (this.acceptsAddingSubnode(match)) {
                    this.addSubnode(match)
                }
                */
            } else {
                // TODO: add CreatorNode with those types and
                // hook to instantiate from mime data
            }
        }
    }

    // --------
	
    isEqual (aNode) {
	    return this === aNode
    }

    hash () {
        // don't assume hash() always returns the puuid as
        // subclasses can override to measure equality in their own way
        return this.puuid()
    }

    createSubnodesIndex () {
        this.subnodes().setIndexClosure( v => v.hash() )
        return this
    }
	
    hasSubnode (aSubnode) {
        const subnodes = this.subnodes()
        if (subnodes.length > 100) {
            this.createSubnodesIndex()
            return subnodes.indexHasItem(aSubnode) 
        }
        //return subnodes.detect(subnode => subnode === aSubnode)
        return subnodes.detect(subnode => subnode.isEqual(aSubnode))
    }
    
    justRemoveSubnode (aSubnode) { // private method 
        this.subnodes().remove(aSubnode)
        
        if (aSubnode.parentNode() === this) {
            aSubnode.setParentNode(null)
        }
        
        return aSubnode
    }
    
    removeSubnode (aSubnode) {
        this.justRemoveSubnode(aSubnode)
        //this.didChangeSubnodeList() handled by hooked array
        return aSubnode
    }

    removeSubnodes (subnodeList) {
        subnodeList.forEach(sn => this.removeSubnode(sn))
        return this
    }
    
    removeAllSubnodes () {
	    if (this.subnodeCount()) {
    		this.subnodes().slice().forEach((subnode) => {
    			this.justRemoveSubnode(subnode)
    		})
    		
            //this.didChangeSubnodeList() handled by hooked array but this could be more efficient
        }
        return this
    }

    didReorderParentSubnodes () {
    }

    onDidReorderSubnodes () {
        this.subnodes().forEach(subnode => subnode.didReorderParentSubnodes())
    }

    didChangeSubnodeList () {
        //this.subnodes().forEach(subnode => assert(subnode.parentNode() === this)) // TODO: remove after debugging
        this.scheduleMethod("onDidReorderSubnodes")
        //this.subnodes().forEach(subnode => subnode.didReorderParentSubnodes())
        this.didUpdateNode()
        return this
    }

    copySubnodes (newSubnodes) {
        this.subnodes().copyFrom(newSubnodes)
        return this
    }

    nodeReorderSudnodesTo (newSubnodes) {
        this.copySubnodes(newSubnodes)
        return this
    }

    orderFirst () {
        this.parentNode().orderSubnodeFirst(this)
        return this
    }

    orderLast () {
        this.parentNode().orderSubnodeLast(this)
        return this  
    }

    orderSubnodeFirst (aSubnode) {
        assert(this.hasSubnode(aSubnode))
        const subnodes = this.subnodes().shallowCopy()
        subnodes.remove(aSubnode)
        subnodes.atInsert(0, aSubnode)
        this.nodeReorderSudnodesTo(subnodes)
        return this
    }

    orderSubnodeLast (aSubnode) {
        assert(this.hasSubnode(aSubnode))
        const subnodes = this.subnodes().shallowCopy()
        subnodes.remove(aSubnode)
        subnodes.push(aSubnode)
        this.nodeReorderSudnodesTo(subnodes)
        return this
    }
    
    // --- update / sync system ----------------------------
    
    scheduleSyncToView () {
        this.didUpdateNode()
        //window.SyncScheduler.shared().scheduleTargetAndMethod(this, "syncToView")
        return this
    }

    didUpdateNode () {
        if (!this.hasDoneInit()) {
            return
        }

        const note = this.didUpdateNodeNote()

        if (note) {
            //console.log("Node '" + this.title() + "' POST didUpdateNode")
            note.post()
        }

        
        // TODO: make this more efficient, as we don't always need it
        
        if (this.parentNode()) {
            assert(this.parentNode() !== this)
            this.parentNode().didUpdateNode()
        }
         
    }

    didUpdateSlot (aSlot, oldValue, newValue) {
        super.didUpdateSlot(aSlot, oldValue, newValue)

        if (aSlot.syncsToView()) { 
            this.scheduleSyncToView()
        }
    }

    indexOfSubnode (aSubnode) {
        return this.subnodes().indexOf(aSubnode);
    }

    subnodeIndexInParent () {
        const p = this.parentNode()
        if (p) {
            return p.indexOfSubnode(this)
        }
        return 0
    }

    nodeDepth () {
        const p = this.parentNode()
        if (p) {
            return p.nodeDepth() + 1
        }
        return 0
    }

    // --- shelf ---
	
    shelfSubnodes () {
        return []
    }

    shelfIconName () {
	    return null
    }
	
    shelfIconUrl () {
	    return null
    }

    // ---------------------------------------
    
    prepareForFirstAccess () {
        // subclasses can override 
    }

    prepareToAccess () {
        // this should be called whenever subnodes need to be accessed
        if (!this._didPrepareForFirstAccess) {
            this._didPrepareForFirstAccess = true
            this.prepareForFirstAccess()
        }
    }
    
    prepareToSyncToView () {
        this.prepareToAccess();
    }

    // --- parent chain notifications ---
    
    tellParentNodes (msg, aNode) {
        const f = this[msg]
        if (f && f.apply(this, [aNode])) {
            return
        }

        const p = this.parentNode()
        if (p) {
            p.tellParentNodes(msg, aNode)
        }
    }
    
    // --- node path ------------------------
    
    nodePath () {
        if (this.parentNode()) {
            const parts = this.parentNode().nodePath()
            parts.push(this)
            return parts
        }
        return [this]
    }

    nodePathArrayForPathComponents (pathComponents, results = []) {
        results.push(this)

        const link = this.nodeRowLink()
        if (link && link !== this) {
            return link.nodePathArrayForPathComponents(pathComponents) 
        }

        const pathComponent = pathComponents.first()
        if (pathComponent) {
            const nextNode = this.firstSubnodeWithTitle(pathComponent)
            if (nextNode) {
                return nextNode.nodePathArrayForPathComponents(pathComponents.rest())
            }
        }
        return results
    }
    
    nodePathString () {
        return this.nodePath().map(node => node.title()).join("/")
    }
    
    nodeAtSubpathString (pathString) {
        return this.nodeAtSubpath(pathString.split("/"));        
    }
    
    nodeAtSubpath (subpathArray) {
        if (subpathArray.length) {
            const t = subpathArray.first()

            let subnode = null
            if (Type.isArray(t)) {
                // supports a path component that is an ordered list of subnodes titles 
                subnode = this.firstSubnodeWithTitles(t)
            } else {
                subnode = this.firstSubnodeWithTitle(t)
            }

            if (subnode) {
                return subnode.nodeAtSubpath(subpathArray.rest())
            }
            return null
        }        
        return this
    }

    // --- log ------------------------
    
    log (msg) {
        //const s = this.nodePathString() + " --  " + msg
        if (this.isDebugging()) {
        	console.log("[" +  this.nodePathString() + "] " + msg)
        }
    }
    
    // --- standard actions -----------------------------
    
    addAction (actionString) {
        if (!this.actions().contains(actionString)) {
	        this.actions().push(actionString)
            this.didUpdateNode()
        }
        return this
    }

    removeAction (actionString) {
        if (this.actions().contains(actionString)) {
        	this.actions().remove(actionString)
            this.didUpdateNode()
        }
        return this
    }
    
    addActions (actionStringList) {
        actionStringList.forEach( (action) => {
            this.addAction(action)
        })
        return this
    }
    
    hasAction (actionName) {
        return this.actions().contains(actionName)
    }
    
    performAction (actionName) {
        return this[actionName].apply(this)
    }
    
    postShouldFocusSubnode (aSubnode) {
        assert(aSubnode)
        this.shouldFocusSubnodeNote().setInfo(aSubnode).post()
        return this
    }

    postShouldFocusAndExpandSubnode (aSubnode) {
        assert(aSubnode)
        this.shouldFocusAndExpandSubnodeNote().setInfo(aSubnode).post()
        return this
    }
    
    justAddAt (anIndex) {
        const classes = this.subnodeClasses().shallowCopy()

        let newSubnode = null
        if (classes.length === 0) {
            newSubnode = null
        } else if (classes.length === 1) {
            newSubnode = classes.first().clone()
        } else {
            newSubnode = BMCreatorNode.clone()
            newSubnode.addSubnodesForObjects(classes)
        }

        if (newSubnode) {
            this.addSubnodeAt(newSubnode, anIndex)
        }
        return newSubnode
    }

    justAdd (anIndex) {  
        return this.justAddAt(this.subnodeCount())
    }

    addAt (anIndex) {
        const newSubnode = this.justAddAt(anIndex)
        if (newSubnode) {
            this.didUpdateNode()
            this.postShouldFocusAndExpandSubnode(newSubnode)
        }
        return newSubnode
    }

    add () {  
        return this.addAt(this.subnodeCount())
    }

    removeFromParentNode () {
        if (this.parentNode()) {
            this.parentNode().removeSubnode(this)
        } else {
            throw new Error("missing parentNode")
        }
        return this
    }
	
    delete () {
        this.removeFromParentNode()
        return this
    }

    /*
    nodeParentHasDeleteAction () {
        const p = this.parentNode()
        return p && p.hasAction("delete")
    }
    */

    /*
    canDelete () {
        if (this._canDelete) {
            return true
        }

        return this.nodeParentHasDeleteAction()
    }
    */

    canSelfAddSubnode () {
        return this.hasAction("add")
    }

    // --- utility -----------------------------
    
    parentNodeOfType (className) {
        if (this.type() === className) {
            return this
        }
        
        if (this.parentNode()) {
            return this.parentNode().parentNodeOfType(className)
        }
        
        return null
    }

    parentNodes () {
        const node = this.parentNode()
        const results = []
		
        while (node) {
            results.push(node)
            node = this.parentNode()
        }
        return results
    }
	
    parentNodeTypes () {
        return this.parentNodes().map(node => node.type())
    }
    
    // --- subnode lookup -----------------------------
    
    subnodesSans (aSubnode) {
	    return this.subnodes().select(subnode => subnode !== aSubnode)
    }
	
    firstSubnodeOfType (aProto) {
        return this.subnodes().detect(subnode => subnode.type() === aProto.type())
    }

    removeFirstSubnodeWithTitle (aString) {
        const sn = this.firstSubnodeWithTitle(aString)
        if (sn) {
            sn.delete()
        }
        return this
    }

    firstSubnodeWithTitle (aString) {
        return this.subnodes().detect(subnode => subnode.title() === aString)
    }

    firstSubnodeWithTitles (titlesArray) {
        for (let i = 0; i < titlesArray.length; i++) {
            const title = titlesArray[i]
            const subnode = this.firstSubnodeWithTitle(title)
            if (subnode) {
                return subnode
            }
        }
        return null
    }

    firstSubnodeWithSubtitle (aString) {
        return this.subnodes().detect(subnode => subnode.subtitle() === aString)
    }

    rootNode () {
        const root = this.defaultStore().rootObject()
        root.setTitle("root")
        return root
    }

    rootSubnodeWithTitleForProto(aString, aProto) {
        return this.rootNode().subnodeWithTitleIfAbsentInsertProto(aString, aProto)
    }

    subnodeWithTitleIfAbsentInsertProto(aString, aProto) {
        let subnode = this.firstSubnodeWithTitle(aString)

        if (subnode) {
            if (subnode.type() !== aProto.type()) {
                const newSubnode = aProto.clone()
                newSubnode.copyFrom(subnode)
                // TODO: Do we need to replace all references in pool and reload?
                this.replaceSubnodeWith(subnode, newSubnode)
                this.removeOtherSubnodeWithSameTitle(newSubnode)
                return newSubnode
            }

            this.removeOtherSubnodeWithSameTitle(subnode)
            return subnode
        }

        return this.subnodeWithTitleIfAbsentInsertClosure(aString, () => aProto.clone())
    }

    removeSubnodesWithTitle (aString) {
        this.subnodes().select(sn => sn.title() === aString).forEach(sn => sn.delete())
        return this
    }

    /*
    removeOtherSubnodeInstances (aSubnode) {
        assert(this.hasSubnode(aSubnode))
        this.subnodes().shallowCopy().forEach((sn) => {
            if (sn !== aSubnode) {
                if (sn.thisClass() === aSubnode.thisClass()) {
                    this.removeSubnode(sn)
                }
            }
        })
        return this
    }
    */

    removeOtherSubnodeWithSameTitle (aSubnode) {
        assert(this.hasSubnode(aSubnode))
        this.subnodes().shallowCopy().forEach((sn) => {
            if (sn !== aSubnode) {
                if (sn.title() === aSubnode.title()) {
                    this.removeSubnode(sn)
                }
            }
        })
        return this
    }

    subnodeWithTitleIfAbsentInsertClosure (aString, aClosure) {
        let subnode = this.firstSubnodeWithTitle(aString)

        if (!subnode && aClosure) {
            subnode = aClosure()
            subnode.setTitle(aString)
            if (subnode.type() === "BMThemeResources") {
                console.log("debug")
            }
            this.addSubnode(subnode)
        }

        return subnode
    }
        
    sendRespondingSubnodes (aMethodName, argumentList) {
        this.subnodes().forEach((subnode) => { 
            if (subnode[aMethodName]) {
                subnode[aMethodName].apply(subnode, argumentList)
            }
        })
        return this
    }
    
    // --- subnodes -----------------------------
    
    subnodesCount () {
        return this.subnodes().length
    }

    onDidMutateObject (anObject) {
        if (anObject === this._subnodes) {
            this.didChangeSubnodeList()
        }
    }

    watchSubnodes () {
        this._subnodes.addMutationObserver(this)
        return this
    }

    didUpdateSlotSubnodes (oldValue, newValue) {
        if (oldValue) {
            oldValue.removeMutationObserver(this)
        }

        this.watchSubnodes()
        if (this._subnodes.contains(null)) {
            this._subnodes.filterInPlace(sn => !(sn === null) )
        }
        this._subnodes.forEach(sn => sn.setParentNode(this))
        this.didChangeSubnodeList() // not handles automatically
        return this
    }
    
    assertSubnodesHaveParentNodes () {
        const missing = this.subnodes().detect(subnode => !subnode.parentNode())
        if (missing) {
            throw new Error("missing parent node on subnode " + missing.type())
        }
        return this
    }
    
    // --- sorting helper ---

    makeSortSubnodesByTitle () {
        this.setSubnodeSortFunc( (a, b) => a.title().localeCompare(b.title()) )
        return this
    }

    // --- subnode sorting ---
	
    setSubnodeSortFunc (f) {
        this.subnodes().setSortFunc(f)
	    return this
    }
	
    doesSortSubnodes () {
	    return this.subnodes().doesSort()
    }
    
    // --- subnode indexing ---
	
    lazyIndexedSubnodes () {
        if (!this.subnodes().indexClosure()) {
            this.subnodes().setIndexClosure( sn => sn.hash() )
        }
	    return this.subnodes()
    }
	
    subnodeWithHash (h) {
        return this.lazyIndexedSubnodes().itemForIndexKey(h)
    }
	
    removeSubnodeWithHash (h) {
	    const subnode = this.subnodeWithHash(h)
	    if (subnode) {
	        this.removeSubnode(subnode)
	    }
	    return this
    }
	
    hasSubnodeWithHash (h) {
	    return this.lazyIndexedSubnodes().hasIndexKey(h)
    }
    
    // --- node view badge ---

    nodeViewShouldBadge () {
        return false
    }

    nodeViewBadgeTitle () {
        return null
    }
	
    // visibility
	
    nodeBecameVisible () {
	    return this
    }

    // --- notification helpers --- 

    watchOnceForNote (aNoteName) {
        const obs = BMNotificationCenter.shared().newObservation()
        obs.setName(aNoteName)
        obs.setObserver(this)
        obs.setIsOneShot(true)
        obs.watch()
        //this.debugLog(".watchOnceForNote('" + aNoteName + "')")
        return obs
    }

    postNoteNamed (aNoteName) {
        const note = window.BMNotificationCenter.shared().newNote()
        note.setSender(this)
        note.setName(aNoteName)
        note.post()
        //this.debugLog(".postNoteNamed('" + aNoteName + "')")
        return note
    }

    scheduleSelfFor (aMethodName, milliseconds) {
        return window.SyncScheduler.shared().scheduleTargetAndMethod(this, aMethodName, milliseconds)
    }

    // -- selection requests ---

    onRequestSelectionOfDecendantNode () {
        return false // allow propogation up the parentNode line
    }

    onRequestSelectionOfNode () {
        this.tellParentNodes("onRequestSelectionOfDecendantNode", this)
        return this
    }

    onTapOfNode () {
        this.tellParentNodes("onTapOfDecendantNode", this)
        return this
    }

    // tracking observer count 
    // usefull for releasing inspectors when no longer needed

    /*
    onStartObserving () {

    }

    onStopObserving () {
        const isStillObserved = BMNotificationCenter.shared().hasObservationsForTargetId(this.typeId())
        if (!isStillObserved) {
            this.onNoMoreObservers()
        }
    }

    onNoMoreObservers () {

    }
    */

    summary () {
        return this.title() + " " + this.subtitle()
    }

    debugTypeId () {
        return super.debugTypeId() + " '" + this.title() + "'"
    }

}.initThisClass()


"use strict"

ResourceLoader.pushRelativePaths([
    "BMStorableNode.js",
    "BMStoredDatedSetNode.js",
    "newstore/_imports.js",
    "inspectors/_imports.js",
    //"NodeStore.js",
])

"use strict"

/*

    BMStorableNode 
    
*/

window.BMStorableNode = class BMStorableNode extends BMNode {
    
    initPrototype () {
        this.setShouldStore(true)
        //this.setShouldStoreSubnodes(true)

        this.overrideSlot("canDelete", false).setShouldStoreSlot(true)  // defined in BMNode, but we want to store it
        this.overrideSlot("title", null).setShouldStoreSlot(true)
        this.overrideSlot("subtitle", "").setShouldStoreSlot(true)

        {
            const slot = this.overrideSlot("nodeFillsRemainingWidth", false)
            slot.setShouldStoreSlot(true)
            slot.setCanEditInspection(true)
            slot.setCanInspect(true)
        }

        {
            const slot = this.overrideSlot("subnodes", null)
            //subnodesSlot.setOwnsSetter(true)
            slot.setShouldStoreSlot(true)
            //slot.setDoesHookGetter(true) //node does this

            slot.setDoesHookGetter(true)
            slot.setHookedGetterIsOneShot(true)
            slot.setIsLazy(true)
            slot.setInitProto(SubnodesArray)

            assert(slot.doesHookGetter())
            slot.setupInOwner()
        }
        
        this.newSlot("lazySubnodeCount", null).setShouldStoreSlot(true)
    }

    init () {
        super.init()
        // do we need to start observing subnodes?
        return this
    }

    // --- udpates ---
	
    didUpdateSlot (aSlot, oldValue, newValue) {
        super.didUpdateSlot(aSlot, oldValue, newValue)

	    if (!this.shouldStore() || !this.isInstance()) {
	        return this
	    }
	    
        if (aSlot.shouldStoreSlot()) { 
            this.scheduleSyncToStore()
        }
        
        // TODO: add a switch for this feature
        // TODO: find a way to avoid this?
        if (newValue !== null && this._subnodes && this._subnodes.includes(oldValue)) { 
            newValue.setParentNode(this)
            this.subnodes().replaceOccurancesOfWith(oldValue, newValue)
            //this.debugLog(" this.subnodes().replaceOccurancesOfWith(", oldValue, ",", newValue, ")")
        }
    }

    /*
    didUpdateSlotSubnodes (oldValue, newValue) {
        super.didUpdateSlotSubnodes(oldValue, newValue)
        this.updateLazySubnodeCount()        
        return this
    }
    */

    updateLazySubnodeCount () {
        if (this._subnodes) {
            this.setLazySubnodeCount(this.subnodes().length)
        }
    }

    didChangeSubnodeList () {
        super.didChangeSubnodeList()
        this.updateLazySubnodeCount()
        return this
    }

    // --- stored slots ---
    
    initStoredSubnodeSlotWithProto (name, proto) {
        const obj = proto.clone()
        this.newSlot(name, obj)
        this.justAddSubnode(obj)
        this.addStoredSlot(name)
        return this
    }
	
    // subnodes
    
    subnodeCount () {
        if (!this._subnodes) {
            return this.lazySubnodeCount()
        }
        return this._subnodes.length
    }

    prepareForFirstAccess (aStore = this.defaultStore()) {
        super.prepareForFirstAccess()
        return this
    }

}.initThisClass()


"use strict"

/*

    BMStoredDatedSetNode

*/

window.BMStoredDatedSetNode = class BMStoredDatedSetNode extends BMStorableNode {
    
    initPrototype () {
        this.newSlot("maxAgeInSeconds", 30*24*60*60).setShouldStoreSlot(true)
        this.newSlot("autoCheckPeriod", 1*60*60).setShouldStoreSlot(true)
        this.newSlot("dict", null).setShouldStoreSlot(true)
        this.setShouldStore(true)
        this.setShouldStoreSubnodes(false)
    }

    init () {
        super.init()
        this.setDict({})
        //this.setNoteIsSubnodeCount(true)
    }
    
    didUpdateSlotAutoCheckPeriod (seconds) {
        if (seconds && this._autoCheckPeriod !== seconds) {
            this._autoCheckPeriod = seconds
            this.autoCheck()
        }
    }
    
    autoCheck () {
        this.deleteExpiredKeys()
        setTimeout(() => { this.autoCheck() }, this.autoCheckPeriod()*1000)
    }
    
    didLoadFromStore () {
        super.didLoadFromStore()
        this.deleteExpiredKeys()
    }

    addKey (h) {
        if (!this.dict().at(h)) {
            this.dict().atPut(h, Date.now())
            this.scheduleSyncToStore()
        }
        return this
    }
    
    hasKey (h) {
        return this.dict().hasOwnProperty(h)
    }
    
    removeKey (h) {
        if (this.dict()[h]) {
            this.dict().removeAt(h)
            this.scheduleSyncToStore()
        }
        return this
    }
    
    ageInSecondsOfKey (h) {
        if (this.hasKey(h)) {
            const ageInSeconds = Date.now() - this.dict()[h]
            return ageInSeconds
        }
        
        return null
    }

    deleteExpiredKeys () {
        const max = this.maxAgeInSeconds()
        const keys = Object.keys(this.dict())
        
        keys.forEach((k) => {
            if (this.ageInSecondsOfKey(k) > max) {
                this.removeKey(k)
            }
        })

        return this
    }
    
}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "categories/_imports.js",
    "ObjectPool.js",
    "PersistentObjectPool.js",
    "StoreRef.js",
])

"use strict"

ResourceLoader.pushRelativePaths([
    //"Object-puuid.js",
    "ProtoClass-store.js",
    "BMNode-store.js",
    "BMStorableNode-store.js",
    "primitives/_imports.js",
])

"use strict"


Object.defineSlots(ProtoClass, {

    instanceFromRecordInStore: function(aRecord, aStore) { // should only be called by Store    

        throw new Error("unimplemented")

        /*
        const proto = window[aRecord.type]
        const obj = proto.clone()
        const entries = aRecord.entries


        aRecord.entries.forEach((entry) => {
            const k = entry[0]
            const v = entry[1]
            obj[k] = aStore.unrefValue(v)
        })
        
        return obj
        */
    },
})

Object.defineSlots(ProtoClass.prototype, {

    recordForStore: function(aStore) { // should only be called by Store

        throw new Error("unimplemented")

        /*
        const record = {
            type: this.type(), 
            entries: [], 
        }


        Object.keys(this).forEach((k) => {
            const v = this[k]
            const entry = [k, aStore.refValue(v)]
            record.entries.push(entry) 
        })

        return record
        */
    },

})
"use strict"


Object.defineSlots(BMNode, {

    instanceFromRecordInStore: function(aRecord, aStore) { // should only be called by Store    
        //const proto = window[aRecord.type]
        const obj = this.clone()
        //obj.loadFromRecord(aRecord, aStore)
        return obj
    },

})


Object.defineSlots(BMNode.prototype, {
    
    recordForStore: function(aStore) { // should only be called by Store
        const aRecord = {
            type: this.type(), 
            entries: [], 
        }

        this.allSlots().ownForEachKV((slotName, slot) => {
            //if (slot.shouldStoreSlot()) {
            if (slot.shouldStoreSlotOnInstance(this)) {
                const v = slot.onInstanceGetValue(this)
                //assert(!Type.isUndefined(v))
                aRecord.entries.push([slotName, aStore.refValue(v)])
            }
        })

        return aRecord
    },

    lazyPids: function(puuids = new Set()) {
        // when doing Store.collect() will need to check for lazy slot pids on active objects
        this.allSlots().ownForEachKV((slotName, slot) => {
            // only need to do this on unloaded store refs in instances
            const storeRef = slot.onInstanceGetValueRef(this)
            if (storeRef) {
                puuids.add(storeRef.pid())
            }
        })
        return puuids
    },


    loadFromRecord: function(aRecord, aStore) {

        aRecord.entries.forEach((entry) => {
            const k = entry[0]
            const v = entry[1]

            const slot = this.thisPrototype().ownSlotNamed(k)

            if (slot) {
                if (!slot.hasSetterOnInstance(this)) {
                    // looks like the schema has changed 
                    // so schedule to store again, which will remove missing slot in the record
                    this.scheduleSyncToStore()
                } else {
                    if (slot.isLazy()) {
                        const pid = v["*"]
                        assert(pid)
                        const storeRef = StoreRef.clone().setPid(pid).setStore(aStore)
                        //console.log(this.typeId() + "." + slot.name() + " [" + this.title() + "] - setting up storeRef ")
                        slot.onInstanceSetValueRef(this, storeRef)
                    } else {
                        const unrefValue = aStore.unrefValue(v)
                        slot.onInstanceSetValue(this, unrefValue)
                    }
                }
            }
        })

        //this.didLoadFromStore() // done in ObjectPool.didInitLoadingPids() instead
        return this
    },

    scheduleDidInit: function () {
        // Object scheduleDidInit just calls this.didInit()
        assert(!this.hasDoneInit())
        window.SyncScheduler.shared().scheduleTargetAndMethod(this, "didInit")
    },

    scheduleDidLoadFromStore: function() {
        window.SyncScheduler.shared().scheduleTargetAndMethod(this, "didLoadFromStore")
    },

    /*
    didLoadFromStore: function() {
        // Object.didLoadFromStore handles this
    },
    */

})

"use strict"

Object.defineSlots(BMStorableNode.prototype, {

    
})

"use strict"

ResourceLoader.pushRelativePaths([
    "Array-store.js",
    "ArrayBuffer-store.js",
    "Date-store.js",
    "Map-store.js",
    "Set-store.js",
    "Object-store.js",
    "TypedArray-store.js",
    "literals/_imports.js",
])

"use strict"


Object.defineSlots(Array, {
    
    instanceFromRecordInStore: function(aRecord, aStore) { // should only be called by Store
        let typeName = aRecord.type
        if (typeName !== "SubnodesArray") {
            typeName = "SubnodesArray" // TODO: have setSubnodes do a type conversion? 
        }
        const aClass = window[typeName]
        const obj = aClass.clone()
        //const obj = this.thisClass().clone()
        //obj.loadFromRecord(aRecord, aStore) 
        return obj
    },

    lengthOfRecord: function(aRecord) {
        return aRecord.values.length
    },

})


Object.defineSlots(Array.prototype, {

    recordForStore: function(aStore) { // should only be called by Store
        const dict = {
            type: Type.typeName(this), 
            values: this.map(v => aStore.refValue(v))
        }

        return dict
    },

    loadFromRecord: function(aRecord, aStore) {
        const loadedValues = aRecord.values.map(v => aStore.unrefValue(v))
        loadedValues.forEach( v => this.unhooked_push(v) )
        return this
    },

    refsPidsForJsonStore: function(puuids = new Set()) {
        this.forEach(v => { 
            if (!Type.isNull(v)) { 
                v.refsPidsForJsonStore(puuids)
            } 
        })
        return puuids
    },

})



"use strict"


Object.defineSlots(ArrayBuffer, {

    instanceFromRecordInStore: function(aRecord, aStore) { // should only be called by Store
        assert(aRecord.type === "ArrayBuffer")
        const bytes = aRecord.bytes
        const obj = new ArrayBuffer(bytes.length)
        // loadFromRecord is called from the Store after puuid is set
        return obj
    },
})


Object.defineSlots(ArrayBuffer.prototype, {

    loadFromRecord: function(aRecord, aStore) {
        assert(aRecord.bytes.length === this.length)
        const bytes = aRecord.bytes
        for (let i = 0; i < bytes.length; i++) {
            this[i] = bytes[i]
        }
        return this
    },

    bytes: function() {
        const bytes = []
        for (let i = 0; i < this.byteLength; i++) {
            bytes.push(this[i])
        }
        return bytes
    },

    recordForStore: function(aStore) { // should only be called by Store
        return {
            type: "ArrayBuffer", //Type.typeName(this), 
            bytes: this.bytes(),
        }
    },

    refsPidsForJsonStore: function(puuids = new Set()) {
        return puuids
    },
})




"use strict"

Object.defineSlots(Date, {
    instanceFromRecordInStore: function(aRecord, aStore) { // should only be called by Store
        const obj = this.clone()
        //obj.loadFromRecord(aRecord, aStore)
        return obj
    },

})

Object.defineSlots(Date.prototype, {

    loadFromRecord: function(aRecord, aStore) {
        this.setTime(aRecord.time)
        return this
    },

    recordForStore: function(aStore) { // should only be called by Store
        return {
            type: this.type(), 
            time: this.getTime() // toJSON is a standard library Date method
        }
    },

    shouldStore: function() {
        return true
    },

    refsPidsForJsonStore: function(puuids = new Set()) {
        return puuids
    },
})


"use strict"

Object.defineSlots(Map, {

    instanceFromRecordInStore: function(aRecord, aStore) { // should only be called by Store
        const obj = this.clone()
        //obj.loadFromRecord(aRecord, aStore)
        return obj
    },

})


Object.defineSlots(Map.prototype, {

    loadFromRecord: function(aRecord, aStore) {

        aRecord.entries.forEach((entry) => {
            const key = entry[0]
            const value = aStore.unrefValue(entry[1])
            this.atPut(key, value)
        })

        return this
    },

    recordForStore: function(aStore) { // should only be called by Store
        let iterator = this.entries();
        let entry = iterator.next().value
        const entries = []
        while (entry) {
            const key = entry[0]
            const value = entry[1]
            entries.push([key, aStore.refValue(value)])
            entry = iterator.next().value
        }

        return {
            type: this.type(), 
            entries: entries
        }
    },

    shouldStore: function() {
        return true
    },

    refsPidsForJsonStore: function(puuids = new Set()) {
        this.forEach(v => { 
            if (!Type.isNull(v)) { 
                v.refsPidsForJsonStore(puuids)
            } 
        })
        return puuids
    },
})





"use strict"


Object.defineSlots(Set, {

    instanceFromRecordInStore: function(aRecord, aStore) { // should only be called by Store
        assert(aRecord.type === "Set")
        const obj = this.clone()
        //obj.loadFromRecord(aRecord, aStore)
        return obj
    },

})

Object.defineSlots(Set.prototype, {

    loadFromRecord: function(aRecord, aStore) {
        const values = aRecord.values.map(v => aStore.unrefValue(v))
        values.forEach(v => this.add(v))
        return this
    },

    recordForStore: function(aStore) { // should only be called by Store
        return {
            type: Type.typeName(this), 
            values: this.valuesArray().map(v => aStore.refValue(v))
        }
    },

    shouldStore: function() {
        return true
    },

    refsPidsForJsonStore: function(puuids = new Set()) {
        this.forEach(v => { 
            if (!Type.isNull(v)) { 
                v.refsPidsForJsonStore(puuids)
            } 
        })
        return puuids
    },
})





"use strict"


Object.defineSlots(Object, {

    instanceFromRecordInStore: function(aRecord, aStore) { // should only be called by Store
        assert(aRecord.type === "Object")
        const obj = {}
        obj.loadFromRecord(aRecord, aStore)
        return obj
    }

})


Object.defineSlots(Object.prototype, {

    loadFromRecord: function(aRecord, aStore) {
        assert(aRecord.type === "Object")
        aRecord.entries.forEach((entry) => {
            const k = entry[0]
            const v = entry[1]
            this[k] = aStore.unrefValue(v)
        })
        return this
    },

    recordForStore: function(aStore) { // should only be called by Store
        const entries = []

        Object.keys(this).forEach((k) => {
            const v = this[k]
            entries.push([k, aStore.refValue(v)])
        })

        return {
            type: this.type(), 
            entries: entries, 
        }
    },

    shouldStore: function() {
        return this._shouldStore
    },

    refsPidsForJsonStore: function(puuids = new Set()) {
        if (this.hasOwnProperty("*")) {
            puuids.add(this["*"])
        } else {
            throw new Error("dictionaries are reserved for pointers, but we found a non-pointer")
        }
        return puuids
    },
    
    defaultStore: function() {
        return PersistentObjectPool.shared()
    },

    scheduleSyncToStore: function(slotName) {
        this.didMutate()
    },

    didLoadFromStore: function () {

    }

})

"use strict"

Type.typedArrayTypeNames().forEach((name) => {
    const aClass = window[name]

    if (Type.isUndefined(aClass)) {
        console.warn("TypeArray-store error: missing type " + name)
        return
    }

    Object.defineSlots(aClass, {
        instanceFromRecordInStore: function(aRecord, aStore) { // should only be called by Store
            const obj = new this.thisClass()(aRecord.length)
            //obj.loadFromRecord(aRecord, aStore)
            return obj
        },
    })

    Object.defineSlots(aClass.prototype, {

        loadFromRecord: function(aRecord, aStore) {
            const values = aRecord.values
            for (let i = 0; i < values.length; i++) {
                this[i] = values[i]
            }
            return this
        },

        valuesArray: function() {
            return Array.fromIterator(this.values())
        },

        recordForStore: function(aStore) { // should only be called by Store
            return {
                type: this.type(), 
                values: this.valuesArray() 
            }
        },

        refsPidsForJsonStore: function(puuids = new Set()) {
            // no references in a TypedArray
            return puuids
        },
    })

})
"use strict"

ResourceLoader.pushRelativePaths([
    "String-store.js",
    "Boolean-store.js",
    "Number-store.js",
])

"use strict"

Object.defineSlots(String.prototype, {

    refsPidsForJsonStore: function(puuids = new Set()) {
        return puuids
    },

})


"use strict"

Object.defineSlots(Boolean.prototype, {

    refsPidsForJsonStore: function(puuids = new Set()) {
        return puuids
    },

})


"use strict"

Object.defineSlots(Number.prototype, {

    refsPidsForJsonStore: function(puuids = new Set()) {
        return puuids
    },

})


"use strict"

/*

    ObjectPool

        For persisting a node tree to JSON and back.
        Usefull for exporting nodes out the the app/browser
        and into others.

        JSON format:

            {
                rootPid: "rootPid",
                puuidToDict: {
                    "objPid" : <nodeDict>
                }

            }

        Example use:
    
            // converting a node to json
            const poolJson = ObjectPool.clone().setRoot(rootNode).asJson()
            
            // converting json to a node
            const rootNode = ObjectPool.clone().fromJson(poolJson).root()


    Literal values can be directly stored in JSON such as:

            String
            Number
            Boolean
            null

    Others need to be encoded, such as:

            Array // need to check for references
            a dictionary
            Date

            { __type__: "Array", v: [] }

    And nodes need to be encoded references: 

            BMNode

    BMNode needs to be referenced by a puuid and the Store needs to know it needs to be written if not already present.

*/

window.ObjectPool = class ObjectPool extends ProtoClass {
    
    initPrototype () {
        this.newSlot("name", "defaultDataStore")
        this.newSlot("rootObject", null)

        // AtomicDictionary
        this.newSlot("recordsDict", null) 

        // dict - objects known to the pool (previously loaded or referenced)
        this.newSlot("activeObjects", null) 

        // dict - objects with mutations that need to be stored
        this.newSlot("dirtyObjects", null)

        // set - pids of objects that we're loading in this event loop
        this.newSlot("loadingPids", null)

        // set - pids of objects that we're storing in this event loop
        this.newSlot("storingPids", null)

        // WARNING: vulnerable to system time changes
        this.newSlot("lastSyncTime", null)
        //isReadOnly: true,

        // Set of puuids
        this.newSlot("markedSet", null) 

        // TODO: change name?
        this.newSlot("nodeStoreDidOpenNote", null)

        this.newSlot("isFinalizing", false)
    }

    init () {
        super.init()
        this.setRecordsDict(ideal.AtomicDictionary.clone())
        this.setActiveObjects({})
        this.setDirtyObjects({})
        this.setLoadingPids(new Set())
        this.setLastSyncTime(null)
        this.setMarkedSet(null)
        this.setNodeStoreDidOpenNote(window.BMNotificationCenter.shared().newNote().setSender(this).setName("nodeStoreDidOpen"))
        this.setIsDebugging(false)
        return this
    }

    clearCache () {
        this.setActiveObjects({})
        this.setDirtyObjects({})
        this.readRoot()
        //this.setRootObject(this.objectForPid(this.rootObject().puuid()))
        return this
    }

    // --- open ---

    open () {
        this.recordsDict().setName(this.name())
        this.recordsDict().open()
        this.onRecordsDictOpen()
        return this
    }

    asyncOpen (callback, errorCallback) {
        this.recordsDict().setName(this.name())
        const successCallback = () => {
            this.onRecordsDictOpen()
            if (callback) {
                callback()
            }
        }

        this.recordsDict().asyncOpen(successCallback, errorCallback)
        return this
    }

    onRecordsDictOpen () {
        this.collect()
        this.readRoot()
        this.nodeStoreDidOpenNote().post()
        return this
    }

    isOpen () {
        return this.recordsDict().isOpen()
    }

    // --- root ---

    rootKey () {
        return "root"
    }

    hasStoredRoot () {
        return this.recordsDict().hasKey(this.rootKey())
    }

    rootOrIfAbsentFromClosure (aClosure) {
        if (!this.hasStoredRoot()) {
            const newRoot = aClosure()
            assert(newRoot)
            this.setRootObject(newRoot)
        }
        return this.rootObject()
    }

    readRoot () {
        //console.log(" this.hasStoredRoot() = " + this.hasStoredRoot())
        if (this.hasStoredRoot()) {
            const rootRecord = this.recordForPid(this.rootKey())
            //console.log("rootRecord.subnodes: ", JSON.stringify(rootRecord, null, 2))

            const root = this.objectForPid(this.rootKey())
            //root.thisPrototype().ownSlotNamed("subnodes").setupInOwner()
            //root.subnodes()
            this._rootObject = root
            //let subnodes = root.subnodes()
            //console.log("root subnodes.length = " + subnodes.length)
            //this.setRootObject()
        }
        return this.rootObject()
    }

    knowsObject (obj) { // private
        const puuid = obj.puuid()
        const foundIt = this.recordsDict().hasKey(puuid) ||
            this.activeObjects().hasOwnProperty(puuid) ||
            this.dirtyObjects().hasOwnProperty(puuid)
        return foundIt
    }

    assertOpen () {
        assert(this.isOpen())
    }

    changeOldPidToNewPid (oldPid, newPid) {
        // flush and change pids on all activeObjects 
        // and pids and pidRefs in recordsDict 
        throw new Error("unimplemented")
        return this
    }
    
    setRootObject (obj) {
        this.assertOpen()
        if (this._rootObject) {
            // can support this if we change all stored and
            //this.changeOldPidToNewPid("root", Object.newUuid())
            throw new Error("can't change root object yet, unimplemented")
        }

        assert(!this.knowsObject(obj))

        obj.setPuuid(this.rootKey())
        this._rootObject = obj
        this.addActiveObject(obj)
        this.addDirtyObject(obj)
        
        return this
    }

    // ---  ---

    asJson () {
        return this.recordsDict().asJson()
    }

    updateLastSyncTime () {
        this.setLastSyncTime(Date.now())
        return this
    }

    // --- active and dirty objects ---

    hasActiveObject (anObject) {
        const puuid = anObject.puuid()
        return this.activeObjects().hasOwnProperty(puuid)
    }
    
    addActiveObject (anObject) {
        assert(!anObject.isClass())

        if (!anObject.shouldStore()) {
            const msg = "attempt to addActiveObject '" + anObject.type() + "' but shouldStore is false"
            console.log(msg)
            anObject.shouldStore()
            throw new Error(msg)
        //return false
        }

        if (!anObject.isInstance()) {
            const msg = "can't store non instance of type '" + anObject.type() + "'"
            console.log(msg)
            anObject.isKindOf(ProtoClass) 
            throw new Error(msg)
        }

        /*
        if (!anObject.isKindOf(ProtoClass) && !anObject.isKindOf(SubnodesArray)) {
        //if (["Object", "PersistentObjectPool", "Set", "Map"].contains(anObject.type())) {
            const msg = "can't store object of type '" + anObject.type() + "'"
            console.log("---")
            console.log(msg)
            console.log("---")
            //anObject.isKindOf(ProtoClass) 
            Object.shouldStore() 
            let path = anObject.slotValuePath("_shouldStore")
            console.log("_shouldStore path:", JSON.stringify(path))
            path = anObject.slotValuePath("shouldStore")
            console.log("shouldStore path:", path)
            anObject.shouldStore() 

            throw new Error(msg)
        }
        */

        if(!this.hasActiveObject(anObject)) {
            anObject.addMutationObserver(this)
            this.activeObjects().atPut(anObject.puuid(), anObject)
            //this.addDirtyObject(anObject)
        }

        return true
    }

    hasDirtyObjects () {
        return Object.keys(this.dirtyObjects()).length !== 0
    }

    /*
    hasDirtyObject (anObject) {
        const puuid = anObject.puuid()
        return this.dirtyObjects().hasOwnProperty(puuid)
    }
    */

    onObjectUpdatePid (anObject, oldPid, newPid) {
        // sanity check for debugging - could remove later
        if (this.hasActiveObject(anObject)) {
            const msg = "onObjectUpdatePid " + anObject.typeId() + " " + oldPid + " -> " + newPid
            console.log(msg)
            throw new Error(msg)
        }
    }

    onDidMutateObject (anObject) {
        if (this.hasActiveObject(anObject)) {
        //if (anObject.hasDoneInit() && this.hasActiveObject(anObject)) {
            this.addDirtyObject(anObject)
        }
    }

    isStoringObject (anObject) {
        const puuid = anObject.puuid()
        if (this.storingPids()) {
            if (this.storingPids().has(puuid)) {
                return true
            }
        }
        return false
    }

    isLoadingObject (anObject) {
        if (this.loadingPids()) {
            if (this.loadingPids().has(puuid)) {
                return true
            }
        }
        return false
    }

    addDirtyObject (anObject) {
        if (!this.hasActiveObject(anObject)) {
            console.log("looks like it hasn't been referenced yet")
            throw new Error("not referenced yet")
        }

        const puuid = anObject.puuid()

        if (this.isStoringObject(anObject)) {
            return this
        }

        if (this.isLoadingObject(anObject)) {
            return this
        }

        if (!this.dirtyObjects().hasOwnProperty(puuid)) {
            this.debugLog(() => "addDirtyObject(" + anObject.typeId() + ")" )
            this.dirtyObjects()[puuid] = anObject
            this.scheduleStore()
        }

        return this
    }

    scheduleStore () {
        if (!this.isOpen()) {
            console.log(this.typeId() + " can't schedule store yet, not open")
            return this
        }
        assert(this.isOpen())
        const scheduler = SyncScheduler.shared()
        const methodName = "commitStoreDirtyObjects"
        if (!scheduler.isSyncingTargetAndMethod(this, methodName)) {
            if (!scheduler.hasScheduledTargetAndMethod(this, methodName)) {
                //console.warn("scheduleStore currentAction = ", SyncScheduler.currentAction() ? SyncScheduler.currentAction().description() : null)
                scheduler.scheduleTargetAndMethod(this, methodName, 1000)
            }
        }
        return this
    }

    // --- storing ---

    commitStoreDirtyObjects () {
        if (this.hasDirtyObjects()) {
            this.debugLog("--- commitStoreDirtyObjects begin ---")
            this.recordsDict().begin()
            const storeCount = this.storeDirtyObjects()
            this.recordsDict().commit()
            this.debugLog("--- commitStoreDirtyObjects end --- stored " + storeCount + " objects")
        }
    }

    storeDirtyObjects () { // PRIVATE
        let totalStoreCount = 0
        this.setStoringPids(new Set())

        while (true) {
            let thisLoopStoreCount = 0
            const dirtyBucket = this.dirtyObjects()
            this.setDirtyObjects({})

            dirtyBucket.ownForEachKV((puuid, obj) => {
                //console.log("  storing pid " + puuid)

                if (this.storingPids().has(puuid)) {
                    const msg = "ERROR: attempt to double store " + obj.typeId()
                    console.log(msg)
                    throw new Error(msg)
                }

                this.storingPids().add(puuid)

                this.storeObject(obj)

                thisLoopStoreCount ++
            })

            totalStoreCount += thisLoopStoreCount
            //this.debugLog(() => "totalStoreCount: " + totalStoreCount)
            if (thisLoopStoreCount === 0) {
                break
            }
        }

        this.setStoringPids(null)
        return totalStoreCount
    }

    // --- reading ---

    conversionDict () {
        return { 
            "BMMenuNode" : "BMFolderNode",
            "KinsaResources" : "Kinsa",
            "BMCamStore" : "BMCams",
        }
        /*
        return {
            "BMThemeFolder" : "BMFolderNode",
            "BMThemeAttribute" : "BMStringField",
        }
        */
    }

    objectForRecord (aRecord) { // private
        const className = aRecord.type
        
        //console.log("loading " + className + " " + aRecord.id)
        
        let aClass = window[className]
        if (!aClass) {
            const altClassName = this.conversionDict()[className]

            if (altClassName) {
                aClass = window[altClassName]
            }

            if (!aClass) {
                throw new Error("missing class '" + className + "'")
            }
        }
        
        assert(aRecord.id)
        const obj = aClass.instanceFromRecordInStore(aRecord, this)
        assert(!this.hasActiveObject(obj))
        obj.setPuuid(aRecord.id)
        this.addActiveObject(obj)
        obj.loadFromRecord(aRecord, this)

        return obj
    }

    activeObjectForPid (puuid) {
        return this.activeObjects().getOwnProperty(puuid)
    }

    objectForPid (puuid) { // private
        //console.log("objectForPid " + puuid)

        const activeObj = this.activeObjectForPid(puuid)
        if (activeObj) {
            return activeObj
        }

        if (!this.isFinalizing() && this.loadingPids().size === 0) {
            window.SyncScheduler.shared().scheduleTargetAndMethod(this, "didInitLoadingPids")
        }

        this.loadingPids().add(puuid)
        
        const aRecord = this.recordForPid(puuid)
        const loadedObj = this.objectForRecord(aRecord)
        if (loadedObj) {
            loadedObj.scheduleDidLoadFromStore()
        }

        return loadedObj
    }

    didInitLoadingPids () {
        this.setIsFinalizing(true)
        while (!this.loadingPids().isEmpty()) {
            const lastSet = this.loadingPids()
            this.setLoadingPids(new Set())

            lastSet.forEach((loadedPid) => {
                const obj = this.activeObjectForPid(loadedPid)
                if (obj.didLoadFromStore) {
                    obj.didLoadFromStore()
                }
            })
        }
        this.setIsFinalizing(false)
    }

    //

    allPids () {
        return this.recordsDict().keys()
    }

    activeLazyPids () { // returns a set of pids
        const pids = new Set()
        this.activeObjects().ownForEachKV((pid, obj) => {
            if (obj.lazyPids) {
                obj.lazyPids(pids)
            }
        })
        return pids
    }

    // --- references ---

    refForPid (aPid) {
        return { "*": this.pid() }
    }

    pidForRef (aRef) {
        return aRef.getOwnProperty("*")
    }

    unrefValueIfNeeded (v) {
        return this.unrefValue(v)
    }

    unrefValue (v) {
        if (Type.isLiteral(v)) {
            return v
        }
        const puuid = v.getOwnProperty("*")
        assert(puuid)
        const obj = this.objectForPid(puuid)
        return obj
    }

    refValue (v) {
        if (Type.isLiteral(v)) {
            return v
        }

        assert(!v.isClass())

        if (!v.shouldStore()) {
            console.log("WARNING: called refValue on " + v.type() + " which has shouldStore=false")
            return null
        }

        if (!this.hasActiveObject(v)) {
            this.addActiveObject(v)
            this.addDirtyObject(v)
        }

        this.addActiveObject(v)
        const ref = { "*": v.puuid() }
        return ref
    }

    // read a record

    recordForPid (puuid) { // private
        if (!this.recordsDict().hasKey(puuid)) {
            return undefined
        }
        const jsonString = this.recordsDict().at(puuid)
        assert(Type.isString(jsonString))
        const aRecord = JSON.parse(jsonString)
        aRecord.id = puuid
        return aRecord
    }

    // write an object

    storeObject (obj) {
        assert(obj.shouldStore())

        const puuid = obj.puuid()
        if (Type.isUndefined(puuid)) {
            obj.puuid()
        }
        assert(puuid)
        let v = JSON.stringify(obj.recordForStore(this))
        this.debugLog("store " + obj.puuid() + " <- " + v)
        this.recordsDict().atPut(puuid, v)
        return this
    }

    // -------------------------------------

    flushIfNeeded () {
        if (this.hasDirtyObjects()) {
            this.storeDirtyObjects()
            assert(!this.hasDirtyObjects())
        }
        return this
    }

    collect () {
        // this is an on-disk collection
        // in-memory objects aren't considered
        // so we make sure they're flushed to the db first 
        this.recordsDict().begin()
        this.flushIfNeeded() // store any dirty objects

        this.debugLog("--- begin collect --- with " + this.recordsDict().keys().length + " pids")
        this.setMarkedSet(new Set())
        this.markPid(this.rootKey())
        this.activeObjects().ownForEachKV((pid, obj) => this.markPid(pid))
        this.activeLazyPids().forEach(pid => this.markPid(pid))
        const deleteCount = this.sweep()
        this.setMarkedSet(null)

        this.recordsDict().commit()
        this.debugLog(() => "--- end collect --- collected " + deleteCount + " pids ---")

        let remainingCount = this.recordsDict().size()
        this.debugLog(() => " remaining keys after commit: " + remainingCount)
        return deleteCount
    }

    markPid (pid) { // private
        //this.debugLog(() => "markPid(" + pid + ")")
        if (!this.markedSet().has(pid)) {
            this.markedSet().add(pid)
            const refPids = this.refSetForPuuid(pid)
            //this.debugLog(() => "markPid " + pid + " w refs " + JSON.stringify(refPids))
            refPids.forEach(refPid => this.markPid(refPid))
            return true
        }
        return false
    }

    refSetForPuuid (puuid) {
        const record = this.recordForPid(puuid)
        const puuids = new Set()

        if (record) {
            Object.keys(record).forEach(k => this.puuidsSetFromJson(record[k], puuids))
        }

        return puuids
    }

    puuidsSetFromJson (json, puuids = new Set()) {
        // json can only contain array's, dictionaries, and literals.
        // We store dictionaries as an array of entries, 
        // and reserve dicts in the json for pointers with the format { "*": "<puuid>" }

        //console.log(" json: ", JSON.stringify(json, null, 2))

        if (Type.isLiteral(json)) {
            // we could call refsPidsForJsonStore but none will add any pids,
            // and null raises exception, so we can just skip it for now
        } else if (Type.isObject(json) && json.refsPidsForJsonStore) {
            json.refsPidsForJsonStore(puuids)
        } else {
            throw new Error("unable to handle json type: " + typeof(json) + " missing refsPidsForJsonStore() method?")
        }
        
        return puuids
    }

    // ------------------------

    sweep () {
        // delete all unmarked records
        let deleteCount = 0
        const recordsDict = this.recordsDict()
        this.recordsDict().keys().forEach((pid) => {
            if (!this.markedSet().has(pid)) {
                //this.debugLog("deletePid(" + pid + ")")
                const count = recordsDict.keys().length
                recordsDict.removeKey(pid)
                assert(recordsDict.keys().length === count - 1)
                deleteCount ++
            }
        })
        return deleteCount
    }

    // ---------------------------

    rootSubnodeWithTitleForProto (aTitle, aProto) {
        return this.rootObject().subnodeWithTitleIfAbsentInsertProto(aTitle, aProto)
    }

    totalBytes () {
        return this.recordsDict().totalBytes()
    }

    // ---------------------------

    /*
    activeObjectsReferencingObject (anObject) {
        // useful for seeing if we can unload an object
        // BUT, to do full collect, do a mark/sweep on active objects
        // where sweep only removes unmarked from activeObjects and records cache?

        assert(this.hasActiveObject(anObject)) 

        const referencers = new Set()
        const pid = anObject.puuid()

        this.activeObjects().forEach((obj) => {
            const refPids = this.refSetForPuuid(obj.puuid())
            if (refPids.has(pid)) {
                referencers.add(obj)
            }
        })

        return referencers
    }
    */

/*
    selfTestRoot () {
        const aTypedArray = Float64Array.from([1.2, 3.4, 4.5])
        const aSet = new Set("sv1", "sv2")
        const aMap = new Map([ ["mk1", "mv1"], ["mk2", "mv2"] ])
        const aNode = BMStorableNode.clone()
        const a = [1, 2, [3, null], { foo: "bar", b: true }, aSet, aMap, new Date(), aTypedArray, aNode]
        return a
    }

    selfTest () {
        console.log(this.type() + " --- self test start --- ")
        const store = ObjectPool.clone()
        store.open()

        store.rootOrIfAbsentFromClosure(() => BMStorableNode.clone())
        store.flushIfNeeded()
        console.log("store:", store.asJson())
        console.log(" --- ")
        store.collect()
        store.clearCache()
        const loadedNode = store.rootObject()
        console.log("loadedNode = ", loadedNode)
        console.log(this.type() + " --- self test end --- ")
    }
    */

}.initThisClass()


// -------------------

/*
setTimeout(() => {
    ObjectPool.selfTest()
}, 1000)
*/



"use strict"

/*

    PersistentObjectPool

        An ObjectPool that uses a PersistentAtomicDictionary
        to store it's records.

*/

window.PersistentObjectPool = class PersistentObjectPool extends ObjectPool {
    
    initPrototype () {

    }

    init () {
        super.init()
        this.setName("defaultDataStore")
        this.setRecordsDict(PersistentAtomicDictionary.clone())
        return this
    }

    open () {
        throw new Error(this.type() + " synchronous open not available - use asyncOpen()")
    }

    selfTest () {
        console.log(this.type() + " --- self test start --- ")
        const store = this.thisClass().clone()
        store.asyncOpen(() => this.selfTestOnStore(store))
    }

    selfTestOnStore (store) {
        store.rootOrIfAbsentFromClosure(() => BMStorableNode.clone())
        //store.flushIfNeeded()
        console.log("store:", store.asJson())
        console.log(" --- ")
        store.collect()
        store.clearCache()
        const loadedNode = store.rootObject()
        console.log("loadedNode = ", loadedNode)
        console.log(this.type() + " --- self test end --- ")
    }
    
}.initThisClass()


//setTimeout(() => {
//PersistentObjectPool.selfTest()
//}, 1000)



"use strict"

/*

    StoreRef

*/


window.StoreRef = class StoreRef {
    
    static clone() {
        const instance = new StoreRef()
        instance.init()
        return instance
    }

    init () {
        Object.defineSlot(this, "_store", null)
    }

    setPid (aPid) {
        this["*"] = aPid
        return this
    }

    pid () {
        return this.getOwnProperty("*")
    }

    setStore (aStore) {
        this._store = aStore
        return this
    }

    store () {
        return this._store
    }

    unref () {
        return this.store().objectForPid(this.pid())
    }

    ref () {
        return this.store().refForPid(this.pid())
    }
    
}


"use strict"

ResourceLoader.pushRelativePaths([
    "BMDataStore.js",
    //"BMDataStoreRecord.js", // need to load FieldSet first
])

"use strict"

/*

    BMDataStore

    A visible representation of the storage system
    
*/

window.BMDataStore = class BMDataStore extends BMNode {
    
    static initThisClass () {
        super.initThisClass()
        this.setIsSingleton(true)
        return this
    }

    initPrototype () {
        this.newSlot("lastSyncTime", 0)
    }

    init () {
        super.init()
        this.setTitle("Storage")
        this.setNodeMinWidth(300)
    }

    subtitle () {
        return this.defaultStore().totalBytes().byteSizeDescription()
    }

    storeHasChanged () {
        return this.defaultStore().lastSyncTime() !== this.lastSyncTime()
    }

    prepareToSyncToView () {
        //console.log("this.storeHasChanged() = ", this.storeHasChanged())

        if (this.subnodeCount() === 0 || this.storeHasChanged()) {
            this.defaultStore().collect()
            this.setLastSyncTime(this.defaultStore().lastSyncTime())
            this.refreshSubnodes()
        }
    }

    store () {
        return this.defaultStore()
    }

    refreshSubnodes () {
        //this.debugLog(" refreshSubnodes")
        this.removeAllSubnodes()
        this.store().allPids().forEach((pid) => {
            const aRecord = this.store().recordForPid(pid)
            this.addRecord(aRecord)
        })
    }

    subnodeForClassName (aClassName) {
        let subnode = this.firstSubnodeWithTitle(aClassName)
        if (!subnode) {
            subnode = BMNode.clone().setTitle(aClassName).setNoteIsSubnodeCount(true)
            this.justAddSubnode(subnode)
        }
        return subnode
    }

    addRecord (aRecord) {
        const subnode = BMDataStoreRecord.clone()
        //subnode.setTitle(aRecord.type + " " + aRecord.id)
        subnode.setTitle(aRecord.id)
        subnode.setKey(aRecord.id)
        subnode.setStore(this.store())
        const size = JSON.stringify(aRecord).length
        subnode.setSubtitle(size.byteSizeDescription())

        const classNode = this.subnodeForClassName(aRecord.type)
        classNode.setNodeMinWidth(300)
        classNode.justAddSubnode(subnode)

        return this
    }
    
    
}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "BMSummaryNode.js",
    "BMFolderNode.js",
    "BMImageNode.js",
    "BMTextNode.js",
    "BMLinkNode.js",
    "BMPrototypesNode.js",
])

//console.log("Currently running script:", Error.callingScriptURL())

"use strict"

/*
    
    BMSummaryNode
    
    A node that contains Text, stores it's:
        content, color, font, padding, margin
    and has an inspector for these attributes
    
    support for links?

*/

window.BMSummaryNode = class BMSummaryNode extends BMStorableNode {
    
    initPrototype () {

        {
            const slot = this.newSlot("nodeSummarySuffix", " ")
            slot.setShouldStoreSlot(true)
            slot.setDuplicateOp("copyValue")
            slot.setCanInspect(true)
            slot.setSlotType("String")
            slot.setLabel("suffix")
            slot.setInspectorPath("Summary")
            slot.setSyncsToView(true)
        }

        {
            const slot = this.newSlot("nodeSubtitleIsChildrenSummary", false)
            slot.setShouldStoreSlot(true)
            slot.setDuplicateOp("copyValue")
            slot.setCanInspect(true)
            slot.setSlotType("Boolean")
            slot.setLabel("is children summary")
            slot.setInspectorPath("Subtitle")
            slot.setSyncsToView(true)
        }

        {
            const slot = this.newSlot("hasNewlineAferSummary", false)
            slot.setShouldStoreSlot(true)
            slot.setDuplicateOp("copyValue")
            slot.setCanInspect(true)
            slot.setSlotType("Boolean")
            slot.setLabel("has new line ending")
            slot.setInspectorPath("Summary")
            slot.setSyncsToView(true)
        }

        {
            const slot = this.newSlot("summaryFormat", "value")
            slot.setShouldStoreSlot(true)
            slot.setDuplicateOp("copyValue")
            slot.setCanInspect(true)
            slot.setSlotType("String")
            slot.setLabel("format")
            slot.setValidValues(["none", "key", "value", "key value", "value key"])
            slot.setSyncsToView(true)
            slot.setInspectorPath("Summary")
        }

        {
            const slot = this.overrideSlot("subtitleIsSubnodeCount", false)
            slot.setDuplicateOp("copyValue")
            slot.setShouldStoreSlot(true)
            slot.setCanInspect(true)
            slot.setSlotType("Boolean")
            slot.setLabel("is subnode count")
            slot.setInspectorPath("Subtitle")
            slot.setSyncsToView(true)
        }

        {
            const slot = this.overrideSlot("noteIsSubnodeCount", false)
            slot.setDuplicateOp("copyValue")
            slot.setShouldStoreSlot(true)
            slot.setCanInspect(true)
            slot.setSlotType("Boolean")
            slot.setLabel("is subnode count")
            slot.setInspectorPath("Note")
            slot.setSyncsToView(true)
        }

        this.setShouldStore(true)
        this.setShouldStoreSubnodes(true)

        this.setTitle("title")
    }

    init () {
        super.init()
    }

    didUpdateSlotSummaryFormat () {
        this.didUpdateNode()
    }

    summaryKey () {
        return this.title()
    }

    summaryValue () {
        return this.subtitle()
    }

    subtitle () {
        if (this.nodeSubtitleIsChildrenSummary()) {
            return this.childrenSummary()
        }

        return super.subtitle()
    }

    didUpdateSlotNodeSubtitleIsChildrenSummary (oldValue, newValue) {
        if (oldValue === true) {
            this.setSubtitle(null)
        }
    }

    // --- summary ---
    		
    summary () {
        const k = this.summaryKey()
        let v = this.summaryValue()

        if (Type.isNull(v)) {
            v = ""
        }

        const f = this.summaryFormat()
        let end = this.nodeSummarySuffixOut()

        if (this.hasNewlineAferSummary()) {
            end = "<br>"
        }

        if (f === "key") { 
            return k + end
        }
    
        if (f === "value") { 
            return v + end
        }

        const j = " "

        if (f === "key value") { 
            return k + j + v + end
        }

        if (f === "value key") { 
            return v + j + k + end
        }

        return ""
    }
        
    childrenSummary () {
        return this.subnodes().map(subnode => subnode.summary()).filter(s => s.length).join("")
    }

    nodeSummarySuffixOut () {
        let s = this._nodeSummarySuffix
        
        if (s === "newline") {
            return "<br>"
        } else {
            s = s.replaceAll("<br>", "")
        }
        
        return s
    }
    
}.initThisClass()


"use strict"

/*
    
    BMFolderNode
    
    A node that supports for adding, reordering, etc other nodes to it within the UI.
    
*/

window.BMFolderNode = class BMFolderNode extends BMSummaryNode {
    
    static availableAsNodePrimitive() {
        return true
    }
    
    initPrototype () {
        this.newSlot("label", "").setShouldStoreSlot(true)

        this.newSlot("target", null)
        this.newSlot("methodName", null)
        this.newSlot("info", null)

        this.setCanDelete(true)
        this.setNodeCanInspect(true)
        this.setShouldStore(true)
        this.setShouldStoreSubnodes(true)
        this.setNodeMinWidth(300)

        this.setTitle("title")
        this.setNodeCanEditTitle(true)
        
        this.setNodeCanReorderSubnodes(true)

        //this.setNodeColumnStyles(BMViewStyles.clone())
        //this.setNodeRowStyles(BMViewStyles.clone())
        //this.setNodeUsesColumnBackgroundColor(false)

        this.setNodeCanInspect(true) 
        //this.setNoteIconName("right arrow")
    }

    init () {
        super.init()
        this.addAction("add")
        this.setSubnodeClasses(BMNode.primitiveNodeClasses())
    }

    title () {
        return this.label()
    }

    setTitle (aString) {
        this.setLabel(aString)
        return this
    }

    acceptedSubnodeTypes () {
        return BMCreatorNode.fieldTypes()
    }

    sendMenuAction () {
       const t = this.target()
       const m = this.methodName()

       if (t && m && t[m]) {
           t[m].apply(t, [this])
       }
    }

    onTapOfNode (aNode) {
        super.onTapOfNode()
        this.sendMenuAction()
        return this
    }

    didUpdateSlotParentNode (oldValue, newValue) {
        this.scheduleSyncToView()
    }

}.initThisClass()


"use strict"

/*

    BMImageNode
    
*/

window.BMImageNode = class BMImageNode extends BMStorableNode {
    
    initPrototype () {
        this.newSlot("dataURL", null).setShouldStoreSlot(true)

        this.setNodeCanEditTitle(true)
        this.setNodeCanEditSubtitle(false)
        this.setNodeMinWidth(200)
        this.setTitle("Untitled")
        this.setSubtitle(null)

        this.setCanDelete(true)
    }

    init () {
        super.init()
        this.addActions(["add"])
    }
    
    onDidEditNode () {
        this.debugLog(" onDidEditNode")
        this.scheduleSyncToStore()
    }
    
}.initThisClass()

"use strict"

/*
    
    BMTextNode
    
    A node that contains Text, stores it's:
        content, color, font, padding, margin
    and has an inspector for these attributes
    
*/

window.BMTextNode = class BMTextNode extends BMStorableNode {
    

    static availableAsNodePrimitive() {
        return true
    }

    initPrototype () {
        /*
        {
            const slot = this.newSlot("nodeUrlLink", "")
            slot.setShouldStoreSlot(true)
            slot.setCanInspect(true)
            slot.setSlotType("String")
            slot.setLabel("URL")
            //slot.setSyncsToView(true)
            //slot.setInspectorPath("Style")
        }
        */

        {
            const slot = this.newSlot("value", "...")
            slot.setShouldStoreSlot(true)
            slot.setCanInspect(true)
            slot.setSlotType("String")
            slot.setLabel("value")
            slot.setSyncsToView(true)
            //slot.setInspectorPath("Style")
        }

        this.setShouldStore(true)
        this.setShouldStoreSubnodes(true)
        this.setCanDelete(true)
        this.setNodeCanInspect(true)
        this.setNodeMinWidth(300)

        this.setTitle("title")
        this.setNodeCanEditTitle(true)
        
        this.setNodeCanReorderSubnodes(true)
  
        this.setNodeCanEditRowHeight(true)
        this.setNodeCanEditColumnWidth(true)
    }

    /*
    init () {
        super.init()
    }
    */

    acceptedSubnodeTypes () {
        return []
    }


}.initThisClass()


"use strict"

/*
    
    BMLinkNode
    
    A node that to represent a link to another node, which is not a subnode
    
*/

window.BMLinkNode = class BMLinkNode extends BMSummaryNode {
    
    static availableAsNodePrimitive() {
        return true
    }

    initPrototype () {
        this.newSlot("linkedNode", null).setShouldStoreSlot(true).setDuplicateOp("copyValue")
        
        const dupSlot = this.newSlot("willDuplicateLinkedObject", false).setShouldStoreSlot(true)
        dupSlot.setCanInspect(true).setSlotType("Boolean").setLabel("Will duplicate linked object")

        this.setShouldStore(true)
        this.setShouldStoreSubnodes(false)
        this.setCanDelete(true)
        this.setNodeCanInspect(true)
        this.setNodeMinWidth(300)

        this.setNodeCanEditTitle(true)

        this.setCanDelete(true)
        this.setNodeCanInspect(true) 
    }

    init () {
        super.init()
    }

    nodeAcceptsDrop (aNode) {
        return true
    }

    nodeDropped (aNode) {
        this.setLinkedNode(aNode)
    }

    duplicate () {
        const obj = super.duplicate()
        if (this.willDuplicateLinkedObject()) {
            const ln = this.linkedNode()
            if (ln) {
                obj.setLinkedNode(ln.duplicate())
            }
        }
        return obj
    }

    title () {
        const ln = this.linkedNode()
        if (ln) {
            return ln.title()
        }
        return "Unlinked"
    }

    subtitle () {
        const ln = this.linkedNode()
        if (ln) {
            return ln.subtitle()
        }
        return "drop row to link"    
    }

    /*
    title () {
        if (Type.isNull(super.title()) && this.linkedNode()) {
            return this.linkedNode().title()
        }

        return super.title()
    }
    */

    acceptedSubnodeTypes () { 
        // TODO: have browser use nodeRowLink for this protocol?
        return []
    }
    
    note () {
        if (this.linkedNode()) {
            return this.linkedNode().note()
        }

        return null
    }

    noteIconName () {
        //return this.nodeRowLink() ? "double right caret" : null
        return null
    }

    nodeRowLink () {
        return this.linkedNode()
    }

    nodeCanReorderSubnodes () {
        const ln = this.linkedNode()
        return ln ? ln.nodeCanReorderSubnodes() : false // have this operation done in the browser?
    }

    addSubnodeAt (aSubnode, anIndex) {
        return super.addSubnodeAt(aSubnode, anIndex)
    }

}.initThisClass()


"use strict"

/*

    BMPrototypesNode
 
 

*/

window.BMPrototypesNode = class BMPrototypesNode extends BMStorableNode {
    
    initPrototype () {
    }

    init () {
        super.init()
        this.setTitle("Prototypes")
        this.setNodeCanReorderSubnodes(true)
        //this.setupSubnodes()
        return this
    }

    setupSubnodes () {
        /*
        let primitives = BMFolderNode.clone().setTitle("Primitives")
        primitives.setShouldStoreSubnodes(false)

        this.addSubnode(primitives)

        primitives.addSubnodes(this.primitiveSubnodes())
        */
        return this
    }

}.initThisClass()


"use strict"

ResourceLoader.pushRelativePaths([
    "BMFieldSetNode.js",
    "BMField.js",
    
    "BMActionNode.js",
    "json/_imports.js",
    "BMCreatorNode.js",
    "subclasses/_imports.js"
])

"use strict"

/*

    BMFieldSetNode

    Useful for node's which are to be viewed and interacted with as forms
    
    child nodes are of type BMField and should only be added via addFieldNamed()
    This method sets the target of the field to this and the method to the field name.
                    
    example use in subclass 

    in BMCustomFormNode class:
    
        init () {
            super.init()

            this.addFieldNamed("from")
            this.addFieldNamed("to")
            this.addFieldNamed("subject")
            this.addFieldNamed("body").setNodeMinRowHeight(-1)

            this.setActions(["send"])
            this.setCanDelete(true)
        }

        ...

*/  
        
window.BMFieldSetNode = class BMFieldSetNode extends BMStorableNode {
    
    initPrototype () {
        this.newSlot("status", "")
        this.newSlot("isEditable", true)
    }

    init () {
        super.init()
        this.setNodeMinWidth(500)
        this.setShouldStoreSubnodes(false)
    }
    
    didUpdateField (aField) {
        // override to implement hooks
    }
	
    // --- fields ---

    addField (aField) {
        aField.setTarget(this) 
        aField.getValueFromTarget()
        this.addSubnode(aField)
        return aField
    }

    addFieldNamed (name) {	
        const field = BMField.clone().setKey(name)
        field.setTarget(this)
        field.setValueMethod(name)
        this.addStoredField(field)
        return field
    }
    
    fieldNamed (aName) {
        return this.subnodes().detect( (subnode) => { 
            return subnode.valueMethod() === aName || subnode.key() === aName
        })
    }
    
    /*
    valueForFieldNamed (aName) {
        return this.fieldNamed(aName).value()
    }
    */

    onDidEditNode () {
        this.scheduleSyncToStore()
        this.didUpdateNode()
    }

    // --- validation ---

    validate () {
        return this.invalidSubnodes().length === 0
    }

    invalidSubnodes () {
        return this.subnodes().select(subnode => !subnode.validate())
    }

    isValid () {
        return this.validate() // could cache this later...
    }

}.initThisClass()

"use strict"

/*

    BMField

    A BMStorageNode that has a key, value, and valueMethod (among other properties),
    that's useful for automatically constructing a UI to interact with properties of a parent Node.
    
*/
        

window.BMField = class BMField extends BMSummaryNode {
    
    initPrototype () {
        this.newSlot("isVisible", true)
        this.newSlot("isEnabled", true)

        // key
        {
            const slot = this.newSlot("key", "key")
            slot.setShouldStoreSlot(true)
            slot.setDuplicateOp("duplicate")
            slot.setCanInspect(true)
            slot.setSlotType("String")
            slot.setLabel("key")
            slot.setInspectorPath("Key")
        }


        {
            const slot = this.newSlot("keyIsVisible", true)
            slot.setShouldStoreSlot(true)
            slot.setDuplicateOp("duplicate")
            slot.setCanInspect(true)
            slot.setSlotType("Boolean")
            slot.setLabel("visible")
            slot.setInspectorPath("Key")
        }

        {
            const slot = this.newSlot("keyIsEditable", false)
            slot.setShouldStoreSlot(true)
            slot.setDuplicateOp("duplicate")
            slot.setCanInspect(true)
            slot.setSlotType("Boolean")
            slot.setLabel("editable")
            slot.setInspectorPath("Key")
        }

        // value
        {
            const slot = this.newSlot("value", null)
            slot.setShouldStoreSlot(true)
            slot.setDuplicateOp("duplicate")
        }

        {
            const slot = this.newSlot("valueIsVisible", true)
            slot.setShouldStoreSlot(true)
            slot.setDuplicateOp("duplicate")
            slot.setCanInspect(true)
            slot.setSlotType("Boolean")
            slot.setLabel("visible")
            slot.setInspectorPath("Value")
        }

        {
            const slot = this.newSlot("valueIsEditable", true)
            slot.setShouldStoreSlot(true)
            slot.setDuplicateOp("duplicate")
            slot.setCanInspect(true)
            slot.setSlotType("Boolean")
            slot.setLabel("editable")
            slot.setInspectorPath("Value")
        }

        this.newSlot("link", null)
        this.newSlot("ownsLink", null)

        {
            const slot = this.newSlot("valuePrefix", null)
            slot.setShouldStoreSlot(true)
            slot.setDuplicateOp("duplicate")
        }

        {
            const slot = this.newSlot("valuePostfix", null)
            slot.setShouldStoreSlot(true)
            slot.setDuplicateOp("duplicate")
        }

        this.newSlot("valueMethod", null).setDuplicateOp("duplicate")
        this.newSlot("noteMethod", null)  // fetches note from a parent node method
        this.newSlot("keyError", null).setSyncsToView(true)
        this.newSlot("valueError", null).setSyncsToView(true)
        this.newSlot("target", null)
    }

    init () {
        super.init()
        this.setShouldStore(true)
        //this.setNodeRowStyles(BMViewStyles.shared().sharedBlackOnWhiteStyle())
        //this.setNodeRowStyles(BMViewStyles.shared().sharedWhiteOnBlackStyle())
        //this.customizeNodeRowStyles().setToBlackOnWhite()
        return this
    }

    didLoadFromStore () {
        super.didLoadFromStore()
        this.validate()
    }

    static nodeCreate () {
        const newNode = super.nodeCreate()

        if (newNode.setKeyIsEditable) {
            newNode.setKeyIsEditable(true)
            newNode.setValueIsEditable(true)
        }

        if (newNode.setIsEditable) {
            newNode.setIsEditable(true)
        }

        newNode.setNodeCanInspect(true)
        newNode.setNodeCanEditTitle(true)
        return newNode
    }

    title () {
        return this.key()
    }

    /*
    target () {
        assert(!Type.isNull(this._target)) 

        if (this._target) {
            return this._target
        }
		
        return this.parentNode() // we can't do this because we want to support free floating Fields
    }
    */

    /*
    setKey (newValue) {
        this._key = newValue
        return this
    }
    */

    didUpdateSlotValue (oldValue, newValue) {  // setValue() is called by View on edit
        if (this.target() && this.valueMethod()) {
            this.setValueOnTarget(newValue)
        } else {
            this.validate()
        }

        this.didUpdateNode()
    }

    setValueOnTarget (v) { // called by View on edit
        //console.log("setValue '" + v + "'")
        const target = this.target()
        const setter = this.setterNameForSlot(this.valueMethod())

        v = this.normalizeThisValue(v)
        
        if (target[setter]) {
            target[setter].apply(target, [v])
            target.didUpdateNode()
            this.validate()
        } else {
            console.warn(this.type() + " target " + target.type() + " missing slot '" + setter + "'")
        }
		
        return this
    }
	
    normalizeThisValue (v) {
	    return v
    }
	
    value () {
        if (this.target()) {
            this._value = this.getValueFromTarget()
        }
        return this._value
    }

    getValueFromTarget () {
        const target = this.target()
        const slotName = this.valueMethod()

        //console.log("target = " + target.type() + " getter = '" + getter + "'")
        if (target[slotName]) {
            const value = target[slotName].apply(target)
            return value
        } else {
            console.warn(this.type() + " target " + target.type() + " missing slot '" + slotName + "'")
        }

        return null
    }
	
    note () {
        const target = this.target()
        const slotName = this.noteMethod()

        if (target && slotName) {
            if (target[slotName]) {
                return target[slotName].apply(target)
            } else {
                console.warn(this.type() + " target " + target.type() + " missing note getter slot '" + slotName + "'")
            }
        }
        return null
    }
	
    didUpdateView (aFieldView) {
        this.scheduleSyncToStore()
        
        let parentNode = this.parentNode()
        if (!parentNode) {
            parentNode = this.target()
        }

        if (parentNode.didUpdateField) {
            parentNode.didUpdateField(this)
        }
        
        return this
    }
	
    visibleValue () {
        return this.value()
    }

    validate () {
        // subclasses should override if needed
        return true
    }
	
    nodeRowLink () {
        return null
    }

    summaryKey () {
        return this.key()
    }

    summaryValue () {
        return this.value()
    }

    setNodeSummaryShowsKey () {
    }

    setNodeSummaryShowsValue () {
    }

    jsonArchive () {
        return this.value()
    }

    setJson (json) {
        this.setValue(json) 
        return this
    }
    
}.initThisClass()

"use strict"

/*

    BMActionNode
    
    An abstraction of a UI visible action that can be performed on an object.
    the value is the action method name, the target is the field owner.

*/

window.BMActionNode = class BMActionNode extends BMStorableNode {
    
    static availableAsNodePrimitive() {
        return true
    }
    
    initPrototype () {

        this.overrideSlot("title", null).setShouldStoreSlot(true).setCanInspect(true).setSlotType("String").setLabel("Title")

        this.newSlot("methodName", null).setShouldStoreSlot(true)
        this.newSlot("info", null).setShouldStoreSlot(true)
        this.newSlot("isEnabled", true).setShouldStoreSlot(true)
        this.newSlot("isEditable", false).setShouldStoreSlot(true)
        this.newSlot("target", null)
        this.setShouldStore(true)
        this.setNodeRowIsSelectable(true)
        this.setNodeCanInspect(true)
    }

    init () {
        super.init()
    }

    setTitle (s) {
        super.setTitle(s)
        return this
    }

    canDoAction () {
        const t = this.target()
        const m = this.methodName()
        return t && t[m]
    }

    doAction () {
        if (this.canDoAction()) {
            const func = this.target()[this.methodName()]
            
            if (Type.isFunction(func)) {
                func.apply(this.target(), [this])
            } else {
                //this.setValueError("no method with this name")
                console.warn("no method with this name")
            }
        } else {
            this.debugLog(" can't perform action ", this.methodName(), " on ", this.target())
        }
	    
	    return this
    }
    
}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "BMJsonNode.js",
    "BMJsonArrayNode.js",
    "BMJsonDictionaryNode.js",
    "BMJsonNullField.js"
])

"use strict"

/*

    BMJsonNode
    

*/
        
window.BMJsonNode = class BMJsonNode extends BMStorableNode {
    
    static canOpenMimeType (mimeType) {
        return mimeType === "application/json"
    }

    static openMimeChunk (dataChunk) {
        const data = dataChunk.decodedData()
        //console.log("data = '" + data + "'")
        let json = null

        try {
            json = JSON.parse(data)
            //console.log("drop json = " + JSON.stringify(json, 2, 2) + "")
        } catch (error) {
            // return an error node instead?
        }

        const aNode = this.nodeForJson(json)
        return aNode
    }

    jsonClasses () {
        return [BMJsonArrayNode, BMBooleanField, BMJsonNullField, BMNumberField, BMJsonDictionaryNode, BMStringField]
    }
    

    static jsonToProtoNameDict () {
        return {
            "Array"   : "BMJsonArrayNode",
            "Boolean" : "BMBooleanField",
            "Null"    : "BMJsonNullField",
            "Number"  : "BMNumberField",
            "Object"  : "BMJsonDictionaryNode",
            "String"  : "BMStringField",
        }
    }
    
    static nodeForJson(json) {
        const t = Type.typeName(json)
        const protoName = this.jsonToProtoNameDict()[t]  
        if (protoName) {
            const proto = window[protoName]
            if (proto) {
                const instance = proto.clone().setJson(json)
                return instance
            }
        }

        return null
    }

    init () {
        super.init()
        this.setNodeCanEditTitle(true)
        this.setShouldStore(true)
        this.setShouldStoreSubnodes(true)
        this.setNodeCanReorderSubnodes(true)
        this.setCanDelete(true)
        this.setNoteIconName("right arrow")

        this.addAction("add")
        this.setSubnodeClasses(this.jsonClasses())
        this.setTitle("JSON")
    }

    
}.initThisClass()

"use strict"

/*

    BMJsonArrayNode
    

*/
        
window.BMJsonArrayNode = class BMJsonArrayNode extends BMJsonNode {
    
    static canOpenMimeType (mimeType) {
        return false
    }

    static availableAsNodePrimitive() {
        return true
    }
    
    initPrototype () {
    }

    init () {
        super.init()
    }

    subtitle () {
        return "Array"
    }

    // --------------

    replaceSubnodeWith (oldNode, newNode) {
        newNode = this.prepareSubnode(newNode)
        return super.replaceSubnodeWith(oldNode, newNode)
    }

    addSubnodeAt (aSubnode, anIndex) {
        return super.addSubnodeAt(this.prepareSubnode(aSubnode), anIndex)
    }

    prepareSubnode (aSubnode) {
        aSubnode.setCanDelete(true)

        if (aSubnode.keyIsVisible) {
            aSubnode.setKey("")
            aSubnode.setKeyIsVisible(false)
            aSubnode.setKeyIsEditable(false)
            const editableValueTypes = ["BMStringField", "BMNumberField", "BMBooleanField"]
            if (editableValueTypes.contains(aSubnode.type())) {
                aSubnode.setValueIsEditable(true)
            }
         }

        //aSubnode.setTitle(null)
        aSubnode.setNodeCanEditTitle(false)
        return aSubnode
    }

    // -------

    jsonArchive () {
        return this.subnodes().map(sn => sn.jsonArchive())
    }

    setJson (json) {
        let index = 0
        json.forEach((v) => {
            const aNode = BMJsonNode.nodeForJson(v)
            //aNode.setTitle(index)
            this.addSubnode(aNode)
            index ++
        })
        return this
    }

    getBMDataUrl () {
        //const json = this.node().copyArchiveDict() 
        const json = this.jsonArchive() 
        const bdd = BMDataUrl.clone()
        bdd.setMimeType("application/json")
        bdd.setFileName(this.title() + ".json")
        bdd.setDecodedData(JSON.stringify(json, null, 4))
        return bdd
    }
    
}.initThisClass()

"use strict"

/*

    BMJsonDictionaryNode
    

*/
        
window.BMJsonDictionaryNode = class BMJsonDictionaryNode extends BMJsonNode {
    
    static canOpenMimeType (mimeType) {
        return false
    }

    initPrototype () {
        this.setNodeCanEditTitle(true)
        this.setShouldStore(true)
        this.setShouldStoreSubnodes(true)
        this.setNodeCanReorderSubnodes(true)
        this.setCanDelete(true)
        this.setNoteIconName("right arrow")
    }

    init () {
        super.init()
    }

    subtitle () {
        return "Dictionary"
    }

    // ------------------------------

    setJson (json) {
        json.ownForEachKV((k, v) => {
            const aNode = this.thisClass().nodeForJson(v)
            aNode.setTitle(k)
            if (aNode.setKey) {
                aNode.setKey(k)
            }
            this.addSubnode(aNode)
        })
        return this
    }

    // ----------

    addSubnodeAt (newNode, anIndex) {
        newNode = this.prepareSubnode(newNode)
        return super.addSubnodeAt(this.prepareSubnode(newNode), anIndex)
    }

    replaceSubnodeWith (oldNode, newNode) {
        newNode = this.prepareSubnode(newNode)
        return super.replaceSubnodeWith(oldNode, newNode)
    }

    prepareSubnode (aSubnode) {
        aSubnode.setCanDelete(true)

        if (aSubnode.keyIsVisible) {
            aSubnode.setKeyIsVisible(true)
            aSubnode.setKeyIsEditable(true)
        }

        aSubnode.setNodeCanEditTitle(true)
        return aSubnode
    }

    // ------------

    jsonArchive () {
        const dict = {}
        this.subnodes().forEach((sn) => {
            const key = sn.key ? sn.key() : sn.title()
            const value = sn.jsonArchive()
            dict[key] = value
        })
        return dict
    }

    getBMDataUrl () {
        const json = this.jsonArchive() 
        const bdd = BMDataUrl.clone()
        bdd.setMimeType("application/json")
        bdd.setFileName(this.title() + ".json")
        bdd.setDecodedData(JSON.stringify(json, null, 4))
        return bdd
    }
    
}.initThisClass()

"use strict"

/*

    BMJsonNullField
    

*/
        
window.BMJsonNullField = class BMJsonNullField extends BMField {
    
    initPrototype () {
    }

    init () {
        super.init()
        this.setNodeCanEditTitle(true)
        this.setNodeCanEditSubtitle(false)
        this.setShouldStore(true)
        this.setShouldStoreSubnodes(false)
        this.setNodeCanReorderSubnodes(false)
        this.setCanDelete(true)
        //this.setNoteIconName("right arrow")

        this.setKeyIsVisible(false)
        this.setValue("NULL")
        //this.setValueIsEditable(false)
        //this.overrideSlot("valueIsEditable", false).setInitValue(false)
    }

    jsonArchive () {
        return null
    }

    setJson (json) {
        return this
    }


    setValueIsEditable (aBool) {
        /*
        if (aBool) {
            console.log(this.type() + " setValueIsEditable true")
        }
        */
        return super.setValueIsEditable(false)
    }
    
}.initThisClass()

"use strict"

/*

    BMCreatorNode
    
    A stand-in node that let's the user select field to replace it with.

*/
        
window.BMCreatorNode = class BMCreatorNode extends BMStorableNode {
    
    initPrototype () {
        this.overrideSlot("subnodes").setShouldStoreSlot(false)
        this.newSlot("typeChoices", []).setInitProto(Array)
    }

    init () {
        super.init()
        this.setNodeCanEditTitle(false)
        this.setShouldStore(true)
        this.setShouldStoreSubnodes(false)
        this.setNodeCanReorderSubnodes(false)
        this.setCanDelete(true)
        this.setNoteIconName("right arrow")
        this.setTitle("Chose type")
    }

    prepareForFirstAccess () {
        super.prepareForFirstAccess()
        this.setupSubnodes()
    }

    static fieldTypes () {
        return [
            "BMActionNode", 
            "BMBooleanField", 
            "BMDateNode",
            "BMImageWellField", 
            "BMJsonDictionaryNode",
            "BMJsonArrayNode",
            "BMFolderNode", 
            "BMNumberField", 
            "BMOptionsNode",
            "BMStringField",
            "BMTextAreaField",
            //"BMTextNode",
            "BMTimeNode",
            "BMLinkNode",
            "BMUrlField",
        ]
    }

    protoObjects () {
        const app = this.rootNode()
        const protosNode = app.firstSubnodeWithTitle("Prototypes")
        const protos = protosNode.subnodes()
        return protos
    }

    setupSubnodes () {
        if (this.subnodes().length == 0) {
            this.addSubnodesForObjects(BMNode.primitiveNodeClasses())
            //this.addSubnodesForObjects(this.protoObjects())
        }
        return this
    }
    
    addSubnodesForObjects (objects) {
        const newSubnodes = objects.map((aClass) => {
            const newNode = BMFolderNode.clone()
            newNode.setTitle(aClass.nodeCreateName())
            newNode.setNodeCanEditTitle(false)
            newNode.setNodeCanEditSubtitle(false)
            newNode.setNoteIconName(null)
            newNode.setTarget(this).setMethodName("didChoose").setInfo(aClass)
            newNode.setCanDelete(false)
            return newNode
        })
        this.addSubnodes(newSubnodes)
    }


   didChoose (actionNode) {
        const obj = actionNode.info()
        const newNode = obj.nodeCreate()
        newNode.setCanDelete(true)
        this.replaceSelfWithNode(newNode)
        return this
   }

    replaceSelfWithNode (newNode) {
        const parentNode = this.parentNode()
        assert(parentNode)
        parentNode.replaceSubnodeWith(this, newNode)
        parentNode.postShouldFocusAndExpandSubnode(newNode) 
    }

    nodeSummary () {
        return ""
    }
    
}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "BMBooleanField.js",
    "BMColorField.js",
    "BMIdentityField.js",
    "BMImageWellField.js",
    "BMNumberField.js",
    "BMPointerField.js",
    "BMStampField.js",
    "BMStringField.js",
    "BMTextAreaField.js",
    "BMUrlField.js",
    "options/_imports.js",
    "date/_imports.js",
    "time/_imports.js",
    
])

"use strict"
      
/*

    BMBooleanField

    
*/

window.BMBooleanField = class BMBooleanField extends BMField {
    
    static availableAsNodePrimitive() {
        return true
    }
    
    initPrototype () {
        this.newSlot("unsetVisibleValue", "unset")
    }

    init () {
        super.init()
        this.setKeyIsEditable(false)
        this.setValueIsEditable(false)
        //this.setValue(false)
    }

    valueIsBool () {
        const b = this.value()
        return Type.isBoolean(b);
    }
	
    validate () {
        const isValid = this.valueIsBool()
		
        if (!isValid) {
            this.setValueError("This needs to be a boolean (true or false).")
        } else {
            this.setValueError(null)
        } 
		
        return isValid
    }
	
    normalizeThisValue (v) {
	    if (v === true || v === "t" || v === "true" | v === 1) { return true; }
	    return false
    }
	
    didUpdateNode () {
        this.validate()
        return super.didUpdateNode()
    }

    jsonArchive () {
        return this.value() ? true : false
    }

    setJson (json) {
        assert(Type.isBoolean(json))
        this.setValue(json) 
        return this
    }

}.initThisClass()

"use strict"

/*

    BMColorField
    
*/

window.BMColorField = class BMColorField extends BMField {
    
    static availableAsNodePrimitive() {
        return true
    }
    
    initPrototype () {
        {
            const slot = this.newSlot("red", null)
            slot.setShouldStoreSlot(true)
            slot.setDuplicateOp("copyValue")
            slot.setCanInspect(true)
            slot.setSlotType("Number")
        }

        {
            const slot = this.newSlot("green", null)
            slot.setShouldStoreSlot(true)
            slot.setDuplicateOp("copyValue")
            slot.setCanInspect(true)
            slot.setSlotType("Number")
        }

        {
            const slot = this.newSlot("blue", null)
            slot.setShouldStoreSlot(true)
            slot.setDuplicateOp("copyValue")
            slot.setCanInspect(true)
            slot.setSlotType("Number")
        }

        {
            const slot = this.newSlot("alpha", null)
            slot.setShouldStoreSlot(true)
            slot.setDuplicateOp("copyValue")
            slot.setCanInspect(true)
            slot.setSlotType("Number")
        }

        this.setNodeCanEditTitle(true)
        this.setNodeCanEditSubtitle(false)
        this.setNodeMinWidth(200)
        this.setTitle("color")
        this.setSubtitle(null)
        this.setCanDelete(true)
        this.setNodeCanInspect(true) 
    }

    init () {
        super.init()
        this.addActions(["add"])
    }

    asCSSColor () {
        return CSSColor.clone().set(this.red(), this.green(), this.blue(), this.alpha())
    }

    fromCSSColor (aCSSColor) {
        return this
    }
    
}.initThisClass()

"use strict"

/*

    BMIdentityField

*/

window.BMIdentityField = class BMIdentityField extends BMField {
    
    initPrototype () {

    }

    init () {
        super.init()
        this.setKeyIsEditable(false)
        this.setValueIsEditable(false)
    }

    validate () {
        if (!bitcore.PublicKey.isValid(this.value())) {
            this.setValueError("invalid address")
        } else {
            this.setValueError(null)
        }
    }
	
    setValue (inValue) { // called by View on edit
        if (Type.isNull(inValue)) {
            console.log("WARNING: " + this.type() + " setValue(null)")
            return this
        }
	    //console.log("inValue = '" + inValue + "'")
	    let newValue = inValue.strip()
	    
        const parts = newValue.split(" ").concat(newValue.split("\n")).concat(newValue.split(","))
	    //console.log("parts = '", parts)
        const validPart = parts.detect((part) => { return bitcore.PublicKey.isValid(part) })

        if (validPart) {
            newValue = validPart
        }

        if (inValue !== newValue) {
            this.scheduleSyncToView() 
        }
        
        //console.log("newValue = '" + newValue + "'")
        super.setValue(newValue)
		
        return this
    }

}.initThisClass()

"use strict"

/*

    BMImageWellField

*/
        
window.BMImageWellField = class BMImageWellField extends BMField {

    static availableAsNodePrimitive() {
        return true
    }
    
    static supportedMimeTypes () {
        return new Set(["image/jpeg", "image/gif", "image/png"])
    }

    static canOpenMimeType (mimeType) {
        return this.supportedMimeTypes().has(mimeType)
    }

    static openMimeChunk (dataChunk) {
        const newNode = this.clone()
        newNode.setValue(dataChunk.dataUrl())
        //newNode.setValue(dataChunk.decodedData())
        newNode.setKeyIsEditable(true)
        newNode.setValueIsEditable(true)
        newNode.setCanDelete(true)
        return newNode
    }

    initPrototype () {
        this.newSlot("onlyShowsKeyWhenEmpty", false)
        this.newSlot("isEditable", true)
        
        this.overrideSlot("nodeMinRowHeight").setShouldStoreSlot(true)

        this.setKey("Image title")
        this.setKeyIsEditable(false)
        this.setValueIsEditable(false)
        this.setNodeCanEditRowHeight(true)
    }

    init () {
        super.init()
    }

    summaryValue () {
        return ""
    }
   
}.initThisClass()

"use strict"

/*

    BMNumberField

    A named number field that validates that the 
    value is a number and shows an appropraite error message.

*/
        
window.BMNumberField = class BMNumberField extends BMField {
    
    static availableAsNodePrimitive() {
        return true
    }

    initPrototype () {
        this.newSlot("unsetVisibleValue", "unset")

        {
            const slot = this.newSlot("isInteger", false)
            slot.setDuplicateOp("copyValue")
            slot.setSlotType("Boolean")
            slot.setShouldStoreSlot(true)
            slot.setCanInspect(true)
            slot.setCanEditInspection(true)
            slot.setLabel("Is integer")
            slot.setInspectorPath("Number")
            //slot.setSyncsToView(true)
        }

        {
            const slot = this.newSlot("hasLimits", false)
            slot.setDuplicateOp("copyValue")
            slot.setSlotType("Boolean")
            slot.setShouldStoreSlot(true)
            slot.setCanInspect(true)
            slot.setCanEditInspection(true)
            slot.setLabel("Has limits")
            slot.setInspectorPath("Number")
            //slot.setSyncsToView(true)
        }

        {
            const slot = this.newSlot("minValue", 0)
            slot.setDuplicateOp("copyValue")
            slot.setSlotType("Number")
            slot.setShouldStoreSlot(true)
            slot.setCanInspect(true)
            slot.setCanEditInspection(true)
            slot.setLabel("Min Value")
            slot.setInspectorPath("Number")
            //slot.setSyncsToView(true)
        }

        {
            const slot = this.newSlot("maxValue", 1)
            slot.setDuplicateOp("copyValue")
            slot.setSlotType("Number")
            slot.setShouldStoreSlot(true)
            slot.setCanInspect(true)
            slot.setCanEditInspection(true)
            slot.setLabel("Max value")
            slot.setInspectorPath("Number")
            //slot.setSyncsToView(true)
        }
    }

    // --- 
    // TODO: 
    // - add a Slot.validatorMethod or methodHook so this can be done dynamically?

    didUpdateSlotIsInteger () {
        this.validate()
    }

    didUpdateSlotHasLimits () {
        this.validate()
    }

    didUpdateSlotMinValue () {
        this.validate()
    }

    didUpdateSlotMaxValue () {
        this.validate()
    }
    

    // ----

    init () {
        super.init()
        this.setKey("Number title")
        this.setKeyIsEditable(false)
        this.setValueIsEditable(true)
        this.setValue(0)
    }

    setValue (v) {
        super.setValue(Number(v))
        return this
    }

    valueIsNumeric () {
        const n = this.value()
        return !isNaN(parseFloat(n)) && isFinite(n);
    }
	
    validate () {
        const v = Number(this.value())
        const errors = []
        
        if (!this.valueIsNumeric()) {
            errors.push("This needs to be a number.")
        }

        if (this.hasLimits()) {
            if (v < this.minValue()) {
                errors.push("Must be >= " + this.minValue() + ".")
            }
            if (v > this.maxValue()) {
                errors.push("Must be <= " + this.maxValue() + ".")
            }
        }

        if (this.isInteger()) {
            if (!Number.isInteger(v)) {
                errors.push("Must be an integer.")
            }
        }

        if (errors.length) {
            this.setValueError(errors.join("\n"))
        } else {
            this.setValueError(null)
        }
        
        const isValid = this.valueError() === null
        return isValid
    }
    
}.initThisClass()

"use strict"

/*

    BMPointerField

    A field that's a pointer to another node.
  (sometimes the other node is used as a list of items, but not always)

*/
        
window.BMPointerField = class BMPointerField extends BMField {
    
    initPrototype () {

    }

    init () {
        super.init()
        this.setKeyIsEditable(false)
        this.setValueIsEditable(false)
        this.setKeyIsVisible(true)
        this.setValueIsVisible(true)
        this.setNodeRowIsSelectable(true)
    }

    /*
    setValue (v) {
        console.warn("WARNING: BMPointerField setValue '" + v + "'")
        return this
    }
    */

    title () {
        return this.value().title()
    }
	
    subtitle () {
        return this.value().subtitle()
    }
	
    note () {
        return this.value().note()
    }
	
    nodeRowLink () {
        return this.value()
    }

}.initThisClass()

"use strict"

/*

    BMStampField

*/

window.BMStampField = class BMStampField extends BMField {
    
    initPrototype () {

    }

    init () {
        super.init()
        //this.setKeyIsVisible(false)
        //this.setKey("drop images here")
        this.setKeyIsEditable(false)
        this.setValueIsEditable(false)
    }
    
}.initThisClass()

"use strict"

/*

    BMStringField

*/
        
window.BMStringField = class BMStringField extends BMField {
    
    static availableAsNodePrimitive() {
        return true
    }

    initPrototype () {
        this.newSlot("unsetVisibleValue", "")
    }

    init () {
        super.init()
        this.setKey("String title")

        this.setKeyIsVisible(true)
        this.setKeyIsEditable(true)

        this.setValueIsVisible(true)
        this.setValueIsEditable(true)
    }
    
}.initThisClass()

"use strict"

/*

    BMTextAreaField
    
*/

window.BMTextAreaField = class BMTextAreaField extends BMField {
    
    static availableAsNodePrimitive() {
        return true
    }

    static canOpenMimeType (mimeType) {
        return mimeType.beginsWith("text/plain")
    }

    static openMimeChunk (dataChunk) {
        const newNode = this.clone()
        newNode.setValue(dataChunk.decodedData())
        newNode.setKeyIsEditable(true)
        newNode.setValueIsEditable(true)
        newNode.setCanDelete(true)
        return newNode
    }

    initPrototype () {
        this.newSlot("isMono", false)
    }

    init () {
        super.init()
        this.setKeyIsVisible(false)
    }
    
}.initThisClass()

"use strict"

/*

    BMUrlField
    
*/

window.BMUrlField = class BMUrlField extends BMField {
    
    static availableAsNodePrimitive() {
        return true
    }

    static canOpenMimeType (mimeType) {
        return mimeType.beginsWith("text/uri-list")
    }

    static openMimeChunk (dataChunk) {
        const newNode = this.clone()
        const uris = dataChunk.decodedData().split("\n")
        const uri = uris.first()

        try {
            const url = new URL(uri)
            newNode.setKey(url.hostname)
            const path = url.pathname
            const p = path.fileName()
            if (p) {
                newNode.setKey(p)
            }
        } catch (error) {
            newNode.setKey("?")
        }

        newNode.setValue(uri)
        newNode.setValueIsVisible(false)

        return newNode
    }

    initPrototype () {
        // scheme : // userinfo @host : port / path ? query # fragment
        this.newStringSlotNamed("href", "")
        
        this.newStringSlotNamed("protocol", "http")
        this.newStringSlotNamed("username", "")
        this.newStringSlotNamed("password", "")
        this.newStringSlotNamed("hostname", "hostname")
        this.newStringSlotNamed("port", "")
        this.newStringSlotNamed("pathname", "")
        this.newStringSlotNamed("search", "")
        this.newStringSlotNamed("hash", "")
        this.newSlot("isUpdatingHref", false)
    }

    newStringSlotNamed (slotName, defaultValue) {
        const slot = this.newSlot(slotName, defaultValue)
        //slot.setShouldStoreSlot(true)
        slot.setDoesHookSetter(true)
        slot.setDuplicateOp("copyValue")
        slot.setCanInspect(true)
        slot.setSlotType("String")
        slot.setLabel(slotName.capitalized())
        slot.setInspectorPath("URL")

        if (slotName !== "href") {
            //slot.setCanEditInspection(false)
        }
        return slot
    }

    init () {
        super.init()

        this.setKey("Link")
        this.setKeyIsVisible(true)
        this.setKeyIsEditable(true)

        this.setValueIsEditable(true)
        this.setValueIsVisible(true)

        this.setCanDelete(true)

        this.setNodeCanInspect(true)
    }

    nodeInspector () {
        return super.nodeInspector()
    }

    urlFromValue () {
        const s = this.value()
        try {
            const url = new URL(s)
            return url
        } catch (e) {
            //this.setError(e.message)
        }
        return null
    }

    didLoadFromStore () {
        super.didLoadFromStore()
        this.parseValue()
    }

    didUpdateSlotValue () {
        this.parseValue()
    }

    didUpdateSlotHref () {
        this.setIsUpdatingHref(true)
        this.setValue(this.href())
        this.parseValue()
        this.setIsUpdatingHref(false)
    }

    // slots

    scheduleUnparse () {
        if (this.hasDoneInit()) {
            //this.scheduleSelfFor("unparseValue")
            this.unparseValue()
        }
    }
    
    didUpdateSlotProtocol () {
        this.scheduleUnparse()
    }

    didUpdateSlotUsername () {
        this.scheduleUnparse()
    }

    didUpdateSlotPassword () {
        this.scheduleUnparse()
    }

    didUpdateSlotHostName () {
        this.scheduleUnparse()
    }

    didUpdateSlotPort () {
        this.scheduleUnparse()
    }

    didUpdateSlotPathname () {
        this.scheduleUnparse()
    }

    didUpdateSlotSearch () {
        this.scheduleUnparse()
    }

    didUpdateSlotHash () {
        this.scheduleUnparse()
    }
    
    // parse / unparse

    parseValue () {
        // set slots using the value
        const url = this.urlFromValue()
        if (!url) {
            return this
        }
        
        this.directSetProtocol(url.protocol)
        this.directSetUsername(url.username)
        this.directSetPassword(url.password)
        this.directSetHostname(url.hostname)
        this.directSetPort(url.port)
        this.directSetPathname(url.pathname)
        this.directSetSearch(url.search)
        this.directSetHash(url.hash)
        this.directSetHref(url.href)
        
        return this
    }

    urlFromComponents () {
        const url = new URL("http://test.com")
        url.protocol = this.protocol()
        url.username = this.username()
        url.password = this.password()
        url.hostname = this.hostname()
        url.port = this.port()
        url.pathname = this.pathname()
        url.search = this.search()
        url.hash = this.hash()
        return url 
    }

    unparseValue () {
        // set the value using the slots
        const url = this.urlFromComponents()
        this.directSetHref(url.href)
        //this.directSetValue(url.href)
        return this
    }

    nodeUrlLink () {
        return this.value()
    }

    validate () {
        const isValid = this.valueIsValidUrl()
		
        if (!isValid) {
            this.setValueError("Invalid URL")
        } else {
            this.setValueError(null)
        } 
		
        return isValid
    }

    valueIsValidUrl () {
        const url = this.value()
        const result = url.match(/(http(s)?:\/\/.)?(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/g);
        return result !== null
    }
    
}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "BMOptionsNode.js",
    "BMOptionNode.js"
])

"use strict"

/*

    BMOptionsNode 
    
*/

window.BMOptionsNode = class BMOptionsNode extends BMField {
    
    static availableAsNodePrimitive() {
        return true
    }

    initPrototype () {
        const picksSlot = this.newSlot("allowsMultiplePicks", false)
        picksSlot.setLabel("Multiple picks").setCanInspect(true).setSlotType("Boolean")
        picksSlot.setShouldStoreSlot(true)

        this.overrideSlot("key", "").setShouldStoreSlot(true)

        this.setShouldStore(true)
        this.setShouldStoreSubnodes(true)

        this.setCanDelete(true)
        this.setNodeCanInspect(true)
        this.setNodeMinWidth(300)

        this.setKey("Options")
        this.setKeyIsVisible(true)
        this.setNodeCanEditTitle(true)

        this.setNodeCanReorderSubnodes(true)
    }

    init () {
        super.init()
        this.addAction("add")
        this.setSummaryFormat("value")
        this.setSubnodeProto(BMOptionNode)
        this.setNoteIconName("right arrow")
    }

    /*
    setValue (v) {
        super.setValue(v)
        return this
    }
    */
    
    title () {
        return this.key()
    }
    
    setTitle (s) {
        this.setKey(s)
        return this
    }

    childrenSummary () {
        const picked = this.pickedSubnodes()
        if (picked.length === 0) {
            return "None"
        }
        return picked.map(subnode => subnode.summary()).join("")
    }

    setSubtitle (aString) {
        return this
    }

    didToggleOption (anOptionNode) {
        if (anOptionNode.isPicked() && !this.allowsMultiplePicks()) {
            this.unpickSubnodesExcept(anOptionNode)
        }

        let pickedValues = this.pickedSubnodes().map(s => s.value())
        //this.setValue(pickedValues)
        
        if (pickedValues.length) {
            if (this.allowsMultiplePicks()) {
                this.setValue(pickedValues)
            } else {
                this.setValue(pickedValues.first())
            }
        } else {
            this.setValue(null)
        }

        return this
    }

    unpickSubnodesExcept (anOptionNode) {
        this.subnodes().forEach(subnode => {
            if (subnode !== anOptionNode) { 
                subnode.setIsPicked(false) 
            }
        })
        return this
    }

    pickedSubnodes () {
        return this.subnodes().select(subnode => subnode.isPicked())
    }

    acceptedSubnodeTypes () {
        return [BMOptionNode.type()]
    }

    setValidValues (values) {        
        const options = values.map(v => BMOptionNode.clone().setTitle(v).setValue(v))
        this.addSubnodes(options)
        //this.copySubnodes(options)
        return this
    }
	
    /*
    validValues () {
        return this.subnodes().map(sn => sn.value())
    }
    */
    
    nodeRowLink () {
        // used by UI row views to browse into next column
        return this
    }
    
}.initThisClass()

"use strict"

/*

    BMOptionNode
    
    A single option from a set of options choices.

*/
        
window.BMOptionNode = class BMOptionNode extends BMStorableNode {
    
    initPrototype () {
        this.newSlot("label", "Option Title").setShouldStoreSlot(true).setDuplicateOp("copyValue")
        this.newSlot("value", null).setShouldStoreSlot(true).setDuplicateOp("copyValue")
        this.newSlot("isPicked", false).setShouldStoreSlot(true).setDuplicateOp("copyValue")

        this.setShouldStore(true)
        this.setShouldStoreSubnodes(false)
        this.setNodeCanReorderSubnodes(false)
        this.setCanDelete(true)
        this.setNodeCanEditTitle(true)
    }

    init () {
        super.init()
    }


    didUpdateSlotIsPicked (oldValue, newValue) {
        if (this.parentNode()) {
            this.parentNode().didToggleOption(this)
            this.didUpdateNode()
            this.scheduleSyncToStore()
        }
    }

    toggle () {
        this.setIsPicked(!this.isPicked())
        return this
    }

    setTitle (aString) {
        this.setLabel(aString)
        return this
    }
    
    title () {
        return this.label()
    }

    value () {
        return this.title()
    }


    subtitle () {
        return null
    }

    summary () {
        return this.title()
    }

    note () {
        return this.isPicked() ? "âœ“" : ""
    }

}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "BMDateNode.js",
    "BMYearNode.js",
    "BMMonthNode.js",
    "BMDayNode.js",
])

"use strict"

/*

    BMDateNode
    
    

*/
        
window.BMDateNode = class BMDateNode extends BMSummaryNode {
    
    static availableAsNodePrimitive() {
        return true
    }
    
    initPrototype () {        
        this.overrideSlot("subnodes").setShouldStoreSlot(false)

        this.newSlot("year", null).setShouldStoreSlot(true).setDoesHookSetter(true).setDuplicateOp("copyValue")
        this.newSlot("month", null).setShouldStoreSlot(true).setDoesHookSetter(true).setDuplicateOp("copyValue")
        this.newSlot("day", null).setShouldStoreSlot(true).setDoesHookSetter(true).setDuplicateOp("copyValue")

        const startYearSlot = this.newSlot("startYear", 2000).setShouldStoreSlot(true).setDoesHookSetter(true)
        startYearSlot.setCanInspect(true).setSlotType("Number").setLabel("Start year")

        const yearRangeSlot =  this.newSlot("yearRange", 20).setShouldStoreSlot(true).setDoesHookSetter(true)
        yearRangeSlot.setCanInspect(true).setSlotType("Number").setLabel("Year range")
    }

    init () {
        super.init()
        
        this.setNoteIconName("right arrow")

        this.setShouldStore(true)
        this.setShouldStoreSubnodes(false)
        this.setNodeCanReorderSubnodes(false)
        this.setCanDelete(true)

        this.setTitle("Date")
        this.setNodeCanEditTitle(true)
        this.setNodeCanEditSubtitle(false)
        this.setNodeCanInspect(true)
    }

    hasDate () {
        return !Type.isNull(this.year())
    }

    jsDate () {
        //new Date(year, month, day, hours, minutes, seconds, milliseconds)
        if (this.hasDate()) {
            const d = new Date(this.year(), this.month(), this.day(), 0, 0, 0, 0, 0)
            //console.log("d = ", d)
            return d
        }
        return null
    }

    subtitle () {
        if (this.hasDate()) {
            const d = this.jsDate()
            const s = d.monthName() + " " + d.dateNumberName() + ", " + d.getFullYear()
            const s2 = [this.year(), this.month(), this.day()].join("-")
            return s2 //+ " - " + s
            return s
        }

        return "No date selected"
    }

    prepareToSyncToView () {
        // called after DateNode is selected
        if (!this.hasSubnodes()) {
            this.setupSubnodes()
        }
    }

    setupSubnodes () {
        this.removeAllSubnodes()
        /*
        const startYear = this.startYear()
        const range = this.yearRange()

        const years = []
        for (let i = startYear; i < startYear + range; i++) {
            const year = BMYearNode.clone().setValue(i)
            year.setCanDelete(false)
            years.push(year)
        }
        //this.setSubnodes(years)
        */
    }

    onTapOfDecendantNode (aNode) {
        if (aNode.type() === "BMDayNode") {
            const dayNode = aNode
            const monthNode = dayNode.parentNode()
            const yearNode = monthNode.parentNode()
            this.setDay(dayNode.value())
            this.setMonth(monthNode.value())
            this.setYear(yearNode.value())
            this.scheduleSyncToView()
            this.parentNode().postShouldFocusSubnode(this)
        }
        return true
    }

    endYear () {
        return this.startYear() + this.yearRange()
    }

    yearRangeOk () {
        return this.startYear() <= this.endYear()
    }

    didUpdateSlotStartYear () {
        if (!this.hasDoneInit()) {
            return
        }

        if (!this.yearRangeOk()) {
            this.setEndYear(this.startYear())
        }
        this.setupSubnodes()
    }

    didUpdateSlotEndYear () {
        if (!this.hasDoneInit()) {
            return
        }

        if (!this.yearRangeOk()) {
            this.setStartYear(this.endYear())
        }
        this.setupSubnodes()
    }

    jsonArchive () {
        const d = this.jsDate()
        return d ? d.toString() : null
    }

}.initThisClass()

"use strict"

/*

    BMYearNode 
    
*/

window.BMYearNode = class BMYearNode extends BMNode {
    
    initPrototype () {
        this.newSlot("allowsMultiplePicks", false)
        this.newSlot("value", 0)
    }

    init () {
        super.init()

        this.setCanDelete(true)
        this.setNodeMinWidth(300)

        this.setNodeCanEditTitle(true)

        //this.setSubnodeProto(BMFolderNode)
        this.setSubnodeProto(BMOptionNode)
        this.setNodeCanReorderSubnodes(true)

        //this.setViewClassName("BMOptionsNodeView")
    }

    title () {
        return this.value()
    }

    hasSubnodes () {
        return true;
    }
    
    prepareToAccess () {
        //console.log("this.storeHasChanged() = ", this.storeHasChanged())
        if (this.subnodeCount() === 0) {
            //this.refreshSubnodes()
        }
    }
    
    nodeRowLink () {
        // used by UI row views to browse into next column
        return this
    }

    prepareToSyncToView () {
        // called after Node is selected
        if (!this.subnodeCount()) {
            for (let i = 1; i < 12 + 1; i++) {
                const month = this.addSubnode(BMMonthNode.clone().setValue(i))
                month.setCanDelete(false)
            }
        }
    }
    
}.initThisClass()

"use strict"

/*

    BMMonthNode 
    
*/

window.BMMonthNode = class BMMonthNode extends BMNode {
    
    initPrototype () {
        this.newSlot("value", 1).setComment("month value starts with 1")
    }

    init () {
        super.init()
        this.setNoteIconName("right arrow")

        this.setCanDelete(false)
        this.setNodeCanInspect(false)
        this.setNodeMinWidth(300)

        this.setTitle("a month")
        this.setNodeCanEditTitle(true)

        //this.setSubnodeProto(BMOptionNode)
        //this.setNodeCanReorderSubnodes(false)

        //this.setViewClassName("BMOptionsNodeView")
    }

    setValue (v) {
        assert(Number.isInteger(v) && v > 0 && v < 13)
        this._value = v
        return this
    }

    year () {
        const year = this.parentNode().value()
        return year
    }

    daysThisMonth () {
        return new Date(this.year(), this.value() - 1, 0).getDate();
    }

    monthNames () {
        return ["January", "February", "March", "April", 
            "May", "June", "July", "August", 
            "September", "October", "November", "December"];
    }

    monthName () {
        return this.monthNames()[this.value()-1]
    }

    title () {
        return this.monthName()
    }

    zeroPaddedMonthNumber () {
        let v = this.value()
        if (v < 10) { 
            v = "0" + v 
        }
        return v
    }

    subtitle () {
        //return this.zeroPaddedMonthNumber()
        return null
    }
    
    nodeRowLink () {
        // used by UI row views to browse into next column
        return this
    }

    prepareToSyncToView () {
        // called after Node is selected
        if (!this.subnodeCount()) {

            for (let i = 1; i < this.daysThisMonth() + 1; i++) {
                const day = BMDayNode.clone().setValue(i)
                day.setCanDelete(false)
                this.addSubnode(day)
            }
        }
    }
    
}.initThisClass()

"use strict"

/*

    BMDayNode 
    
*/

window.BMDayNode = class BMDayNode extends BMNode {
    
    initPrototype () {
        this.newSlot("value", 1).setComment("day value starts with 1")
    }

    init () {
        super.init()

        this.setCanDelete(false)
        this.setNodeCanInspect(false)
        this.setNodeMinWidth(300)

        this.setTitle("a day")
        this.setNodeCanEditTitle(false)

        this.setNodeCanReorderSubnodes(false)
    }

    setValue (v) {
        assert(Number.isInteger(v) && v > 0 && v < 32)
        this._value = v
        return this
    }

    dayName () {
        const v = this.value()
        return v + v.ordinalSuffix()
    }

    title () {
        return this.dayName()
    }

    subtitle () {
        return null
    }
    
    note () {
        return null
    }
    
    nodeRowLink () {
        // used by UI row views to browse into next column
        return null
    }
    
}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "BMTimeNode.js",
    "BMHourNode.js",
    "BMMinuteNode.js",
    "BMMeridiemNode.js",
])

"use strict"

/*

    BMTimeNode
    
    

*/
        
window.BMTimeNode = class BMTimeNode extends BMSummaryNode {
      
    static availableAsNodePrimitive() {
        return true
    }

    initPrototype () {
        this.overrideSlot("subnodes").setShouldStoreSlot(false)

        this.newSlot("hour", null).setShouldStoreSlot(true)
        this.newSlot("minute", null).setShouldStoreSlot(true)
        this.newSlot("timezone", null).setShouldStoreSlot(true)
        this.newSlot("formatter", null).setShouldStoreSlot(true)

        this.setShouldStore(true)
        this.setShouldStoreSubnodes(false)
        this.setNodeCanReorderSubnodes(false)
        this.setCanDelete(true)

        this.setTitle("Time")

        this.setNodeCanEditTitle(true)
        this.setNodeCanEditSubtitle(false)
    }

    init () {
        super.init()
        this.setNoteIconName("right arrow")
        this.setFormatter(TimeFormatter.clone())
        return this
    }

    hasTime () {
        return !Type.isNull(this.hour())
    }

    jsDate () {
        //new Date(year, month, day, hours, minutes, seconds, milliseconds)
        if (this.hasTime()) {
            const d = new Date(0, 0, 0, this.hour(), this.minute(), 0, 0, 0)
            return d
        }
        return null
    }

    timeString () {
        return this.formatter().setDate(this.jsDate()).formattedValue()
    }

    subtitle () {
        if (this.hasTime()) {
            return this.timeString()
        }

        return "No time selected"
    }

    prepareToSyncToView () {
        // called after clicked
        if (!this.hasSubnodes()) {
            for (let i = 0; i < 23; i++) {
                const hour = BMHourNode.clone().setValue(i)
                this.addSubnode(hour)
            }
        }
    }

    onTapOfDecendantNode (aNode) {
        if (aNode.type() === "BMMinuteNode") {
            const minuteNode = aNode
            const hourNode = minuteNode.parentNode()
            this.setHour(hourNode.value())
            this.setMinute(minuteNode.value())
            this.scheduleSyncToView()
            this.parentNode().postShouldFocusSubnode(this)
        }
        return true
    }

    jsonArchive () {
        const d = this.jsDate()
        return d ? d.toString() : null
    }

}.initThisClass()

"use strict"

/*

    BMHourNode 
    
*/

window.BMHourNode = class BMHourNode extends BMNode {
    
    initPrototype () {
        this.newSlot("value", 0).setComment("0 to 23")
    }

    init () {
        super.init()

        this.setCanDelete(false)
        this.setNodeCanInspect(false)
        this.setNodeMinWidth(300)

        this.setNodeCanEditTitle(false)
        this.setNodeCanReorderSubnodes(false)

        this.setNoteIconName("right arrow")
    }

    setValue (v) {
        assert(Number.isInteger(v) && v > -1 && v < 23)
        this._value = v
        return this
    }

    meridiemName () {
        if (this.value() > 11) {
            return "pm"
        }
        return "am"
    }

    hourName () {
        let v = this.value() % 12
        if (v === 0) { v = 12 }
        return v + "" + this.meridiemName()
    }

    title () {
        return this.hourName()
    }

    subtitle () {
        return null
    }
    
    /*
    nodeRowLink () {
        return this
    },    
    */

    prepareToSyncToView () {
        // called after clicked
        if (!this.hasSubnodes()) {
            for (let i = 0; i < 60; i += 5) {
                const minute = BMMinuteNode.clone().setValue(i)
                this.addSubnode(minute)
            }
        }
    }
    
}.initThisClass()

"use strict"

/*

    BMMinuteNode 
    
*/

window.BMMinuteNode = class BMMinuteNode extends BMNode {
    
    initPrototype () {
        this.newSlot("value", 1)
    }

    init () {
        super.init()
        this.setCanDelete(false)
        this.setNodeCanInspect(false)
        this.setNodeMinWidth(300)
        this.setNodeCanEditTitle(false)
        this.setNodeCanReorderSubnodes(false)
    }

    setValue (v) {
        assert(Number.isInteger(v) && v > -1 && v < 60)
        this._value = v
        return this
    }

    minuteName () {
        let s = this.value()
        if (s < 10) { 
            s = "0" + s
        }
        return s
    }

    title () {
        return this.minuteName()
    }

    subtitle () {
        return null
    }
    
    note () {
        return null
    }
    
    nodeRowLink () {
        // used by UI row views to browse into next column
        return null
    }
    
}.initThisClass()

"use strict"

/*

    BMMeridiemNode 
    
*/

window.BMMeridiemNode = class BMMeridiemNode extends BMNode {
    
    initPrototype () {
        this.newSlot("value", 1).setComment("month value starts with 1")
    }

    /*
    init () {
        super.init()
        this.setNoteIconName("right arrow")

        this.setCanDelete(false)
        this.setNodeCanInspect(false)
        this.setNodeMinWidth(300)

        this.setTitle("a month")
        this.setNodeCanEditTitle(true)

        //this.setSubnodeProto(BMOptionNode)
        //this.setNodeCanReorderSubnodes(false)

        //this.setViewClassName("BMOptionsNodeView")
    }

    setValue (v) {
        assert(Number.isInteger(v) && v > 0 && v < 13)
        this._value = v
        return this
    }

    year () {
        const year = this.parentNode().value()
        return year
    }

    daysThisMonth () {
        return new Date(this.year(), this.value() - 1, 0).getDate();
    }

    monthNames () {
        return ["January", "February", "March", "April", 
            "May", "June", "July", "August", 
            "September", "October", "November", "December"];
    }

    monthName () {
        return this.monthNames()[this.value()-1]
    }

    title () {
        return this.monthName()
    }

    zeroPaddedMonthNumber () {
        let v = this.value()
        if (v < 10) { 
            v = "0" + v 
        }
        return v
    }

    subtitle () {
        //return this.zeroPaddedMonthNumber()
        return null
    }
    
    nodeRowLink () {
        // used by UI row views to browse into next column
        return this
    }

    prepareToSyncToView () {
        // called after Node is selected
        if (!this.subnodeCount()) {

            for (let i = 1; i < this.daysThisMonth() + 1; i++) {
                this.addSubnode(BMDayNode.clone().setValue(i))
            }
        }
    }
    */
    
}.initThisClass()

"use strict"

/*
    
    BMDataStoreRecord
    
    A visible representation of a storage record.
    
*/

window.BMDataStoreRecord = class BMDataStoreRecord extends BMFieldSetNode {
    
    initPrototype () {
        this.newSlot("key", null)
        this.newSlot("store", null)
    }

    init () {
        super.init()
        this.setCanDelete(false) // too dangerous
        this.setNodeMinWidth(600)
    }

    prepareForFirstAccess () {
        super.prepareForFirstAccess()
        const jsonField = BMTextAreaField.clone().setKey("recordString")
        jsonField.setValueMethod("recordString").setValueIsEditable(false).setIsMono(true)
        this.addField(jsonField)

        this.referencedRecords().forEach((aRecord) => {
            const node = BMDataStoreRecord.forRecord(aRecord)
            this.addSubnode(node)
        })
    }

    record () {
        return this.store().recordForPid(this.key())
    }

    setRecordString (s) {
        throw new Error("not editable")
    }

    recordString () {
        return JSON.stringify(this.record(), null, 2)
    }

    referencedRecords () {
        return this.referencedPidSet().map( pid => this.defaultStore().recordForPid(pid) )
    }

    referencedPidSet () {
        return this.defaultStore().refSetForPuuid(this.record().id)
    }

    /*
    delete () {
        super.delete()
        this.defaultStore().justRemovePid(this.key())
        return this
    }
    */

    static forRecord (aRecord) {
        const subnode = BMDataStoreRecord.clone()
        subnode.setTitle(aRecord.type + " " + aRecord.id)
        //subnode.setTitle(aRecord.id)
        subnode.setKey(aRecord.id)
        subnode.setStore(this.defaultStore()) //// <-------------------- avoid this?
        const size = JSON.stringify(aRecord).length
        subnode.setSubtitle(size.byteSizeDescription())
        return subnode
    }
    
}.initThisClass()


"use strict"

ResourceLoader.pushRelativePaths([
    "_css.css",
    "NodeView.js",
    "HeaderFooterView.js",
    "ImageWellView.js",
    "ImageView.js",
    "browser/_imports.js",
    "field_views/_imports.js",
    "stack/_imports.js",
])


"use strict"

/*

    NodeView

*/

window.NodeView = class NodeView extends DomStyledView {
    
    initPrototype () {
        this.newSlot("node", null) //.setDuplicateOp("duplicate")
        this.newSlot("overrideSubviewProto", null)
        this.newSlot("nodeObservation", null)
        this.newSlot("isInspecting", false)
    }

    init () {
        super.init()
        //this.setNodeObservation(BMNotificationCenter.shared().newObservation().setName("didUpdateNode").setObserver(this))
        this.setNodeObservation(BMNotificationCenter.shared().newObservation().setObserver(this)) // observe all posts from node
        this.updateSubnodeToSubviewMap()
        return this
    } //.setDocs("init", "initializes the object", "returns this"),
    
    
    prepareToRetire () {
        this.setNode(null)
        super.prepareToRetire()
    }
	
    setNode (aNode) {
        if (this._node !== aNode) {
            this.stopWatchingNode()
            this._node = aNode
            this.startWatchingNode()

            this.updateElementIdLabel()
            this.didChangeNode()
        }
		
        return this
    }

    updateElementIdLabel () {
        const nodeId = this.node() ? this.node().debugTypeId() : "null"
        this.element().id = this.debugTypeId() + " for node " + nodeId
    }
    
    didChangeNode () {
        if (this.node()) {
            this.scheduleSyncFromNode()
        }
        return this
    }
 
    startWatchingNode () {
        if (this.node()) {
            //console.log("startWatchingNode " + this.node() + " observation count = " + BMNotificationCenter.shared().observations().length)
            this.nodeObservation().setTarget(this.node()).watch()
            //this.node().onStartObserving()
        }
        return this
    }
       
    stopWatchingNode () {
        if (this.node()) {
            //console.log("stopWatchingNode " + this.node() + " observation count = " + BMNotificationCenter.shared().observations().length)
            this.nodeObservation().stopWatching()
            //this.nodeObservation().setTarget(null)
            //this.node().onStopObserving()
        }
        return this
    }
    
    willRemove () {
        super.willRemove()
        this.stopWatchingNode()
        return this
    }
    
    subviewProto () {
        //console.log("looking for subviewProto")
        if (this.node()) {
            const vc = this.node().nodeRowViewClass()
            if (vc) { 
                return vc
            }
        }
        return super.subviewProto()
    }

    // --- syncing ---

    subviewForNode (aNode) {
        assert(this._subnodeToSubview)
        return this._subnodeToSubview[aNode]
    }

    updateSubnodeToSubviewMap () {
        // TODO: make this more efficient with add/remove hooks
        const dict = {}
        this.subviews().forEach( sv => {
            if (sv.node) { 
                dict.atPut(sv.node(), sv) 
            } 
        })
        this._subnodeToSubview = dict
        return this
    }

    subviewProtoForSubnode (aSubnode) {
        let proto = this.overrideSubviewProto()
		
        if (!proto) {
		    proto = aSubnode.viewClass()
        }
				
        return proto      
    }

    newSubviewForSubnode (aSubnode) {
        if (!aSubnode) {
            throw new Error("null aSubnode")
        }

        //console.log(this.debugTypeId() + ".newSubviewForSubnode(" + aSubnode.debugTypeId() + ")")
        
        const proto = this.subviewProtoForSubnode(aSubnode)
		
        if (!proto) {
            throw new Error("no subviewProto for subnode " + aSubnode.typeId())
        }
		
        return proto.clone().setNode(aSubnode) //.setParentView(this)
    }

    updateSubviews () {
        // for subclasses to override
        return this
    }
    
    visibleSubnodes () {
        return this.node().subnodes()
    }
    
    syncFromNode () {
        let subnodesDidChange = false
        // override this method if the view manages it's own subviews

        if (!this.node()) { 
            this.removeAllSubviews();
            return
        }

        //console.log("> " + this.debugTypeId() + " syncFromNode")
        
        this.node().prepareToSyncToView()
        this.updateSubnodeToSubviewMap() // not ideal - move this to update on subview add/remove
       
        const newSubviews = []
        
        // only replace subviews if sync requires it,
        // and reuse subviews for subnodes which are still present 

        this.visibleSubnodes().forEach((subnode) => {
            let subview = this.subviewForNode(subnode) // get the current view for the node, if there is one
            
            if (!subview) {
                subview = this.newSubviewForSubnode(subnode)
            }
            
            if(Type.isNull(subview)) {
                throw new Error("null subview")
            }
            
            newSubviews.push(subview)   
        })
        
        if (!newSubviews.isEqual(this.subviews())) {
            subnodesDidChange = true
            //this.removeAllSubviews() 
            this.removeAllSubviews()
            this.addSubviews(newSubviews)
            this.updateSubnodeToSubviewMap()
            // since node's don't hold a view reference, 
            // subviews no longer referenced in subviews list will be collected
        }

        this.subviews().forEach(subview => subview.syncFromNodeNow())

        return subnodesDidChange
    }
    
    syncToNode () {
        const node = this.node()
        if (node) {
            node.didUpdateNode()
            //node.scheduleSyncToStore()
        }
        return this
    }

    didUpdateNode () {
        //this.debugLog(" didUpdateNode " + this.node().type())
        this.scheduleSyncFromNode()
    }
    
    scheduleSyncToNode () {
        if (this.hasScheduleSyncFromNode()) {
            this.hasScheduleSyncFromNode()
            console.log("SKIPPING scheduleSyncToNode because hasScheduleSyncFromNode")
            this.unscheduleSyncFromNode()
            return this
        }
        
        window.SyncScheduler.shared().scheduleTargetAndMethod(this, "syncToNode", 0)
        return this
    }
    
    hasScheduleSyncToNode () {
        return window.SyncScheduler.shared().isSyncingOrScheduledTargetAndMethod(this, "syncToNode")
    }

    hasScheduleSyncFromNode () {
        return window.SyncScheduler.shared().isSyncingOrScheduledTargetAndMethod(this, "syncFromNode")
    }

    scheduleSyncFromNode () {
        assert(!this.hasScheduleSyncToNode())
        window.SyncScheduler.shared().scheduleTargetAndMethod(this, "syncFromNode", 2) // let posts happen first
        return this
    }

    unscheduleSyncFromNode () {
        SyncScheduler.shared().unscheduleTargetAndMethod(this, "syncFromNode")
    }

    syncFromNodeNow () { // unschedule syncFromNode if scheduled, and call syncFromNode now
        this.unscheduleSyncFromNode()
        this.syncFromNode()
    }

    // logging 
    
    logName () {
        return this.type()
    }
    
    log (msg) {
        const s = "[" + this.logName() + "] " + msg
        console.log(s)
        return this
    }
    
    // visibility
    
    onVisibility () {
	    super.onVisibility()
	    //this.debugLog(".onVisibility()")
	    const node = this.node()
	    if (node && node.nodeBecameVisible) {
	        node.nodeBecameVisible()
	    }

	    return this
    }
    
    // value
    
    setValue (newValue) {
        this.setInnerHTML(newValue)			
        return this
    }
    
    value () {
        return this.innerHTML()
    }

    // ---

    resyncAllViews () {
        if (!this.hasScheduleSyncToNode()) {
            this.scheduleSyncFromNode()
        }
        super.resyncAllViews()
        return this
    }
    
}.initThisClass()

"use strict"

/*

    HeaderFooterView

*/

window.HeaderFooterView = class HeaderFooterView extends NodeView {
    
    initPrototype () {
        this.newSlot("headerClass", null)
        this.newSlot("headerView", null)

        this.newSlot("middleClass", null)
        this.newSlot("middleView", null)

        this.newSlot("footerClass", null)
        this.newSlot("footerView", null)
    }

    init () {
        super.init()
        return this
    } 
    
    setupHeaderMiddleFooterViews () {

        if (this.headerClass()) {
            const v = this.headerClass().clone()
            v.setOrder(0)
            this.setHeaderView(v)
            this.addSubview(v)
        }

        if (this.middleClass()) {
            const v = this.middleClass().clone()
            v.setOrder(1)
            this.setMiddleView(v)
            this.addSubview(v)
        }

        if (this.footerClass()) {
            const v = this.footerClass().clone()
            v.setOrder(2)
            this.setFooterView(v)
            this.addSubview(v)
        }

        return this
    }

    /*
    setHeaderView (aView) {
        if (this.headerView()) {
            this.replaceSubviewwith(this.headerView(), aView)
        } else {
            this.addSubview(aView)
        }

        aView.setOrder(0)
        return this
    }
    */
    
}.initThisClass()

"use strict"

/*

    ImageWellView

    - designed to contain an ImagineView
    - can have it's own frame and decoration
    - supports drag & drop of images

*/

window.ImageWellView = class ImageWellView extends NodeView {
    initPrototype () {
        this.newSlot("imageView", null)
        this.newSlot("isEditable", true)
    }


    init () {
        super.init()
        this.setDisplay("flex")
        this.setPosition("relative")
        this.setJustifyContent("center")
        this.setAlignItems("center")
        this.setMinHeight("10em")
        this.setMinWidth("10em")
        this.setOverflowX("hidden")
        this.setOverflowY("hidden")
        this.setBorder("1px solid #444")
        this.setColor("white")
        this.setBackgroundColor("transparent")

        this.setIsRegisteredForBrowserDrop(true)
        this.dragUnhighlight()
        this.turnOffUserSelect()
        this.setTransition("all 0.3s")
        this.autoFitParentWidth()
        this.autoFitChildHeight()
        this.setMinHeightPx(100)
        this.setPadding("0px")
        return this
    }

    syncToNode () {
        super.syncToNode()
        this.tellParentViews("didUpdateImageWellView", this)
        return this
    }
    
    isEditable () {
        // we need this to override the normal isContentEditable return value
        return this._isEditable
    }
    
    setIsEditable (aBool) {
        this._isEditable = aBool
        if (this.imageView()) {
            this.imageView().setIsEditable(aBool)
        }
        return this
    }
    
    dragHighlight () {
        this.setBackgroundColor("rgba(128, 128, 128, 0.5)")
    }
    
    dragUnhighlight () {
        this.setBackgroundColor("transparent")
    }
    
    isFull () {
        //console.log("this.imageView().dataURL()  = ", this.imageView().dataURL() )
        return this.subviews().length > 0
    }
    
    acceptsDrop (event) {
        return true
        //return this.isEditable()        
    }

    /*
    onBrowserDrop (event) {
        return super.onBrowserDrop(event)
    }

    onBrowserDragOver (event) {
        const r =  super.onBrowserDragOver(event)
        //console.log(this.debugTypeId() + " onBrowserDragOver() -> " + r)
        return r
    }
    */

    setValue (aValue) {
        this.setImageDataUrl(aValue)
        return this
    }

    value () {
        return this.imageDataUrl()
    }
    
    setImageDataUrl (dataURL) {
        assert(!Type.isArray(dataURL)) 

        if (dataURL === this.imageDataUrl()) {
            return this
        }
        
        this.removeAllSubviews()

        if (!Type.isNullOrUndefined(dataURL)) {
            const v = ImageView.clone()
            this.setImageView(v)
            this.addSubview(v)

            v.fetchDataURLFromSrc(dataURL)
            v.autoFitChildHeight()
            v.autoFitParentWidth()
        }

        return this
    }
    
    imageDataUrl () {
        const v = this.imageView()
        if (v && v.dataURL()) {
            return v.dataURL()
        }
        return null
    }
    

    // need these as method name is constructed from MIME type

    onBrowserDropImageJpeg (dataChunk) {
        this.droppedImageData(dataChunk)
    }

    onBrowserDropImageGif (dataChunk) {
        this.droppedImageData(dataChunk)
    }

    onBrowserDropImagePng (dataChunk) {
        this.droppedImageData(dataChunk)
    }

    // image data chunk

    droppedImageData (dataChunk) {
        this.setImageDataUrl(dataChunk.dataUrl())
        this.scheduleSyncToNode() //this.syncToNode()
        return this        
    }
    
    willRemoveSubview (aSubview) {
        super.willRemoveSubview(aSubview)

        if (aSubview === this.imageView()) {
            this.setImageView(null)
        }
        return this
    }
    
}.initThisClass()

"use strict"

/*

    ImageView

*/

window.ImageView = class ImageView extends NodeView {
    
    initPrototype () {
        this.newSlot("imageContainer", null)
        this.newSlot("rawImageView", null)
        this.newSlot("closeButtonView", null)
        this.newSlot("dataURL", null)
        this.newSlot("isEditable", false)
    }

    init () {
        super.init()
        this.setDisplay("flex")
        this.setPosition("relative")
        this.setJustifyContent("center")
        this.setAlignItems("center")
        this.setTransition("all 0.5s")
        this.setOverflow("hidden")
        this.setWidth("auto")
        this.setHeight("auto")
        //this.setIsRegisteredForBrowserDrop(false)

        // image container
        const ic = this.newImageViewContainer()
        this.setImageContainer(ic)
        this.addSubview(ic)

        // close button
        const cb = this.newCloseButtonView()
        this.setCloseButtonView(cb)
        this.addSubview(cb)

        this.setIsEditable(false)
        this.dragUnhighlight()
        this.turnOffUserSelect()
        this.setTransition("all 0.3s")
        return this
    }

    newCloseButtonView () {
        const v = ButtonView.clone().setDivClassName("ImageCloseButton")
        v.setDisplay("flex")
        v.setPosition("absolute")
        v.setTitleIsVisible(false)
        v.setTopPx(0)
        v.setRightPx(0)
        v.setTarget(this).setAction("close")
        v.setIconName("close")
        return v
    }

    newImageViewContainer () {
        const v = DomFlexView.clone().setDivClassName("ImageViewImageContainer")
        v.setDisplay("flex")
        v.setPosition("relative")
        v.setJustifyContent("center")
        v.setAlignItems("center")
        v.setOverflow("hidden")
        v.setWidth("auto")
        v.setHeight("auto")
        return v
    }

    setIsRegisteredForBrowserDrop(aBool) {
        throw new Error("shouldn't be called")
    }

    // --- editable ---
    
    setIsEditable (aBool) {
        this.closeButtonView().setDisplayIsHidden(!aBool)
        return this
    }

    setEditable (aBool) {
        // to avoid editable content?
        return this
    }
    
    acceptsDrop () {
        return false
    }

    // --- close button ---

    collapse () {
        this.closeButtonView().setOpacity(0).setTarget(null)
        this.setOpacity(0)
		
        this.setWidth("0px")
		
        this.setPaddingLeftPx(0)
        this.setPaddingRightPx(0)
		
        this.setMarginLeft(0)
        this.setMarginRightPx(0)
    }
    
    close () {
        const seconds = 0.3
		
        this.collapse()
        
        this.addTimeout( () => { 
            this.closeButtonView().hideDisplay()
            const parentView = this.parentView()
            this.removeFromParentView()
            parentView.scheduleSyncToNode()
        }, seconds * 1000)
    }

    // --- sync ---
    
    removeRawImageView () {
        if (this.rawImageView()) {
            this.imageContainer().removeSubview(this.rawImageView())
            this.setRawImageView(null)
        }
        return this
    }
    
    fetchDataURLFromSrc (src) {
        if (src.beginsWith("data:")) {
	        this.setFromDataURL(src)
        } else {
            const img = new Image();
            img.setDelegate(this)
            img.loadUrl(src)
        }
		
        return this
    }
    
    didFetchDataUrl (dataURL) {
        this.setFromDataURL(dataURL)
        this.scheduleSyncToNode() 
        return this
    }

    newRawImageViewForImage (image) {
        const v = DomFlexView.clone().setElement(image).setDivClassName("RawImageView")
        v.setDisplay("flex")
        v.setPosition("relative")
        v.setJustifyContent("center")
        v.setAlignItems("center")
        v.setOverflow("hidden")
        v.makeStandardFlexView()
        v.setWidth("fit-content")
        v.setHeight("auto")
        return v
    }

    setFromDataURL (dataURL) {
        //console.log("setFromDataURL: ", dataURL)
        assert(!Type.isNull(dataURL))
        assert(dataURL.beginsWith("data:")) 

        this.removeRawImageView()
        this.setDataURL(dataURL)

        const image = new Image();
        image.src = dataURL;

        const v = this.newRawImageViewForImage(image)
        this.setRawImageView(v)
        this.imageContainer().addSubview(v)
	
        return this
    }
    
}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "_css.css",
    //"HashCommand.js",
    //"BrowserView.js",
    
    //"header/_imports.js",
    //"column/_imports.js",
    "row/_imports.js",
    //"shelf/_imports.js",
    //"top_shelf/_imports.js",
])

"use strict"

ResourceLoader.pushRelativePaths([
    "BrowserRow.js",
    "BrowserTitledRow.js",
    "BrowserRowNote.js",
    "BrowserRowSubtitle.js",
    "BrowserRowTitle.js",
    "BMTextNodeRowView.js",
])

"use strict"

/*
    
    BrowserRow

    Base row view.  
    
    Features:
    - applying styles to match state
    - supports slide-to-delete and pan-to-reorder gestures.
    - right side delete button
    
    NOTES
    
    Row styles lookup order:

        node -> (fallback to) -> row -> (fallback to) -> column

    See lookedUpStyles method.

*/

window.BrowserRow = class BrowserRow extends NodeView {
    
    initPrototype () {
        this.newSlot("isSelectable", true) //.setDuplicateOp("copyValue")
        this.newSlot("closeButtonView", null)
        this.newSlot("defaultHeight", 30)
        this.newSlot("restCloseButtonOpacity", 0.4)
        this.newSlot("transitionStyle", "all 0.2s ease, width 0s, max-width 0s, min-width 0s")
        this.newSlot("selectedFlashColor", "#ccc")
        this.newSlot("shouldShowFlash", false)
        this.newSlot("shouldCenterCloseButton", true)
        this.newSlot("contentView", null)
    
        this.newSlot("slideDeleteOffset", 0)
        this.newSlot("dragDeleteButtonView", null)
        this.newSlot("isDeleting", false)
        this.newSlot("lastTapDate", null)
        this.newSlot("lastSelectionDate", null)
    }

    setDisplay (v) {
        if (v === "block") {
            console.log(this.typeId() + " setDisplay " + v)
        }
        return super.setDisplay(v)
    }

    init () {
        super.init()
        this.setDisplay("inline-block")
        this.setPosition("relative") // so absolute position on close button works
        //this.setFlexGrow(0)
        //this.setFlexShrink(0)
        this.makeOrientationRight()

        this.setWidth("100%")
        this.setHeight("fit-content")
        this.setWhiteSpace("no-wrap")
        //this.setHeight("auto")

        //this.setMinHeight("4em")
        //this.setColor("rbga(255, 255, 255, 0.5)")
        this.setTransition("all 0s, top 0.3s, background-color .3s ease-out")
        this.setOverflow("hidden")
        this.setWhiteSpace("nowrap")
        
        /*
        this.setBorderStyle("solid")
        this.setBorderColor("transparent")
        this.setBorderLeft("0px")
        this.setBorderRight("0px")
        this.setBorderTop("1px")
        this.setBorderBottom("1px")
        this.setTextAlign("left")
        */

        this.setWebkitOverflowScrolling("touch")

        this.turnOffUserSelect()
        this.setAcceptsFirstResponder(false)
        this.setupRowContentView()

        if (TouchScreen.shared().isSupported() || true) { // testing 
            //
        } else {
            //this.addCloseButton()
        }

        this.setTransition(this.transitionStyle())

        //this.animateOpen()
        
        this.addGestureRecognizer(LongPressGestureRecognizer.clone()) // for long press & pan reordering
        this.addGestureRecognizer(SlideGestureRecognizer.clone()) // for slide delete
        this.addGestureRecognizer(TapGestureRecognizer.clone()) // for selection, and tap-longpress
        //this.addGestureRecognizer(RightEdgePanGestureRecognizer.clone()) // for adjusting width?
        //this.addGestureRecognizer(BottomEdgePanGestureRecognizer.clone()) // for adjusting height?

        this.setIsRegisteredForKeyboard(true)
        this.setIsDebugging(true)

        return this
    }

    setNode (aNode) {
        super.setNode(aNode)
        return this
    }

    duplicate () {
        const dup = super.duplicate()
        dup.setNode(this.node().duplicate())
        return dup
    }

    // bottom edge pan 

    acceptsBottomEdgePan () {
        if (this.node().nodeCanEditRowHeight) {
            if (this.node().nodeCanEditRowHeight()) {
                return true
            }
        }
        return false
    }

    onBottomEdgePanBegin (aGesture) {
        this._beforeEdgePanBorderBottom = this.borderBottom()
        this.setBorderBottom("1px dashed red")
        this.setTransition("min-height 0s, max-height 0s")
    }

    onBottomEdgePanMove (aGesture) {
        const p = aGesture.currentPosition() // position in document coords
        const f = this.frameInDocument()
        const newHeight = p.y() - f.y()
        const minHeight = this.node() ? this.node().nodeMinRowHeight() : 10;
        if (newHeight < 10) {
            newHeight = 10;
        }
        this.node().setNodeMinRowHeight(newHeight)
        this.updateSubviews()

        /*
            this.node().setNodeMinRowHeight(h)
            this.updateSubviews()
            //this.setMinAndMaxHeight(newHeight) // what about contentView?
            //this.contentView().autoFitParentHeight()
        */

        return this
    }

    onBottomEdgePanComplete (aGesture) {
        this.setBorderBottom(this._beforeEdgePanBorderBottom)
    }

    // -- contentView -- a special subview within the BrowserRow for it's content
    // we route style methods to it

    setupRowContentView () {
        const cv = DomView.clone().setDivClassName("BrowserRowContentView")
        cv.setDisplay("flex")
        cv.setHeight("auto")
        cv.setMinHeightPx(60)
        cv.setWidthPercentage(100)
        cv.setHeightPercentage(100) 
        cv.setPosition("relative")
        cv.setFloat("left")

        //cv.autoFitParentWidth().autoFitParentHeight() // can't do this since we need to float left for sliding

        cv.setTransition("all 0.2s ease, transform 0s, left 0s, right 0s, width 0s, min-width 0s, max-width 0s")
        cv.setZIndex(2) // so it will be above other views like the slide delete button 
        this.setZIndex(1)
        this.setContentView(cv)
        this.addSubview(cv)

        return this
    }

    desiredWidth () {
        return this.calcWidth()
    }

    /*
    setMinAndMaxWidth (w) {
        super.setMinAndMaxWidth(w)
        this.contentView().setMinAndMaxWidth(w)
        return this
    }

    setMinAndMaxHeight (h) {
        super.setMinAndMaxHeight(h)
        this.contentView().setMinAndMaxHeight(h)
        return this
    }
    */

    addContentSubview (aView) {
        return this.contentView().addSubview(aView)
    }

    removeContentSubview (aView) {
        return this.contentView().removeSubview(aView)
    }

    // ----

    setBackgroundColor (s) {
        this.contentView().setBackgroundColor(s)
        return this
    }

    setColor (s) {
        this.contentView().setColor(s)
        return this
    }

    setOpacity (v) {
        this.contentView().setOpacity(v)
        return this
    }

    // --- helpers --------
    
    browser () {
        return this.column().browser()
    }

    column () {
        return this.parentView()
    }
    
    columnGroup () {
        return this.column().columnGroup()
    }

    // node style dict
    
    rowStyles () {
        return null
    }

    didChangeParentView () {
        super.didChangeParentView()
        //window.SyncScheduler.shared().scheduleTargetAndMethod(this, "applyStyles", 0)
        this.applyStyles()
        return this
    }

    lookedUpStyles () {
        const debugStyles = false

        if (this.node()) {
            const ns = this.node().nodeRowStyles()
            if (ns) {
                if (debugStyles) {
                    this.debugLog(" using nodeRowStyles")
                }
                return ns
            }
        }

        const rs = this.rowStyles()
        if (rs) {
            if (debugStyles) {
                this.debugLog(" using rowStyles")
            }
            return rs
        }

        if (this.column() && this.column().rowStyles) {
            const cs = this.column().rowStyles()
            if (cs) {
                if (debugStyles) {
                    this.debugLog(" using column().rowStyles()")
                }
                return cs
            }
        } else if (debugStyles) {
            const title = this.node() ? this.node().title() : "no node yet"
            this.debugLog(" (" + title + ") has no column yet")
        }

        return BMViewStyles.shared().sharedWhiteOnBlackStyle()
    }

    /*
    currentRowStyle () {
        const styles = this.node().nodeRowStyles()
        //styles.selected().set
        
        if (this.isSelected()) {
        	return styles.selected()
 		}
        
        return styles.unselected()
    }
    */

   didUpdateSlotIsSelected (oldValue, newValue) {
        super.didUpdateSlotIsSelected (oldValue, newValue)

        if (this.isSelected()) {
            this.setLastSelectionDate(Date.clone())
        } else {
            this.setShouldShowFlash(true)
            this.setLastSelectionDate(null)
        }

        this.itemSetView().didChangeNavSelection()
        this.updateSubviews()
    }
    
    // update
     
    updateSubviews () {   
        if (this.closeButtonView()) {
            const node = this.node()

            if (node) {
                this.closeButtonView().setColor(this.currentColor()) // needed?
            }
			
            if (this.canDelete()) {
                this.closeButtonView().setOpacity(this.restCloseButtonOpacity())
            } else {
                this.closeButtonView().setOpacity(0)
            }

            if (node) {
                const h = node.nodeMinRowHeight()
                if (h) {
                    this.setMinAndMaxHeight(h) 
                    this.contentView().autoFitParentHeight()
                }
            }
        }

        /*
        // take up full height if node asks for it
        const node = this.node()
        if (node && node.nodeMinRowHeight()) {
            const e = this.element()
            if (node.nodeMinRowHeight() === -1) {
                this.setHeight("auto")                
                this.setPaddingBottom("calc(100% - 20px)")
            } else {
                this.setHeight(this.pxNumberToString(node.nodeMinRowHeight()))
            }
        }
        */
        
        this.applyStyles()

        return this
    }
    
    // -------------
    
    onDidEdit (aView) {
        //this.browser().fitColumns()
        this.scheduleSyncToNode() 
        return true // stop propogation
    }
    
    // --- sync ---
	
    syncFromNode () {
        // is this ever called?
        this.updateSubviews()
        this.syncOrientation()
        return this
    }

    itemSetView () {
        return this.parentView()
    }

    stackView () {
        const scrollView = this.itemSetView().parentView()
        const navView = scrollView.parentView()
        const stackView = navView.parentView()
        return stackView
        //return this.firstParentViewWithAncestorClass(StackView)
    }

    syncOrientation () {
        if (!this.parentView()) {
            return this
        }

        const d = this.stackView().direction()
        if (d === "right") {
            this.makeOrientationRight()
        } else if (d === "down") {
            this.makeOrientationDown() 
        }
        return this
    }

    makeOrientationRight () {  //stackview is right (other view is on the right and nav is top to bottom)
        this.setDisplay("inline-block")  
        this.setWidth("100%")
        this.setHeight("fit-content")
        //this.setBorderBottom("1px solid rgba(255, 255, 255, 0.3)")

        //this.setBorderRight("1px solid rgba(255, 0, 0, 1)")
        this.setMinAndMaxHeight(null)
        //this.setBoxShadow("inset -10px 0 20px rgba(0, 0, 0, 0.05)")
    }

    makeOrientationDown () { 
        this.setDisplay("inline-block")  
        this.setWidth("170px")
        //this.setHeight("fit-content")
        this.setHeight("100%")
        //this.setBorderRight("1px solid rgba(255, 255, 255, 0.3)")
        //this.setBoxShadow("inset -10px 0 20px rgba(0, 0, 0, 0.05)")

        
        if (this.stackView()) {
            const node = this.stackView().node()
            if (node) {
                const h = node.nodeMinRowHeight()
                console.log("node " + this.node().title() + " height " + h)
                if (h) {
                    this.setMinAndMaxHeight(h)
                    this.contentView().setMinAndMaxHeight(h)
                }
            }
        }
    }

    // --- styles ---
    
    styles () { 
        const lookedUpStyles = this.lookedUpStyles()
        if (lookedUpStyles) {
            return lookedUpStyles
        } else {
            this.lookedUpStyles() // for debugging
        }
        throw new Error("missing styles")
    }

    applyStyles () {
        super.applyStyles()

        // flash
        
        /*
        if (this.shouldShowFlash() && this.selectedFlashColor()) {
            this.setBackgroundColor(this.selectedFlashColor())
            this.setTransition("background-color 0.3s")
            //setTimeout(() => { this.setBackgroundColor(this.currentBgColor()) }, 100)
            setTimeout(() => { super.applyStyles() }, 100)
            this.setShouldShowFlash(false)
        }
        */
        
        return this
    }
    
    
    // close button
    
    addCloseButton () {
        if (this.closeButtonView() === null) {

            const cb = DomView.clone().setDivClassName("BrowserRowCloseButton")
            cb.setCssDict({
                "display": "block",
                "right": "20px",
                "top": "16px",
                
                "min-width": "20px",
                "max-width": "20px",
                "min-height": "20px",
                "max-height": "20px",
                
                "font-size": "2em",
                "line-height": "2em",
                "font-weight": "normal",
                "white-space": "nowrap",
                "border": "0px dashed yellow",
                "color": "rgba(255, 255, 255, 0.5)",
                "margin": "0px",
                "padding": "0px",
                "padding-bottom": "10px",
            })

            cb.setPosition("absolute")
            this.setCloseButtonView(cb)
            this.contentView().addSubview(cb) 
            
            cb.setBackgroundImageUrlPath(this.pathForIconName("close-white"))
            cb.makeBackgroundContain()
            cb.makeBackgroundCentered()
            cb.makeBackgroundNoRepeat()  
            
            cb.setMinAndMaxWidthAndHeight(8)
            cb.setAction("delete")
            cb.setOpacity(0).setTransition(this.transitionStyle())
        }
        return this
    }
    
    removeCloseButton () {
        if (this.closeButtonView() !== null) {
            this.contentView().removeSubview(this.closeButtonView()) 
            this.setCloseButtonView(null)
        }
    }
    
    passFirstResponderToColumn () {
        if (this.isFirstResponder()) {
            if (this.column()) {
                this.column().becomeFirstResponder()
            }
        }
        return this
    }

    delete () {
        //console.log("delete")
        if (this.canDelete()) {
            this.node().delete()

            /*
            this.passFirstResponderToColumn()
            this.setOpacity(0)
            //this.setRightPx(-this.clientWidth())
            this.setMinAndMaxHeight(0)
            this.setIsDeleting(true)

            if (this.isSelected()) {
                // to make sure next column is cleared
                this.setIsSelected(false)
                //this.browser().scheduleSyncToNode()
            }

            setTimeout(() => {
                this.node().performAction("delete")
            }, 240)
            */
        }
    }

    /*
	animateOpen () {
		this.setTransition(this.transitionStyle())
		this.setOpacity(0)
		this.setMinAndMaxHeight(0)
		setTimeout(() => {
			this.setOpacity(1)
			this.setMinAndMaxHeight(this.defaultHeight())
		}, 0)		
	},
	*/
    
    canDelete () {
        if (this.node()) {
            return this.node().canDelete()
        }
        return false
    }

    // --- tap gesture -------- 

    acceptsTapBegin (aGesture) {
        return true
    }

    debugTypeId () {
        return this.typeId() + " " + (this.node() ? this.node().title() : "")
    }

    onTapComplete (aGesture) {
        //console.log(this.debugTypeId() + " onTapComplete")
        this.setLastTapDate(new Date())
        const keyModifiers = BMKeyboard.shared().modifierNamesForEvent(aGesture.upEvent());
        ///const hasThreeFingersDown = aGesture.numberOfFingersDown() === 3;
        //const isAltTap = keyModifiers.contains("Alternate");
    
        //if (keyModifiers.length) {
            const methodName = "just" + keyModifiers.join("") + "Tap"
            //this.debugLog(" tap method " + methodName)
            if (this[methodName]) {
                this[methodName].apply(this)
                return this
            }
        //} 
        
        /*
        if (hasThreeFingersDown || isAltTap) {
            this.justInspect()
        } else {
            this.setIsInspecting(false)
            this.justTap()
        }
        */

        return this
    }

    // -- just taps ---

    justTap () {
        this.setIsInspecting(false)
        this.column().didTapItem(this)

        //console.log(this.debugTypeId() + " justTap")
        if (this.isSelectable()) {
            //this.select()

            const node = this.node()
            if (node) {
                node.onTapOfNode()
                node.onRequestSelectionOfNode(this)
            }

            if (this.isFocused() && node.nodeUrlLink) {
                if (!BMKeyboard.shared().hasKeysDown()) {
                    const url = node.nodeUrlLink()
                    window.open(url, "_blank")
                }
            }
        }
    }

    justShiftTap () {
        this.setIsInspecting(false)
        this.column().didShiftTapItem(this)
    }

    justAlternateTap () {
        this.debugLog(".justInspect()")
        if (this.node().nodeCanInspect()) { 
            this.setIsInspecting(true)
            this.column().didTapItem(this)
        }
    }

    justMetaTap () {
        this.setIsInspecting(false)
        this.toggleSelection()
    }

    
    // -------------------

    /*
    unselectNextColumnRows() {
        const c = this.column().nextColumn()
        if (c) {
            c.unselectAllRows()
        }
        return this
    }
    */

    // --- keyboard controls ---

   onEnterKeyUp () {
        //this.debugLog(this.type() + " for " + this.node().title() + " onEnterKeyUp")
        this.justTap()
        return false // stop propogation
    }

    onShiftBackspaceKeyUp (event) {
        this.debugLog(this.type() + " for " + this.node().title() + " onBackspaceKeyUp")
        this.delete()
        return false // stop propogation
    }

    // --- dragging key ---

    onMeta_a_KeyDown (event) {
        // only select subnodes if this row can have them,
        // otherwise, like the column handle this event
        const c = this.column().nextColumn()
        if (c) {
            c.selectAllRows()
        }
        event.stopPropagation()
        return false 
    }

    on_d_KeyDown (event) {
        this.debugLog(" on_d_KeyDown ", event._id)
        this.setIsRegisteredForBrowserDrag(true)
        return true
    }

    on_d_KeyUp (event) {
        this.debugLog(" on_d_KeyUp ", event._id)
        this.setIsRegisteredForBrowserDrag(false)
        return true
    }
    
    decendantReleasedFocus (aView) {
        this.focus()
        return true
    }

    /*
    onEscapeKeyDown (event) {
        console.log(" onEscapeKeyDown ", event._id)
        this.column().onLeftArrowKeyUp()
        return true
    }
    */

    // -- slide gesture ---

    acceptsSlide () {
        return this.canDelete()
    }

    onSlideBegin () {
        //this.debugLog(".onSlideBegin()")
        this.setSlideDeleteOffset(this.clientWidth() * 0.5);
        this.contentView().setTransition("all 0s") 
        this.setupSlide() 
        return this
    }

    underContentViewColor () {
        return "black"
    }

    setupSlide () {
        if (!this.dragDeleteButtonView()) {
            const h = this.clientHeight()

            // need to do this because we re-route setBackgroundColor
            this.element().style.backgroundColor = this.underContentViewColor()
            const cb = CloseButton.clone().setOpacity(0).setTransition("opacity 0.1s").setPosition("absolute")
            this.addSubview(cb)
            //cb.setBorder("1px dashed white")

            const size = 10
            cb.setMinAndMaxWidthAndHeight(size)
            cb.verticallyAlignAbsoluteNow()
            cb.setRightPx(size * 2)
            cb.setZIndex(0)
            this.setDragDeleteButtonView(cb)
        }
        return this
    }

    cleanupSlide () {
        if (this.dragDeleteButtonView()) {
            this.dragDeleteButtonView().removeFromParentView()
            this.setDragDeleteButtonView(null)
        }
        this.setTouchRight(null)
    }
	
    onSlideMove (slideGesture) {
        const d = slideGesture.distance()
        const isReadyToDelete = d >= this._slideDeleteOffset

        this.setTouchRight(d)

        if (this._dragDeleteButtonView) {
            this._dragDeleteButtonView.setOpacity(isReadyToDelete ? 1 : 0.2)
        }
    }

    setTouchRight (v) {
        //this.setTransform("translateX(" + (v) + "px)");
        //this.setLeftPx(-v)
        //this.setRightPx(v)
        this.contentView().setRightPx(v)
    }
	
    onSlideComplete (slideGesture) {
        //console.log(">>> " + this.type() + " onSlideComplete")
        const d = slideGesture.distance()
        const isReadyToDelete  = d >= this._slideDeleteOffset

        if (isReadyToDelete) {
            this.finishSlideAndDelete()
        } else {
            this.slideBack()
        }
    }

    onSlideCancelled (aGesture) {
        this.slideBack()
    }

    finishSlideAndDelete () {
        this.setIsDeleting(true)
        const dt = 0.08 // seconds
        this.contentView().setTransition("right " + dt + "s")
        this.setTransition(this.transitionStyle())
        
        setTimeout(() => {
            this.setTouchRight(this.clientWidth())
            setTimeout(() => {
                this.cleanupSlide()
                this.delete()
            }, dt * 1000)
        }, 0)
    }

    slideBack () {
        this.disableColumnUntilTimeout(400)

        this.contentView().setTransition("all 0.2s ease")

        setTimeout(() => {
            this.setTouchRight(0)
            this.contentView().setTransition(this.transitionStyle())
        })

        setTimeout(() => {
            this.didCompleteSlide()
        }, 300)
    }

    disableColumnUntilTimeout (ms) {
        //this.column().columnGroup().disablePointerEventsUntilTimeout(ms)
        //this.setPointerEvents("none")
    }

    didCompleteSlide () {
        this.cleanupSlide()
    }
    
    hasCloseButton () {
        return this.closeButtonView() && this.closeButtonView().target() != null
    }

    // tap hold

    acceptsLongPress () {
        if (!this.column()) {
            console.log("missing parent view on: " + this.typeId())
        }

        if (this.column()) {
            return this.column().canReorderRows()
        }
        return false
    }
    
    onLongPressBegin (aGesture) {
        if (this.isRegisteredForBrowserDrag()) {
            aGesture.cancel() // don't allow in-browser drag when we're doing a drag outside
        }
    }

    onLongPressCancelled (aGesture) {
    }

    isTapLongPress () {
        // ok, now we need to figure out if this is a tap-hold or tap-tap-hold
        const maxDt = 0.7 // between tap time + long tap hold time before complete is triggered
        let isTapTapHold = false
        const t1 = this.lastTapDate()
        const t2 = new Date()
        if (t1) {
            const dtSeconds = (t2.getTime() - t1.getTime())/1000
            //console.log("dtSeconds = " + dtSeconds)
            
            if (dtSeconds < maxDt) {
                isTapTapHold = true
            }
        }
        return isTapTapHold
    }

    onLongPressComplete (longPressGesture) {
        longPressGesture.deactivate() // needed?

        const isTapLongPress = this.isTapLongPress() // is tap-hold

        if (!this.isSelected()) {
            this.column().unselectAllRowsExcept(this)
        }

        this.select()
        const dv = DragView.clone().setItems(this.column().selectedRows()).setSource(this.column())

        if (isTapLongPress) {
            dv.setDragOperation("copy")
        } else { // otherwise, it's just a normal long press
            dv.setDragOperation("move")
        }
        
        dv.openWithEvent(longPressGesture.currentEvent())
    }

    // --- handle pan gesture ---

    acceptsPan () {
        return this._isReordering
    }

    // --- selecting ---
	
    willAcceptFirstResponder () {
        super.willAcceptFirstResponder()
	    //this.debugLog(".willAcceptFirstResponder()")
        return this
    }

    // -------------------------
    
    nodeRowLink () {
        //this.debugLog(".visibleSubnodes() isInspecting:" + this.isInspecting())
        if (this.isInspecting()) {
            return  this.node().nodeInspector()
        }

        return this.node().nodeRowLink()
    }

    /*
    show () {
        const d = this.getComputedCssAttribute("display")
        const p = this.getComputedCssAttribute("position")
        console.log("row display:" + d + " position:" + p)
    }
    */

    // --- dragging source protocol ---

    hideForDrag () {
        //this.setVisibility("hidden")
        this.hideDisplay()
    }

    unhideForDrag () {
        //this.setVisibility("visible")
        this.unhideDisplay()
    }

    /*
    onDragItemBegin (aDragView) {
    }

    onDragItemCancelled (aDragView) {
    }

    onDragItemDropped (aDragView) {
    }
    */

    onDragRequestRemove () {
        //assert(this.hasParentView()) //
        if (this.hasParentView()) {
            this.removeFromParentView()
        }
        assert(!this.hasParentView()) //

        this.node().removeFromParentNode()
        assert(!this.node().parentNode())

        //this.delete() // we don't want to delete it, we want to move it
        return true
    }

    // --- dropping destination protocol implemented to handle selecting/expanding row ---

    acceptsDropHover (dragView) {
        return this.canDropSelect() || this.acceptsDropHoverComplete(dragView)
    }

    onDragDestinationEnter (dragView) {
        if (this.canDropSelect()) {
            this.setupDropHoverTimeout()
        }
    }

    onDragDestinationHover (dragView) {
        //console.log(this.typeId() + " onDragDestinationHover")
    }

    onDragDestinationExit (dragView) {
        this.cancelDropHoverTimeout()
        //this.unselect()
        //this.column().unselectAllRowsExcept(anItem)
    }

    // --- dropping on row - usefull for LinkNode? ---

    acceptsDropHoverComplete (dragView) {
        const node = this.node()
        if (node && node.nodeAcceptsDrop) {
            return node.nodeAcceptsDrop(dragView.item().node())
        }
    }

    onDragDestinationDropped (dragView) {
        console.log(this.typeId() + " onDragDestinationDropped")

        const itemNode = dragView.item().node()

        const node = this.node()
        if (itemNode && node && node.nodeDropped) {
            return node.nodeDropped(itemNode)
        }
    }

    dropCompleteDocumentFrame () {
        return this.frameInDocument()
    }

    // ----

    dropHoverDidTimeoutSeconds () {
        return 0.3
    }

    canDropSelect () {
        // only want to prevent this for non-navigation nodes
        return true
        //return this.node().hasSubnodes() || this.node().nodeCanReorderSubnodes()
    }

    // -----------------

    setupDropHoverTimeout () {
        const seconds = this.dropHoverDidTimeoutSeconds()
        this._dropHoverEnterTimeout = setTimeout(
            () => { this.dropHoverDidTimeout() }, 
            seconds * 1000
        )
    }

    cancelDropHoverTimeout () {
        clearTimeout(this._dropHoverEnterTimeout)
        this._dropHoverEnterTimeout = null
    }

    dropHoverDidTimeout () {
        this.justTap()
    }

    // Browser style drag

    onBrowserDragStart (event) {  
        let dKey = BMKeyboard.shared().keyForName("d")
        if (!dKey.isDown()) {
            return false
        }

        const node = this.node()
        if (node && node.getBMDataUrl) {
            const bdd = node.getBMDataUrl()
            if (bdd) {
                event.dataTransfer.setData(bdd.transferMimeType(), bdd.dataUrlString())
                return true;
            }
        }

        return false;
    }

    // focus

    onFocusIn () {
        return super.onFocusIn()
    }

}.initThisClass()

"use strict"

/*
    
    BrowserTitledRow
    
*/

window.BrowserTitledRow = class BrowserTitledRow extends BrowserRow {
    
    initPrototype () {
        this.newSlot("titleView", null)
        this.newSlot("subtitleView", null)
        this.newSlot("noteView", null)
        this.newSlot("noteIconView", null) // created lazily
        this.newSlot("thumbnailView", null)
    }

    init () {
        super.init()

        this.contentView().setMinHeight("5em")
        this.contentView().flexSplitIntoColumns(2)
        let lv = this.contentView().subviews().at(0)

        lv.setPaddingTop("0.7em")
        lv.setPaddingBottom("0.7em")

        lv.setPaddingLeft("1.5em")
        lv.setPaddingRight("1em")

        lv.setDisplay("flex")
        lv.setFlex("10")
        lv.setAlignItems("flex-start") // alignment in direction of flex
        lv.setJustifyContent("center") // alignment perpendicutal to flex
        lv.setFlexDirection("column")

        const tv = BrowserRowTitle.clone()
        lv.addSubview(tv)
        this.setTitleView(tv)
        tv.setUsesDoubleTapToEdit(true)
        tv.setOverflow("visible")
        tv.setPaddingLeft("0em")

        const st = BrowserRowSubtitle.clone()
        lv.addSubview(st)
        this.setSubtitleView(st)
        st.setPaddingLeft("0em")
        st.setPaddingTop("0em")
        st.setOpacity(0.6)


        const rv = this.contentView().subviews().at(1)
        rv.setDisplay("flex")
        rv.setAlignItems("center")
        this.setNoteView(rv.addSubview(BrowserRowNote.clone()))
        rv.setMinWidth("2em")
        rv.setJustifyContent("center")

        const icon = SvgIconView.clone().setDivClassName("NoteIconView")
        icon.setMinAndMaxWidth(12)
        icon.setMinAndMaxHeight(15)
        //icon.setFillColor("white")
        icon.setStrokeColor("white")
        icon.setOpacity(0.2)
        this.setNoteIconView(rv.addSubview(icon))
        
        this.updateSubviews()
        this.setIsSelectable(true)
        return this
    }

    setupThumbnailViewIfAbsent () {
        if (!this.thumbnailView()) {
            const tv = DomView.clone().setDivClassName("BrowserRowThumbnailView")
            tv.setDisplay("block")
            tv.setLeftPx(10)
            tv.setTopPx(5)
            tv.setMinHeight("40px")
            tv.setMinWidth("40px")
            tv.setBorderRadiusPx(7)
            tv.setBackgroundColor("transparent")
            tv.setBorder("0px solid #aaa")

    		tv.makeBackgroundNoRepeat()
            tv.makeBackgroundCentered()
            //tv.makeBackgroundContain()
            tv.setBackgroundSizeWH(50, 50)

            this.setThumbnailView(tv)
            this.addSubview(tv)
            
            // TODO: make this dynamic with subview for title & subtitle
            const offset = 60
            this.titleView().setLeftPx(offset)
            this.subtitleView().setLeftPx(offset)
        }
        return this
    }
    
    hasSubtitle () {
        const node = this.node()

        if (node) {
            if (node.subtitle() !== null && node.subtitle() !== "") {
                return true
            }

            if (node.nodeCanEditSubtitle()) {
                return true
            }
        }

        return false
    }
    

    syncSelected () {
        const b = this.isSelected()
        this.titleView().setIsSelected(b)
        this.subtitleView().setIsSelected(b)
        this.noteView().setIsSelected(b)
        return this
    }

    updateSubviews () {
        super.updateSubviews()
	
        const node = this.node()

        if (node) {
            this.titleView().setIsEditable(node.nodeCanEditTitle() )
            this.subtitleView().setIsEditable(node.nodeCanEditSubtitle())
            this.subtitleView().setDisplayIsHidden(!this.hasSubtitle())
    
            this.syncSelected()

            if (node) {
                const imageUrl = node.nodeThumbnailUrl()
                if (imageUrl) {
                    this.setupThumbnailViewIfAbsent()
                    this.thumbnailView().setBackgroundImageUrlPath(imageUrl)
                }
            } 

            if (node.noteIconName()) {
                this.hideNoteView()
                this.showNoteIconView()
            } else {
                this.showNoteView()
                this.hideNoteIconView()
            }
        } else {
            this.titleView().setIsEditable(false)
            this.subtitleView().setIsEditable(false)
            this.subtitleView().setDisplayIsHidden(true)
        }

        return this
    }

    // noteView

    showNoteView () {
        this.noteView().unhideDisplay()   
        this.noteView().setInnerHTML(this.node().note())
    }

    hideNoteView () {
        this.noteView().hideDisplay()     
    }

    // noteIconView

    showNoteIconView () {
        const v = this.noteIconView()
        if (v.iconName() != this.node().noteIconName()) {
            v.unhideDisplay()    
            v.setIconName(this.node().noteIconName())
            //v.setDoesMatchParentColor(true)

        }
        const color = this.currentColor()
        v.setColor(color)
        v.setFillColor(color)
        v.setOpacity(0.95)
        //console.log( this.node().title() + " - " + color)
        v.updateAppearance()
    }

    hideNoteIconView () {
        this.noteIconView().hideDisplay()  
    }

    // ---

    desiredWidth () {
        /*
        const tw = this.titleView().calcCssWidth()
        const sw = this.subtitleView().calcCssWidth()
        let w = tw
        if (sw > w) {
            w = sw
        }
        //console.log("calcCssWidth of row title '" + this.node().title() + "' = " + w)
        return w + 50
        */
        return this.calcWidth()
    }

    // --- edit ---

    didInput () {
        // if text is blocked, sync browser?
        this.browser().fitColumns()
        this.scheduleSyncToNode()
    }

    onDidEdit (aView) {
        super.onDidEdit() 
        // need to broadcast recompact to all
        //this.browser().fitColumns()
        return true // stop propogation
    }

    // --- sync ---

    syncToNode () {   
        //console.log("syncToNode")
        const node = this.node()
        node.setTitle(this.titleView().innerText())
        node.setSubtitle(this.subtitleView().innerText())
        return this
    }

    syncFromNode () {
        super.syncFromNode()
        const node = this.node()
        this.titleView().setString(node.title())
        this.subtitleView().setString(node.subtitle())
        //this.noteView().setString(this.node().note())
        this.updateSubviews()
        return this
    }
    
    // arrow
    
    makeNoteRightArrow () {
        const nv = this.noteView()
        
        nv.setBackgroundImageUrlPath(this.pathForIconName("right-gray"))        
        nv.setBackgroundSizeWH(10, 10)
        
        nv.setMinAndMaxWidth(10)
        nv.setMinAndMaxHeight(10)

        /*
        const icon = this.noteSvgIconForName("right-gray")
        nv.setInnerHTML("")
        nv.removeAllSubviews()
        nv.addSubview(icon)
        */
        return this		
    }

    onEnterKeyUp (event) {
        //this.debugLog(".onEnterKeyUp()")

        if(this.titleView().isEditable()) {
            this.titleView().activate()
            event.stopPropagation()
        } else if (this.subtitleView().isEditable()) {
            this.subtitleView().activate()
            event.stopPropagation()
        } else {
            super.onEnterKeyUp(event)
        }        
    }

    
}.initThisClass()

"use strict"

/*
    
    BrowserRowNote
    
*/

window.BrowserRowNote = class BrowserRowNote extends TextField {

    initPrototype () {
    }

    init () {
        super.init()
        this.setFontSize("80%")
        this.setFontWeight("normal")
        this.setWhiteSpace("nowrap")
        this.setTextAlign("right")
        this.setTextOverflow("ellipsis")
        return this
    } 
    
}.initThisClass()

"use strict"

/*
    
    BrowserRowSubtitle
    
*/

window.BrowserRowSubtitle = class BrowserRowSubtitle extends TextField {
    
    initPrototype () {

    }

    init () {
        super.init()
        this.setDisplay("block")
        this.setMarginTop("3px")
        this.setMarginLeft("0px")
        this.setMarginBottom("3px")
        this.setFontSize("80%")
        this.setFontWeight("normal")
        this.setTextAlign("left")
        this.setOverflow("visible")
        this.setWordWrap("break-word")
        return this
    }

}.initThisClass()



"use strict"

/*
    BrowserRowTitle

    A title element in a BrowserRow. 

    Reasons not to just use setDivClassName() on a TextField instead:
    - to automatically get the full class hierarchy in the div name
    - a place to (potentially) override interaction behaviors

*/

window.BrowserRowTitle = class BrowserRowTitle extends TextField {
    
    initPrototype () {

    }

    init () {
        super.init()
        this.setDisplay("block")
        this.setPosition("relative")
        this.setMarginTop("0em")
        this.setMarginLeft("0em")
        this.setMinWidth("20px")
        this.setPaddingTop("2px")
        this.setPaddingBottom("2px")
        this.setTextAlign("left")
        this.setWhiteSpace("nowrap")
        this.setOverflow("hidden")
        this.setWordWrap("normal")
        return this
    }

    /*
    row () {
        return this.parentView().parentView()
    }
    */

    selectNextKeyView () {
        /*
        this.debugLog(".selectNextKeyView()")
        const row = this.parentView().parentView();
        const nextRow = this.row().column().selectNextRow()
        */
        return true
    }
    
}.initThisClass()

"use strict"

/*
    
    BMTextNodeRowView
    
*/

window.BMTextNodeRowView = class BMTextNodeRowView extends BrowserRow {
    
    initPrototype () {
        this.newSlot("textView", null)
    }

    init () {
        super.init()

        const cv = this.contentView()
        cv.setMinHeight("1em")
        cv.setPadding("0em")

        const tv = TextField.clone()
        this.setTextView(tv)
        this.contentView().addSubview(tv)

        tv.setDisplay("flex")
        //tv.setFlex("10")
        tv.setAlignItems("flex-start") // alignment in direction of flex
        tv.setJustifyContent("center") // alignment perpendicutal to flex
        tv.setFlexDirection("column")
        tv.setWidth("100%")

        tv.setUsesDoubleTapToEdit(true)
        tv.setOverflow("visible")
        tv.setPaddingLeft("0em")

        this.updateSubviews()
        this.setIsSelectable(true)
        return this
    }

    updateSubviews () {
        super.updateSubviews()
        return this
    }
    
    // ---

    desiredWidth () {
        return this.calcWidth()
    }

    // --- edit ---

    didInput () {
        this.browser().fitColumns()
        this.scheduleSyncToNode()
    }

    onDidEdit (aView) {
        super.onDidEdit() 
        this.browser().fitColumns()
        return true // stop propogation
    }

    // --- sync ---

    syncToNode () {   
        //console.log("syncToNode")
        const node = this.node()
        node.setValue(this.textView().innerText())
        return this
    }

    themeClassName () {
        const node = this.node()
        if (node && node.themeClassName) {
            return node.themeClassName()
        }
        return super.themeClassName()
    }

    syncFromNode () {
        const node = this.node()
        if (!node) {
            return 
        }
        
        this.textView().setString(node.value())

        this.applyStyles()
        return this
    }

    applyStyles () {
        //console.log("themePathArray = ", this.themePathArray())

        this.textView().setColor(this.themeValueForAttribute("color"))
        this.textView().setBackgroundColor(this.themeValueForAttribute("backgroundColor"))

        this.textView().setFontSize(this.themeValueForAttribute("fontSize"))
        this.textView().setFontFamily(this.themeValueForAttribute("fontFamily"))
        this.textView().setFontWeight(this.themeValueForAttribute("fontWeight"))

        this.textView().setLetterSpacing(this.themeValueForAttribute("letterSpacing"))
        this.textView().setLineHeight(this.themeValueForAttribute("lineHeight"))
        this.textView().setTextTransform(this.themeValueForAttribute("textTransform"))

        this.textView().setPaddingLeft(this.themeValueForAttribute("paddingLeft"))
        this.textView().setPaddingRight(this.themeValueForAttribute("paddingRight"))
        this.textView().setPaddingTop(this.themeValueForAttribute("paddingTop"))
        this.textView().setPaddingBottom(this.themeValueForAttribute("paddingBottom"))
    }
    
}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "_css.css",
    "BMFieldRowView.js",
    "BMActionNodeRowView.js",
    "BMBooleanFieldRowView.js",
    "BMStringFieldRowView.js",
    "BMTextAreaFieldRowView.js",
    "BMImageWellFieldRowView.js",
    "options/_imports.js",
    "BMPointerFieldRowView.js"
])

"use strict"

/*

    BMFieldRowView

*/


window.BMFieldRowView = class BMFieldRowView extends BrowserRow {
    
    initPrototype () {
        this.newSlot("allowsCursorNavigation", false)
        this.newSlot("vPadding",  "0.1em")

        this.newSlot("titlesSection", null)
        this.newSlot("keyViewContainer", null)
        this.newSlot("valueViewContainer", null)

        this.newSlot("errorViewContainer", null)
        this.newSlot("noteViewContainer", null)

        this.newSlot("keyView", null)
        this.newSlot("valueView", null)
        this.newSlot("errorView", null)
        this.newSlot("noteView", null)

        this.newSlot("editableColor", "#aaa")
        this.newSlot("uneditableColor", "#888")
        this.newSlot("errorColor", "red")

        this.newSlot("valueEditableBorder", "1px solid rgba(255, 255, 255, 0.2)")
        //this.newSlot("valueEditableBorder", "none")
        this.newSlot("valueUneditableBorder", "none")
    }

    setupRowContentView () {
        super.setupRowContentView()

        const cv = this.contentView()
        cv.setMinHeight("5em")
        cv.setPaddingTop("0.5em")
        cv.setPaddingBottom("0.5em")
        cv.setJustifyContent("center") // alignment perpendicular to flex
        cv.setFlexDirection("column")
        return this
    }

    init () {
        super.init()
        this.makeCursorDefault()
        this.setSpellCheck(false)

        this.setOpacity(1)
        this.setPosition("relative")
        this.setHeight("auto")
        this.setMinHeight("5em")
        this.setMaxHeight("none")
        this.setHeight("auto")
        this.setOverflow("visible")
        this.setWidth("auto")
        this.setTransition("background-color .3s ease-out")
        this.setTextAlign("left")

        {
            this.setTitlesSection(this.contentView().newFlexSubview().setDivClassName("TitlesSection"))
            this.titlesSection().setFlexDirection("column")

            this.setKeyViewContainer(this.titlesSection().newFlexSubview().setDivClassName("KeyViewContainer"))
            this.keyViewContainer().setAlignItems("flex-start")
            this.setupKeyView()

            this.setValueViewContainer(this.titlesSection().newFlexSubview().setDivClassName("ValueViewContainer"))
            this.valueViewContainer().setAlignItems("flex-start")
            this.setupValueView()

            this.setNoteViewContainer(this.contentView().newFlexSubview().setDivClassName("NoteViewContainer"))
            this.setupNoteView()

            this.setErrorViewContainer(this.contentView().newFlexSubview().setDivClassName("ErrorViewContainer"))
            this.setupErrorView()

            this.contentView().subviews().forEach(subview => {
                subview.setPaddingLeft("1.5em")
                subview.setPaddingRight("1em")
            })
        }

        
        return this
    }

    setupKeyView() {
        const v = TextField.clone().setDivClassName("BMFieldKeyView")
        v.setDisplay("inline-block")
        v.setOverflow("hidden")
        v.setTextAlign("left")
        v.setWhiteSpace("nowrap")

        this.setKeyView(v)
        v.turnOffUserSelect()
        v.setSpellCheck(false)
        //v.setPaddingTop(this.vPadding())
        //v.setPaddingBottom(this.vPadding())
        v.setMarginTop(this.vPadding())
        v.setMarginBottom(this.vPadding())
        v.setPaddingLeft("0em")
        v.setPaddingRight("0em")

        this.keyViewContainer().addSubview(v)     
        return v
    }

    setupValueView () {
        const v = this.createValueView()
        v.setUserSelect("text")   // should the value view handle this?
        v.setSpellCheck(false)   // should the value view handle this?
        //v.setPaddingTop(this.vPadding())
        //v.setPaddingBottom(this.vPadding())
        v.setMarginTop(this.vPadding())
        v.setMarginBottom(this.vPadding())

        this.setValueView(v)
        this.valueViewContainer().addSubview(v)  
        //this.valueSectionView().addSubview(v)  
        return v
    }

    setupNoteView () {
        const v = DomView.clone().setDivClassName("BMFieldRowViewNoteView")
        v.setDisplay("block")
        v.setPosition("relative")
        v.setOverflow("hidden")
        v.setWidth("100%")
        v.setFontWeight("normal")
        v.setColor("#aaa")
        v.setMarginLeft("0em")
        v.setMarginRightPx(0)
        v.setMarginTop("0em")
        v.setMarginBottom("0.2em")
        v.setUserSelect("text")
        this.setNoteView(v)
        this.noteViewContainer().addSubview(v)
        return v
    }

    setupErrorView () {
        const v = DomView.clone().setDivClassName("BMFieldRowViewErrorView")
        v.setUserSelect("text")
        v.setSpellCheck(false)
        //v.setInnerHTML("error")
        v.setColor("red")
        v.setPaddingBottom("0em")
        this.setErrorView(v)
        this.errorViewContainer().addSubview(v)
        return v 
    }

    createValueView () {
        const v = TextField.clone().setDivClassName("BMFieldValueView")
        v.setDisplay("flex")
        v.setPosition("relative")
        v.setWidth("100%")
        v.setMarginTop("0.1em")
        v.setMarginLeft("0em")
        v.setMarginRight("0em")
        v.setMarginBottom("0.1em")
        v.setTextAlign("left")
        v.setOverflow("hidden")
        v.setWhiteSpace("nowrap")
        v.setPaddingLeft("7px")
        v.setPaddingRight("4px")
        v.setPaddingBottom("5px")
        v.setColor("white")
        v.setBackgroundColor("transparent")
        //tf.setSelectAllOnDoubleClick(true)
        return v
    }

    // colors

    currentBackgroundCssColor () {
        const bg = this.columnGroup().computedBackgroundColor()
        return CSSColor.clone().setCssColorString(bg)
    }

    valueBackgroundCssColor () {
        return this.currentBackgroundCssColor().contrastComplement(0.2)
    }

    valueBackgroundColor () {
        return this.valueBackgroundCssColor().cssColorString()
    }

    editableColor () {
        return this.valueBackgroundCssColor().contrastComplement(0.2).cssColorString()
    }

    keyViewColor () {
        //console.log(this.node().title() + " " + this.typeId() + ".isSelected() = ", this.isSelected())
        return this.currentColor()
        //return this.valueBackgroundCssColor().contrastComplement(0.2).cssColorString()
    }

	
    // visible key and value
    
    visibleValue () {
        return this.node().visibleValue()
    }
	
    visibleKey () {
        return this.node().key()
    }

    // sync 
    
    didUpdateSlotIsSelected (oldValue, newValue) {
        super.didUpdateSlotIsSelected(oldValue, newValue)
        this.syncFromNodeNow() // need this to update selection color on fields?
        return this
    }

    syncFromNode () {
        super.syncFromNode()
        //this.debugLog(" syncFromNode")
		
        const node = this.node()
        node.prepareToSyncToView()
        this.setDisplayIsHidden(!node.isVisible())

        this.syncKeyFromNode()
        this.syncValueFromNode()
        this.syncErrorFromNode()
        this.syncNoteFromNode()
        
        return this
    }

    syncKeyFromNode () {
        const node = this.node()
        const keyView = this.keyView()

        keyView.setInnerHTML(this.visibleKey())
        keyView.setIsVisible(node.keyIsVisible())
        keyView.setDisplayIsHidden(!node.keyIsVisible())
        keyView.setIsEditable(node.keyIsEditable())
        keyView.setColor(this.keyViewColor())
    }

    syncValueFromNode () {
        const node = this.node()
        const valueView = this.valueView()

        const newValue = this.visibleValue()
        valueView.setValue(newValue)
        valueView.setIsEditable(node.valueIsEditable())
        valueView.setDisplayIsHidden(!node.valueIsVisible())

        if (node.valueIsEditable()) {
            //valueView.setColor(this.editableColor())
            valueView.setColor(this.currentColor())
            //valueView.setBorder("1px solid #444")
            //valueView.setBorder("1px solid rgba(255, 255, 255, 0.2)")
            valueView.setBorder(this.valueEditableBorder())
            valueView.setPaddingLeft("0.5em").setPaddingRight("0.5em")

        } else {
            //console.log("fieldview key '", node.key(), "' node.valueIsEditable() = ", node.valueIsEditable(), " setColor ", this.uneditableColor())
            //valueView.setColor(this.uneditableColor())
            valueView.setColor(this.styles().disabled().color())
            //valueView.setBorder("1px solid rgba(255, 255, 255, 0.05)")
            valueView.setBorder(this.valueUneditableBorder())
            valueView.setPaddingLeft("0em").setPaddingRight("0em")
        }
    }

    syncErrorFromNode () {
        const node = this.node()
        const valueView = this.valueView()
        const errorView = this.errorView()

        const color = valueView.color()
        
        if (node.valueError()) {
            valueView.setColor(this.errorColor())
            errorView.setColor(this.errorColor())
            errorView.setInnerHTML(node.valueError())
            errorView.fadeInHeightToDisplayBlock(15)
            //valueView.setToolTip(node.valueError())
        } else {
            valueView.setBackgroundColor("transparent")
            valueView.setColor(color)
            errorView.fadeOutHeightToDisplayNone()
            //valueView.setToolTip("")
        }
    }

    syncNoteFromNode () {
        const node = this.node()
        const noteView = this.noteView()
        
        if (this.visibleNote()) {
            noteView.unhideDisplay()
            noteView.setInnerHTML(this.visibleNote())
        } else {
            noteView.hideDisplay()
            noteView.setInnerHTML("")
        }
    }


    // ----------------------

    visibleNote () {
        return this.node().note()
    }
    
    syncToNode () {
        const node = this.node()

        if (node.keyIsEditable()) {
        	node.setKey(this.keyView().value())
        }
	
        if (node.valueIsEditable()) {
        	node.setValue(this.valueView().value())
        }
		
        super.syncToNode()
        return this
    }
    
    onDidEdit (changedView) {
        this.scheduleSyncToNode() 
        return true
    }

    updateSubviews () {
        super.updateSubviews()
        
        /*
        const node = this.node()

        if (node && node.nodeMinRowHeight()) {
            if (node.nodeMinRowHeight() === -1) {
                this.setHeight("auto")
                this.setPaddingBottom("calc(100% - 20px)")

            } else {
                this.setHeight(this.pxNumberToString(node.nodeMinRowHeight()))
            }
        }
        */
        
        return this
    }

    /*
    applyStyles () {
        super.applyStyles()
        return this
    }
    */
    
    onEnterKeyUp (event) {
        //this.debugLog(".onEnterKeyUp()")
        if(this.valueView().activate) {
            this.valueView().activate()
        }
        return this
    }

    setBackgroundColor (c) {
        /*
        this.debugLog(".setBackgroundColor ", c)
        if (c !== "white") {
            console.log("not white")
        }
        */
        super.setBackgroundColor(c)
        return this
    }

    becomeKeyView () {
        this.valueView().becomeKeyView()
        return this
    }

    unselect () {
        super.unselect()
        this.valueView().blur()
        this.keyView().blur()
        return this
    }
    
}.initThisClass()

"use strict"

/*

    BMActionNodeRowView

*/

window.BMActionNodeRowView = class BMActionNodeRowView extends BrowserRow {
    
    initPrototype () {
        this.newSlot("buttonView", null)
    }

    init () {
        super.init()

        const cv = this.contentView()
        cv.flexCenterContent()

        cv.setPaddingTop("0.5em")
        cv.setPaddingBottom("0.5em")
        cv.setPaddingLeft("1em")
        cv.setPaddingRight("1em")
        

		
        this.setButtonView(ButtonView.clone().setDivClassName("BMActionNodeView"))
	    this.buttonView().setTarget(this).setAction("didClickButton")
	    this.buttonView().setTransition("all 0.3s")
	    this.buttonView().setBorder("1px solid rgba(128, 128, 128, 0.5)")

        this.addContentSubview(this.buttonView())
        //this.setMinHeightPx(64)
        return this
    }

    updateSubviews () {	
        super.updateSubviews()
		
        const bv = this.buttonView()
        bv.setTitle(this.node().title())
        
        this.buttonView().setIsEditable(this.node().nodeCanEditTitle())

        if (this.node().isEnabled()) {
            bv.setOpacity(1)	
        } else {
            bv.setOpacity(0.5)	
        }
		
        return this
    }
    
    onEnterKeyUp (event) {
        this.doAction()
        return false
    }
    
    doAction () {
        if (this.node().isEnabled()) { // check in node field?
            this.node().doAction()
        }
        return this     
    }
    
    didClickButton () {
        this.doAction()
        return this
    }

    syncToNode () {
        this.node().setTitle(this.buttonView().title()) 
        super.syncToNode()
        return this
    }

    onDidEdit (changedView) {     
        this.scheduleSyncToNode()
        //this.node().didUpdateView(this)
        //this.scheduleSyncFromNode() // needed for validation?
        return true
    }
    
}.initThisClass()

"use strict"

/*

    BMBooleanFieldRowView

*/

window.BMBooleanFieldRowView = class BMBooleanFieldRowView extends BMFieldRowView {
    
    initPrototype () {

    }

    init () {
        super.init()
        
        this.turnOffUserSelect()
        this.keyView().setTransition("color 0.3s")
        this.keyView().setPaddingLeft("0.5em")

        this.valueView().parentView().flexCenterContent()
        this.valueView().setPaddingBottom("0em")

        //this.contentView().debugBorders()
        this.titlesSection().subviews().at(1).flexCenterContent()
        //this.contentView().setFlexDirection("column")
        this.titlesSection().setFlexDirection("row").makeSubviewsReverseOrdered()
        //this.titlesSection().subviews().forEach(sv => sv.setAlignItems("center"))
        this.titlesSection().subviews().forEach(sv => sv.flexCenterContent())
        //this.keyView().parentView().swapSubviews(this.keyView(), this.valueView())

        this.setValueEditableBorder("none")
        this.setValueUneditableBorder("none")

        return this
    }

    createValueView () {
        const bv = BooleanView.clone()
        return bv
    }
	
    booleanView () {
        return this.valueView()
    }

    syncFromNode () {
        super.syncFromNode()
        this.booleanView().updateAppearance()
        return this
    }
    
}.initThisClass()

"use strict"

/*

    BMStringFieldRowView

*/

window.BMStringFieldRowView = class BMStringFieldRowView extends BMFieldRowView {
    
    initPrototype () {

    }

    init () {
        super.init()
        
        return this
    }

    createValueView () {
        const v = TextField.clone()
        v.setDisplay("block")
        v.setPosition("relative")
        v.setWordWrap("normal")
        v.setHeight("auto")
        v.setWidth("-webkit-fill-available")
        v.setTextAlign("left")
        v.setMargin("0em")
        v.setOverflowX("hidden")
        v.setBorderRadius("0.2em")
        return v
    }

    syncValueFromNode () {
        super.syncValueFromNode()
        
        const node = this.node()
        const valueView = this.valueView()

        if (node.valueIsEditable()) {
            valueView.setColor(this.currentColor())
            valueView.setBorder(this.valueEditableBorder())
            valueView.setPaddingLeft("0.5em").setPaddingRight("0.5em")
        } else {
            valueView.setColor(this.styles().disabled().color())
            valueView.setBorder(this.valueUneditableBorder())
            valueView.setPaddingLeft("0em").setPaddingRight("0em")
        }
    }
    
}.initThisClass()

"use strict"

/*

    BMTextAreaFieldRowView

    
*/

window.BMTextAreaFieldRowView = class BMTextAreaFieldRowView extends BMFieldRowView {
    
    initPrototype () {
    }

    init () {
        super.init()
        this.keyView().hideDisplay()
        this.setValueUneditableBorder("none")
        this.setValueEditableBorder("none")
        return this
    }

    createValueView () {
        const v = TextField.clone().setDivClassName("BMTextAreaFieldValueView")
        v.setDisplay("block")
        v.setPosition("relative")
        v.setWordWrap("normal")
        v.setHeight("auto")
        v.setWidth("-webkit-fill-available")
        v.setTextAlign("left")
        v.setMargin("0em")
        v.setOverflowX("hidden")
        v.setOverflowY("scroll")
        //v.setDoesHoldFocusOnReturn(true)
        v.setDoesInput(false)
        return v
    }
    
    /*
    updateSubviews () {   
        super.updateSubviews()

        return this
    }
    */

    /*
	
    fillBottomOfColumnIfAvailable () {
        if (this.column().rows().last() === this) {
            //this.debugLog(" update height")
            this.setMinAndMaxHeightPercentage(100)
            this.setFlexGrow(100)
            this.setBorderBottom("0em")

            this.valueView().setHeight("100%")
        } else {
            this.setFlexGrow(1)
            this.setBorderBottom("1px solid rgba(125, 125, 125, 0.5)")
        }
        return this
    }
    */
    
}.initThisClass()

"use strict"

/*

    BMImageWellFieldRowView

*/

window.BMImageWellFieldRowView = class BMImageWellFieldRowView extends BMFieldRowView {
    
    canOpenMimeType (mimeType) {
        // TODO: add checks for browser supported image types?
        return mimeType.beginsWith("image/")
    }

    initPrototype () {

    }

    init () {
        super.init()
        this.valueViewContainer().flexCenterContent()
        this.valueViewContainer().setPaddingTop("0px").setPaddingBottom("0px")
        this.valueView().setPaddingTop("0px").setPaddingBottom("0px")

        //this.keyView().setDivClassName("BMImageWellKeyField")
        //this.valueView().setIsEditable(false)
        this.turnOffUserSelect()
        this.keyView().setTransition("all 0.3s")
        //this.valueViewContainer().setPadding("0px")
        return this
    }

    createValueView () {
        const imageWellView = ImageWellView.clone()
        //imageWellView.setWidth("100%").setHeight("fit-content")
        return imageWellView
    }
	
    imageWellView () {
        return this.valueView()
    }

    syncFromNode () {
        super.syncFromNode()

        const field = this.node()
        this.setMaxWidth("100em") // get this from node instead?
        
        this.applyStyles() // normally this would happen in updateSubviews
        this.imageWellView().setImageDataUrl(field.value())

        return this
    }

    syncToNode () {
        const field = this.node()
				
        //this.updateKeyView()
        
        field.setKey(this.keyView().value())

        if (field.valueIsEditable()) {
            const data = this.imageWellView().imageDataUrl()
            //console.log("data = " + (data ? data.slice(0, 40) + "..." : "null"))
        	field.setValue(data)
        }
        
        //super.suncToNode()
        return this
    }

    dataUrl () {
        return this.imageWellView().imageDataUrl()
    }

    isEmpty () {
        return Type.isNull(this.dataUrl())
    }
    
    didUpdateImageWellView (anImageWell) {
        //this.debugLog(".didUpdateImageWellView()")
        this.scheduleSyncToNode() 
        return this
    }
    
}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "BMOptionsNodeRowView.js",
    "BMOptionNodeRowView.js"
])

"use strict"

/*

    BMOptionsNodeRowView 

    View for BMOptionsNode

    BMOptionsNode -> BMOptionsNodeRowView
        BMOption -> BMSingleOptionRowView
        BMMultiOption -> BMMultiOptionRowView

*/


window.BMOptionsNodeRowView = class BMOptionsNodeRowView extends BrowserTitledRow {
    
    initPrototype () {

    }

    init () {
        super.init()
        return this
    }
	
}.initThisClass()

"use strict"

/*

    BMOptionNodeRowView 

 
*/

window.BMOptionNodeRowView = class BMOptionNodeRowView extends BrowserTitledRow {
    
    initPrototype () {

    }

    init () {
        super.init()
        //this.setHasSubtitle(true)
        return this
    }

    toggle () {
        this.node().toggle()
        return this
    }

    onEnterKeyUp (event) {
        super.onEnterKeyUp(event)
        this.toggle()
        return this
    }
    
    onTapComplete (aGesture) {
        super.onTapComplete(aGesture)
        this.toggle()
        return this
    }
    
    /*
    activate () { // not getting called?
        super.activate(aGesture)
        this.node().toggle()
        return this
    }
    */   
               
    /*
    select () {
        super.select()
        this.debugLog(+ " " + this.node().title() + " picked ")
        
        // will tell parent node which will ensure only one selected if needed
        //this.browser().previous()
        // unselect parentNode's view in previous column?
        //this.didEdit()
        this.node().toggle()
        return this
    }
    */

    syncToNode () {
        super.syncToNode()
        return this
    }
	
}.initThisClass()

"use strict"

/*

    BMPointerFieldRowView

*/

window.BMPointerFieldRowView = class BMPointerFieldRowView extends BrowserTitledRow {
    
    initPrototype () {

    }

    init () {
        super.init()

        this.makeNoteRightArrow()
		
        this.styles().unselected().setColor("#888")
        this.styles().unselected().setBackgroundColor("white")

        this.styles().selected().setColor("#888")
        this.styles().selected().setBackgroundColor("#eee")
		
        return this
    }

    updateSubviews () {	
        super.updateSubviews()
		
        let node = this.node()

        if (this.isSelected()) {
            this.noteView().setOpacity(1)	
        } else {
            this.noteView().setOpacity(0.4)	
        }

        this.applyStyles()
		
        return this
    }
    
}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "StackView.js",
    "StackNavView.js",
    "StackScrollView.js",
    "StackItemSetView.js",
    //"StackItemView.js",
])


"use strict"

/*
    
    StackView
    
*/

window.StackView = class StackView extends NodeView {

    static instanceCache () {
        let v = this.getClassVariable("_instanceCache")
        if (!v) {
            v = Dictionary.clone()
            this.setClassVariable("_instanceCache", v)
        }
        return v
    }

    initPrototype () {
        this.newSlot("navView", null)
        this.newSlot("otherView", null)
        this.newSlot("direction", "right").setDoesHookSetter(true) // valid values: left, right, up, down
    }

    init () {
        super.init()
        this.setDisplay("flex")
        this.setPosition("relative")
        this.setWidth("100%")
        this.setHeight("100%")

        this.setFlexDirection("row")
        this.setFlexWrap("nowrap")
        this.setOverflow("hidden")

        this.setupNavView()
        this.setupOtherView()

        //this.setBorder("1px dashed white")

        this.setFlexBasis("fit-content")
        this.setFlexGrow(1)
        this.setFlexShrink(0)

        // events
        this.setIsRegisteredForDocumentResize(true)
        //this.addGestureRecognizer(LeftEdgePanGestureRecognizer.clone()) 
        //this.addGestureRecognizer(RightEdgePanGestureRecognizer.clone()) 

        this.syncOrientation()
        return this
    }

    setupNavView () {
        const v = StackNavView.clone()
        v.setStackView(this)
        this.setNavView(v)
        this.addSubview(v)
        return this
    }

    setupOtherView () {
        const v = DomFlexView.clone()
        v.setFlexGrow(1)
        v.setFlexShrink(1)
        v.setFlexDirection("column")
        v.setWidth("100%")
        v.setHeight("100%")
        this.setOtherView(v)
        this.addSubview(v)
        this.clearOtherView()
        return this
    }

    // --- direction ---

    // --- cache ---

    cacheId () {
        return this.node().typeId()
    }

    isCached () {
        return this.thisClass().instanceCache().hasKey(this.cacheId())
    }

    cache () {
        this.thisClass().instanceCache().atPut(this.cacheId(), this)
        return this
    }

    uncache () {
        this.thisClass().instanceCache().removeKey(this.cacheId())
        return this
    }

    stackViewForNode (aNode) {
        let sv = this.thisClass().instanceCache().at(aNode.typeId(), this)
        if (!sv) {
            sv = StackView.clone().setNode(aNode)
        }
        return sv
    }

    // ---  ---

    didUpdateSlotDirection () {
        this.syncOrientation()
    }

    syncOrientation () {
        const d = this.direction()
        const nv = this.navView()
        if (d === "right") {
            this.setFlexDirection("row")
            //this.navView().setIsVertical(false)

        } else if (d == "down") {
            this.setFlexDirection("column")
            //this.navView().setIsVertical(true)
        }
        this.navView().syncOrientation()
    }

    setNode (aNode) {
        super.setNode(aNode)
        this.navView().setNode(this.node())
        return this
    }

    syncFromNode () {
        this.setDirection(this.node().nodeOrientation())

        this.syncOrientation()
        //this.navView().syncFromNodeNow()
        this.syncFromNavSelection()

        //this.setupColumnGroupColors()
        //this.fitColumns()
        return this
    }

    onDocumentResize (event) {
        this.updateCompaction()
        return this
    }

    setOtherViewContent(v) {
        const ov = this.otherView()
        ov.setFlexBasis(null)
        ov.setFlexGrow(1)
        ov.setFlexShrink(1)
        ov.removeAllSubviews().addSubview(v)
        return this
    }

    clearOtherView () {
        const ov = this.otherView()
        ov.setFlexBasis("0px")
        ov.setFlexGrow(0)
        ov.setFlexShrink(0)
        ov.removeAllSubviews()
        return this
    }

    otherViewContent () {
        return this.otherView().subviews().first()
    }

    didChangeNavSelection () {
        //this.syncFromNavSelection()
        this.scheduleMethod("syncFromNode")
        return true
    }

    syncFromNavSelection () {
        // update otherViewContent view to match selected ite,
        /*
        if (this.node().title() === "A") {
            console.log(" --- A --- ")
        }
        */

        //console.log("StackView " + this.node().title() + " syncFromNavSelection")
        const itemView = this.navView().itemSetView().selectedRow()
        if (itemView && itemView.nodeRowLink()) {
            const oNode = itemView.nodeRowLink()
            const ovc = this.otherViewContent()
            if (!ovc || (ovc.node() !== oNode)) {
                const ov = this.stackViewForNode(oNode)
                this.setOtherViewContent(ov)
                this.updateCompaction()
                this.tellParentViews("updateCompaction")
            }
        } else {
            this.clearOtherView()
        }
    }

    // stack view chain

    previousStackView () {
        // stackView -> otherView -> stackView
        const p = this.parentView()
        if (p) {
            return p.parentView()
        }
        return null
    }

    nextStackView( ) {
        return this.otherView().subviews().first()
    }

    topStackView () {
        let p = this
        while (p.previousStackView()) {
            p = p.previousStackView()
        }
        return p
    }

    // compaction

    updateCompaction () {
        this.compactNavAsNeeded()
        /*
        let pd = this.firstParentWithDifferentDirection()
        if (pd) {
            pd.compactNavAsNeeded()
        }
        */
        return false
    }

    /*
    firstParentWithDifferentDirection () {
        const d = this.direction()
        let current = this
        while (current) {
            const p = current.previousStackView() 
            if (p && p.direction() !== d) {
                break
            }
            current = p
        }
        return current
    }
    */

    stackViewSuperChain () {
        // returns list of self and StackViews above self
        const chain = []
        let current = this
        while (current) {
            chain.push(current)
            const p = current.previousStackView()
            current = p
        }
        return chain
    }

    stackViewDepth () {
        return this.stackViewSuperChain().length - 1
    }

    stackViewSubchain () {
        // returns all self and StackViews below self
        const chain = []
        let current = this
        while (current) {
            chain.push(current)
            current = current.otherView().subviews().first()
        }
        return chain
    }

    sumOfNavWidths () {
        let w = 0
        const views = this.stackViewSubchain()
        for (let i = 0; i < views.length; i++) {
            const sv = views[i]
            /*
            if (sv.direction() !== this.direction()) {
                break
            }
            */
            if (sv.navView().isVertical()) {
                w += sv.navView().targetWidth()
            }
        }
        return w
    }

    compactNavAsNeeded () {
        if (this.direction() === "right") {
            const maxWidth = this.frameInDocument().width()
            const w = this.sumOfNavWidths()

            if (w > maxWidth) {
                console.log(this.node().title() + " sum" + w + " > win" + maxWidth + " COLLAPSE")
                this.navView().collapse()
            } else {
                console.log(this.node().title() + " sum" + w + " < win" + maxWidth + " UNCOLLAPSE")
                this.navView().uncollapse()
            }
        }

        return false
    }


}.initThisClass()

"use strict"

/*
    
    StackNavView
    
*/

window.StackNavView = class StackNavView extends NodeView {

    initPrototype() {
        this.newSlot("stackView", null)
        this.newSlot("scrollView", null) // contains column is middleView
        this.newSlot("itemSetView", null) // is inside scrollView
        this.newSlot("isCollapsed", false)
        this.newSlot("animatesCollapse", true)
    }

    targetWidth() {
        if (this.node()) {
            const w = Math.max(0, this.node().nodeMinRowWidth())
            if (w) {
                return w
            }
        }
        return 300
    }

    targetHeight () {
        if (this.node()) {
            const h = this.node().nodeMinRowHeight()
            if (h) {
                return h
            }
        }
        return 64
    }

    init() {
        super.init()
        this.setDisplay("block")
        this.setPosition("relative")
        this.setFlexDirection("column")
        this.setFlexGrow(1)
        //this.setOpacity(0)
        this.setOverflow("hidden")
        this.setUserSelect("none")
        //this.setTransition("opacity 0.5s ease-in-out")
        //this.setTransition("flex-basis 0.1s")
        this.setTransition("opacity 0.5s ease-in-out, flex-basis 0s")


        /*
        this.setHeaderClass(ColumnGroupHeader)
        this.setMiddleClass(BrowserScrollView)
        this.setFooterClass(ColumnGroupFooter)
        this.setupHeaderMiddleFooterViews()
        this.footerView().hideDisplay()
        */

        this.setScrollView(StackScrollView.clone())
        this.addSubview(this.scrollView())

        this.setItemSetView(StackItemSetView.clone())
        this.scrollView().addSubview(this.itemSetView())

        this.addGestureRecognizer(RightEdgePanGestureRecognizer.clone()) // for adjusting width
        this.addGestureRecognizer(BottomEdgePanGestureRecognizer.clone()) // for adjusting height

        //this.addGestureRecognizer(RightEdgePanGestureRecognizer.clone()) 
        return this
    }

    isVertical() {
        return this.stackView().direction() === "right"
    }

    syncOrientation() {
        if (this.isVertical()) {
            this.makeOrientationRight()
        } else {
            this.makeOrientationDown()
        }
        return this
    }

    borderColor() {
        return "rgba(255, 255, 255, 0.3)"
    }

    makeOrientationRight() {
        this.setFlexDirection("column")
        this.setFlexBasis(this.targetWidth() + "px")
        this.setFlexGrow(0)
        this.setFlexShrink(0)
        this.setBorderRight("1px solid " + this.borderColor())
        this.scrollView().setIsVertical(true)
        //this.setBoxShadow("inset -10px 0 20px rgba(0, 0, 0, 0.05)")
    }

    makeOrientationDown() {
        this.setFlexDirection("row")
        this.setFlexBasis(this.targetHeight() + "px")
        this.setFlexGrow(0)
        this.setFlexShrink(0)
        this.setBorderBottom("1px solid " + this.borderColor())
        this.scrollView().setIsVertical(false)
        //this.setBoxShadow("inset 0 -10px 40px #222")
    }

    setNode(aNode) {
        super.setNode(aNode)
        this.itemSetView().setNode(aNode)
        return this
    }

    syncFromNode() {
        this.syncOrientation()
        //this.itemSetView().syncFromNode()
        this.applyStyles()

        if (this.isVertical()) {
            const w = this.node().nodeMinRowWidth()
            if (w && !Type.isNullOrUndefined(w)) {
                this.setMinAndMaxWidth(w)
                /*
                this.setFlexBasis(w + "px")
                this.setFlexGrow(0)
                this.setFlexShrink(0)
                */
            }
        } else {
            const h = this.node().nodeMinRowHeight()
            if (h && !Type.isNullOrUndefined(h)) {
                this.setMinAndMaxHeight(h)
            }
        }

        return this
    }

    applyStyles() {
        super.applyStyles()
        const themeClass = this.currentThemeClass()
        if (themeClass) {
            const columns = themeClass.firstSubnodeWithTitle("columns")
            if (columns) {
                const colorFields = columns.subnodes().select(sn => sn.thisClass().isSubclassOf("BMStringField") || sn.type() === "BMField")
                const count = colorFields.length
                if (count) {
                    let i = this.stackView().stackViewDepth()
                    let ci = i % count
                    const color = colorFields.at(ci).value()
                    console.log("column " + i + " color index " + ci + " color " + color)
                    this.setBackgroundColor(color)
                }
            }
        }
        return this
    }

    // --- collpase / uncollapse ---

    collapse() {
        if (!this.isCollapsed()) {
            this.hideDisplay()
            //this.setMinAndMaxWidth(0)

            /*
            this.setFlexBasis("0px")
            this.setFlexGrow(0)
            this.setFlexShrink(0)
            */
           this.setIsCollapsed(true)
        }
    }

    uncollapse() {
        if (this.isCollapsed()) {
            this.unhideDisplay()
            //this.setMinAndMaxWidth(this.targetWidth() + "px")
            this.syncOrientation()
            this.setIsCollapsed(false)
        }
    }

    // --- right edge gesture ---

    onRightEdgePanBegin(aGesture) {
        this._beforeEdgePanBorderRight = this.borderRight()
        this.setBorderRight("1px dashed red")
    }

    onRightEdgePanMove(aGesture) {
        const p = aGesture.currentPosition() // position in document coords
        const f = this.frameInDocument()
        const nw = Math.max(10, p.x() - f.x())
        //console.log("nw = ", nw)
        this.node().setNodeMinRowWidth(nw)
        this.scheduleSyncToNode()

        return this
    }

    onRightEdgePanComplete(aGesture) {
        this.onRightEdgePanMove(aGesture)
        this.setBorderRight(this._beforeEdgePanBorderRight)
        this._beforeEdgePanBorderBottom = null
        this.unhideTransition()
    }

    // --- bottom edge gesture ---


    onBottomEdgePanBegin(aGesture) {
        this._beforeEdgePanBorderBottom = this.borderBottom()
        this.setBorderBottom("1px dashed red")
        //this.setTransition("min-height 0s, max-height 0s")
        this.hideTransition()
    }

    onBottomEdgePanMove(aGesture) {
        const p = aGesture.currentPosition() // position in document coords
        const f = this.frameInDocument()
        const newHeight = Math.max(10, p.y() - f.y())
        //console.log("node " + this.node().title() + " newHeight = ", newHeight)
        this.node().setNodeMinRowHeight(newHeight)
        this.scheduleSyncToNode()
        return this
    }

    onBottomEdgePanComplete(aGesture) {
        this.onBottomEdgePanMove(aGesture)
        this.setBorderBottom(this._beforeEdgePanBorderBottom)
        this._beforeEdgePanBorderBottom = null
        this.unhideTransition()
    }

}.initThisClass()

"use strict"

/*

    StackScrollView

*/

window.StackScrollView = class StackScrollView extends DomView {
    
    initPrototype () {
    }

    init () {
        super.init()
        this.setDisplay("block")
        this.setPosition("relative")
        this.setTopPx(null)
        this.makeVertical()
        this.setMsOverflowStyle("none") // removes scrollbars on IE 10+ 
        this.setOverflow("-moz-scrollbars-none") // removes scrollbars on Firefox 
        this.setBackgroundColor("transparent")
        //this.setBorder("1px solid purple")
        return this
    }

    setIsVertical (aBool) {
        if (aBool) {
            this.makeVertical()
        } else {
            this.makeHorizontal()
        }
        return this
    }

    makeVertical () {
        //this.setWidth("fit-content")
        this.setWidth("100%")
        this.setHeight("100%")
        this.setOverflowY("scroll") // has to be scroll, not auto, for touch scroll momentum to work 
        this.setOverflowX("hidden")
        return this
    }

    makeHorizontal () {
        this.setWidth("100%")
        this.setHeight("100%")
        //this.setHeight("fit-content")
        this.setOverflowY("hidden") 
        this.setOverflowX("scroll") // has to be scroll, not auto, for touch scroll momentum to work 
        return this
    }
    
}.initThisClass()



"use strict"

/*
    
    StackItemSetView
    
*/

window.StackItemSetView = class StackItemSetView extends NodeView {
    
        
    initPrototype () {
        this.newSlot("rows", null)
        this.newSlot("allowsCursorNavigation", true)
        this.newSlot("defaultRowStyles", null)
        this.newSlot("rowStyles", null)
        this.newSlot("rowPlaceHolder", null)
        this.newSlot("hasPausedSync", false)
        //this.newSlot("isColumnInspecting", false)
    }

    init () {
        super.init()
        this.setDisplay("block")
        this.setPosition("relative")
        //this.setFlexBasis("fit-content")
        //this.setFlexGrow(0)
        //this.setFlexShrink(0)
        this.makeOrientationRight()

        this.setOverflow("hidden")
        this.setWebkitOverflowScrolling("regular")
        this.setMsOverflowStyle("none")
        this.setUserSelect("none")

        //this.setIsDebugging(true)
        this.setIsRegisteredForKeyboard(true)
        this.setAcceptsFirstResponder(true)

        this.setUserSelect("none")
        this.addGestureRecognizer(PinchGestureRecognizer.clone()) // for pinch open to add row
        this.addGestureRecognizer(TapGestureRecognizer.clone()) // for pinch open to add row

        this.setRowStyles(BMViewStyles.clone().setToWhiteOnBlack())
        //this.rowStyles().selected().setBackgroundColor("red")

        this.setIsRegisteredForBrowserDrop(true)
        
        //this.setBorder("1px dashed red")

        return this
    }

    didInit () {
        super.didInit()
        //this.applyStyles()
    }

    stackView () {
        const scrollView = this.parentView()
        const navView = scrollView.parentView()
        const stackView = navView.parentView()
        return stackView
    }

    syncOrientation () {
        if (this.isVertical()) {
            this.makeOrientationRight()
        } else {
            this.makeOrientationDown() 
        }
        return this
    }

    makeOrientationRight () {
        //this.setFlexDirection("column")
        this.setMinAndMaxWidth("100%")
        this.setMinHeight("100%")
        //this.setMaxHeight("fit-content")
        //this.setFlexBasis("300px")
        //this.setMinAndMaxWidth("300px")
        //this.setMinAndMaxHeight(null)
    }

    makeOrientationDown () {
        //this.setFlexDirection("row")
        //this.setMinAndMaxWidth("fit-content")
        this.setMinAndMaxWidth("100%")
        this.setMinAndMaxHeight("100%")
        //this.setMinAndMaxWidth(null)
        //this.setMinAndMaxHeight("50px")   
        //this.setFlexBasis("300px")
    }

    syncFromNode () {
        this.syncOrientation()
        super.syncFromNode() 

        /*
        if (this.node().nodeMinRowHeight()) {
            this.setMinAndMaxHeight(this.node().nodeMinRowHeight())
        }
        */

        if (this.selectedRows().length === 0) {
            this.didChangeNavSelection() // TODO: is this right?
        }
        return this
    }

    unselectRowsInNextColumn () {
        const c = this.nextColumn()
        if (c) {
            c.unselectAllRows()
        }
        return this
    }

    subviewProtoForSubnode (aSubnode) {
        let proto = aSubnode.nodeRowViewClass()
		
        if (!proto) {
            proto = BrowserTitledRow
        }
				
        return proto      
        
        //return StackItemView      
    }

    /*
    didSelectItem (itemView) {
        console.log(this.typeId() + " didSelectItem")
        this.subviews().forEach(sv => {
            if (sv === itemView) {
                //sv.select()
            } else {
                sv.unselect()
            }
        })
    
        return false
    }
    */

    // from column


    // -----------------------------------------------------------------------------------------------------------------
    // -----------------------------------------------------------------------------------------------------------------
    // -----------------------------------------------------------------------------------------------------------------


    onFocus () {
        return super.onFocus()
    }

    setRowBackgroundColor (aColor) {
        this.rowStyles().unselected().setBackgroundColor(aColor)
        return this
    }

    setRowSelectionColor (aColor) {
        this.rowStyles().selected().setBackgroundColor(aColor)
        return this
    }

    applyStyles () {
        //this.debugLog(".applyStyles()")
        super.applyStyles()
        return this
    }
    
    title () {
        return this.node() ? this.node().title() : ""
    }

    browser () {
        return this.stackNavView().browser()
    }
    
    columnGroup () {
        return this.parentView().parentView()
    }

    // --- rows ---
    
    rows () {
        return this.subviews()
    }

    addRow (v) {
        return this.addSubview(v)
    }

    removeRow (v) {
        return this.removeSubview(v)
    }

    // selection
	
    didUpdateSlotIsSelected (oldValue, newValue) {
        super.didUpdateSlotIsSelected(oldValue, newValue)

        if (this.isSelected()) {
            const focusedView = WebBrowserWindow.shared().activeDomView()

            // TODO: need a better solution to this problem
            if (!focusedView || (focusedView && !this.hasFocusedDecendantView())) {
                this.focus()    
            }
        } else {
            this.blur()
        }
		
        return this
    }

    /*
    darkenUnselectedRows () {
        const darkenOpacity = 0.5
        this.rows().forEach((row) => {
            if (row.isSelected()) {
                row.setOpacity(1)
            } else {
                row.setOpacity(darkenOpacity)
            }
        })
        return this
    }

    undarkenAllRows () {
        this.rows().forEach((row) => {
            row.setOpacity(1)
        })
    }
    */

    rowsWithNodes (nodeArray) {
        return nodeArray.map(node => this.rowWithNode(node))
    }

    rowWithNode (aNode) {
        return this.rows().detect(row => row.node() === aNode)
    }

    // --- row tapping ---

    didTapItem (anItem) {
        anItem.select()
        if (!anItem.hasFocusedDecendantView()) {
            anItem.focus()
        }
        this.unselectAllRowsExcept(anItem)
        this.unselectRowsInNextColumn()
        this.didChangeNavSelection() // this may already have been sent
    }
    
    didShiftTapItem (anItem) {
        let lastItem = this.lastSelectedRow()

        if (!lastItem) {
            lastItem = this.rows().first()
        }

        if (lastItem) {
            const r1 = this.indexOfRow(anItem)
            const r2 = this.indexOfRow(lastItem)
            assert(r1 !== -1 && r2 !== -1)
            const i1 = Math.min(r1, r2)
            const i2 = Math.max(r1, r2)
            for (let i = i1; i <= i2; i++) {
                const item = this.rowAtIndex(i)
                if (!item.isSelected()) {
                    item.select()
                }
            }
        }

        return this
    }

    didMetaTapItem (anItem) {
        anItem.toggleSelection()
    }

    // ------------------
    
    // --- ---
    
    unselectAllRowsExcept (selectedRow) {
        const rows = this.rows()

        // unselect all other rows
        rows.forEach((row) => {
            if (row !== selectedRow) {
                if (row.unselect) {
                    row.unselect()
                } else {
                    //console.warn("=WARNING= " + this.typeId() + ".unselectAllRowsExcept() row " + row.typeId() + " missing unselect method")
                }
            }
        })
        
        return this
    }

    unselectAllRowsExceptRows (rowsToSelect) {
        const rows = this.rows()

        // unselect all other rows
        rows.forEach((row) => {
            if (rowsToSelect.contains(row)) {
                row.performIfResponding("select") 
            } else {
                row.performIfResponding("unselect") 
            }
        })
        
        return this
    }

    // -----------------------------------------

    indexOfRow (aRow) {
        // we might want this to be based on flex view order instead, 
        // so best to keep it abstract
        return this.indexOfSubview(aRow)
    }

    rowAtIndex (anIndex) {
        return this.subviews().at(anIndex)
    }

    lastSelectedRow () {
        return this.selectedRows().maxItem(row => row.lastSelectionDate().getTime())
    }

    /*
    didSelectRow (aRow) {
        this.didChangeNavSelection()
    }

    didUnselectRow (aRow) {
        this.didChangeNavSelection()

    }
    */

  
    // selection

    hasMultipleSelections () {
        return this.selectedRows().length > 0
    }

    // selected rows

    selectedRows () {
        return this.rows().filter(row => row.isSelected && row.isSelected())
    }

    selectedRow () {
        const sr = this.selectedRows()
        if (sr.length === 1) {
            return sr.first()
        }
        return null
    }

    // selected nodes

    selectedNodes () {
        return this.selectedRows().map(row => row.node())
    }

    selectedNode () {
        const r = this.selectedRow()
        return r ? r.node() : null
    }
    
    selectedRowIndex () { 
        // returns -1 if no rows selected
        return this.rows().indexOf(this.selectedRow())
    }

    // selecting rows
    
    setSelectedRowIndex (index) {
        const oldIndex = this.selectedRowIndex()
        //console.log("this.setSelectedRowIndex(" + index + ") oldIndex=", oldIndex)
        if (index !== oldIndex) {
            const rows = this.rows()
            if (index >= 0 && index < rows.length) {
                const row = rows[index]
                this.didTapItem(row)
            }
        }
        return this
    }
  
    indexOfRowWithNode (aNode) {
        return this.rows().detectIndex(row => row.node() === aNode)
    }

    selectAllRows () {
        this.rows().forEachPerformIfResponds("select")
        return this
    }

    unselectAllRows () {
        this.rows().forEachPerformIfResponds("unselect")
        return this
    }

    rowWithNode (aNode) {
        const row = this.rows().detect(row => row.node().nodeRowLink() === aNode)
        return row
    }
	
    selectRowWithNode (aNode) {
        //console.log(">>> column " + this.node().title() + " select row " + aNode.title())
        const selectedRow = this.rowWithNode(aNode)
		
        if (selectedRow) {
            selectedRow.setIsSelected(true)
			
            this.rows().forEach((aRow) => {
                if (aRow !== selectedRow) {
                    aRow.unselect()
                }
            })
        }

        return selectedRow
    }
    
    selectedRowTitle () {
        const row = this.selectedRow()
        if (row) { 
            return row.title().innerHTML() 
        }
        return null
    }

    // --- sync -----------------------------

    subviewProtoForSubnode (aSubnode) {
        let proto = aSubnode.nodeRowViewClass()
		
        if (!proto) {
            proto = BrowserTitledRow
        }
				
        return proto      
    }

    setNode (aNode) {
        if (this.node() !== aNode) {
            super.setNode(aNode)
            this.unselectAllRows() // move to didChangeNode
            //"shouldFocusSubnode"
        }
        return this
    }

    isInBrowser () {
        return !Type.isNull(this.parentView())
        //return this.browser().columns().contains(this)
    }

    shouldFocusAndExpandSubnode (aNote) { // focus & expand row
        if (!this.isInBrowser()) {
            return this
        }

	    const subnode = aNote.info()
	    let subview = this.subviewForNode(subnode)
	    
        if (!subview) {
            this.syncFromNodeNow()
	        subview = this.subviewForNode(subnode)
        } 

        if (subview) {
            this.selectRowWithNode(subnode)
            subview.scrollIntoView()
            subview.justTap()
            //this.didChangeNavSelection()
		    //subview.dynamicScrollIntoView()
        } else {
            console.warn("BrowserColumn for node " + this.node().typeId() + " has no matching subview for shouldSelectSubnode " + subnode.typeId())
	    }

	    return this 
    }

    shouldFocusSubnode (aNote) { //  focus but don't expand row
	    const subnode = aNote.info()

	    let subview = this.subviewForNode(subnode)
	    
        if (!subview) {
            this.syncFromNodeNow()
	        subview = this.subviewForNode(subnode)
        } 

        if (subview) {
            this.selectRowWithNode(subnode)
            subview.scrollIntoView()

            // just focus the row without expanding it
            /*
            if (this.previousItemSet()) {
                this.previousItemSet().didChangeNavSelection()
            }
            */

            this.didChangeNavSelection()
		    //subview.dynamicScrollIntoView()
        } else {
            console.warn("BrowserColumn for node " + this.node().typeId() + " has no matching subview for shouldFocusSubnode " + subnode.typeId())
            //console.log("row nodes = ", this.rows().map(row => row.node().typeId()) )
	    }

	    return this 
    }

    didChangeNavSelection () {
        if (this.stackView()) {
            this.stackView().didChangeNavSelection()
        }
        return this
    }
	
    scrollToSubnode (aSubnode) {
	    //this.debugLog(".scrollToSubnode")
	    const subview = this.subviewForNode(aSubnode)
	    assert(subview)
	    this.stackNavView().scrollView().setScrollTop(subview.offsetTop())
	    return this 	    
    }
    
    scrollToBottom () {
        const last = this.rows().last()

        if (last) { 
            last.scrollIntoView()
        }

        return this
    }

    didChangeNode () {
        super.didChangeNode()

        if (this.node() && this.node().nodeRowsStartAtBottom()) {
            setTimeout(() => { this.scrollToBottom() }, 0)
            //this.row().last().scrollIntoView()
        }

        return this
    }
    
    /*
    scheduleSyncFromNode () {
        //assert(this.browser().columns().contains(this))

        //console.log(this.type() + " " + this.node().title() + " .scheduleSyncFromNode()")
        if (this.node() === null || !this.isInBrowser()) {
            console.warn("WARNING: skipping BrowserColumn.scheduleSyncFromNode")
            console.warn("  this.isInBrowser() = " , this.isInBrowser())
            console.warn("  this.node() = " , this.node().debugTypeId())
            return this
        }
        
 	    super.scheduleSyncFromNode()
	    return this
    }
    */
	
    // --- keyboard controls, arrow navigation -----------------------------

    canNavigate () {
        return this.allowsCursorNavigation() 
        //return this.allowsCursorNavigation() && this.isActiveElement()
    }
	
    showSelected () {
        /*
        TODO: add check if visible
        if (this.selectedRow()) {
            this.selectedRow().scrollIntoView()
        }
        */
        return this	    
    }


    // --- controls --------------

    onMetaKeyDown (event) {
        console.log("new folder")
        event.stopPropagation()
        event.preventDefault();
    }

    onMeta_m_KeyDown (event) {
        console.log("new folder")
        event.stopPropagation()
        event.preventDefault()
    }

    onMeta_d_KeyDown (event) {
        console.log("duplicate selection down")
        this.duplicateSelectedRows()
        event.stopPropagation()
        event.preventDefault();
    }

    duplicateSelectedRows () {
        const newNodes = []

        this.selectedRows().forEach(row => {
            const i = this.indexOfSubview(row)
            const dupNode = row.node().duplicate()
            newNodes.push(dupNode)
            this.node().addSubnodeAt(dupNode, i+1)
        })
        this.unselectAllRows()
        this.syncFromNodeNow()

        // TODO: unselect current rows at browser level
        newNodes.forEach(newNode => {
            const newRow = this.rowWithNode(newNode)
            if (newRow) {
                newRow.select()
            }
        })

        return this
    }

    onMeta_d_KeyUp (event) {
        console.log("duplicate selection up")
        this.selectedRows().forEach()
        event.stopPropagation()
        event.preventDefault();
    }

    onShiftBackspaceKeyUp (event) {
        this.debugLog(this.type() + " for " + this.node().title() + " onShiftBackspaceKeyUp")
        if (this.selectedRow()) { 
            this.selectedRow().delete()
        }
        event.stopPropagation()
    }

    onShiftPlusKeyUp (event) {
        this.debugLog(this.type() + " for " + this.node().title() + " onShiftPlusKeyUp")
        this.addIfPossible()
        event.stopPropagation()
    }

    addIfPossible () {
        const node = this.node()

        if (node.canSelfAddSubnode()) {
            const newNode = node.add()
            if (newNode) {
                this.syncFromNode()
                const newSubview = this.subviewForNode(newNode)
                newSubview.justTap()
            }
        }
    }

    // duplicate

    onAlternate_d_KeyUp (event) {
        //this.debugLog(" onMetaLeft_d_KeyUp")
        this.duplicateSelectedRow()
        return false // stop propogation
    }

    // select all

    onMeta_a_KeyDown (event) {
        this.selectAllRows()
        event.stopPropagation()
        return false // stop propogation
    }

    // inspecting

    isInspecting () {
        /*
        if (this.isColumnInspecting()) {
            return true
        }
        */
        // see if the row that selected this column is being inspected
        const prev = this.previousItemSet() 
        if (prev) {
            const row = prev.selectedRow()
            if (row) {
                return row.isInspecting()
            }
        }
        return false
    }

    duplicateSelectedRow () {
        const node = this.node()
        const row = this.selectedRow()
        const canAdd = node.canSelfAddSubnode() 
        if (row && canAdd) {
            const canCopy = !Type.isNullOrUndefined(row.node().copy)
            if (canCopy) { 
                //this.debugLog(" duplicate selected row " + this.selectedRow().node().title())
                const subnode = row.node()
                const newSubnode = subnode.copy()
                const index = node.indexOfSubnode(subnode)
                node.addSubnodeAt(newSubnode, index)
                this.scheduleSyncFromNode()
            }
        }
    }

    onControl_c_KeyUp (event) {
        // copy?
    }

    onControl_p_KeyUp (event) {
        // paste?
    }

    // --- arrow keys ---

    onUpArrowKeyUp (event) {
        if (!this.canNavigate()) { 
            return 
        }

        if (this.isVertical()) {
            this.moveDown()
        } else {
            this.moveLeft()
        }
        return false
    }
	
    onDownArrowKeyUp (event) {
        if (!this.canNavigate()) { 
            return 
        }

        if (this.isVertical()) {
            this.moveUp()
        } else {
            this.moveRight()
        }
        return false
    }

	
    onLeftArrowKeyUp (event) {
        if (!this.canNavigate()) { 
            return this
        }	
        if (this.isVertical()) {
            this.moveLeft()
        } else {
            this.moveDown()
        }
    }
	
    onRightArrowKeyUp (event) {
        if (!this.canNavigate()) { 
            return this
        }	

        if (this.isVertical()) {
            this.moveRight()
        } else {
            this.moveUp()
        }
    }

    // --- arrow moves ---

    moveLeft () {
        const pc = this.previousItemSet()	
        if (pc) {
            if (this.selectedRow()) { 
                this.selectedRow().unselect() 
            }
			
            const newSelectedRow = pc.selectedRow()
            newSelectedRow.setShouldShowFlash(true).updateSubviews()
            pc.didTapItem(newSelectedRow)
        	this.selectPreviousColumn()
        }
        return this
    }

    moveRight () {
        this.selectNextColumn()
        return this
    }

    moveUp () {
        this.selectNextRow()
        this.showSelected()
        return this
    }

    moveDown () {
        this.selectPreviousRow()
        this.showSelected()
        return this
    }

    // -----------------------------------------------

    onEscapeKeyDown (event) {
        //this.setIsColumnInspecting(false)

        if (!this.canNavigate()) { 
            return this
        }	

        this.moveLeft()
        //return true
    }
	
    // --- enter key begins row editing ---------------------------
	
    onEnterKeyUp (event) {        
        if (!this.canNavigate()) { 
            return this
        }
	
        const row = this.selectedRow()
        if (row) { 
		    row.onEnterKeyUp(event)
        }

        return false
    }

    // --- keyboard controls, add and delete actions -----------------------------

    /*
    deleteRow (aRow) {
        let sNode = aRow.node()
        if (sNode && sNode.canDelete()) { 
			sNode.performAction("delete") 
		}
        return this
    }

    deleteSelectedRows () {
        this.selectedRows().forEach(r => this.deleteRow(r))

        if (this.rows().length === 0) {
            this.selectPreviousColumn()
        }
    }
    */

    onShiftDeleteKeyUp (event) {
        if (!this.canNavigate()) { 
            return 
        }

        //this.deleteSelectedRows()
        return false
    }
	
    onPlusKeyUp (event) {
        if (!this.canNavigate()) { 
            return 
        }		

        const sNode = this.selectedNode()
        if (sNode && sNode.hasAction("add")) { 
            const newNode = sNode.performAction("add") 
            this.selectNextColumn()
            if (this.nextColumn()) {
                this.nextColumn().selectRowWithNode(newNode)
            }
        }
        return false		
    }
	
    // -----------------------------
    
    /*
    setIsColumnInspecting (aBool) {
        if (this._isColumnInspecting !== aBool) {
            this._isColumnInspecting = aBool
            this.scheduleSyncFromNode()
        }
        return this
    }
    */

    onTapComplete (aGesture) {
        console.log(this.typeId() + ".onTapComplete()")
        if (this.node()) {

            // add a subnode if tapping on empty area
            const p = aGesture.downPosition() // there may not be an up position on windows?
            //this.debugLog(".onTapComplete() ", aGesture.upEvent())
            if (p.event().target === this.element()) {
                const keyModifiers = BMKeyboard.shared().modifierNamesForEvent(aGesture.upEvent());
                const isAltTap = keyModifiers.contains("Alternate");
                if (isAltTap) {
                    // inspect parent node
                    //this.setIsColumnInspecting(true)
                    return this
                } else {
                    this.addIfPossible()
                }
            }
        }
        return this
    }

    // -----------------------------

    columnIndex () {
        return this.parentViewsOfClass(StackView).length
    }

    // nextRow

    selectFirstRow () {
        this.setSelectedRowIndex(0)
        return this
    }

    firstRow () {
        if (this.rows().length > 0) {
            return this.rows()[0]
        }
        return null
    }

    nextRow () {
        const si = this.selectedRowIndex()
        if (si !== -1 && si < this.rows().length) {
            const nextRow = this.rows()[si +1]
            return nextRow
        }
        return null
    }

    selectNextRow () {
        const si = this.selectedRowIndex()
        if (si === -1) {
            this.setSelectedRowIndex(0)
        } else {
            this.setSelectedRowIndex(si + 1)
        }
        return this
    }
    
    selectPreviousRow () {
        const si = this.selectedRowIndex()
        if (si === -1) {
            this.setSelectedRowIndex(0)
        } else {
            this.setSelectedRowIndex(si - 1)
        }
        return this
    }

    // next column
    
    nextColumn () {
        const nsv = this.stackView().nextStackView()
        if (nsv) {
            return nsv.navView().itemSetView()
        }
        return null
        /*
        const i = this.columnIndex()
        const nextColumn = this.browser().columns()[i+1]
        return nextColumn
        */
    }

    focus () {
        super.focus()
		
	    if (this.selectedRowIndex() === -1) {
            const sr = this.rows().first()
            if (sr) {
                sr.setShouldShowFlash(true)
            }
            this.setSelectedRowIndex(0)
        }

        //this.debugLog(" focus")
        return this
    }
    
    selectNextColumn () {
        const nextColumn = this.nextColumn()
        if (nextColumn) {
            this.blur()
            //console.log("nextColumn.focus()")
            /*
            const sr = nextColumn.selectedRow()
            if (sr) {
                sr.setShouldShowFlash(true)
            }
            */
            nextColumn.focus()
        }
        return this
    }
    
    // previous column
	
    previousItemSet () {
        if(this.stackView()) {
            const ps = this.stackView().previousStackView()
            if (ps) {
                return ps.navView().itemSetView()
            }
        }
        return null
    }

    selectPreviousColumn () {
        //this.log("selectPreviousColumn this.columnIndex() = " + this.columnIndex())
        const prevColumn = this.previousItemSet()
        if (prevColumn) {
            this.blur()
            prevColumn.focus()
            //this.browser().selectColumn(prevColumn)
        }
        return this
    }

    // paths
    
    /*
    browserPathArray () {
        let subviews = this.browser().columns().subviewsBefore(this)
        subviews.push(this)
        return subviews
    }
    
    browserPathString () {
        return this.browserPathArray().map(function (column) { 
            return column.title()  // + ":" + column.node().type()
        }).join("/")
    }
    */

    logName () {
        return this.browserPathString()
    }

    maxRowWidth () {
        if (this.rows().length === 0) {
            return 0
        }
        
        const maxWidth = this.rows().maxValue(row => row.desiredWidth())			
        return maxWidth	
    }

    // editing

    onDoubleClick (event) {
        //this.debugLog(".onDoubleClick()")
        return true
    }

    // reordering support

    /*
    absolutePositionRows () {
        const ys = []
        this.rows().forEach((row) => {
            const y = row.relativePos().y()
            ys.append(y)
        })

        let i = 0
        this.rows().forEach((row) => {
            const y = ys[i]
            i ++
            row.unhideDisplay()
            row.setPosition("absolute")
            row.setTopPx(y)
            row.setLeftPx(0)
            row.setRightPx(null)
            row.setBottomPx(null)
            row.setWidthPercentage(100)
            //console.log("i" + i + " : y" + y)
        })
        
        return this
    }
    */


    /*
    orderRows () {
        const orderedRows = this.rows().shallowCopy().sortPerform("topPx")

        this.rows().forEach((row) => {
            row.setPosition("absolute")
            row.unhideDisplay()
        })

        this.removeAllSubviews()
        this.addSubviews(orderedRows)
        return this
    }
    */

    // -- stacking rows ---

    /*
    Row methods:

    makeAbsolutePositionAndSize () {
        const f = this.frameInParentView()
        this.setFrameInParent(f)
        return this 
    }

    makeRelativePositionAndSize () {
        this.setPosition("relative")

        this.setTopPx(null)
        this.setLeftPx(null)
        this.setRightPx(null)
        this.setBottomPx(null)

        this.setMinAndMaxWidth(null)
        this.setMinAndMaxHeight(null)  
        return this 
    }

    flexDirectionLength () {
        const fd = this.parentView().flexDirection() 
        // row is left to right
        if (Type.isNull(fd)) {
            fd = "row"
        }
        assert(fd)
        const wfunc = () => { return this.computedWidth() }
        const hfunc = () => { return this.computedHeight() }
        const d = {
            "row" : () => hfunc,
            "row-reverse" : hfunc,
            "column" : () => wfunc,
            "column-reverse" : wfunc,
        }
        return d[fd]()
    }

    flexDirectionBreadth () {
        const fd = this.parentView().flexDirection()
        if (fd)
        assert(fd)
        const wfunc = () => { return this.computedWidth() }
        const hfunc = () => { return this.computedHeight() }
        const d = {
            "row" : wfunc,
            "row-reverse" : wfunc,
            "column" : () => hfunc,
            "column-reverse" : hfunc,
        }
        return d[fd]()
    }
    flexDirectionStartPosition

    */

    // --------------

    isVertical () {
        return this.stackView().direction() === "right"
    }

    stackRows () {
        if (this.isVertical()) {
            this.stackRowsVertically()
        } else {
            this.stackRowsHorizontally()
        }
        return this
    }

    unstackRows () {
        if (this.isVertical()) {
            this.unstackRowsVertically()
        } else {
            this.unstackRowsHorizontally()
        }
        return this
    }

    // --------------

    stackRowsVertically () {
        // we don't need to order rows for 1st call of stackRows, 
        // but we do when calling stackRows while moving a drop view around,
        // so just always do it as top is null, and rows are already ordered the 1st time

        const orderedRows = this.rows().shallowCopy().sortPerform("topPx") 
        const displayedRows = orderedRows.filter(r => !r.isDisplayHidden())
        let y = 0
        
        displayedRows.forEach((row) => {
            let h = row.computedHeight() 
            if (row.position() !== "absolute") {
                row.makeAbsolutePositionAndSize()
                row.setLeftPx(0)
                row.setOrder(null)
            }
            row.setTopPx(y)
            y += h
        })

        return this
    }

    unstackRowsVertically  () {
        const orderedRows = this.rows().shallowCopy().sortPerform("topPx")
        orderedRows.forEachPerform("makeRelativePositionAndSize")
        this.removeAllSubviews()
        this.addSubviews(orderedRows)
        return this
    }

    // --------------

    stackRowsHorizontally () {
        const orderedRows = this.rows().shallowCopy().sortPerform("leftPx") 
        const displayedRows = orderedRows.filter(r => !r.isDisplayHidden())
        let x = 0

        /*
        let names = []
        this.rows().forEach((row) => { 
            if (row.node) { 
                names.push(row.node().title() + " " + row.leftPx() + "px")
            }
        })
        console.log("horizontal: ", names.join(", "))
        */
        
        displayedRows.forEach((row) => {
            let w = row.computedWidth() 
            if (row.position() !== "absolute") {
                row.makeAbsolutePositionAndSize()
                row.setTopPx(0)
                row.setOrder(null)
            }
            row.setLeftPx(x)
            x += w
        })

        return this
    }

    unstackRowsHorizontally () {
        const orderedRows = this.rows().shallowCopy().sortPerform("leftPx")
        orderedRows.forEachPerform("makeRelativePositionAndSize")
        this.removeAllSubviews()
        this.addSubviews(orderedRows)
        return this
    }

    // --------------

    canReorderRows () {
        return this.node().nodeRowLink().nodeCanReorderSubnodes()
    }

    didReorderRows () { 
        if (!this.node() || !this.isInBrowser()) {
            return this
        }
        // TODO: make a more scaleable API
        const subnodes = this.rows().map(row => row.node())
        this.node().nodeRowLink().nodeReorderSudnodesTo(subnodes)
        //this.node().nodeReorderSudnodesTo(subnodes)
        return this
    }

    // pinch

    rowContainingPoint (aPoint) {
        return this.rows().detect((row) => {
            return row.frameInDocument().containsPoint(aPoint)
        })
    }


    onPinchBegin (aGesture) { // pinch apart to insert a new row
        // TODO: move row specific code to BrowserRow

        //this.debugLog(".onPinchBegin()")

        // - calc insert index
        const p = aGesture.beginCenterPosition()
        const row = this.rowContainingPoint(p)
        if (!row) {
            // don't allow pinch if it's bellow all the rows
            // use a tap gesture to create a row there instead?
            return this
        }

        const insertIndex = this.rows().indexOf(row)

        //console.log("insertIndex: ", insertIndex)

        if (this.node().hasAction("add")) {
            // create new subnode at index
            const newSubnode = this.node().addAt(insertIndex)

            // reference it with _temporaryPinchSubnode so we
            // can delete it if pinch doesn't complete with enough height
            this._temporaryPinchSubnode = newSubnode

            // sync with node to add row view for it
            this.syncFromNodeNow()

            // find new row and prepare it
            const newRow = this.subviewForNode(newSubnode)
            newRow.setMinAndMaxHeight(0)
            newRow.contentView().setMinAndMaxHeight(64)
            newRow.setTransition("all 0.3s")
            newRow.contentView().setTransition("all 0s")
            newRow.setBackgroundColor("black")

            // set new row view height to zero and 
            const minHeight = BrowserRow.defaultHeight()
            const cv = newRow.contentView()
            cv.setBackgroundColor(this.stackNavView().backgroundColor())
            cv.setMinAndMaxHeight(minHeight)
            //newRow.scheduleSyncFromNode()
            //this._temporaryPinchSubnode.didUpdateNode()
        } else {
            //this.debugLog(".onPinchBegin() cancelling due to no add action")

            aGesture.cancel()
        }        
    }
    
    onPinchMove (aGesture) {
        if (this._temporaryPinchSubnode) {
            let s = Math.floor(aGesture.spreadY())
            if (s < 0) {
                s = 0
            }
            //this.debugLog(".onPinchMove() s = ", s)
            const minHeight = BrowserRow.defaultHeight()
            const newRow = this.subviewForNode(this._temporaryPinchSubnode)
            //newRow.setBackgroundColor("black")
            newRow.setMinAndMaxHeight(s)
            const t = Math.floor(s/2 - minHeight/2);
            newRow.contentView().setTopPx(t)

            const h = BrowserRow.defaultHeight()

            if (s < h) {
                const f = s/h;
                const rot = Math.floor((1 - f) * 90);
                newRow.setPerspective(1000)
                newRow.setTransformOrigin(0)
                //newRow.contentView().setTransformOriginPercentage(0)
                newRow.contentView().setTransform("rotateX(" + rot + "deg)")
                const z = -100 * f;
                //newRow.contentView().setTransform("translateZ(" + z + "dg)")
            } else {
                newRow.setPerspective(null)
                newRow.contentView().setTransform(null)                
            }
        } else {
            console.warn(this.typeId() + ".onPinchMove() missing this._temporaryPinchSubnode")
        }
        // do we need to restack views?
    }

    onPinchComplete (aGesture) {
        //this.debugLog(".onPinchCompleted()")
        // if pinch is tall enough, keep new row

        if (this._temporaryPinchSubnode) {
            const newRow = this.subviewForNode(this._temporaryPinchSubnode)
            const minHeight = BrowserRow.defaultHeight()
            if (newRow.clientHeight() < minHeight) {
                this.removeRow(newRow)
            } else {
                //newRow.contentView().setTransition("all 0.15s, height 0s")
                //newRow.setTransition("all 0.3s, height 0s")
                setTimeout(() => { 
                    newRow.contentView().setTopPx(0)
                    newRow.setMinAndMaxHeight(minHeight) 
                }, 0)
            }

            this._temporaryPinchSubnode = null
        }
    }

    onPinchCancelled (aGesture) {
        //this.debugLog(".onPinchCancelled()")
        if (this._temporaryPinchSubnode) {
            this.node().removeSubnode(this._temporaryPinchSubnode)
            this._temporaryPinchSubnode = null
        }
    }

    selectNextKeyView () {
        const nextRow = this.nextRow()
        if (nextRow) {
            this.selectNextRow()
            nextRow.becomeKeyView()
        } else {
            const firstRow = this.firstRow()
            if (firstRow) {
                this.selectFirstRow()
                firstRow.becomeKeyView()
            }
        }
        return this
    }

    // -- messages sent by DragView to the parent/owner of the view it's dragging ---

    onDragSourceBegin (dragView) {
        this.setHasPausedSync(true)
        console.log(this.typeId() + " onDragSourceBegin")
        // ---


        /*
        dragView.items().forEach(sv => {
            sv.hideForDrag()
        })
        */

        // ---
        const subview = dragView.item()
        const index = this.indexOfSubview(subview)
        assert(index !== -1)

        if (dragView.isMoveOp()) {
            dragView.items().forEach(sv => this.removeSubview(sv))
        } else if (dragView.isCopyOp()) {

        }

        this.rows().forEach(row => row.setTransition("all 0.3s"))

        this.newRowPlaceHolder(dragView)

        /*
        if (dragView.isMoveOp()) {
            subview.hideForDrag()
            this.moveSubviewToIndex(this.rowPlaceHolder(), index)
        }
        */

        this.moveSubviewToIndex(this.rowPlaceHolder(), index)

        this.stackView().cache() // only needed for source column, since we might navigate while dragging


        this.stackRows()
        return this
    }

    onDragSourceCancelled (dragView) {
        /*
        dragView.items().forEach(subview => {
            subview.unhideForDrag()
        })
        */
        this.onDragSourceDropped(dragView)
        //this.removeRowPlaceHolder()
    }

    onDragSourceEnter (dragView) {
        this.onDragDestinationHover(dragView)
    }

    onDragSourceHover (dragView) {
        this.onDragDestinationHover(dragView)
        this.indexOfRowPlaceHolder()
    }

    onDragSourceExit (dragView) {
        this.onDragDestinationHover(dragView)
    }

    indexOfRowPlaceHolder () {
        const sortMethod = this.isVertical() ? "topPx" : "leftPx"
        const orderedRows = this.rows().shallowCopy().sortPerform(sortMethod) 
        const insertIndex = orderedRows.indexOf(this.rowPlaceHolder()) 
        
        //this.showRows(orderedRows)
        //console.log("hover insertIndex: ", insertIndex)
        
        return insertIndex
    }

    showRows (rows) {
        console.log("rows: ", rows.map(r => {
            if (r.node) {
                return r.node().title() + (r.display() !== "block" ? ("-" + r.display()) : "")
            }
            return r.type() 
        }).join(", "))
        return this
    }

    showNodes (nodes) {
        console.log("nodes: ", nodes.map(node => {
            return node.title()
        }).join(", "))
        return this
    }

    onDragSourceDropped (dragView) {
        const insertIndex = this.indexOfRowPlaceHolder()

        let movedNodes = dragView.items().map(item => item.node())
        if (dragView.isMoveOp()) {

        } else if (dragView.isCopyOp()) {
             movedNodes = movedNodes.map(aNode => aNode.duplicate())
        } else {
            throw new Error("unhandled drag operation")
        }

        this.unstackRows()
        this.removeRowPlaceHolder()
    
        //console.log("---")
        //this.showNodes(movedNodes)
        //this.showRows(this.subviews())
        const newSubnodesOrder = this.subviews().map(sv => sv.node())
        //this.showNodes(newSubnodesOrder)
        
        this.node().removeSubnodes(movedNodes) // is this needed?
        //assert(!newSubnodesOrder.containsAny(movedNodes))


        newSubnodesOrder.atInsertItems(insertIndex, movedNodes)
        //this.showNodes(newSubnodesOrder)

        this.node().setSubnodes(newSubnodesOrder)

        //console.log("new order: " + this.node().subnodes().map(sn => sn.title()).join("-"))
        this.setHasPausedSync(false)
        this.syncFromNodeNow()
        this.selectAndFocusNodes(movedNodes)
    }

    selectAndFocusNodes (nodes) {
        const selectRows = this.rowsWithNodes(nodes)
        this.unselectAllRowsExceptRows(selectRows)
        if (nodes.length === 1) {
            const focusNode = nodes.first()
            focusNode.parentNode().postShouldFocusAndExpandSubnode(focusNode)
        }
        return this
    }

    onDragDestinationDropped (dragView) {
        const insertIndex = this.indexOfRowPlaceHolder()

        let movedNodes = dragView.items().map(item => item.node())
        if (dragView.isMoveOp()) {
            movedNodes.forEach(aNode => aNode.removeFromParentNode())
        } else if (dragView.isCopyOp()) {
             movedNodes = movedNodes.map(aNode => aNode.duplicate())
        } else {
            throw new Error("unhandled drag operation")
        }

        this.unstackRows()
        this.removeRowPlaceHolder()

        const newSubnodesOrder = this.subviews().map(sv => sv.node())
        assert(!newSubnodesOrder.containsAny(movedNodes))
        newSubnodesOrder.atInsertItems(insertIndex, movedNodes)
        this.node().setSubnodes(newSubnodesOrder)

        this.setHasPausedSync(false)
        this.syncFromNodeNow()
        this.selectAndFocusNodes(movedNodes)
    }

    onDragSourceEnd (dragView) {
        this.stackView().scheduleMethod("uncache")
        this.endDropMode()
    }

    // -- messages sent by DragView to the potential drop view, if not the source ---

    acceptsDropHover (dragView) {
        return true 

        const node = this.node()
        if (node) {
            const dropNode = dragView.item().node()

            if (dropNode === this.node()) {
                return false
            }
            
            const acceptsNode = node.acceptsAddingSubnode(dropNode)
            const canReorder = this.canReorderRows()
            //console.log(node.title() + " acceptsNode " + dropNode.title() + " " + acceptsNode)
            //console.log("parentNode " + node.parentNode().title())
            const result = acceptsNode && canReorder
            return result
        }
        return false
    }

    newRowPlaceHolder (dragView) {
        this.debugLog("newRowPlaceHolder")
        if (!this.rowPlaceHolder()) {
            const ph = DomView.clone().setDivClassName("BrowserRowPlaceHolder")
            ph.setBackgroundColor("black")

            //ph.setTransition("top 0s, left 0.3s, max-height 1s, min-height 1s")
            this.addSubview(ph)
            this.setRowPlaceHolder(ph)
            this.syncRowPlaceHolderSize(dragView)
        }
        return this.rowPlaceHolder()
    }

    syncRowPlaceHolderSize (dragView) {
        const ph = this.rowPlaceHolder()

        if (this.isVertical()) {
            ph.setMinAndMaxWidth(this.computedWidth())
            ph.setMinAndMaxHeight(dragView.minHeight())
            ph.transitions().at("top").updateDuration(0)
            ph.transitions().at("left").updateDuration(0.3)
        } else {
            ph.setMinAndMaxWidth(dragView.minWidth())
            ph.setMinAndMaxHeight(this.computedHeight())
            ph.transitions().at("top").updateDuration(0.3)
            ph.transitions().at("left").updateDuration(0)
        }

        return this
    }

    // --- drag destination ---

    onDragDestinationEnter (dragView) {
        this.setHasPausedSync(true)

        // insert place holder view
        if (!this.rowPlaceHolder()) {
            this.newRowPlaceHolder(dragView)
            this.rowPlaceHolder().setMinAndMaxHeight(dragView.computedHeight())
            this.onDragDestinationHover(dragView)
        }
    }

    onDragDestinationHover (dragView) {
        // move place holder view
        const ph = this.rowPlaceHolder()
        if (ph) {
            this.syncRowPlaceHolderSize(dragView)
            const vp = this.viewPosForWindowPos(dragView.dropPoint())
            if (this.isVertical()) {
                const h = dragView.computedHeight()
                const y = vp.y() - h/2
                ph.setTopPx(y)
            } else {
                const w = dragView.computedWidth()
                const x = vp.x() - w/2
                //console.log("w:" + w + " x:" + vp.x())
                ph.setLeftPx(x)
            }
            //console.log("ph.top() = ", ph.top())
            this.stackRows() // need to use this so we can animate the row movements
        }
    }
    
    onDragDestinationExit (dragView) {
        this.endDropMode()
    }

    onDragDestinationEnd (aDragView) {
        this.endDropMode()
    }

    acceptsDropHoverComplete (aDragView) {
        return this.acceptsDropHover(aDragView);
    }

    dropCompleteDocumentFrame () {
        return this.rowPlaceHolder().frameInDocument()
    }


    removeRowPlaceHolder () {
        this.debugLog("removeRowPlaceHolder")

        const ph = this.rowPlaceHolder()
        if (ph) {
            //console.log("removeRowPlaceHolder")
            this.removeSubview(ph)
            this.setRowPlaceHolder(null)
        }
    }

    animateRemoveRowPlaceHolderAndThen (callback) {
        this.debugLog("animateRemoveRowPlaceHolder")

        const ph = this.rowPlaceHolder()
        if (ph) {
            ph.setMinAndMaxHeight(0)
            setTimeout(() => {
                this.removeRowPlaceHolder()
                if (callback) { callback() }
            }, 1*1000)
        } else {
            if (callback) { callback() }
        }
    }

    endDropMode () {
        this.debugLog("endDropMode")
        //this.unstackRows()
        this.removeRowPlaceHolder()
        this.unstackRows()
        this.setHasPausedSync(false)
        this.didReorderRows()

        /*
        this.animateRemoveRowPlaceHolderAndThen(() => {
         this.debugLog("endDropMode")
            this.unstackRows()
            this.setHasPausedSync(false)
            this.didReorderRows()
        })
        */

        return this
    }

    /*
    rowIndexForViewportPoint (aPoint) {
        if (this.rows().length === 0) {
            return 0
        }

        const row = this.rows().detect((row) => {
            return row.frameInDocument().containsPoint(aPoint)
        })

        if (row) {
            return this.rows().indexOf(row)
        }

        return this.rows().length
    }
    */

    // Browser drop from desktop

    acceptsDrop () {
        return true
    }

    onBrowserDropChunk (dataChunk) {
        const node = this.node()

        if (node && node.onBrowserDropChunk) {
            node.onBrowserDropChunk(dataChunk)
        }
        this.scheduleSyncFromNode()
    }

    nodeDescription () {
        const node = this.node()
        if (node) {
            return node.debugTypeId()
        }
        return null
    }

    debugTypeId () {
       return super.debugTypeId() + this.debugTypeIdSpacer() + this.nodeDescription()
    }
    


    
    
}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "BMBlob.js",
    "BMBlobs.js",
])


"use strict"

/*

    BMBlob

*/

window.BMBlob = class BMBlob extends BMNode {

    initPrototype() {

        {
            const slot = this.newSlot("name", null)
            slot.setSyncsToView(true)
            slot.setShouldStoreSlot(true)
            slot.setDoesHookSetter(true)
        }

        {
            const slot = this.newSlot("valueHash", null)
            slot.setSyncsToView(true)
            slot.setShouldStoreSlot(true)
            slot.setDoesHookSetter(true)
        }

        {
            const slot = this.newSlot("valueSize", null)
            slot.setSyncsToView(true)
            slot.setShouldStoreSlot(true)
            slot.setDoesHookSetter(true)
        }

        {
            const slot = this.newSlot("lastModifiedTime", null)
            slot.setSyncsToView(true)
            slot.setShouldStoreSlot(true)
            slot.setDoesHookSetter(true)
        }

        {
            const slot = this.newSlot("expirationDate", null)
            slot.setSyncsToView(true)
            slot.setShouldStoreSlot(true)
            slot.setDoesHookSetter(true)
        }

        {
            const slot = this.newSlot("value", null)
            slot.setSyncsToView(true)
            slot.setShouldStoreSlot(false)
            slot.setDoesHookSetter(true)
        }
    }

    init() {
        super.init()
        this.setNodeMinWidth(600)
        this.setShouldStore(true)
        this.setShouldStoreSubnodes(false)
        this.setCanDelete(true)
        return this
    }

    age () {
        return new Date().getTime() - this.lastModifiedTime() 
    }

    prepareForFirstAccess() {
        super.prepareForFirstAccess()
        this.setupValueField()
    }

    setupValueField() {
        const field = BMTextAreaField.clone().setKey("value")
        field.setValueMethod("value")
        field.setValueIsEditable(false)
        field.setIsMono(true)
        field.setTarget(this)
        field.getValueFromTarget()
        this.addSubnode(field)

        this.asyncReadValue()
        this.scheduleSyncToView()
    }

    title () {
        return this.name()
    }

    subtitle () {
        const size = this.valueSize()
        if (size) {
            return size.byteSizeDescription() 
        }
        return null
    }

    // key

    hash() {
        return this.name() // for subnode lookup
    }

    didUpdateSlotValue (oldValue, newValue) {
        if (newValue) {
            this.setValueSize(newValue.length)
            this.setLastModifiedTime(new Date().getTime())
            this.asyncWriteValue()
        }
        return this
    }

    store () {
        return this.parentNode().store()
    }

    async asyncWriteValue () {
        const v = this.value()
        const digest = await v.asyncSha256Digest()
        const h = digest.base64Encoded()
        this.setValueHash(h)

        assert(this.isValid())

        const success = () => {
            //console.log("did write hash/value pair: " + this.description())
        }

        this.store().asyncAtPut(h, v, success, null)
    }

    asyncReadValue (resolve, reject) {
        if (this.value()) {
            resolve()
        }

        assert(this.isValid())

        this.store().asyncAt(this.valueHash(), (value) => {
            this._value = value
            this.didUpdateNode()
            if (resolve) {
                resolve()    
            }     
        }, reject)
    }

    isValid () {
        if (Type.isNull(this.name())) {
            return false
        }

        if (Type.isNull(this.valueHash())) {
            return false
        }

        if (Type.isNull(this.valueSize())) {
            return false
        }

        if (Type.isNull(this.lastModifiedTime()) || this.lastModifiedTime() === 0) {
            return false
        }

        return true
    }

    description () {
        const slotNames = ["name", "valueHash", "valueSize", "lastModifiedTime"]
        const parts = [this.typeId()]
        slotNames.forEach(slotName => {
            parts.push(slotName + ":" + this[slotName]())
        })
        return parts.join(", ")
    }

    /*
    recordForStore (aStore) {
        const r = super.recordForStore(aStore)
        console.log(this.typeId() + " recordForStore : ", JSON.stringify(r, null, 2))
        return r
    }

    loadFromRecord (aRecord, aStore) {
        const result = super.loadFromRecord(aRecord, aStore)
        console.log("after loadFromRecord:" + JSON.stringify(aRecord, null, 2))
        return result
    }

    addMutationObserver (anObserver) {
        //console.log(this.typeId() + ".addMutationObserver(" + anObserver.typeId() + ")")
        return super.addMutationObserver(anObserver)
    }

    didMutate () {
        //console.log("didMutate:" + this.description())
        return super.didMutate()
    }
    */

}.initThisClass()



"use strict"

/*

    BMBlobs

    blobs -> blob (name, valueHash) -> CamStore -> CamRecord (valueHash, valueData)

    A container for existing blobs. 
    A blob is a name to data hash entry.
    The data hash is used as a pointer to a CamRecord

    store a blob:

    const blob = blobs.blobForKey(k)
    // returns existing blob if there's a match
    //

*/

window.BMBlobs = class BMBlobs extends BMStorableNode {
    
    static initThisClass () {
        super.initThisClass()
        this.setIsSingleton(true)
		return this
    }
    
    initPrototype () {
        this.newSlot("store", null)
    }

    init () {
        super.init()
        this.setTitle("Blobs")
        this.setNodeMinWidth(400)
        this.setNoteIsSubnodeCount(true)
        this.setShouldStore(true)
        this.setShouldStoreSubnodes(true)
        this.setNodeCanReorderSubnodes(true)

        this.setStore(PersistentAsyncDictionary.clone().setName("BlobHashStore"))
        this.store().asyncOpen(() => {
            //this.removeAllSubnodes()
            //this.camForValue("hello world") 
            this.collectGarbage()
        })

        return this
    }

    blobWithName (aName) {
        return this.subnodeWithHash(aName)
    }

    hasBlobWithName (aName) {
        return !Type.isNullOrUndefined(this.blobWithName(aName))
    }

    createBlobWithNameAndValue (aName, aValue) {
        const oldBlob = this.blobWithName(aName)
        if (oldBlob) {
            oldBlob.setValue(aValue)
            return oldBlob
        }

        assert(!this.hasBlobWithName(aName))
        const blob = BMBlob.clone()
        blob.setName(aName)
        blob.setValue(aValue) // this will trigger an async compute of valueHash and store of value
        this.addSubnode(blob)
        return blob
    }

    collectGarbage () {
        this.subnodes().shallowCopy().forEach((blob) => {
            if (!blob.isValid()) {
                this.debugLog(" collecting inValid blob:", blob.description())
                blob.delete()
            }
        })

        const subnodeHashes = this.subnodes().map(sn => sn.valueHash()).asSet()
        const store = this.store()
        store.asyncAllKeys((storedHashes) => {
            storedHashes.forEach((h) => {
                if (!subnodeHashes.has(h)) {
                    this.debugLog("collecting unreferenced blob hash:", h)
                    store.asyncRemoveKey(h)
                }
            })
        })
    }

}.initThisClass()

/*
setTimeout(() => {
    const blob = BMBlobs.shared().blobForKey("http://test.com/")
    blob.setValue("test content")
    blob.asyncWrite()
})
*/

"use strict"

ResourceLoader.pushRelativePaths([
    "BMUrlResource.js",
])


"use strict"

/*

    BMUrlResource

*/

window.BMUrlResource = class BMUrlResource extends BMStorableNode {
    
    initPrototype () {
        this.newSlot("path", "")
        this.newSlot("error", null).setSyncsToView(true)
        this.newSlot("status", null).setSyncsToView(true)
        this.newSlot("dataUrl", null)
        //this.newSlot("rawData", null).setSyncsToView(true)
        this.newSlot("decodedData", null).setSyncsToView(true)
        this.newSlot("timeoutInterval", 24*60*60*1000).setSyncsToView(true)
        //this.newSlot("decodedJson", null).setSyncsToView(true)
        //this.newSlot("completeNote", null).setSyncsToView(true)
        this.newSlot("urlDelegate", null)
    }

    init () {
        super.init()
        this.setNodeMinWidth(600)
        this.setDataUrl(BMDataUrl.clone())
        //this.setCompleteNote(BMNotificationCenter.shared().newNote().setSender(this).setName("onUrlResourceComplete"))
        return this
    }

    postComplete() {
        //this.completeNote().post()
        this.urlDelegate().performIfResponding("onUrlResourceComplete", this)
        return this
    }

    title () {
        const s = super.title()
        if (s === null) {
            return this.path().fileName()
        }
        return s
    }

    subtitle () {
        if (this.error()) {
            return this.error()
        }

        if (this.status()) {
            return this.status()
        }

        const dataType = this.path().pathExtension()
        if (this.decodedData()) {
            return this.dataUrl().decodedData().byteSizeDescription() + " " + this.dataUrl().mimeTypeDescription()
        }
        return ""
    }

    didUpdateSlotPath () {
    }

    isLoaded () {
        return this.hasData() || this.isCached()
    }

    hasData () {
        return !Type.isNull(this.data())
    }

    // --- setup ---

    prepareForFirstAccess () {
        super.prepareForFirstAccess()
        this.setupDataField()
        this.load()
    }

    setupDataField () {
        const field = BMTextAreaField.clone().setKey("dataString")
        field.setValueMethod("dataString").setValueIsEditable(false).setIsMono(true)
        field.setTarget(this) 
        field.getValueFromTarget()
        this.addSubnode(field)
        return this
    }

    // --- actions ---

    refresh () {
        this.clear()
        this.load()
        return this
    }

    clear () {
        this.setData(null)
        return this
    }

    // --- loading ---

    blobName () {
        return "URL:encoded:" + this.path()
    }

    load () {
        if (this.loadIfCached()) {
            return this
        }
        this.justLoad()
        return this
    }

    loadIfCached () {        
        const blobs = BMBlobs.shared()
        const isCached = blobs.hasBlobWithName(this.path())
        if (isCached) {
            const blob = blobs.blobWithName(this.path())
            if (blob.age() < this.timeoutInterval()) {
                this.setStatus("reading from cache...")

                const resolve = () => { 
                    this.justSetDataUrlString(blob.value()) 
                    this.postComplete()
                }

                const reject = () => { 
                    this.justLoad() 
                }
                
                blob.asyncReadValue(resolve, reject)
                return this
            }
            return true
        }
        return false
    }

    justLoad () {
        this.setStatus("sending request...")
        const rq = new XMLHttpRequest();
        rq.open("get", this.path());
        rq.responseType = "blob";
        rq.onabort     = (event) => { this.onRequestAbort(event) }
        rq.onerror     = (event) => { this.onRequestError(event) }
        rq.onload      = (event) => { this.onRequestLoad(event) }
        rq.onloadend   = (event) => { this.onRequestLoadEnd(event) }
        rq.onloadstart = (event) => { this.onRequestLoadStart(event) }
        rq.onprogress  = (event) => { this.onRequestProgress(event) }
        rq.ontimeout   = (event) => { this.onRequestTimeout(event) }
        rq.send()
        return this
    }

    // --- http request events ---

    onRequestAbort (event) {
        this.setError("request aborted") 
    }

    onRequestError (event) {
        this.setError("request error") 
    }

    onRequestLoadEnd (event) {
    }

    onRequestProgress (event) {
        if (event.total) {
            const percentage = Math.round( (event.loaded / event.total) * 100 )
            this.setStatus("requesting: " + percentage + "%")
        } else {
            this.setStatus("receiving header")
        }
    }

    onRequestLoadStart (event) {
        this.setStatus("sending request")
    }

    onRequestTimeout (event) {
        this.setError("request timeout") 
    }

    onRequestLoad (event) {
        const request = event.currentTarget
        const fr = new FileReader();
        fr.onload     = (event) => { this.onReaderLoad(event) }
        fr.onprogress = (event) => { this.onReaderProgress(event) }
        fr.onabort    = (event) => { this.onReaderAbort(event) }
        fr.onerror    = (event) => { this.onReaderError(event) }
        fr.onloadend  = (event) => { this.onReaderLoadEnd() }
        fr.readAsDataURL(request.response)
        return this
    }

    // --- file reader events ---

    onReaderAbort (event) {
        this.setError("aborted")
    }

    onReaderError (event) {
        this.setError("load error")
    }

    onReaderProgress (event) {
        const percentage = (event.loaded / event.total) * 100 
        this.setStatus("loading: " + percentage + "%")
    }

    onReaderLoad (event) {
        const fileReader = event.currentTarget
        const result = fileReader.result
        this.justSetDataUrlString(result)
    }

    onReaderLoadEnd () {
        this.setStatus(null)
    }

    justSetDataUrlString (aString) {
        this.dataUrl().setDataUrlString(aString)
        BMBlobs.shared().createBlobWithNameAndValue(this.path(), aString)
        this.setStatus(null)
        this.setError(null)
        this.scheduleSyncToView()
        this.postComplete()
    }

    // --- decoding ---

    decodedData () {
        return this.dataUrl().decodedData()
    }

    asJson () {
        if(this.dataUrl().isJson() ) {
            return JSON.parse(this.decodedData())
        }
        return undefined
    }

    dataString () {
        const du = this.dataUrl()
        if (du.isXml() ) { 
            return this.escapeHtml(this.decodedData())
        } else if (du.isJson()) {
            //const json = JSON.parse(this.decodedData())
            //return JSON.stringify(json, null, 2)
        }
        return this.decodedData() 
    }

    escapeHtml (unsafe) {
        return unsafe
             .replace(/&/g, "&amp;")
             .replace(/</g, "&lt;")
             .replace(/>/g, "&gt;")
             .replace(/"/g, "&quot;")
             .replace(/'/g, "&#039;");
    }

}.initThisClass()

"use strict"

/*
    App 
    
    A shared instance that represents the application. For your application, 
    create a subclass called App and implement a custom setup method.

    Handles starting up persistence system.

*/

window.App = class App extends BMStorableNode {
    
    static loadAndRunShared () {
        const name = this.name
        this.defaultStore().setName(name)

        /*
        const successCallback = () => {
            this.defaultStore().rootOrIfAbsentFromClosure(() => BMStorableNode.clone())
            const app = this.defaultStore().rootObject().subnodeWithTitleIfAbsentInsertProto(name, this)
            this.setShared(app)
            app.run()
        }

        const errorCallback = (errorMessage) => {
            window.ResourceLoaderPanel.shared().setError(errorMessage)
            return this
        }

        this.defaultStore().asyncOpen(successCallback, errorCallback) 
        */

        this.defaultStore().asyncOpen(() => { this.onLoadSuccess() }, (e) => { this.onLoadError(e) }) 
    }

    static onLoadSuccess () {
        const name = this.name
        this.defaultStore().rootOrIfAbsentFromClosure(() => BMStorableNode.clone())
        const app = this.defaultStore().rootObject().subnodeWithTitleIfAbsentInsertProto(name, this)
        this.setShared(app)
        app.run()
    }

    static onLoadError (errorMessage) {
        window.ResourceLoaderPanel.shared().setError(errorMessage)
    }

    initPrototype () {
        this.newSlot("name", "App")
        this.newSlot("version", [0, 0])
        //this.newSlot("nodeStoreDidOpenObs", null)
    }

    init () {
        super.init()

        //Documentation.shared().show()
        //console.log(ProtoClass.subclassesDescription())

        //this.setNodeStoreDidOpenObs(window.BMNotificationCenter.shared().newObservation())
        //this.nodeStoreDidOpenObs().setName("nodeStoreDidOpen").setObserver(this).setTarget(this.defaultStore())
        this.setIsDebugging(true)
    }

    title () {
        return this.name()
    }
    
    // run and setup sequence in order of which methods are called
    // 1. setup NodeStore

    isBrowserCompatible () {
        // subclasses can override to do their own checks
        return true
    }

    run () {
        if (!this.isBrowserCompatible()) {
            window.ResourceLoaderPanel.shared().setError("Sorry, this app only works on<br>Chrome, FireFox, and Brave browsers.")
            return this
        }

        /*
        this.nodeStoreDidOpenObs().watch()
        this.defaultStore().setName(this.name())

        const errorCallback = (errorMessage) => {
            window.ResourceLoaderPanel.shared().setError(errorMessage)
            return this
        }
        this.defaultStore().asyncOpen(null, errorCallback) 
       this.nodeStoreDidOpen()
        */

       this.setup()

    }

    /*
    showBrowserCompatibilityPanel () {
        console.log("showing panel")
        const panel = window.PanelView.clone()
        this.documentBodyView().addSubview(panel)
        panel.setTitle("Sorry, this app only works on<br>Chrome, FireFox, and Brave browsers.")
        panel.orderFront()
        panel.setZIndex(100)
        console.log("showed panel")
    }
    */

    // 2. setup 

    /*
    nodeStoreDidOpen (aNote) {
        console.log("App nodeStoreDidOpen <<<<<<<<<<<<<<<<<<")
        this.nodeStoreDidOpenObs().stopWatching()
        this.defaultStore().rootOrIfAbsentFromClosure(() => BMStorableNode.clone())
        this.setup()
    }
    */

    setup () {
        return this        
    }

    appDidInit () {
        this.showVersion()

        this.postNoteNamed("appDidInit")

        if (this.runTests) {
		    this.runTests()
        }

        //Documentation.shared().show()
        this.registerServiceWorker() // not working yet
        window.ResourceLoaderPanel.shared().stop() 
    }
	
    documentBodyView () {
        //return DomView.documentBodyView()
        return WebBrowserWindow.shared().documentBody()
    }

    mainWindow () {
        return Window
    }

    setName (aString) {
        this._name = aString
        this.setTitle(aString)
        WebBrowserWindow.shared().setTitle(aString)
        return this
    }
    
    // --- version ---

    versionsString () {
        return this.version().join(".")
    }

    showVersion () {
        console.log("Application '" + this.name() + "' version " + this.versionsString())
    }

    // --- server worker ---

    registerServiceWorker () {
        // doesn't work
        // "srsourcec/ServiceWorker.js"
        // "/source/ServiceWorker.js"
        // "../ServiceWorker.js"
        const path = "ServiceWorker.js"
        console.log("registering service worker '" + path + "'")
        const promise = navigator.serviceWorker.register(path); //{ scope: ""../"}

        promise.then(function (registration) {
            console.log("Service worker successfully registered on scope", registration.scope);
        }).catch(function (error) {
            console.log("Service worker failed to register:\n",
                "  typeof(error): ", typeof(error), "\n", 
                "  message:", error.message, "\n",
                "  fileName:", error.fileName, "\n",
                "  lineNumber:", error.lineNumber,  "\n",
                "  stack:", error.stack,  "\n"
                //"  JSON.stringify(error):", JSON.stringify(error),  "\n",
                //"  toString:", error.toString()
            );
        });
    }

    setupTheme () {
        const doc = DocumentBody.shared()
        doc.setColor("#f4f4ec")
        doc.setBackgroundColor("rgb(25, 25, 25)")

        this.setupNormalTheme()
        //this.setupVectorTheme()
    }

    setupNormalTheme () {
        const doc = DocumentBody.shared()
        doc.setBackgroundColor("#191919")
        //doc.setFontFamily("Sans-Serif")
        //doc.setFontFamily("Electrolize-Regular")
        doc.setFontFamily("Helvetica")
        //doc.setFontWeight("bold")
        //doc.setFontFamily("Helvetica Neue")
        //doc.setFontFamily("San Francisco Display")
        //doc.setFontFamily("PublicSans Light")
        //doc.setFontFamily("OpenSans Regular")
        doc.setFontSizeAndLineHeight("15px")
        doc.setLetterSpacing("0.05em")
        //doc.setTextTransform("uppercase")
   }

}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "files/_imports.js",
    "fonts/_imports.js",
    "sounds/_imports.js",
    "images/_imports.js",
    "themes/_imports.js",
    "icons/_imports.js",
    "json/_imports.js",
    "BMResources.js",
])

"use strict"

ResourceLoader.pushRelativePaths([
    "BMFileResources.js",
    "BMFileSystemFolder.js",
    "BMFileSystemFile.js",
])

"use strict"

/*

    BMFileResources

*/

window.BMFileResources = class BMFileResources extends BMNode {
    
    static initThisClass () {
        super.initThisClass()
        this.setIsSingleton(true)
		return this
    }
    
    initPrototype () {
        this.newSlot("rootPath", ".")
    }

    init () {
        super.init()

        this.setTitle("FileSystem")
        this.setNodeMinWidth(270)
        this.setNoteIsSubnodeCount(true)
        this.watchOnceForNote("appDidInit")
        return this
    }

    appDidInit () {
        //this.debugLog(".appDidInit()")
        //this.setupSubnodes()
        this.setup()
        return this
    }
    
    setupSubnodes () {
        this.addSubnode(BMFileSystemFolder.clone())
        return this
    }

    setup () {
        window.requestFileSystem  = window.requestFileSystem || window.webkitRequestFileSystem;

        window.requestFileSystem(
            window.PERSISTENT, 
            1*1000*1000, 
            (fileSystem) => this.onOpen(fileSystem), 
            (error) => this.onOpenError(error)
        )

        return this
    }

    onOpen (fileSystem) {
        console.log("opened filesystem")

    }

    onOpenError (error) {
        console.log(error)
    }


}.initThisClass()

"use strict"

/*

    BMFileSystemFolder

*/

window.BMFileSystemFolder = class BMFileSystemFolder extends BMNode {
    
    static initThisClass () {
        super.initThisClass()
        this.setIsSingleton(true)
		return this
    }
    
    initPrototype () {
        this.newSlot("path", ".")
    }

    init () {
        super.init()

        this.setTitle("BMFileSystemFolder")
        this.setNodeMinWidth(270)
        this.setNoteIsSubnodeCount(true)
        //this.watchOnceForNote("appDidInit")
        return this
    }


    
    setupSubnodes () {
        //this.resourcePaths().forEach(path => this.addFontWithPath(path))
        return this
    }


}.initThisClass()

"use strict"

/*

    BMFileResources

*/

window.BMFile = class BMFile extends BMNode {
    
    static initThisClass () {
        super.initThisClass()
        this.setIsSingleton(true)
		return this
    }
    
    initPrototype () {
        this.newSlot("path", ".")
    }

    init () {
        super.init()

        this.setTitle("File")
        this.setNodeMinWidth(270)
        this.setNoteIsSubnodeCount(true)
        return this
    }

    appDidInit () {
        //this.debugLog(".appDidInit()")
        //this.setupSubnodes()
        return this
    }
    
    setupSubnodes () {
        //this.resourcePaths().forEach(path => this.addFontWithPath(path))
        return this
    }


}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "BMFontResources.js",
    "BMFontFamily.js",
    "BMFont.js",
    "BMFontRowView.js",
])

"use strict"

/*

    BMFontResources

*/

window.BMFontResources = class BMFontResources extends BMNode {
    
    static initThisClass () {
        super.initThisClass()
        this.setIsSingleton(true)
		return this
    }
    
    initPrototype () {
        this.newSlot("extensions", ["ttf", "woff", "woff2"])
    }

    init () {
        super.init()

        this.setTitle("Fonts")
        this.setNodeMinWidth(270)
        this.setNoteIsSubnodeCount(true)
        this.watchOnceForNote("appDidInit")
        return this
    }

    appDidInit () {
        //this.debugLog(".appDidInit()")
        this.setupSubnodes()
        return this
    }
    
    addFamily (aFontFamily) {
        this.addSubnode(aFontFamily)
        return this
    }

    families () {
        return this.subnodes()
    }

    resourcePaths () {
        return ResourceLoader.resourceFilePathsWithExtensions(this.extensions())
    }

    setupSubnodes () {
        this.resourcePaths().forEach(path => this.addFontWithPath(path))
        return this
    }

    fontFamilyNamed (aName) {
        let family = this.families().detect(family => family.name() === aName);

        if (!family) {
            family = BMFontFamily.clone().setName(aName)
            this.addFamily(family)
        }

        return family
    }

    addFontWithPath (aPath) {
        const components = aPath.split("/")

        // verify path is in expected format 
        const dot = components.removeFirst()
        assert(dot === ".")

        const resources = components.removeFirst()
        assert(resources === "resources")

        const fonts = components.removeFirst()
        assert(fonts === "fonts")

        const familyName = components.removeFirst()
        const family = this.fontFamilyNamed(familyName) 
        family.addFontWithPath(aPath)

        return this
    }

}.initThisClass()

"use strict"

/*

    BMFontFamily


*/

window.BMFontFamily = class BMFontFamily extends BMNode {
    
    initPrototype () {
        this.newSlot("name", null)
        this.newSlot("fonts", null)
    }

    init () {
        super.init()
        this.setNodeMinWidth(270)
    }

    title () {
        return this.name()
    }

    /*
    subtitle () {
        return "font family"
    }
    */

    addFontWithPath (aPath) {
        const font = BMFont.clone().setPath(aPath)
        font.load()
        this.addSubnode(font)
        return this
    }

}.initThisClass()

"use strict"

/*

    BMFont

    Managed by BMFontResources.

*/

window.BMFont = class BMFont extends BMNode {
    
    initPrototype () {
        this.newSlot("path", null)
        this.newSlot("name", null)
        this.newSlot("options", null)
    }

    init () {
        super.init()
        this.setNodeMinWidth(270)
        this.setOptions({})  // example options { style: 'normal', weight: 700 }  
        //this.setIsDebugging(true)
    }

    title () {
        return this.name()
    }

    name () {
        if (this._name) {
            return this._name
        }

        return this.path().fileName()
    }

    // loading 

    load () {
        if (!window["FontFace"]) {
            console.warn("this browser is missing FontFace class")
            return this
        }

        const urlString = "url('" + this.path() + "')"
        const aFontFace = new FontFace(this.name(), urlString, this.options()); 
        
        aFontFace.load().then((loadedFace) => {
            this.didLoad()
            assert(loadedFace === aFontFace)
            document.fonts.add(loadedFace)
        }).catch((error) => {
            this.onLoadError(error)
        });

        return this
    }

    didLoad () {
        if (this.isDebugging()) {
            this.debugLog(".didLoad(" + this.name() + ") " + this.path())
            //this.debugLog(".didLoad('" + this.name() + "')")
        }
        return this
    }

    onLoadError (error) {
        if (this.isDebugging()) {
            this.debugLog(".onLoadError() ", error)
        }
        return this
    }

}.initThisClass()

"use strict"

/*
    
    BMFontRowView
    
*/

window.BMFontRowView = class BMFontRowView extends BrowserTitledRow {
    
    initPrototype () {

    }

    init () {
        super.init()
        return this
    }
    
    updateSubviews () {
        super.updateSubviews()
	
        const node = this.node()

        if (node) {
            const name = node.name()
            this.titleView().setFontFamily(name)
        }

        return this
    }

    
}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "BMSoundResurces.js",
    "BMSound.js",
    "BMAudioPlayer.js",
])

"use strict"

/*

    BMSoundResurces

*/

window.BMSoundResurces = class BMSoundResurces extends BMNode {
    
    static initThisClass () {
        super.initThisClass()
        this.setIsSingleton(true)
		return this
    }

    initPrototype () {
        this.newSlot("extensions", ["wav", "mp3", "m4a", "mp4", "oga", "ogg"])
    }

    init () {
        super.init()

        this.setTitle("Sounds")
        this.setNodeMinWidth(270)
        this.setNoteIsSubnodeCount(true)

        this.watchOnceForNote("appDidInit")
    }

    appDidInit () {
        this.setupSubnodes()
        return this
    }

    resourcePaths () {
        return ResourceLoader.resourceFilePathsWithExtensions(this.extensions())
    }

    setupSubnodes () {
        this.resourcePaths().forEach(path => this.addSoundWithPath(path))
        return this
    }

    addSoundWithPath (aPath) {
        const sound = BMSound.clone().setPath(aPath)
        this.addSound(sound)
        return this
    }

    addSound (aSound) {
        this.addSubnode(aSound)
        return this
    }

    sounds () {
        return this.subnodes()
    }

}.initThisClass()

"use strict"

/*

    BMSound

    Managed by BMSoundResurces.

*/

window.BMSound = class BMSound extends BMNode {
    
    // --- mime types ---

    static supportedMimeTypes() {
        return new Set(["audio/ogg", "audio/wave", "audio/mp3"])
    }

    static canOpenMimeType (mimeType) {
        return this.supportedMimeTypes().has(mimeType)
    }

    static openMimeChunk (dataChunk) {
        const aNode = this.clone()
        //setValue(dataChunk)
        console.log(dataChunk.mimeType() + " data.length: " + dataChunk.decodedData().length)
        return aNode
    }

    // ---

    initPrototype () {
        this.newSlot("path", null)
    }

    init () {
        super.init()
        this.setNodeMinWidth(270)
    }

    title () {
        return this.name()
    }

    subtitle () {
        return this.path().pathExtension()
    }

    name () {
        return this.path().lastPathComponent().sansExtension()
    }

    play () {
        const audioPlayer = BMAudioPlayer.shared()
        audioPlayer.setPath(this.path())
        audioPlayer.play()
        return this
    }

    prepareToAccess () {
        super.prepareToAccess()
        this.play() // not a good way to do this
        //audio.src = 'data:audio/wav;base64,UklGR...;
    }

}.initThisClass()

"use strict"


/*

    BMAudioPlayer

    Adds a body element like this:

        <audio id="audio" autoplay>
            <source id="audioSource" src="sounds/test.mp3" type="audio/mpeg"/ >
        </audio>

    Example use:

        const audioPlayer = BMAudioPlayer.shared().setPath(urlToAudioFile)
        audioPlayer.play()
        ...
        audioPlayer.stop()

*/

window.BMAudioPlayer = class BMAudioPlayer extends DomView {
    
    initPrototype () {
        this.newSlot("path", "")
        this.newSlot("sourceElement", null)
    }

    init () {
        this.setElementType("audio") // TODO: use a method override instead?
        super.init()
        this.open()
        return this
    }

    // open / close

    open () {
        this.setVisibility("hidden");
        DocumentBody.shared().addSubviewIfAbsent(this)
        return this
    }

    close () {
        DocumentBody.shared().removeSubviewIfPresent(this)
        return this
    }

    // element

    createElement () {
        const audio = document.createElement("audio")
        audio.setAttribute("autoplay", "");

        const source = document.createElement("source")
        this.setSourceElement(source)

        audio.appendChild(source)
        audio.addEventListener("playing", event => this.onPlaying(event), false); 
        return audio
    }

    onPlaying () {
        if (this.isDebugging()) {
            this.debugLog(".onPlaying() ")
        }
        return this
    }

    // path

    audioTypeForExtension (extString) {
        const fileExtensionToType = {
            "mp3": "mpeg",
            "wav": "wav",
            "mp4": "mp4",
            "mpa": "mp4",
            "ogg": "ogg",
            "oga": "ogg",
        }
        const type =  "audio/" + fileExtensionToType[extString.toLowerCase()]
        assert(type)
        return type
    }

    setPath (aPath) {
        if (this._path != aPath) {
            this._path = aPath
        
            this.stop()

            if (this.isDebugging()) {
                this.debugLog( ".setPath:'" + aPath + "'")
            }

            const source = this.sourceElement()
            source.src = aPath;

            const type = this.audioTypeForExtension(aPath.pathExtension());
            source.setAttribute("type", type);
            this.load() 
        }
        return this
    }

    path () {
        return this.sourceElement().getAttribute("src");
    }

    name () {
        if (!this.path()) {
            return ""
        }
        return this.path().fileName()
    }

    // loading

    load () {
        if (this.isDebugging()) {
            this.debugLog( ".load() '" + this.path() + "'")
        }
        this.element().load()
        return this
    }

    // playing / pausing / stopping

    play () {
        if (this.isPlaying()) {
            return this
        }

        if (this.isDebugging()) {
            this.debugLog( ".play() '" + this.path() + "'")
        }

        const promise = this.element().play()
        promise.catch((e) => {
            console.log("audio play exception: ", e.message)
        })
        return this

    }

    isPlaying () {
        const e = this.element()
        return e.duration > 0 && !e.paused
    }

    // pausing

    pause () {
        this.element().pause()
        return this
    }

    isPaused () {
        const e = this.element()
        return e.paused
    }

    // stopping

    stop () {
        if (this.isDebugging()) {
            this.debugLog( ".stop() '" + this.path() + "'")
        }

        this.pause();
        this.setCurrentTime(0);
        return this
    }

    // current time

    setCurrentTime (t) {
        this.element().currentTime = t;
        return this;
    }

    currentTime () {
        return this.element().currentTime;
    }

    // playback rate

    playbackRate () {
        return this.element().playbackRate;
    }

    setPlaybackRate (r) {
        this.element().playbackRate = r;
        return this;
    }

}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "BMImageResources.js",
    "BMURLImage.js",
])

"use strict"

/*

    BMImageResources

*/

window.BMImageResources = class BMImageResources extends BMNode {
    
    static initThisClass () {
        super.initThisClass()
        this.setIsSingleton(true)
		return this
    }
    
    initPrototype () {
        this.newSlot("extensions", ["png", "jpg", "jpeg", "gif", "tiff", "bmp"])
    }

    init () {
        super.init()
        this.setTitle("Images")
        this.setNodeMinWidth(270)
        this.setNoteIsSubnodeCount(true)
        //this.setSubnodeClasses([BMURLImage])
        return this
    }

    resourcePaths () {
        return ResourceLoader.resourceFilePathsWithExtensions(this.extensions())
    }
    
    appDidInit () {
        this.setupSubnodes()
        return this
    }

    setupSubnodes () {
        this.resourcePaths().forEach(path => this.addImageWithPath(path))
        return this
    }

    addImageWithPath (aPath) {
        const image = this.justAdd()
        image.setPath(aPath)
        return this
    }

}.initThisClass()

"use strict"

/*

    BMURLImage

*/

window.BMURLImage = class BMURLImage extends BMNode {
    
    initPrototype () {
        this.newSlot("path", "")
        this.newSlot("dataURL", "")
    }

    init () {
        super.init()
        this.setNodeMinWidth(270)
        return this
    }

    title () {
        return this.path().fileName()
    }

    subtitle () {
        return this.path().pathExtension()
    }

    setPath (aPath) {
        if (this._path !== aPath) {
            this._path = aPath
            this.loadDataURL()
        }
        return this
    }

    loadDataURL () {
        if (this.isDebugging()) {
            this.debugLog(".loadDataURL() " + this.path())
        }

        const request = new XMLHttpRequest();
        request.open("get", this.path());
        request.responseType = "blob";
        request.onload = () => { this.loadedRequest(request) };
        request.send();
        return this
    }

    loadedRequest (request) {

        if (this.isDebugging()) {
            this.debugLog(".loadedRequest() ", request)
        }

        const fileReader = new FileReader();

        fileReader.onload = () => {
            const dataURL = fileReader.result
            this.setDataURL(dataURL);

            if (this.isDebugging()) {
                this.debugLog(" setDataURL() ", dataURL)
            }

        };

        fileReader.readAsDataURL(request.response); 
        
        return this
    }

    didFetchDataUrl (dataURL) {
        this.setDataURL(dataURL);
        
        /*
        // now just to show that passing to a canvas doesn't hold the same results
        const canvas = document.createElement("canvas");
        canvas.width = myImage.naturalWidth;
        canvas.height = myImage.naturalHeight;
        canvas.getContext("2d").drawImage(myImage, 0, 0);
        */

        return this
    }

}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    "BMThemeResources.js",
    "BMTheme.js",
    "BMDefaultTheme.js",
    "BMThemeLevel.js",
    "BMThemeClass.js",
    "BMThemeState.js",
    "BMThemeFolder.js",
])

"use strict"

/*

    BMThemeResources

    hierarchy:

        BMThemeResources -> Theme -> ThemeClass -> ThemeState -> ThemeAttribute
        global           -> "Dark" -> "Field"   -> "active"   -> "opacity" : "0.5"

    Example use by views:

        BMThemeResources.shared().currentTheme().classNamed("x").attributeNamed("y").value()

    We'd like to implement some form  of inheritance system.
    Example:

    The ThemeClass "FieldValue" has a "unselected" ThemeState, but no "active" ThemeState, 
    so we default to the "unselected" ThemeState.

    Should ThemeClass implement a defaultSubnode() method for failed lookups?
    Should it ask subnodes isDefault()? 


*/

window.BMThemeResources = class BMThemeResources extends BMStorableNode {
    
    static initThisClass () {
        super.initThisClass()
        this.setIsSingleton(true)
		return this
    }

    static initPrototype () {
    }

    init () {
        super.init()
        this.setTitle("Themes")

        this.setShouldStore(true)
        this.setShouldStoreSubnodes(true)

        this.setNoteIsSubnodeCount(true)
        this.setNodeMinWidth(200)
        this.addAction("add")
        this.setSubnodeClasses([BMTheme, BMDefaultTheme])
        this.setNodeCanReorderSubnodes(true)
    }

    activeTheme () {
        return this.subnodes().first()
    }

    defaultThemeClass () {
        return this.activeTheme().subnodes().first()
    }
    
}.initThisClass()

"use strict"

/*

    BMTheme

*/

window.BMTheme = class BMTheme extends BMStorableNode {
    
    initPrototype () {

    }

    init () {
        super.init()

        this.setShouldStore(true)
        this.setShouldStoreSubnodes(true)

        this.setNodeCanEditTitle(true)
        this.setTitle("Untitled " + this.thisClass().visibleClassName())
        //this.setSubtitle("Theme")
        this.setNodeMinWidth(270)
        this.setCanDelete(true)
        this.addAction("add")
        this.setSubnodeClasses([BMThemeLevel])
        this.setNodeCanReorderSubnodes(true)

        //this.setupSubnodes()
    }

    /*
    didLoadFromStore () {
        super.didLoadFromStore()
        this.setupSubnodes()
    }

    setupSubnodes () {
        const viewClasses = DomView.descendantClasses()

        viewClasses = viewClasses.select((viewClass) => {
            return viewClass.hasOwnProperty("styles")
        }).select((viewClass) => { return !viewClass.styles().isEmpty() })

        //console.log("viewClasses:", viewClasses)
        const themeClasses = viewClasses.map((childProto) => {
            return BMThemeFolder.clone().setTitle(childProto.type());
        })

        this.copySubnodes(themeClasses);
        return this
    }
    */

   atPath (aPath) {
       
   }

    setupAsDefault() {
        this.setTitle("DefaultTheme")
        const defaultThemeClass = BMThemeClass.clone().setupAsDefault()
        this.addSubnode(defaultThemeClass)
        return this
   }

}.initThisClass()

"use strict"

/*

    BMDefaultTheme

*/

window.BMDefaultTheme = class BMDefaultTheme extends BMTheme {
    

    init () {
        super.init() 
        return this
    }

    didInit () {
        super.didInit()
        this.setupAsDefault() 
    }

    setupAsDefault() {
        if (this.subnodes().length === 0) {
            this.setTitle("DefaultTheme")
            const defaultThemeClass = BMThemeClass.clone().setupAsDefault()
            this.addSubnode(defaultThemeClass)
        }
        return this
   }

}.initThisClass()

"use strict"

/*

    BMThemeLevel

*/

window.BMThemeLevel = class BMThemeLevel extends BMStorableNode {
    
    initPrototype () {

    }

    init () {
        super.init()

        this.setShouldStore(true)
        this.setShouldStoreSubnodes(true) 
        
        this.setNodeCanEditTitle(true)
        this.setTitle("Untitled " + this.thisClass().visibleClassName())
        this.setNodeCanEditTitle(false)
        this.setNodeMinWidth(200)
        this.setCanDelete(true)
        this.addAction("add")
        this.setSubnodeClasses([BMThemeFolder, BMThemeClass])
        this.setNodeCanReorderSubnodes(true)
    }

    updateTitle () {
        const pn = this.parentNode()
        if (pn) {
            const index = pn.indexOfSubnode(this)
            if (index !== -1) {
                this.setTitle("Level " + index)
            }
        }
    }

    
    didUpdateSlotParentNode (oldValue, newValue) {
        super.didUpdateSlotParentNode(oldValue, newValue)
        this.updateTitle()
        return this
    }
    

    didReorderParentSubnodes () {
        super.didReorderParentSubnodes()
        this.updateTitle()
        return this
    }


}.initThisClass()

"use strict"

/*

    BMThemeClass

*/

window.BMThemeClass = class BMThemeClass extends BMStorableNode {
    
    initPrototype () {

    }

    init () {
        super.init()

        this.setShouldStore(true)
        this.setShouldStoreSubnodes(true) 
        
        this.setNodeCanEditTitle(true)
        this.setTitle("Untitled " + this.thisClass().visibleClassName())
        //this.setSubtitle("ThemeClass")
        this.setNodeMinWidth(200)
        this.setCanDelete(true)
        this.addAction("add")
        this.setSubnodeClasses([BMThemeState, BMThemeFolder])
        this.setNodeCanReorderSubnodes(true)

    }

    didInit () {
        super.didInit()
        //console.log(this.typeId() + " subnodes: ", this.subnodes())
        this.setupSubnodes()
    }

    /*
    didLoadFromStore () {
        super.didLoadFromStore()
        this.setupSubnodes()
    }
    */

    subnodeNames () {
        return BMThemeState.standardStateNames()
    }

    setupSubnodes () {
        const subnodeClass = this.subnodeClasses().first()
        this.subnodeNames().forEach(name => {
            const subnode = this.subnodeWithTitleIfAbsentInsertProto(name, subnodeClass)
            
        })
    }

    unselectedThemeState () {
        return this.firstSubnodeWithTitle("unselected")
    }

    selectedThemeState () {
        return this.firstSubnodeWithTitle("selected")
    }

    setupAsDefault() {
        this.setTitle("DefaultThemeClass")
        this.setupSubnodes()
        this.subnodes().forEach(sn => sn.didInit())

        {
            const unselected = this.unselectedThemeState()
            unselected.setThemeAttribute("color", "#bbb")
            unselected.setThemeAttribute("backgroundColor", "transparent")
            unselected.setThemeAttribute("fontWeight", "normal")
        }

        {
            const selected = this.selectedThemeState()
            selected.setThemeAttribute("color", "white")
            selected.setThemeAttribute("backgroundColor", "#333")
            selected.setThemeAttribute("fontWeight", "bold")
        }

        {
            const columns = BMThemeFolder.clone().setTitle("columns")
            this.addSubnode(columns)

            const colors = [
                [60, 60, 60],
                [48, 48, 48],
                [32, 32, 32],
                [26, 26, 26],
                [16, 16, 16],
            ]

            colors.forEach(c => {
                const cssColorString = "rgb(" + c.join(",") + ")"
                const field = BMStringField.clone().setKey("backgroundColor").setValue(cssColorString)
                columns.addSubnode(field)
            })
        }

        return this
   }

}.initThisClass()

"use strict"

/*

    BMThemeState

    Replaces BMStyle

*/

window.BMThemeState = class BMThemeState extends BMStorableNode {
    
    static standardStateNames () {
        return [
            "unselected", 
            "selected", 
            //"active", 
            //"disabled"
        ]
    }

    static styleNames () {
        return  [
            "color", 
            "backgroundColor", 
            "opacity", 

            "fontFamily",
            "fontWeight",
            "fontSize",
            "lineHeight",
            "letterSpacing",

            "borderLeft", 
            "borderRight", 
            "borderTop", 
            "borderBottom",

            "borderWidth", 
            "borderColor", 
            "borderRadius",
        ]
    }

    initPrototype () {
        /*
        {
            const slot = this.newSlot("color", "")
            slot.setShouldStoreSlot(true)
            slot.setDuplicateOp("duplicate")
            slot.setSlotType("String")
            slot.setLabel("color")
        }
        */

        this.thisClass().styleNames().forEach(styleName => {
            const slot = this.newSlot(styleName, "")
            slot.setShouldStoreSlot(true)
            slot.setDuplicateOp("duplicate")
            //slot.setCanInspect(true)
            slot.setSlotType("String")
            slot.setLabel(styleName)
            //slot.setInspectorPath("Key")
        })
    }

    init () {
        super.init()

        this.setShouldStore(true)
        this.setShouldStoreSubnodes(true) 
        
        //this.setSubtitle("ThemeState")
        this.setNodeMinWidth(200)
        this.setSubnodeClasses([BMStringField])
        //this.setupSubnodes()

        //this._didChangeThemeNote = BMNotificationCenter.shared().newNote().setSender(this).setName("didChangeTheme")
    }

    didInit () {
        if(this.hasDoneInit()) {
            return
        }

        //console.log(this.typeId() + " subnodes: ", this.subnodes())
        super.didInit()
        this.setupSubnodes()
    }

    /*
        setupInspectorFromSlots() {
        const slots = this.thisPrototype().allSlots()
        slots.ownForEachKV((name, slot) => {
            const field = slot.newInspectorField()
            if (field) {
                field.setTarget(this)
                let node = this.nodeInspector().createNodePath(slot.inspectorPath())
                node.addSubnode(field)
            }
        })
        return this
    }    
    */

    setThemeAttribute (key, value) {
        this.firstSubnodeWithTitle(key).setValue(value)
        return this
    }

    syncFromViewStyle () {
  
        return this
    }

    subnodeNames () {
        return this.thisClass().styleNames()
    }

    setupSubnodes () {
        const subnodeClass = this.subnodeClasses().first()
        this.subnodes()
        this.subnodeNames().forEach(name => {
            const subnode = this.subnodeWithTitleIfAbsentInsertProto(name, subnodeClass)
            subnode.setKey(name) //.setValue("")
            subnode.setTarget(this)
            subnode.setValueMethod(name)
        })
    }

    styleNames () {
        return this.thisClass().styleNames()
    }

    applyToView (aView) {		
        this.styleNames().forEach( (name) => { 
            const getterMethod = this[name]
            if (!getterMethod) {
                const errorMsg = "missing getter method: " + this.type() + "." + name + "()"
                console.warn(errorMsg)
                throw new Error(errorMsg)
            }
            let v = getterMethod.apply(this)
            if (v === "") { 
                v = null
            }
            //try {
                if (v !== null) {
                    const isLocked = aView.lockedStyleAttributeSet().has(name)
                    //console.log("apply style to " + aView.type())
                    if (aView.type() === "BrowserRowTitle") {
                        //console.log("ready")
                    }
                    if (!isLocked) {
                        aView.performIfResponding(aView.setterNameForSlot(name), v)
                    }
                    //const setter = aView[aView.setterNameForSlot(name)]
                    //aView[aView.setterNameForSlot(name)].apply(aView, [v])
                }
                /*
            } catch (e) {
                console.warn("error appling style '" + name + "' " + e.message)
            }
            */
        })
		
        return this
    }
    
    onDidEdit () {
        console.log(this.typeId() + " onDidEdit")
        return false
    }

    didUpdateSlot (aSlot, oldValue, newValue) {
        if (this.hasDoneInit()) {
            DocumentBody.shared().resyncAllViews()
        }
        return super.didUpdateSlot(aSlot, oldValue, newValue) 
    }
    
}.initThisClass()



"use strict"

/*

    BMThemeFolder

*/

window.BMThemeFolder = class BMThemeFolder extends BMStorableNode {
    
    initPrototype () {

    }

    init () {
        super.init()

        this.setShouldStore(true)
        this.setShouldStoreSubnodes(true) 
        
        this.setNodeCanEditTitle(true)
        this.setTitle("Untitled " + this.thisClass().visibleClassName())
        this.setNodeMinWidth(200)
        this.setCanDelete(true)
        this.addAction("add")
        this.setSubnodeClasses([BMThemeFolder, BMThemeClass, BMStringField, BMNumberField])
        this.setNodeCanReorderSubnodes(true)
    }

}.initThisClass()


ResourceLoader.pushRelativePaths([
    "BMIconResources.js",
    "SvgIconNode.js",
    "SvgData.js",
]);

"use strict"

/*
    
	BMIconResources
	
	Hack to put SVG files into Javascript strings to avoid cross site loading issues.
    
*/

window.BMIconResources = class BMIconResources extends BMNode {
	
	static initThisClass () {
        super.initThisClass()
		this.setIsSingleton(true)
		return this
	}
	
    initPrototype () {
	}
	
	init () {
		super.init()
		this.setTitle("Icons")
		this.setNoteIsSubnodeCount(true)
		this.addIcon("empty", null)
		return this
	}

    addIcon (aName, svgString) {
		const node = SvgIconNode.clone().setTitle(aName).setSvgString(svgString)
		this.addSubnode(node)
        return this
	}
	
	iconWithName (aName) {
		const node = this.subnodeWithTitle(aName)
		if (node) {
			return node.svgIconView()
		}
		return null
	}

	iconNames () {
		return this.subnodes().map(sn => sn.title())
	}

}.initThisClass()




"use strict"

/*
    
	SvgIconNode
	
    
*/

window.SvgIconNode = class SvgIconNode extends BMNode {
    
    initPrototype () {
      this.newSlot("svgString", null).setCanInspect(true).setSlotType("String").setLabel("SVG string")
    }

    svgIconView () {
      const icon = SvgIconView.clone().setSvgString(this.svgString())
      return icons
    }

    noteIconName () {
      return this.title()
    }

}.initThisClass()





BMIconResources.shared().addIcon("double right caret", `
<svg x="0px" y="0px" width="100%" height="100%" preserveAspectRatio="xMidYMin slice" viewBox="0 0 284.936 284.936" style="enable-background:new 0 0 284.936 284.936;">
	<g>
		<g>
			<path d="M277.515,135.9L144.464,2.857C142.565,0.955,140.375,0,137.9,0c-2.472,0-4.659,0.955-6.562,2.857l-14.277,14.275
				c-1.903,1.903-2.853,4.089-2.853,6.567c0,2.478,0.95,4.664,2.853,6.567l112.207,112.204L117.062,254.677
				c-1.903,1.903-2.853,4.093-2.853,6.564c0,2.477,0.95,4.667,2.853,6.57l14.277,14.271c1.902,1.905,4.089,2.854,6.562,2.854
				c2.478,0,4.665-0.951,6.563-2.854l133.051-133.044c1.902-1.902,2.851-4.093,2.851-6.567S279.417,137.807,277.515,135.9z"/>
			<path d="M170.732,142.471c0-2.474-0.947-4.665-2.857-6.571L34.833,2.857C32.931,0.955,30.741,0,28.267,0s-4.665,0.955-6.567,2.857
				L7.426,17.133C5.52,19.036,4.57,21.222,4.57,23.7c0,2.478,0.95,4.664,2.856,6.567L119.63,142.471L7.426,254.677
				c-1.906,1.903-2.856,4.093-2.856,6.564c0,2.477,0.95,4.667,2.856,6.57l14.273,14.271c1.903,1.905,4.093,2.854,6.567,2.854
				s4.664-0.951,6.567-2.854l133.042-133.044C169.785,147.136,170.732,144.945,170.732,142.471z"/>
		</g>
	</g>
</svg>
`)

BMIconResources.shared().addIcon("single right caret", `
<svg x="0px" y="0px" width="100%" height="100%" viewBox="0 0 284.936 284.936" style="enable-background:new 0 0 284.936 284.936;">
	<g>
		<g>
			<path d="M277.515,135.9L144.464,2.857C142.565,0.955,140.375,0,137.9,0c-2.472,0-4.659,0.955-6.562,2.857l-14.277,14.275
				c-1.903,1.903-2.853,4.089-2.853,6.567c0,2.478,0.95,4.664,2.853,6.567l112.207,112.204L117.062,254.677
				c-1.903,1.903-2.853,4.093-2.853,6.564c0,2.477,0.95,4.667,2.853,6.57l14.277,14.271c1.902,1.905,4.089,2.854,6.562,2.854
				c2.478,0,4.665-0.951,6.563-2.854l133.051-133.044c1.902-1.902,2.851-4.093,2.851-6.567S279.417,137.807,277.515,135.9z"/>
		</g>
	</g>
</svg>
`)

BMIconResources.shared().addIcon("add", `
<svg width="100%" height="100%" viewBox="0 0 401.994 401.994">
	<path d="M394,154.175c-5.331-5.33-11.806-7.994-19.417-7.994H255.811V27.406c0-7.611-2.666-14.084-7.994-19.414
		C242.488,2.666,236.02,0,228.398,0h-54.812c-7.612,0-14.084,2.663-19.414,7.993c-5.33,5.33-7.994,11.803-7.994,19.414v118.775
		H27.407c-7.611,0-14.084,2.664-19.414,7.994S0,165.973,0,173.589v54.819c0,7.618,2.662,14.086,7.992,19.411
		c5.33,5.332,11.803,7.994,19.414,7.994h118.771V374.59c0,7.611,2.664,14.089,7.994,19.417c5.33,5.325,11.802,7.987,19.414,7.987
		h54.816c7.617,0,14.086-2.662,19.417-7.987c5.332-5.331,7.994-11.806,7.994-19.417V255.813h118.77
		c7.618,0,14.089-2.662,19.417-7.994c5.329-5.325,7.994-11.793,7.994-19.411v-54.819C401.991,165.973,399.332,159.502,394,154.175z"
		/>
</svg>
`)

BMIconResources.shared().addIcon("close", `
<svg x="0px" y="0px" width="100%" height="100%" viewBox="0 0 174.239 174.239" style="enable-background:new 0 0 174.239 174.239;" xml:space="preserve">
	<path d="M146.537,1.047c-1.396-1.396-3.681-1.396-5.077,0L89.658,52.849c-1.396,1.396-3.681,1.396-5.077,0L32.78,1.047
		c-1.396-1.396-3.681-1.396-5.077,0L1.047,27.702c-1.396,1.396-1.396,3.681,0,5.077l51.802,51.802c1.396,1.396,1.396,3.681,0,5.077
		L1.047,141.46c-1.396,1.396-1.396,3.681,0,5.077l26.655,26.655c1.396,1.396,3.681,1.396,5.077,0l51.802-51.802
		c1.396-1.396,3.681-1.396,5.077,0l51.801,51.801c1.396,1.396,3.681,1.396,5.077,0l26.655-26.655c1.396-1.396,1.396-3.681,0-5.077
		l-51.801-51.801c-1.396-1.396-1.396-3.681,0-5.077l51.801-51.801c1.396-1.396,1.396-3.681,0-5.077L146.537,1.047z"/>
</svg>
`)

BMIconResources.shared().addIcon("left", `
<svg width="100%" height="100%" viewBox="0 0 512 512">
	<path d="M 416.00,416.00l-96.00,96.00L 64.00,256.00L 320.00,0.00l 96.00,96.00L 256.00,256.00L 416.00,416.00z" ></path>
</svg>
`)

BMIconResources.shared().addIcon("right arrow", `
<svg width="100%" height="100%" viewBox="0 0 306 306">
	<polygon points="94.35,0 58.65,35.7 175.95,153 58.65,270.3 94.35,306 247.35,153" fill="#888"/>
</svg>
`)

BMIconResources.shared().addIcon("repost", `
<svg width="100%" height="100%" viewBox="0 0 100 100">
	<path style="fill:#030104;" d="M24.9,66V39.9H35L17.5,20L0,39.9h10.1V70c0,5.523,4.476,10,10,10H65L52.195,66H24.9z M89.9,60.1V30 c0-5.523-4.477-10-10-10H35l12.804,14h27.295v26.1H65L82.5,80L100,60.1H89.9z"/>
</svg>
`)

BMIconResources.shared().addIcon("heart-black-filled", `
<svg width="100%" height="100%" viewBox="0 0 51.997 51.997">
	<path d="M51.911,16.242C51.152,7.888,45.239,1.827,37.839,1.827c-4.93,0-9.444,2.653-11.984,6.905
		c-2.517-4.307-6.846-6.906-11.697-6.906c-7.399,0-13.313,6.061-14.071,14.415c-0.06,0.369-0.306,2.311,0.442,5.478
		c1.078,4.568,3.568,8.723,7.199,12.013l18.115,16.439l18.426-16.438c3.631-3.291,6.121-7.445,7.199-12.014
		C52.216,18.553,51.97,16.611,51.911,16.242z"/>
</svg>
`)

BMIconResources.shared().addIcon("outer-checkbox", `
<svg height='100%' width='100%' viewBox='0 0 16 16'>
	<circle stroke-width='1' cx=7 cy=7 r=6 />
</svg>
`)

BMIconResources.shared().addIcon("inner-checkbox", `
<svg height='100%' width='100%' viewBox='0 0 16 16'>
	<circle stroke-width='1' cx=7 cy=7 r=4 />
</svg>
`)
"use strict"

ResourceLoader.pushRelativePaths([
    "BMJsonResources.js",
])

"use strict"

/*

    BMJsonResources

*/

window.BMJsonResources = class BMJsonResources extends BMNode {
    
    static initThisClass () {
        super.initThisClass()
        this.setIsSingleton(true)
		return this
    }
    
    initPrototype () {
        this.newSlot("extensions", ["json"])
    }

    init () {
        super.init()
        this.setTitle("Json")
        this.setNodeMinWidth(270)
        this.setNoteIsSubnodeCount(true)
        //this.setSubnodeClasses([BMJsonResource])
        this.watchOnceForNote("appDidInit")
        return this
    }
    
    /*
    prepareForFirstAccess () {
         super.prepareForFirstAccess()
       this.setupSubnodes()
        return this
    }
    */

    resourcePaths () {
        return ResourceLoader.resourceFilePathsWithExtensions(this.extensions())
    }
    
    appDidInit () {
        this.setupSubnodes()
        return this
    }

    setupSubnodes () {
        this.resourcePaths().forEach(path => this.addResourceWithPath(path))
        return this
    }

    addResourceWithPath (aPath) {
        const resource = this.justAdd()
        resource.setPath(aPath)
        return this
    }

}.initThisClass()



"use strict"

/*

    BMResources

*/

window.BMResources = class BMResources extends BMStorableNode {
    
    static initThisClass () {
        super.initThisClass()
        this.setIsSingleton(true)
		return this
    }

    initPrototype () {
        this.newSlot("themes", null)
        this.newSlot("fonts", null)
        this.newSlot("sounds", null)
        this.newSlot("images", null)
        this.newSlot("icons", null)
        this.newSlot("json", null)
        this.newSlot("files", null)
    }

    init () {
        super.init()
        this.setShouldStore(false)

        this.setTitle("Resources")
        this.setSubtitle("")
        this.setNodeMinWidth(200)

        this.setupSubnodes()
        //this.watchOnceForNote("appDidInit")
    }

    setupSubnodes () {
        const themes = this.defaultStore().rootSubnodeWithTitleForProto("Themes", BMThemeResources)
        themes.setNodeCanReorderSubnodes(true)
        //this.addSubnode(themes)
        let link = this.addLinkSubnode(themes)
        //console.log("themes link = ", link.debugTypeId())

        this.setFonts(BMFontResources.shared())
        this.addSubnode(this.fonts())

        this.setSounds(BMSoundResurces.shared())
        this.addSubnode(this.sounds())

        this.setImages(BMImageResources.shared())
        this.addSubnode(this.images())

        this.setIcons(BMIconResources.shared())
        this.addSubnode(this.icons())

        this.setJson(BMJsonResources.shared())
        this.addSubnode(this.json())

        this.setFiles(BMFileResources.shared())
        this.addSubnode(this.files())

        return this
    }

    /*
    appDidInit () {
        this.findResources()
    }

    findResources () {
        this.sendRespondingSubnodes("findResources")
        return this
    }

    loadResources () {
        this.sendRespondingSubnodes("loadResources")
        return this
    }
    */

}.initThisClass()

"use strict"

ResourceLoader.pushRelativePaths([
    //"Game/_imports.js",
    //"Peer/_imports.js",
    "Strvct/_imports.js",
    //"Stats/_imports.js",
])
"use strict"

ResourceLoader.pushRelativePaths([
    "StrvctApp.js",
])

ResourceLoader.pushDoneCallback( () => {
    StrvctApp.loadAndRunShared()
    //StrvctApp.shared().run()
})

"use strict"

/*
    
    StrvctApp


*/

window.StrvctApp = class StrvctApp extends App {
    
    initPrototype () {
        // model
        this.newSlot("notes", null)
        this.newSlot("prototypes", null)
        this.newSlot("settings", null)
        this.newSlot("resources", null)
        this.newSlot("dataStore", null)

        // view
        this.newSlot("browser", null)
        this.newSlot("stackView", null)
    }

    init () {
        super.init()
        this.setName("StrvctApp")
        this.setVersion([0, 0, 0, 0])
        this.setNodeCanReorderSubnodes(true)
        this.addAction("add")
        return this
    } 

    setup () {
        this.setupTheme()
        this.setupModel()

        const v = StackView.clone() //.setDirection("down")
        this.setStackView(v)
        v.setNode(this.rootNode())
        this.documentBodyView().addSubview(v)
        this.appDidInit()
    }

    setup_old () { // called by App.run
        super.setup()        
        this.setupTheme()
        this.setupModel()
        this.setupViews()
        this.appDidInit()
        return this
    }

    // --- setup model ---


    setupModel () {        
        //console.log("App.setupModel rooObject.subnodes = ", root.subnodes().map(sn => sn.title()).join(",") )dfdfdfddfsdfsfdsdfsdsfdfsdfsfdsdsffdsfds
        //root.removeAllSubnodes( 
        {
            this.rootNode().removeFirstSubnodeWithTitle("StrvctApp")
            this.rootNode().removeFirstSubnodeWithTitle("Themes")
            this.rootNode().scheduleMethod("scheduleSyncToStore")

        }
        const notes = this.rootNode().subnodeWithTitleIfAbsentInsertProto("Notes", BMFolderNode)
        //notes.subnodes().forEach(sn => sn.setCanDelete(true))
        //notes.orderFirst()
        this.setNotes(notes)

        const prototypes = this.rootNode().subnodeWithTitleIfAbsentInsertProto("Prototypes", BMPrototypesNode)
        this.setPrototypes(notes)

        this.setupSettings()
        return this
    }

    setupSettings () {
        // settings
        const settings = this.rootNode().subnodeWithTitleIfAbsentInsertProto("Settings", BMStorableNode)
        settings.setNodeMinWidth(150)
        this.setSettings(settings)
        //this.removeOtherSubnodeWithSameTitle(settings)

        this.addSettingNameAndClass("Resources", BMResources)
        this.addSettingNameAndClass("Storage", BMDataStore)
        this.addSettingNameAndClass("Resources", BMResources)
        this.addSettingNameAndClass("Blobs", BMBlobs)
    }

    addSettingNameAndClass (aName, aClass) {
        const subnode = this.settings().subnodeWithTitleIfAbsentInsertProto(aName, aClass)
        this.settings().removeOtherSubnodeWithSameTitle(subnode)
        const slot = this.thisPrototype().ownSlotNamed(aName)
        if (slot) {
            slot.onInstanceSetValue(subnode) // or should we dynamically get these from the subnodes?
        }
        return subnode
    }

    // --- setup views ---
    
    setupViews () { 
        this.setupBrowser()
        //this.setupShelf()
    }

    isBrowserCompatible () {
        return true
    }

    /*
    setupBrowser () {	
        //console.log("App setupBrowser")
        this.setBrowser(BrowserView.clone())
        this.browser().hideAndFadeIn()
        this.browser().setNode(this)
        this.documentBodyView().addSubview(this.browser())
        this.browser().syncFromNodeNow()
        this.browser().syncFromHashPath()
        return this
    }
    */

    appDidInit () {
        super.appDidInit()
        this.rootNode().removeFirstSubnodeWithTitle("Themes")

        // ResourceLoaderPanel can't use notification as it's a boot object
        // what if we added a one-shot observation for it, or would that be more confusing?

    }

    // themes - temporary, until ThemesResources is ready

    setupTheme () {
        const doc = DocumentBody.shared()
        doc.setColor("#f4f4ec")
        doc.setBackgroundColor("rgb(25, 25, 25)")

        this.setupNormalTheme()
        //this.setupVectorTheme()
    }

    setupNormalTheme () {
        const doc = DocumentBody.shared()
        doc.setBackgroundColor("#191919")
        //doc.setFontFamily("Sans-Serif")
        //doc.setFontFamily("Electrolize-Regular")
        doc.setFontFamily("Helvetica")
        //doc.setFontWeight("bold")
        //doc.setFontFamily("Helvetica Neue")
        //doc.setFontFamily("San Francisco Display")
        //doc.setFontFamily("PublicSans Light")
        //doc.setFontFamily("OpenSans Regular")
        doc.setFontSizeAndLineHeight("14px")
        //doc.setLetterSpacing("0.05em")
        //doc.setTextTransform("uppercase")
   }

    setupVectorTheme () {
        const doc = DocumentBody.shared()
        doc.setBackgroundColor("#191919")
        doc.setFontFamily("Hyperspace Bold")
        doc.setFontSize("15px")
        doc.setFontWeight("bold")
        //doc.setFontSizeAndLineHeight("1.1em")
        doc.setLetterSpacing("0.1em")
        doc.setTextShadow("0px 0px 1px rgba(255,255,255,1)")
        doc.setFontWeight(900)
        //doc.setTextTransform("uppercase")
        //DocumentBody.shared().setTextTransform("uppercase")
    }

    setupBlenderProTheme () {
        const doc = DocumentBody.shared()
        doc.setFontFamily("Blender Pro Book")
        doc.setFontSizeAndLineHeight("18px")
    }

    setupLatoTheme () {
        const doc = DocumentBody.shared()
        doc.setFontFamily("Lato Light")
        doc.setFontSizeAndLineHeight("16px")
        doc.setLetterSpacing("0.05em")
        doc.setTextShadow("0px 0px 0.5px rgba(255,255,255,0.7)")
    }

}.initThisClass()

/*

let windowEventCount = 0
window.addEventListener('mouseup', function(event){
    console.log("window mouseup <<<<<<<<<<<<<<<<<<<<")
})

window.addEventListener('mouseleave', function(event){
    console.log("window mouseleave <<<<<<<<<<<<<<<<<<<<")
})

window.addEventListener('mousemove', function(event){
    windowEventCount ++
    console.log("window mousemove <<<<<<<<<<<<<<<<<<<< " + windowEventCount)
})
*/


ResourceLoader.pushRelativePaths([
    "fonts/_imports.js",
    "sounds/_imports.js",
    "images/_imports.js",
]);


ResourceLoader.pushRelativePaths([
    "Courier Prime/_imports.js",
    "Blender Pro/_imports.js",
    "OpenSans/_imports.js",
    "Lato/_imports.js",
    "ShareTechMono/_imports.js",

    "Hyperspace/_imports.js",
    "PublicSans/_imports.js",
    "Electrolize/_imports.js",
    "Helvetica/_imports.js",
]);


ResourceLoader.pushRelativePaths([
    //"Code/Courier Prime Code Italic.ttf",
    //"Code/Courier Prime Code.ttf",
    "Default/Courier Prime Bold Italic.ttf",
    "Default/Courier Prime Bold.ttf",
    "Default/Courier Prime Italic.ttf",
    "Default/Courier Prime.ttf",
    "Sans/Courier Prime Sans Bold Italic.ttf",
    "Sans/Courier Prime Sans Bold.ttf",
    "Sans/Courier Prime Sans Italic.ttf",
    "Sans/Courier Prime Sans.ttf",
    "Semibold/CourierPrime Medium.ttf",
    "Semibold/CourierPrime Semibold.ttf",
]);


ResourceLoader.pushRelativePaths([
    "Blender Pro Book.ttf",
    "Blender Pro Thin.ttf",
]);


ResourceLoader.pushRelativePaths([
    "OpenSans Bold.ttf",
    "OpenSans Bold Italic.ttf",
    "OpenSans Condensed Bold.ttf",
    "OpenSans Condensed Light.ttf",
    "OpenSans Condensed Light Italic.ttf",
    "OpenSans Extra Bold.ttf",
    "OpenSans Extra Bold Italic.ttf",
    "OpenSans Italic.ttf",
    "OpenSans Light.ttf",
    "OpenSans Light Italic.ttf",
    "OpenSans Regular.ttf",
    "OpenSans Semibold.ttf",
    "OpenSans Semibold Italic.ttf",
]);


ResourceLoader.pushRelativePaths([
    "Lato Bold.ttf",
    "Lato Hairline.ttf",
    "Lato Hairline Italic.ttf",
    "Lato Light.ttf",
]);


ResourceLoader.pushRelativePaths([
    "ShareTechMono Regular.ttf",
]);


ResourceLoader.pushRelativePaths([
    "Hyperspace.ttf",
    "Hyperspace Bold.ttf",
    "Hyperspace Bold Italic.ttf",
    "Hyperspace Italic.ttf"
]);

//"LICENSE.txt",
//"CREDITS.txt",
//"README.md",


ResourceLoader.pushRelativePaths([
    "PublicSans Black.woff2",
    "PublicSans Black Italic.woff2",
    "PublicSans Bold.woff2",
    "PublicSans Bold Italic.woff2",
    "PublicSans Extra Bold.woff2",
    "PublicSans Extra Light.woff2",
    "PublicSans Extra Light Italic.woff2",
    "PublicSans Italic.woff2",
    "PublicSans Light.woff2",
    "PublicSans Light Italic.woff2",
    "PublicSans Medium.woff2",
    "PublicSans Medium Italic.woff2",
    "PublicSans Regular.woff2",
    "PublicSans Semibold.woff2",
    "PublicSans Semibold Italic.woff2",
    "PublicSans Thin.woff2",
    "PublicSans Thin Italic.woff2",
]);



ResourceLoader.pushRelativePaths([
    "Electrolize-Regular.ttf",
]);


ResourceLoader.pushRelativePaths([
    "fonts.css",
]);


ResourceLoader.pushRelativePaths([
    "beep_06.wav",
    "bleep_04.wav",
]);


ResourceLoader.pushRelativePaths([
    "appicon-black-600x600.png",
]);

ResourceLoader.setResourceFilePaths(["./resources/fonts/Courier Prime/Default/Courier Prime Bold Italic.ttf","./resources/fonts/Courier Prime/Default/Courier Prime Bold.ttf","./resources/fonts/Courier Prime/Default/Courier Prime Italic.ttf","./resources/fonts/Courier Prime/Default/Courier Prime.ttf","./resources/fonts/Courier Prime/Sans/Courier Prime Sans Bold Italic.ttf","./resources/fonts/Courier Prime/Sans/Courier Prime Sans Bold.ttf","./resources/fonts/Courier Prime/Sans/Courier Prime Sans Italic.ttf","./resources/fonts/Courier Prime/Sans/Courier Prime Sans.ttf","./resources/fonts/Courier Prime/Semibold/CourierPrime Medium.ttf","./resources/fonts/Courier Prime/Semibold/CourierPrime Semibold.ttf","./resources/fonts/Blender Pro/Blender Pro Book.ttf","./resources/fonts/Blender Pro/Blender Pro Thin.ttf","./resources/fonts/OpenSans/OpenSans Bold.ttf","./resources/fonts/OpenSans/OpenSans Bold Italic.ttf","./resources/fonts/OpenSans/OpenSans Condensed Bold.ttf","./resources/fonts/OpenSans/OpenSans Condensed Light.ttf","./resources/fonts/OpenSans/OpenSans Condensed Light Italic.ttf","./resources/fonts/OpenSans/OpenSans Extra Bold.ttf","./resources/fonts/OpenSans/OpenSans Extra Bold Italic.ttf","./resources/fonts/OpenSans/OpenSans Italic.ttf","./resources/fonts/OpenSans/OpenSans Light.ttf","./resources/fonts/OpenSans/OpenSans Light Italic.ttf","./resources/fonts/OpenSans/OpenSans Regular.ttf","./resources/fonts/OpenSans/OpenSans Semibold.ttf","./resources/fonts/OpenSans/OpenSans Semibold Italic.ttf","./resources/fonts/Lato/Lato Bold.ttf","./resources/fonts/Lato/Lato Hairline.ttf","./resources/fonts/Lato/Lato Hairline Italic.ttf","./resources/fonts/Lato/Lato Light.ttf","./resources/fonts/ShareTechMono/ShareTechMono Regular.ttf","./resources/fonts/Hyperspace/Hyperspace.ttf","./resources/fonts/Hyperspace/Hyperspace Bold.ttf","./resources/fonts/Hyperspace/Hyperspace Bold Italic.ttf","./resources/fonts/Hyperspace/Hyperspace Italic.ttf","./resources/fonts/PublicSans/PublicSans Black.woff2","./resources/fonts/PublicSans/PublicSans Black Italic.woff2","./resources/fonts/PublicSans/PublicSans Bold.woff2","./resources/fonts/PublicSans/PublicSans Bold Italic.woff2","./resources/fonts/PublicSans/PublicSans Extra Bold.woff2","./resources/fonts/PublicSans/PublicSans Extra Light.woff2","./resources/fonts/PublicSans/PublicSans Extra Light Italic.woff2","./resources/fonts/PublicSans/PublicSans Italic.woff2","./resources/fonts/PublicSans/PublicSans Light.woff2","./resources/fonts/PublicSans/PublicSans Light Italic.woff2","./resources/fonts/PublicSans/PublicSans Medium.woff2","./resources/fonts/PublicSans/PublicSans Medium Italic.woff2","./resources/fonts/PublicSans/PublicSans Regular.woff2","./resources/fonts/PublicSans/PublicSans Semibold.woff2","./resources/fonts/PublicSans/PublicSans Semibold Italic.woff2","./resources/fonts/PublicSans/PublicSans Thin.woff2","./resources/fonts/PublicSans/PublicSans Thin Italic.woff2","./resources/fonts/Electrolize/Electrolize-Regular.ttf","./resources/sounds/beep_06.wav","./resources/sounds/bleep_04.wav","./resources/images/appicon-black-600x600.png"]);


      window.onload = function() { 
        setTimeout(() => { ResourceLoader.done() }, 200) // hack for startWhenReady for loading order issue        
      }

    </script>
  </head>
  <body id="body"></body>
</html>
