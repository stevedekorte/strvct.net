"use strict";

/**
 * @module library.services.OpenAI.Text_to_Image.images
 */

/**
 * @class OpenAiImage
 * @extends SvSummaryNode
 * @classdesc Represents an image generated by OpenAI's text-to-image service.
 */
(class OpenAiImage extends SvSummaryNode {
    /**
   * @description Initializes the prototype slots for the OpenAiImage class.
   */
    initPrototypeSlots () {

        /**
     * @member {string} imageUrl - The URL of the generated image.
     * @category Image Data
     */
        {
            const slot = this.newSlot("imageUrl", null);
            slot.setShouldJsonArchive(true);
            slot.setInspectorPath("");
            slot.setLabel("image");
            slot.setShouldStoreSlot(true);
            slot.setSyncsToView(true);
            slot.setDuplicateOp("duplicate");
            slot.setSlotType("String");
            slot.setIsSubnodeField(true);
            slot.setCanEditInspection(false);
            slot.setFieldInspectorClassName("SvImageWellField"); // field inspector view class
        }

        /**
     * @member {string} revisedPrompt - The revised prompt used for image generation.
     * @category Prompt
     */
        {
            const slot = this.newSlot("revisedPrompt", null);
            slot.setShouldJsonArchive(true);
            slot.setInspectorPath("");
            slot.setLabel("revised prompt");
            slot.setShouldStoreSlot(true);
            slot.setSyncsToView(true);
            slot.setDuplicateOp("duplicate");
            slot.setSlotType("String");
            slot.setIsSubnodeField(true);
            slot.setCanEditInspection(false);
        }

        /**
     * @member {string} url - The URL of the image.
     * @category Image Data
     */
        {
            const slot = this.newSlot("url", null);
            slot.setShouldJsonArchive(true);
            slot.setInspectorPath("");
            slot.setLabel("url");
            slot.setShouldStoreSlot(true);
            slot.setSyncsToView(true);
            slot.setDuplicateOp("duplicate");
            slot.setSlotType("String");
            slot.setIsSubnodeField(true);
            slot.setCanEditInspection(false);
        }

        /**
     * @member {Action} fetchAction - The action to fetch the image.
     * @category Actions
     */
        {
            const slot = this.newSlot("fetchAction", null);
            slot.setInspectorPath("");
            slot.setLabel("Fetch");
            //slot.setShouldStoreSlot(true)
            slot.setSyncsToView(true);
            slot.setDuplicateOp("duplicate");
            slot.setSlotType("Action");
            slot.setIsSubnodeField(true);
            slot.setActionMethodName("fetch");
        }

        /**
     * @member {string} error - Error message if any.
     * @category Error Handling
     */
        {
            const slot = this.newSlot("error", ""); // String
            slot.setInspectorPath("");
            slot.setShouldStoreSlot(true);
            slot.setSyncsToView(true);
            slot.setDuplicateOp("duplicate");
            slot.setSlotType("String");
            //slot.setIsSubnodeField(true)
            slot.setCanEditInspection(false);
        }

        /**
     * @member {string} status - Current status of the image.
     * @category Status
     */
        {
            const slot = this.newSlot("status", ""); // String
            slot.setInspectorPath("");
            slot.setShouldStoreSlot(true);
            slot.setSyncsToView(true);
            slot.setDuplicateOp("duplicate");
            slot.setSlotType("String");
            slot.setIsSubnodeField(true);
            slot.setCanEditInspection(false);
        }

        /**
     * @member {boolean} isLoading - Indicates if the image is currently loading.
     * @category Status
     */
        {
            const slot = this.newSlot("isLoading", false); // String
            slot.setSlotType("Boolean");
        }

        this.setTitle("Image");
        this.setShouldStore(true);
        this.setShouldStoreSubnodes(false);
        this.setSubnodeClasses([]);
        this.setNodeCanAddSubnode(false);
        this.setNodeCanReorderSubnodes(false);
        this.setCanDelete(true);
        this.setNodeFillsRemainingWidth(true);
    }

    /**
   * @description Gets the subtitle for the image.
   * @returns {string} The status of the image.
   * @category UI
   */
    subtitle () {
        return this.status();
    }

    /**
   * @description Gets the parent node containing the images.
   * @returns {Object} The parent node.
   * @category Hierarchy
   */
    images () {
        return this.parentNode();
    }

    /**
   * @description Gets the service used for image generation.
   * @returns {Object} The OpenAI service.
   * @category Service
   */
    service () {
        return OpenAiService.shared();
    }

    /**
   * @description Gets the image prompt.
   * @returns {string} The image prompt.
   * @category Prompt
   */
    imagePrompt () {
        return this.images().imagePrompt();
    }

    /**
   * @description Checks if the image is loaded.
   * @returns {boolean} True if the image is loaded, false otherwise.
   * @category Status
   */
    isLoaded () {
        return this.imageUrl() !== null;
    }

    /**
   * @description Checks if there's an error.
   * @returns {boolean} True if there's an error, false otherwise.
   * @category Error Handling
   */
    hasError () {
        return this.error() !== "" && this.error() !== null;
    }

    /**
   * @description Checks if the image can be fetched.
   * @returns {boolean} True if the image can be fetched, false otherwise.
   * @category Actions
   */
    canFetch () {
        return Type.isString(this.url());
    }

    /**
   * @description Gets the fetch action information.
   * @returns {Object} An object containing fetch action information.
   * @category Actions
   */
    fetchActionInfo () {
        return {
            isEnabled: this.canFetch(),
            //title: this.title(),
            isVisible: true
        };
    }

    /**
   * @description Gets the proxy URL for the image.
   * @returns {string} The proxy URL.
   * @category Networking
   */
    getProxyUrl () {
        const proxyUrl = ProxyServers.shared().defaultServer().proxyUrlForUrl(this.url());
        console.log(this.svType() + " url: '" + this.url() + "'");
        console.log(this.svType() + " proxy url: '" + proxyUrl + "'");
        return proxyUrl;
    }

    // NOTE: the fetch is now done by the prompt as it only returns one image
    /**
   * @description Fetches the image.
   * @returns {Promise<void>}
   * @category Actions
   */
    /*
  async fetch () {
    this.setIsLoading(true);

    const url = this.getProxyUrl();
    this.setStatus("fetching...");
    //console.log("fetch url " + this.url());
    console.log(this.svType() + " fetch proxy url: " + url);
    const urlObject = new URL(url);
    // now change the port to 8000
    urlObject.port = "8000";
    const proxyUrl = urlObject.toString(); // send it to the old proxy server


    const apiKey = await OpenAiService.shared().apiKeyOrUserAuthToken();

    try {

      const response = await fetch(proxyUrl, {
        method: 'GET',
        headers: {
            'Authorization': `Bearer ` + apiKey,
            'Content-Type': 'application/json'
        },
    });

      if (!response.ok) {
          const error = new Error(`HTTP error! Status: ${response.status}`);
          throw error;
      }

      const blob = await response.blob();
      const dataUrl = await blob.asyncAsDataUrl();
      this.onLoaded(dataUrl);
    } catch (error) {
      this.onError(error);
      //error.rethrow();
    }
  }
    */

    /**
   * @description Shuts down the image fetching process.
   * @returns {OpenAiImage} The current instance.
   * @category Lifecycle
   */
    shutdown () {
        return this;
    }

    /**
   * @description Handles the successful loading of the image.
   * @param {string} imageDataUrl - The data URL of the loaded image.
   * @category Image Processing
   */
    onLoaded (imageDataUrl) {
        this.setIsLoading(false);
        console.log("Image Data URL: " + imageDataUrl.length + " bytes");
        this.setImageUrl(imageDataUrl);
        this.setStatus("complete");
        this.sendDelegateMessage("onImageLoaded", [this]);
    }

    /**
   * @description Handles errors during image loading.
   * @param {Error} error - The error that occurred.
   * @category Error Handling
   */
    onError (error) {
        this.setIsLoading(false);
        const s = "ERROR: " + error.message;
        console.error(s);
        this.setError(s);
        this.setStatus(s);
        this.sendDelegateMessage("onImageError", [this]);
    }

    /**
   * @description Gets the delegate for this image.
   * @returns {Object} The delegate object.
   * @category Delegation
   */
    delegate () {
        return this.imagePrompt();
    }

}.initThisClass());
