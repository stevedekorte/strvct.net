"use strict";

/**
 * @module library.services.OpenAI.Text_to_Image.images
 */

/**
 * @class OpenAiImage
 * @extends SvSummaryNode
 * @classdesc Represents an image generated by OpenAI's text-to-image service.
 */
(class OpenAiImage extends SvSummaryNode {
  /**
   * @description Initializes the prototype slots for the OpenAiImage class.
   */
  initPrototypeSlots () {

    /**
     * @member {string} imageUrl - The URL of the generated image.
     * @category Image Data
     */
    {
      const slot = this.newSlot("imageUrl", null);
      slot.setShouldJsonArchive(true);
      slot.setInspectorPath("");
      slot.setLabel("image");
      slot.setShouldStoreSlot(true);
      slot.setSyncsToView(true);
      slot.setDuplicateOp("duplicate");
      slot.setSlotType("String");
      slot.setIsSubnodeField(true);
      slot.setCanEditInspection(false);
      slot.setFieldInspectorViewClassName("SvImageWellField"); // field inspector view class
    }

    /**
     * @member {string} revisedPrompt - The revised prompt used for image generation.
     * @category Prompt
     */
    {
      const slot = this.newSlot("revisedPrompt", null);
      slot.setShouldJsonArchive(true);
      slot.setInspectorPath("");
      slot.setLabel("revised prompt");
      slot.setShouldStoreSlot(true);
      slot.setSyncsToView(true);
      slot.setDuplicateOp("duplicate");
      slot.setSlotType("String");
      slot.setIsSubnodeField(true);
      slot.setCanEditInspection(false);
    }

    /**
     * @member {string} url - The URL of the image.
     * @category Image Data
     */
    {
      const slot = this.newSlot("url", null);
      slot.setShouldJsonArchive(true)
      slot.setInspectorPath("")
      slot.setLabel("url")
      slot.setShouldStoreSlot(true)
      slot.setSyncsToView(true)
      slot.setDuplicateOp("duplicate")
      slot.setSlotType("String")
      slot.setIsSubnodeField(true)
      slot.setCanEditInspection(false)
    }

    /**
     * @member {Action} fetchAction - The action to fetch the image.
     * @category Actions
     */
    {
      const slot = this.newSlot("fetchAction", null);
      slot.setInspectorPath("");
      slot.setLabel("Fetch");
      //slot.setShouldStoreSlot(true)
      slot.setSyncsToView(true);
      slot.setDuplicateOp("duplicate");
      slot.setSlotType("Action");
      slot.setIsSubnodeField(true);
      slot.setActionMethodName("fetch");
    }

    /**
     * @member {string} error - Error message if any.
     * @category Error Handling
     */
    {
      const slot = this.newSlot("error", ""); // String
      slot.setInspectorPath("")
      slot.setShouldStoreSlot(true)
      slot.setSyncsToView(true)
      slot.setDuplicateOp("duplicate")
      slot.setSlotType("String")
      //slot.setIsSubnodeField(true)
      slot.setCanEditInspection(false);
    }

    /**
     * @member {string} status - Current status of the image.
     * @category Status
     */
    {
      const slot = this.newSlot("status", ""); // String
      slot.setInspectorPath("")
      slot.setShouldStoreSlot(true)
      slot.setSyncsToView(true)
      slot.setDuplicateOp("duplicate")
      slot.setSlotType("String")
      slot.setIsSubnodeField(true)
      slot.setCanEditInspection(false);
    }

    /**
     * @member {boolean} isLoading - Indicates if the image is currently loading.
     * @category Status
     */
    {
      const slot = this.newSlot("isLoading", false); // String
      slot.setSlotType("Boolean");
    }

    this.setTitle("Image");
    this.setShouldStore(true);
    this.setShouldStoreSubnodes(false);
    this.setSubnodeClasses([]);
    this.setNodeCanAddSubnode(false);
    this.setNodeCanReorderSubnodes(false);
    this.setCanDelete(true);
    this.setNodeFillsRemainingWidth(true);
  }

  /**
   * @description Gets the subtitle for the image.
   * @returns {string} The status of the image.
   * @category UI
   */
  subtitle () {
    return this.status();
  }

  /**
   * @description Gets the parent node containing the images.
   * @returns {Object} The parent node.
   * @category Hierarchy
   */
  images () {
    return this.parentNode();
  }

  /**
   * @description Gets the service used for image generation.
   * @returns {Object} The OpenAI service.
   * @category Service
   */
  service () {
    return OpenAiService.shared();
  }

  /**
   * @description Gets the image prompt.
   * @returns {string} The image prompt.
   * @category Prompt
   */
  imagePrompt () {
    return this.images().imagePrompt();
  }

  /**
   * @description Checks if the image is loaded.
   * @returns {boolean} True if the image is loaded, false otherwise.
   * @category Status
   */
  isLoaded () {
    return this.imageUrl() !== null;
  }

  /**
   * @description Checks if there's an error.
   * @returns {boolean} True if there's an error, false otherwise.
   * @category Error Handling
   */
  hasError () {
    return this.error() !== "" && this.error() !== null;
  }

  /**
   * @description Checks if the image can be fetched.
   * @returns {boolean} True if the image can be fetched, false otherwise.
   * @category Actions
   */
  canFetch () {
    return Type.isString(this.url());
  }

  /**
   * @description Gets the fetch action information.
   * @returns {Object} An object containing fetch action information.
   * @category Actions
   */
  fetchActionInfo () {
    return {
        isEnabled: this.canFetch(),
        //title: this.title(),
        isVisible: true
    }
  }

  /**
   * @description Gets the proxy URL for the image.
   * @returns {string} The proxy URL.
   * @category Networking
   */
  getProxyUrl () {
    const proxyUrl = ProxyServers.shared().defaultServer().proxyUrlForUrl(this.url());
    console.log(this.type() + " url: '" + this.url() + "'");
    console.log(this.type() + " proxy url: '" + proxyUrl + "'");
    return proxyUrl;
  }

  // NOTE: the fetch is now done by the prompt as it only returns one image
  /**
   * @description Fetches the image.
   * @returns {Promise<void>}
   * @category Actions
   */
  /*
  async fetch () {
    this.setIsLoading(true);

    const url = this.getProxyUrl();
    this.setStatus("fetching...");
    //console.log("fetch url " + this.url());
    console.log(this.type() + " fetch proxy url: " + url);
    const urlObject = new URL(url);
    // now change the port to 8000
    urlObject.port = "8000";
    const proxyUrl = urlObject.toString(); // send it to the old proxy server


    const apiKey = OpenAiService.shared().apiKeyOrUserAuthToken();

    try {

      const response = await fetch(proxyUrl, {
        method: 'GET',
        headers: {
            'Authorization': `Bearer ` + apiKey,
            'Content-Type': 'application/json'
        },
    });

      if (!response.ok) {
          const error = new Error(`HTTP error! Status: ${response.status}`);
          throw error;
      }

      const blob = await response.blob();
      const dataUrl = await blob.asyncToDataUrl();
      this.onLoaded(dataUrl);
    } catch (error) {
      this.onError(error);
      //error.rethrow();
    }
  }
    */

  /**
   * @description Shuts down the image fetching process.
   * @returns {OpenAiImage} The current instance.
   * @category Lifecycle
   */
  shutdown () {
   return this;
  }

  /**
   * @description Handles the successful loading of the image.
   * @param {string} imageDataUrl - The data URL of the loaded image.
   * @category Image Processing
   */
  onLoaded (imageDataUrl) {
    this.setIsLoading(false)
    console.log('Image Data URL: ' + imageDataUrl.length + " bytes");
    this.setImageUrl(imageDataUrl);
    this.setStatus("complete")
    this.sendDelegate("onImageLoaded", [this])
  }

  /**
   * @description Handles errors during image loading.
   * @param {Error} error - The error that occurred.
   * @category Error Handling
   */
  onError (error) {
    this.setIsLoading(false)
    const s = "ERROR: " + error.message;
    console.error(s);
    this.setError(s);
    this.setStatus(s)
    this.sendDelegate("onImageError", [this])
  }

  /**
   * @description Gets the delegate for this image.
   * @returns {Object} The delegate object.
   * @category Delegation
   */
  delegate () {
    return this.imagePrompt()
  }

  /**
   * @description Sends a method call to the delegate.
   * @param {string} methodName - The name of the method to call.
   * @param {Array} args - The arguments to pass to the method.
   * @returns {boolean} True if the method was called successfully, false otherwise.
   * @category Delegation
   */
  sendDelegate (methodName, args = [this]) {
    const d = this.delegate();
    if (d) {
      const f = d[methodName];
      if (f) {
        f.apply(d, args);
        return true;
      }
    }
    return false;
  }

}.initThisClass());